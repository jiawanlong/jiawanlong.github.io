<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="狗敦A季的个人博客"><title>JavaScript：十大排序的算法思路和代码实现 | 狗敦A季</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'c4b51b451f35032c4372319853929ba5';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript：十大排序的算法思路和代码实现</h1><a id="logo" href="/.">狗敦A季</a><p class="description">贾宛龙的个人博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/demo/"><i class="fa fa-archive"> DEMO</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript：十大排序的算法思路和代码实现</h1><div class="post-meta">Jun 5, 2019<span> | </span><span class="category"><a href="/categories/FUCK-WORK/">FUCK WORK</a></span><span id="arcicleVister">本文第    <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span><span>位访客</span></span><script src="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。</p>
<p>最好：<code>O(n)</code>，只需要冒泡一次数组就有序了。<br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p>
<h2 id="单向冒泡"><a href="#单向冒泡" class="headerlink" title="单向冒泡"></a>单向冒泡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(nums) &#123;</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len-1; i++) &#123;</span><br><span class="line">    // 如果一轮比较中没有需要交换的数据，则说明数组已经有序。主要是对[5,1,2,3,4]之类的数组进行优化</span><br><span class="line">    let mark = true;</span><br><span class="line">    for(let j=0; j&lt;len-i-1; j++) &#123;</span><br><span class="line">      if(nums[j] &gt; nums[j+1]) &#123;</span><br><span class="line">        [nums[j], nums[j+1]] = [nums[j+1], nums[j]];</span><br><span class="line">        mark = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mark)  return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向冒泡"><a href="#双向冒泡" class="headerlink" title="双向冒泡"></a>双向冒泡</h2><p>普通的冒泡排序在一趟循环中只能找出一个最大值或最小值，双向冒泡则是多一轮循环既找出最大值也找出最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort_twoWays(nums) &#123;</span><br><span class="line">  let low = 0;</span><br><span class="line">  let high = nums.length - 1;</span><br><span class="line">  while(low &lt; high) &#123;</span><br><span class="line">    let mark = true;</span><br><span class="line">    // 找到最大值放到右边</span><br><span class="line">    for(let i=low; i&lt;high; i++) &#123;</span><br><span class="line">      if(nums[i] &gt; nums[i+1]) &#123;</span><br><span class="line">        [nums[i], nums[i+1]] = [nums[i+1], nums[i]];</span><br><span class="line">        mark = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high--;</span><br><span class="line">    // 找到最小值放到左边</span><br><span class="line">    for(let j=high; j&gt;low; j--) &#123;</span><br><span class="line">      if(nums[j] &lt; nums[j-1]) &#123;</span><br><span class="line">        [nums[j], nums[j-1]] = [nums[j-1], nums[j]];</span><br><span class="line">        mark = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    low++;</span><br><span class="line">    if(mark)  return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>和冒泡排序相似，区别在于选择排序是将每一个元素和它后面的元素进行比较和交换。</p>
<p>最好：<code>O(n²)</code><br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function selectSort(nums) &#123;</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    for(let j=i+1; j&lt;len; j++) &#123;</span><br><span class="line">      if(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>以第一个元素作为有序数组，其后的元素通过在这个已有序的数组中找到合适的位置并插入。</p>
<p>最好：<code>O(n)</code>，原数组已经是升序的。<br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function insertSort(nums) &#123;</span><br><span class="line">  for(let i=1, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    let temp = nums[i];</span><br><span class="line">    let j = i;</span><br><span class="line">    while(j &gt;= 0 &amp;&amp; temp &lt; nums[j-1]) &#123;</span><br><span class="line">      nums[j] = nums[j-1];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>选择一个元素作为基数（通常是第一个元素），把比基数小的元素放到它左边，比基数大的元素放到它右边（相当于二分），再不断递归基数左右两边的序列。</p>
<p>最好：<code>O(n * logn)</code>，所有数均匀分布在基数的两边，此时的递归就是不断地二分左右序列。<br>最坏：<code>O(n²)</code>，所有数都分布在基数的一边，此时划分左右序列就相当于是插入排序。<br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" target="_blank" rel="noopener">算法 3：最常用的排序——快速排序</a><br><a href="https://blog.csdn.net/insistGoGo/article/details/7785038" target="_blank" rel="noopener">三种快速排序以及快速排序的优化</a></p>
<h2 id="快速排序之填坑"><a href="#快速排序之填坑" class="headerlink" title="快速排序之填坑"></a>快速排序之填坑</h2><p>从右边向中间推进的时候，遇到小于基数的数就赋给左边（一开始是基数的位置），右边保留原先的值等之后被左边的值填上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(nums) &#123;</span><br><span class="line">  // 递归排序基数左右两边的序列</span><br><span class="line">  function recursive(arr, left, right) &#123;</span><br><span class="line">    if(left &gt;= right)  return;</span><br><span class="line">    let index = partition(arr, left, right);</span><br><span class="line">    recursive(arr, left, index - 1);</span><br><span class="line">    recursive(arr, index + 1, right);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  // 将小于基数的数放到基数左边，大于基数的数放到基数右边，并返回基数的位置</span><br><span class="line">  function partition(arr, left, right) &#123;</span><br><span class="line">    // 取第一个数为基数</span><br><span class="line">    let temp = arr[left];</span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">      while(left &lt; right &amp;&amp; arr[right] &gt;= temp)  right--;</span><br><span class="line">      arr[left] = arr[right];</span><br><span class="line">      while(left &lt; right &amp;&amp; arr[left] &lt; temp)  left++;</span><br><span class="line">      arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改基数的位置</span><br><span class="line">    arr[left] = temp;</span><br><span class="line">    return left;</span><br><span class="line">  &#125;</span><br><span class="line">  recursive(nums, 0, nums.length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序之交换"><a href="#快速排序之交换" class="headerlink" title="快速排序之交换"></a>快速排序之交换</h2><p>从左右两边向中间推进的时候，遇到不符合的数就两边交换值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function quickSort1(nums) &#123;</span><br><span class="line">  function recursive(arr, left, right) &#123;</span><br><span class="line">    if(left &gt;= right)  return;</span><br><span class="line">    let index = partition(arr, left, right);</span><br><span class="line">    recursive(arr, left, index - 1);</span><br><span class="line">    recursive(arr, index + 1, right);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  function partition(arr, left, right) &#123;</span><br><span class="line">    let temp = arr[left];</span><br><span class="line">    let p = left + 1;</span><br><span class="line">    let q = right;</span><br><span class="line">    while(p &lt;= q) &#123;</span><br><span class="line">      while(p &lt;= q &amp;&amp; arr[p] &lt; temp)  p++;</span><br><span class="line">      while(p &lt;= q &amp;&amp; arr[q] &gt; temp)  q--;</span><br><span class="line">      if(p &lt;= q) &#123;</span><br><span class="line">        [arr[p], arr[q]] = [arr[q], arr[p]];</span><br><span class="line">        // 交换值后两边各向中间推进一位</span><br><span class="line">        p++;</span><br><span class="line">        q--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改基数的位置</span><br><span class="line">    [arr[left], arr[q]] = [arr[q], arr[left]];</span><br><span class="line">    return q;</span><br><span class="line">  &#125;</span><br><span class="line">  recursive(nums, 0, nums.length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>递归将数组分为两个序列，有序合并这两个序列。</p>
<p>最好：<code>O(n * logn)</code><br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(nums) &#123;</span><br><span class="line">  // 有序合并两个数组</span><br><span class="line">  function merge(l1, r1, l2, r2) &#123;</span><br><span class="line">    let arr = [];</span><br><span class="line">    let index = 0;</span><br><span class="line">    let i = l1, j = l2;</span><br><span class="line">    while(i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line">      arr[index++] = nums[i] &lt; nums[j] ? nums[i++] : nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt;= r1)  arr[index++] = nums[i++];</span><br><span class="line">    while(j &lt;= r2)  arr[index++] = nums[j++];</span><br><span class="line">    // 将有序合并后的数组修改回原数组</span><br><span class="line">    for(let t=0; t&lt;index; t++) &#123;</span><br><span class="line">      nums[l1 + t] = arr[t];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 递归将数组分为两个序列</span><br><span class="line">  function recursive(left, right) &#123;</span><br><span class="line">    if(left &gt;= right)  return;</span><br><span class="line">    // 比起(left+right)/2，更推荐下面这种写法，可以避免数溢出</span><br><span class="line">    let mid = parseInt((right - left) / 2) + left;</span><br><span class="line">    recursive(left, mid);</span><br><span class="line">    recursive(mid+1, right);</span><br><span class="line">    merge(left, mid, mid+1, right);</span><br><span class="line">    return nums;</span><br><span class="line">  &#125;</span><br><span class="line">  recursive(0, nums.length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>取 n 个桶，根据数组的最大值和最小值确认每个桶存放的数的区间，将数组元素插入到相应的桶里，最后再合并各个桶。</p>
<p>最好：<code>O(n)</code>，每个数都在分布在一个桶里，这样就不用将数插入排序到桶里了(类似于计数排序以空间换时间)。<br>最坏：<code>O(n²)</code>，所有的数都分布在一个桶里。<br>平均：<code>O(n + k)</code>，k表示桶的个数。</p>
<p>参考学习链接：<br><a href="http://zhuanlan.51cto.com/art/201811/586129.htm" target="_blank" rel="noopener">拜托，面试别再问我桶排序了！！！</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(nums) &#123;</span><br><span class="line">  // 桶的个数，只要是正数即可</span><br><span class="line">  let num = 5;</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let min = Math.min(...nums);</span><br><span class="line">  // 计算每个桶存放的数值范围，至少为1，</span><br><span class="line">  let range = Math.ceil((max - min) / num) || 1;</span><br><span class="line">  // 创建二维数组，第一维表示第几个桶，第二维表示该桶里存放的数</span><br><span class="line">  let arr = Array.from(Array(num)).map(() =&gt; Array().fill(0));</span><br><span class="line">  nums.forEach(val =&gt; &#123;</span><br><span class="line">    // 计算元素应该分布在哪个桶</span><br><span class="line">    let index = parseInt((val - min) / range);</span><br><span class="line">    // 防止index越界，例如当[5,1,1,2,0,0]时index会出现5</span><br><span class="line">    index = index &gt;= num ? num - 1 : index;</span><br><span class="line">    let temp = arr[index];</span><br><span class="line">    // 插入排序，将元素有序插入到桶中</span><br><span class="line">    let j = temp.length - 1;</span><br><span class="line">    while(j &gt;= 0 &amp;&amp; val &lt; temp[j]) &#123;</span><br><span class="line">      temp[j+1] = temp[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[j+1] = val;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 修改回原数组</span><br><span class="line">  let res = [].concat.apply([], arr);</span><br><span class="line">  nums.forEach((val, i) =&gt; &#123;</span><br><span class="line">    nums[i] = res[i];</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>使用十个桶 0-9，把每个数从低位到高位根据位数放到相应的桶里，以此循环最大值的位数次。<strong>但只能排列正整数，因为遇到负号和小数点无法进行比较</strong>。</p>
<p>最好：<code>O(n * k)</code>，k表示最大值的位数。<br>最坏：<code>O(n * k)</code><br>平均：<code>O(n * k)</code></p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html" target="_blank" rel="noopener">算法总结系列之五: 基数排序(Radix Sort)</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function radixSort(nums) &#123;</span><br><span class="line">  // 计算位数</span><br><span class="line">  function getDigits(n) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">      sum++;</span><br><span class="line">      n = parseInt(n / 10);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line">  // 第一维表示位数即0-9，第二维表示里面存放的值</span><br><span class="line">  let arr = Array.from(Array(10)).map(() =&gt; Array());</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let maxDigits = getDigits(max);</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    // 用0把每一个数都填充成相同的位数</span><br><span class="line">    nums[i] = (nums[i] + &apos;&apos;).padStart(maxDigits, 0);</span><br><span class="line">    // 先根据个位数把每一个数放到相应的桶里</span><br><span class="line">    let temp = nums[i][nums[i].length-1];</span><br><span class="line">    arr[temp].push(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  // 循环判断每个位数</span><br><span class="line">  for(let i=maxDigits-2; i&gt;=0; i--) &#123;</span><br><span class="line">    // 循环每一个桶</span><br><span class="line">    for(let j=0; j&lt;=9; j++) &#123;</span><br><span class="line">      let temp = arr[j]</span><br><span class="line">      let len = temp.length;</span><br><span class="line">      // 根据当前的位数i把桶里的数放到相应的桶里</span><br><span class="line">      while(len--) &#123;</span><br><span class="line">        let str = temp[0];</span><br><span class="line">        temp.shift();</span><br><span class="line">        arr[str[i]].push(str);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 修改回原数组</span><br><span class="line">  let res = [].concat.apply([], arr);</span><br><span class="line">  nums.forEach((val, index) =&gt; &#123;</span><br><span class="line">    nums[index] = +res[index];</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。因为 JavaScript 的数组下标是以字符串形式存储的，所以<strong>计数排序可以用来排列负数，但不可以排列小数</strong>。</p>
<p>最好：<code>O(n + k)</code>，k是最大值和最小值的差。<br>最坏：<code>O(n + k)</code><br>平均：<code>O(n + k)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(nums) &#123;</span><br><span class="line">  let arr = [];</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let min = Math.min(...nums);</span><br><span class="line">  // 装桶</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    let temp = nums[i];</span><br><span class="line">    arr[temp] = arr[temp] + 1 || 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let index = 0;</span><br><span class="line">  // 还原原数组</span><br><span class="line">  for(let i=min; i&lt;=max; i++) &#123;</span><br><span class="line">    while(arr[i] &gt; 0) &#123;</span><br><span class="line">      nums[index++] = i;</span><br><span class="line">      arr[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序优化"><a href="#计数排序优化" class="headerlink" title="计数排序优化"></a>计数排序优化</h2><p>把每一个数组元素都加上 <code>min</code> 的相反数，来避免特殊情况下的空间浪费，通过这种优化可以把所开的空间大小从 <code>max+1</code> 降低为 <code>max-min+1</code>，<code>max</code> 和 <code>min</code> 分别为数组中的最大值和最小值。</p>
<p>比如数组 <code>[103, 102, 101, 100]</code>，普通的计数排序需要开一个长度为 104 的数组，而且前面 100 个值都是 <code>undefined</code>，使用该优化方法后可以只开一个长度为 4 的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(nums) &#123;</span><br><span class="line">  let arr = [];</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let min = Math.min(...nums);</span><br><span class="line">  // 加上最小值的相反数来缩小数组范围</span><br><span class="line">  let add = -min;</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    let temp = nums[i];</span><br><span class="line">    temp += add;</span><br><span class="line">    arr[temp] = arr[temp] + 1 || 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let index = 0;</span><br><span class="line">  for(let i=min; i&lt;=max; i++) &#123;</span><br><span class="line">    let temp = arr[i+add];</span><br><span class="line">    while(temp &gt; 0) &#123;</span><br><span class="line">      nums[index++] = i;</span><br><span class="line">      temp--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>根据数组建立一个堆（类似完全二叉树），每个结点的值都大于左右结点（最大堆，通常用于升序），或小于左右结点（最小堆，通常用于降序）。对于升序排序，先构建最大堆后，交换堆顶元素（表示最大值）和堆底元素，每一次交换都能得到未有序序列的最大值。重新调整最大堆，再交换堆顶元素和堆底元素，重复 n-1 次后就能得到一个升序的数组。</p>
<p>最好：<code>O(n * logn)</code>，logn是调整最大堆所花的时间。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function heapSort(nums) &#123;</span><br><span class="line">  // 调整最大堆，使index的值大于左右节点</span><br><span class="line">  function adjustHeap(nums, index, size) &#123;</span><br><span class="line">    // 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右结点</span><br><span class="line">    while(true) &#123;</span><br><span class="line">      let max = index;</span><br><span class="line">      let left = index * 2 + 1;   // 左节点</span><br><span class="line">      let right = index * 2 + 2;  // 右节点</span><br><span class="line">      if(left &lt; size &amp;&amp; nums[max] &lt; nums[left])  max = left;</span><br><span class="line">      if(right &lt; size &amp;&amp; nums[max] &lt; nums[right])  max = right;</span><br><span class="line">      // 如果左右结点大于当前的结点则交换，并再循环一遍判断交换后的左右结点位置是否破坏了堆结构（比左右结点小了）</span><br><span class="line">      if(index !== max) &#123;</span><br><span class="line">        [nums[index], nums[max]] = [nums[max], nums[index]];</span><br><span class="line">        index = max;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 建立最大堆</span><br><span class="line">  function buildHeap(nums) &#123;</span><br><span class="line">    // 注意这里的头节点是从0开始的，所以最后一个非叶子结点是 parseInt(nums.length/2)-1</span><br><span class="line">    let start = parseInt(nums.length / 2) - 1;</span><br><span class="line">    let size = nums.length;</span><br><span class="line">    // 从最后一个非叶子结点开始调整，直至堆顶。</span><br><span class="line">    for(let i=start; i&gt;=0; i--) &#123;</span><br><span class="line">      adjustHeap(nums, i, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildHeap(nums);</span><br><span class="line">  // 循环n-1次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构</span><br><span class="line">  for(let i=nums.length-1; i&gt;0; i--) &#123;</span><br><span class="line">    [nums[i], nums[0]] = [nums[0], nums[i]];</span><br><span class="line">    adjustHeap(nums, 0, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。</p>
<p>最好：<code>O(n * logn)</code>，步长不断二分。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(nums) &#123;</span><br><span class="line">  let len = nums.length;</span><br><span class="line">  // 初始步数</span><br><span class="line">  let gap = parseInt(len / 2);</span><br><span class="line">  // 逐渐缩小步数</span><br><span class="line">  while(gap) &#123;</span><br><span class="line">    // 从第gap个元素开始遍历</span><br><span class="line">    for(let i=gap; i&lt;len; i++) &#123;</span><br><span class="line">      // 逐步其和前面其他的组成员进行比较和交换</span><br><span class="line">      for(let j=i-gap; j&gt;=0; j-=gap) &#123;</span><br><span class="line">        if(nums[j] &gt; nums[j+gap]) &#123;</span><br><span class="line">          [nums[j], nums[j+gap]] = [nums[j+gap], nums[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gap = parseInt(gap / 2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>贾宛龙</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/06/05/JavaScript：十大排序的算法思路和代码实现/">https://jiawanlong.github.io/2019/06/05/JavaScript：十大排序的算法思路和代码实现/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>要什么版权，欢迎随意转载！</li></ul></div><br><div class="tags"><a href="/tags/排序/">排序</a><a href="/tags/算法/">算法</a></div><div class="post-nav"><a class="pre" href="/2019/06/05/前端面试知识点目录整理/">JavaScript：前端面试知识点目录整理</a><a class="next" href="/2019/06/05/页面性能优化办法有哪些/">页面性能优化办法有哪些</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNzQwMC8xMzkzNA"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://jiawanlong.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/FUCK-FUCK-FUCK/">FUCK FUCK FUCK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FUCK-WORK/">FUCK WORK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GREAT-LIFE/">GREAT LIFE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WHAT-A-BLOG/">WHAT A BLOG</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/Axios/" style="font-size: 15px;">Axios</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/number/" style="font-size: 15px;">number</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/let-const/" style="font-size: 15px;">let const</a> <a href="/tags/函数/" style="font-size: 15px;">函数</a> <a href="/tags/function/" style="font-size: 15px;">function</a> <a href="/tags/async-await/" style="font-size: 15px;">async-await</a> <a href="/tags/leaflet/" style="font-size: 15px;">leaflet</a> <a href="/tags/gis/" style="font-size: 15px;">gis</a> <a href="/tags/supermap专题图/" style="font-size: 15px;">supermap专题图</a> <a href="/tags/专题图/" style="font-size: 15px;">专题图</a> <a href="/tags/GIS/" style="font-size: 15px;">GIS</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/Leaflet/" style="font-size: 15px;">Leaflet</a> <a href="/tags/热力图/" style="font-size: 15px;">热力图</a> <a href="/tags/聚合图/" style="font-size: 15px;">聚合图</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/require-js/" style="font-size: 15px;">require.js</a> <a href="/tags/sea-js/" style="font-size: 15px;">sea.js</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/别，千万别/" style="font-size: 15px;">别，千万别</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/知识点/" style="font-size: 15px;">知识点</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/我爱这被风带走不会再有的每一天/" style="font-size: 15px;">我爱这被风带走不会再有的每一天</a> <a href="/tags/原生js/" style="font-size: 15px;">原生js</a> <a href="/tags/ajax/" style="font-size: 15px;">ajax</a> <a href="/tags/图吧/" style="font-size: 15px;">图吧</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/加密坐标/" style="font-size: 15px;">加密坐标</a> <a href="/tags/坐标转换/" style="font-size: 15px;">坐标转换</a> <a href="/tags/数组/" style="font-size: 15px;">数组</a> <a href="/tags/FUCK/" style="font-size: 15px;">FUCK</a> <a href="/tags/社会主义好/" style="font-size: 15px;">社会主义好</a> <a href="/tags/组件/" style="font-size: 15px;">组件</a> <a href="/tags/组件化/" style="font-size: 15px;">组件化</a> <a href="/tags/开发环境/" style="font-size: 15px;">开发环境</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/页面性能/" style="font-size: 15px;">页面性能</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/05/前端面试知识点目录整理/">JavaScript：前端面试知识点目录整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/05/JavaScript：十大排序的算法思路和代码实现/">JavaScript：十大排序的算法思路和代码实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/05/页面性能优化办法有哪些/">页面性能优化办法有哪些</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/async-await入门/">async-await入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/数组遍历方法详解/">数组遍历方法详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/Axios入门/">Axios入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/15/ES6第三课、number扩展/">ES6第三课、number扩展</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/15/ES6第四课、函数扩展/">ES6第四课、函数扩展</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/原生js封装ajax/">原生js封装ajax</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/ES6第二课、字符串扩展/">ES6第二课、字符串扩展</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.wejser.com/" title="贾宛龙个人网站" target="_blank">贾宛龙个人网站</a><ul></ul><a href="http://www.github.com/jiawanlong" title="贾宛龙的github" target="_blank">贾宛龙的github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">狗敦A季 本站第</a><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span></span><span>位访客</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>