/*!
 * 
 *     ol-mapbox-style
 *     Copyright 2016-present Boundless Spatial
 *     CopyrightÂ© 2000-2018 SuperMap Software Co. Ltd
 *     github: https://github.com/boundlessgeo/ol-mapbox-style
 *     github: https://github.com/SuperMap/ol-mapbox-style
 *     license: BSD 2-Clause "Simplified" License
 *     version: v2.11.2-4
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("ol/Map"), require("ol/Observable"), require("ol/format/GeoJSON"), require("ol/format/MVT"), require("ol/geom/Point"), require("ol/layer/Tile"), require("ol/layer/Vector"), require("ol/layer/VectorTile"), require("ol/proj"), require("ol/source/TileJSON"), require("ol/source/Vector"), require("ol/source/VectorTile"), require("ol/style/Circle"), require("ol/style/Fill"), require("ol/style/Icon"), require("ol/style/Stroke"), require("ol/style/Style"), require("ol/style/Text"), require("ol/tilegrid"));
	else if(typeof define === 'function' && define.amd)
		define(["ol/Map", "ol/Observable", "ol/format/GeoJSON", "ol/format/MVT", "ol/geom/Point", "ol/layer/Tile", "ol/layer/Vector", "ol/layer/VectorTile", "ol/proj", "ol/source/TileJSON", "ol/source/Vector", "ol/source/VectorTile", "ol/style/Circle", "ol/style/Fill", "ol/style/Icon", "ol/style/Stroke", "ol/style/Style", "ol/style/Text", "ol/tilegrid"], factory);
	else if(typeof exports === 'object')
		exports["olms"] = factory(require("ol/Map"), require("ol/Observable"), require("ol/format/GeoJSON"), require("ol/format/MVT"), require("ol/geom/Point"), require("ol/layer/Tile"), require("ol/layer/Vector"), require("ol/layer/VectorTile"), require("ol/proj"), require("ol/source/TileJSON"), require("ol/source/Vector"), require("ol/source/VectorTile"), require("ol/style/Circle"), require("ol/style/Fill"), require("ol/style/Icon"), require("ol/style/Stroke"), require("ol/style/Style"), require("ol/style/Text"), require("ol/tilegrid"));
	else
		root["olms"] = factory(root["ol"]["Map"], root["ol"]["Observable"], root["ol"]["format"]["GeoJSON"], root["ol"]["format"]["MVT"], root["ol"]["geom"]["Point"], root["ol"]["layer"]["Tile"], root["ol"]["layer"]["Vector"], root["ol"]["layer"]["VectorTile"], root["ol"]["proj"], root["ol"]["source"]["TileJSON"], root["ol"]["source"]["Vector"], root["ol"]["source"]["VectorTile"], root["ol"]["style"]["Circle"], root["ol"]["style"]["Fill"], root["ol"]["style"]["Icon"], root["ol"]["style"]["Stroke"], root["ol"]["style"]["Style"], root["ol"]["style"]["Text"], root["ol"]["tilegrid"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_ol_Map__, __WEBPACK_EXTERNAL_MODULE_ol_Observable__, __WEBPACK_EXTERNAL_MODULE_ol_format_GeoJSON__, __WEBPACK_EXTERNAL_MODULE_ol_format_MVT__, __WEBPACK_EXTERNAL_MODULE_ol_geom_Point__, __WEBPACK_EXTERNAL_MODULE_ol_layer_Tile__, __WEBPACK_EXTERNAL_MODULE_ol_layer_Vector__, __WEBPACK_EXTERNAL_MODULE_ol_layer_VectorTile__, __WEBPACK_EXTERNAL_MODULE_ol_proj__, __WEBPACK_EXTERNAL_MODULE_ol_source_TileJSON__, __WEBPACK_EXTERNAL_MODULE_ol_source_Vector__, __WEBPACK_EXTERNAL_MODULE_ol_source_VectorTile__, __WEBPACK_EXTERNAL_MODULE_ol_style_Circle__, __WEBPACK_EXTERNAL_MODULE_ol_style_Fill__, __WEBPACK_EXTERNAL_MODULE_ol_style_Icon__, __WEBPACK_EXTERNAL_MODULE_ol_style_Stroke__, __WEBPACK_EXTERNAL_MODULE_ol_style_Style__, __WEBPACK_EXTERNAL_MODULE_ol_style_Text__, __WEBPACK_EXTERNAL_MODULE_ol_tilegrid__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./olms.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                                              ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                                                                                                                                                                                                                                              Copyright 2016-present Boundless Spatial, Inc.
                                                                                                                                                                                                                                                                              License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                                                                                                                                                                                                                                              */

exports.applyStyle = applyStyle;
exports.applyBackground = applyBackground;
exports.apply = apply;
exports.getLayer = getLayer;
exports.getSource = getSource;

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

var _google = __webpack_require__(/*! webfont-matcher/lib/fonts/google */ "./node_modules/webfont-matcher/lib/fonts/google.js");

var _google2 = _interopRequireDefault(_google);

var _proj = __webpack_require__(/*! ol/proj */ "ol/proj");

var _tilegrid = __webpack_require__(/*! ol/tilegrid */ "ol/tilegrid");

var _Map = __webpack_require__(/*! ol/Map */ "ol/Map");

var _Map2 = _interopRequireDefault(_Map);

var _GeoJSON = __webpack_require__(/*! ol/format/GeoJSON */ "ol/format/GeoJSON");

var _GeoJSON2 = _interopRequireDefault(_GeoJSON);

var _MVT = __webpack_require__(/*! ol/format/MVT */ "ol/format/MVT");

var _MVT2 = _interopRequireDefault(_MVT);

var _Observable = __webpack_require__(/*! ol/Observable */ "ol/Observable");

var _Tile = __webpack_require__(/*! ol/layer/Tile */ "ol/layer/Tile");

var _Tile2 = _interopRequireDefault(_Tile);

var _Vector = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");

var _Vector2 = _interopRequireDefault(_Vector);

var _VectorTile = __webpack_require__(/*! ol/layer/VectorTile */ "ol/layer/VectorTile");

var _VectorTile2 = _interopRequireDefault(_VectorTile);

var _TileJSON = __webpack_require__(/*! ol/source/TileJSON */ "ol/source/TileJSON");

var _TileJSON2 = _interopRequireDefault(_TileJSON);

var _Vector3 = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");

var _Vector4 = _interopRequireDefault(_Vector3);

var _VectorTile3 = __webpack_require__(/*! ol/source/VectorTile */ "ol/source/VectorTile");

var _VectorTile4 = _interopRequireDefault(_VectorTile3);

var _XYZ = __webpack_require__(/*! ol/source/XYZ */ "./node_modules/ol/source/XYZ.js");

var _XYZ2 = _interopRequireDefault(_XYZ);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var availableFonts;

function loadFont(fonts) {
  var i, ii;
  if (!Array.isArray(fonts)) {
    var stops = fonts.stops;
    if (stops) {
      for (i = 0, ii = stops.length; i < ii; ++i) {
        loadFont(stops[i][1]);
      }
    }
    return;
  }
  var googleFamilies = _google2.default.getNames();
  var families = fonts.map(function (font) {
    return (0, _mapboxToCssFont2.default)(font, 1).split(' 1px ')[1].replace(/"/g, '');
  });
  for (i = 0, ii = families.length; i < ii; ++i) {
    var family = families[i];
    var font = fonts[i];
    if (googleFamilies.indexOf(family) !== -1) {
      if (!availableFonts) {
        availableFonts = [];
      }
      if (availableFonts.indexOf(font) == -1) {
        availableFonts.push(font);
        var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+');
        if (!document.querySelector('link[href="' + fontUrl + '"]')) {
          var markup = document.createElement('link');
          markup.href = fontUrl;
          markup.rel = 'stylesheet';
          document.getElementsByTagName('head')[0].appendChild(markup);
        }
      }
      break;
    }
  }
}

var defaultFont = ['Open Sans Regular', 'Arial Regular'];

function preprocess(layer) {
  if ('layout' in layer && 'text-field' in layer.layout) {
    loadFont(layer.layout['text-font'] || defaultFont);
  }
}

var spriteRegEx = /^(.*)(\?.*)$/;

function withPath(url, path) {
  if (path && url.indexOf('http') != 0) {
    url = path + url;
  }
  return url;
}

function toSpriteUrl(url, path, extension) {
  url = withPath(url, path);
  var parts = url.match(spriteRegEx);
  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;
}

/**
 * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`
 * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function
 * will render all layers from the `glStyle` object that use the specified
 * `source`, or a subset of layers from the same source. The source needs to be
 * a `"type": "vector"`, `"type": "geojson"` or `"type": "raster"` source.
 *
 * @param {ol.layer.VectorTile} layer OpenLayers layer.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string} source `source` key or an array of layer `id`s from the
 * Mapbox Style object. When a `source` key is provided, all layers for the
 * specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {string} [path=undefined] Path of the style file. Only required when
 * a relative path is used with the `"sprite"` property of the style.
 * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */
function applyStyle(layer, glStyle, source, path, resolutions) {
  return new Promise(function (resolve, reject) {

    if ((typeof glStyle === 'undefined' ? 'undefined' : _typeof(glStyle)) != 'object') {
      glStyle = JSON.parse(glStyle);
    }
    if (glStyle.version != 8) {
      reject(new Error('glStyle version 8 required.'));
    }
    var spriteScale, spriteData, spriteImageUrl;
    if (glStyle.sprite) {
      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
      var sizeFactor = spriteScale == 0.5 ? '@2x' : '';
      var spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');

      fetch(spriteUrl, { credentials: 'same-origin' }).then(function (response) {
        // if the response is ready return the JSON promise
        if (response.status === 200) {
          return response.json();
        } else if (sizeFactor !== '') {
          // return the JSON promise for the low-resolution sprites.
          sizeFactor = '';
          spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');
          return fetch(spriteUrl, { credentials: 'same-origin' }).then(function (r) {
            return r.json();
          });
        }
      }).then(function (spritesJson) {
        if (spritesJson === undefined) {
          throw 'No sprites found.';
        }
        spriteData = spritesJson;
        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');
        onChange();
      }).catch(function (err) {
        console.error(err);
        reject(new Error('Sprites cannot be loaded from ' + spriteUrl));
      });
    }

    var style;
    function onChange() {
      if (!style && (!glStyle.sprite || spriteData) && (!availableFonts || availableFonts.length > 0)) {
        style = (0, _stylefunction2.default)(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, availableFonts);
        resolve();
      } else if (style) {
        layer.setStyle(style);
      }
    }

    if (layer instanceof _VectorTile2.default || layer instanceof _Vector2.default) {
      try {
        var layers = glStyle.layers;
        for (var i = 0, ii = layers.length; i < ii; ++i) {
          if (typeof source == 'string' && layers[i].source == source || source.indexOf(layers[i].id) >= 0) {
            preprocess(layers[i]);
          }
        }
        onChange();
      } catch (e) {
        setTimeout(function () {
          reject(e);
        }, 0);
      }
    }
  });
}

function setBackground(map, layer) {
  var background = {
    type: layer.type
  };
  function updateStyle() {
    var element = map.getTargetElement();
    if (!element) {
      return;
    }
    var layout = layer.layout || {};
    var paint = layer.paint || {};
    background['paint'] = paint;
    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];
    var zoom = map.getView().getZoom();
    if (paint['background-color'] !== undefined) {
      var bg = (0, _stylefunction.getValue)(background, 'paint', 'background-color', zoom, {});
      element.style.background = _mapboxGlStyleSpec.Color.parse(bg).toString();
    }
    if (paint['background-opacity'] !== undefined) {
      element.style.opacity = (0, _stylefunction.getValue)(background, 'paint', 'background-opacity', zoom, {});
    }
    if (layout.visibility == 'none') {
      element.style.backgroundColor = '';
      element.style.opacity = '';
    }
  }
  if (map.getTargetElement()) {
    updateStyle();
  }
  map.on(['change:resolution', 'change:target'], updateStyle);
}

/**
 * Applies properties of the Mapbox Style's first `background` layer to the map.
 * @param {ol.Map} map OpenLayers Map.
 * @param {Object} glStyle Mapbox Style object.
 */
function applyBackground(map, glStyle) {
  glStyle.layers.some(function (l) {
    if (l.type == 'background') {
      setBackground(map, l);
      return true;
    }
  });
}

function getSourceIdByRef(layers, ref) {
  var sourceId;
  layers.some(function (layer) {
    if (layer.id == ref) {
      sourceId = layer.source;
      return true;
    }
  });
  return sourceId;
}

function processStyle(glStyle, map, baseUrl, host, path, accessToken) {
  var view = map.getView();
  if ('center' in glStyle && !view.getCenter()) {
    view.setCenter((0, _proj.fromLonLat)(glStyle.center));
  }
  if ('zoom' in glStyle && view.getZoom() === undefined) {
    view.setZoom(glStyle.zoom);
  }
  if (!view.getCenter() || view.getZoom() === undefined) {
    view.fit(view.getProjection().getExtent(), {
      nearest: true,
      size: map.getSize()
    });
  }
  if (glStyle.sprite) {
    if (glStyle.sprite.indexOf('mapbox://') == 0) {
      glStyle.sprite = baseUrl + '/sprite' + accessToken;
    } else if (glStyle.sprite.indexOf('http') != 0) {
      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;
    }
  }

  var glLayers = glStyle.layers;
  var geoJsonFormat = new _GeoJSON2.default();
  var layerIds = [];

  function finalizeLayer(layer) {
    if (layerIds.length > 0) {
      map.addLayer(layer);
      var setStyle = function setStyle() {
        applyStyle(layer, glStyle, layerIds, path).then(function () {
          layer.setVisible(true);
        }, function (e) {
          /*eslint no-console: ["error", { allow: ["error"] }] */
          console.error(e);
        });
      };
      if (layer.getSource()) {
        setStyle();
      } else {
        layer.once('change:source', setStyle);
      }
    }
  }

  var glLayer, glSource, glSourceId, id, layer, mapid, url;
  for (var i = 0, ii = glLayers.length; i < ii; ++i) {
    glLayer = glLayers[i];
    if (glLayer.type == 'background') {
      setBackground(map, glLayer);
    } else {
      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
      if (id != glSourceId) {
        finalizeLayer(layer);
        layerIds = [];
        glSource = glStyle.sources[id];
        url = glSource.url;
        var tiles = glSource.tiles;
        if (url) {
          if (url.indexOf('mapbox://') == 0) {
            mapid = url.replace('mapbox://', '');
            tiles = ['a', 'b', 'c', 'd'].map(function (host) {
              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;
            });
          }
        }

        if (glSource.type == 'vector') {
          layer = tiles ? function () {
            var tileGrid = (0, _tilegrid.createXYZ)({
              tileSize: 512,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              minZoom: glSource.minzoom
            });
            return new _VectorTile2.default({
              declutter: true,
              maxResolution: tileGrid.getMinZoom() > 0 ? tileGrid.getResolution(tileGrid.getMinZoom()) : undefined,
              source: new _VectorTile4.default({
                attributions: glSource.attribution,
                format: new _MVT2.default(),
                tileGrid: tileGrid,
                urls: tiles
              }),
              visible: false,
              zIndex: i
            });
          }() : function () {
            var layer = new _VectorTile2.default({
              declutter: true,
              visible: false,
              zIndex: i
            });
            var tilejson = new _TileJSON2.default({
              url: url
            });
            var key = tilejson.on('change', function () {
              if (tilejson.getState() == 'ready') {
                var tileJSONDoc = tilejson.getTileJSON();
                var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];
                for (var i = 0, ii = tiles.length; i < ii; ++i) {
                  var tile = tiles[i];
                  if (tile.indexOf('http') != 0) {
                    tiles[i] = glSource.url + tile;
                  }
                }
                var tileGrid = tilejson.getTileGrid();
                layer.setSource(new _VectorTile4.default({
                  attributions: tilejson.getAttributions() || tileJSONDoc.attribution,
                  format: new _MVT2.default(),
                  tileGrid: (0, _tilegrid.createXYZ)({
                    minZoom: tileGrid.getMinZoom(),
                    maxZoom: tileGrid.getMaxZoom(),
                    tileSize: 512
                  }),
                  urls: tiles
                }));
                if (tileGrid.getMinZoom() > 0) {
                  layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));
                }
                (0, _Observable.unByKey)(key);
              }
            });
            return layer;
          }();
        } else if (glSource.type == 'raster') {
          var source;
          if (!glSource.tiles) {
            source = function () {
              return new _TileJSON2.default({
                url: url,
                crossOrigin: 'anonymous'
              });
            }();
          } else {
            source = new _XYZ2.default({
              attributions: glSource.attribution,
              minZoom: glSource.minzoom,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              tileSize: glSource.tileSize || 512,
              url: url,
              urls: glSource.tiles,
              crossOrigin: 'anonymous'
            });
          }
          source.setTileLoadFunction(function (tile, src) {
            if (src.indexOf('{bbox-epsg-3857}') != -1) {
              var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());
              src = src.replace('{bbox-epsg-3857}', bbox.toString());
            }
            tile.getImage().src = src;
          });
          layer = new _Tile2.default({
            source: source,
            visible: glLayer.layout ? glLayer.layout.visibility !== 'none' : true
          });
        } else if (glSource.type == 'geojson') {
          var data = glSource.data;
          var features, geoJsonUrl;
          if (typeof data == 'string') {
            geoJsonUrl = withPath(data, path);
          } else {
            features = geoJsonFormat.readFeatures(data, { featureProjection: 'EPSG:3857' });
          }
          layer = new _Vector2.default({
            source: new _Vector4.default({
              attributions: glSource.attribution,
              features: features,
              format: geoJsonFormat,
              url: geoJsonUrl
            }),
            visible: false,
            zIndex: i
          });
        }
        glSourceId = id;
      }
      layerIds.push(glLayer.id);
    }
  }
  finalizeLayer(layer);
  map.set('mapbox-style', glStyle);
}

/**
 * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes
 * the map background, the layers, the center and the zoom.
 *
 * The center and zoom will only be set if present in the Mapbox Style document,
 * and if not already set on the OpenLayers map.
 *
 * Layers will be added to the OpenLayers map, without affecting any layers that
 * might already be set on the map.
 *
 * Layers added by `apply()` will have two additional properties:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * The map returned by this function will have an additional `mapbox-style`
 * property which holds the Mapbox Style object.
 *
 * @param {ol.Map|HTMLElement|string} map Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url must contain an access
 * token and look like
 * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @return {ol.Map} The OpenLayers Map instance that will be populated with the
 * contents described in the Mapbox Style object.
 */
function apply(map, style) {

  var accessToken, baseUrl, host, path;
  accessToken = baseUrl = host = path = '';

  if (!(map instanceof _Map2.default)) {
    map = new _Map2.default({
      target: map
    });
  }

  if (typeof style === 'string') {
    var parts = style.match(spriteRegEx);
    if (parts) {
      baseUrl = parts[1];
      accessToken = parts.length > 2 ? parts[2] : '';
    }

    fetch(style, {
      credentials: 'same-origin'
    }).then(function (response) {
      return response.json();
    }).then(function (glStyle) {
      var a = document.createElement('A');
      a.href = style;
      path = a.pathname.split('/').slice(0, -1).join('/') + '/';
      host = style.substr(0, style.indexOf(path));

      processStyle(glStyle, map, baseUrl, host, path, accessToken);
    }).catch(function (err) {
      console.error(err);
      throw new Error('Could not load ' + style);
    });
  } else {
    setTimeout(function () {
      processStyle(style, map);
    }, 0);
  }
  return map;
}

/**
 * Get the OpenLayers layer instance that contains the provided Mapbox Style
 * `layer`. Note that multiple Mapbox Style layers are combined in a single
 * OpenLayers layer instance when they use the same Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} layerId Mapbox Style layer id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getLayer(map, layerId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    if (layers[i].get('mapbox-layers').indexOf(layerId) !== -1) {
      return layers[i];
    }
  }
}

/**
 * Get the OpenLayers source instance for the provided Mapbox Style `source`.
 * @param {ol.Map} map OpenLayers Map.
 * @param {string} sourceId Mapbox Style source id.
 * @return {ol.layer.Layer} layer OpenLayers layer instance.
 */
function getSource(map, sourceId) {
  var layers = map.getLayers().getArray();
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var source = layers[i].getSource();
    if (layers[i].get('mapbox-source').indexOf(sourceId) !== -1) {
      return source;
    }
  }
}

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toArray3(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var $version = 8;
var $root = {
    version: {
        required: true,
        type: "enum",
        values: [8],
        doc: "Style specification version number. Must be 8.",
        example: 8
    },
    name: {
        type: "string",
        doc: "A human-readable name for the style.",
        example: "Bright"
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    center: {
        type: "array",
        value: "number",
        doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: [-73.9749, 40.7736]
    },
    zoom: {
        type: "number",
        doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 12.5
    },
    bearing: {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90Â° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 29
    },
    pitch: {
        type: "number",
        "default": 0,
        units: "degrees",
        doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
        example: 50
    },
    light: {
        type: "light",
        doc: "The global light source.",
        example: {
            anchor: "viewport",
            color: "white",
            intensity: 0.4
        }
    },
    terrain: {
        type: "terrain",
        doc: "A global modifier that elevates layers and markers based on a DEM data source."
    },
    fog: {
        type: "fog",
        doc: "A global effect that fades layers and markers based on their distance to the camera. The fog can be used to approximate the effect of atmosphere on distant objects and enhance the depth perception of the map when used with terrain or 3D features."
    },
    sources: {
        required: true,
        type: "sources",
        doc: "Data source specifications.",
        example: {
            "mapbox-streets": {
                type: "vector",
                url: "mapbox://mapbox.mapbox-streets-v6"
            }
        }
    },
    sprite: {
        type: "string",
        doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://sprites/mapbox/bright-v8"
    },
    glyphs: {
        type: "string",
        doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
        example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    transition: {
        type: "transition",
        doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
        example: {
            duration: 300,
            delay: 0
        }
    },
    projection: {
        type: "projection",
        doc: "The projection the map should be rendered in. Suported projections are Albers, Equal Earth, Equirectangular (WGS84), Lambert conformal conic, Mercator, Natural Earth, and Winkel Tripel. Terrain, fog, sky and CustomLayerInterface are not supported for projections other than mercator.",
        example: {
            name: "albers",
            center: [-154, 50],
            parallels: [55, 65]
        }
    },
    layers: {
        required: true,
        type: "array",
        value: "layer",
        doc: "Layers will be drawn in the order of this array.",
        example: [{
            id: "water",
            source: "mapbox-streets",
            "source-layer": "water",
            type: "fill",
            paint: {
                "fill-color": "#00ffff"
            }
        }]
    }
};
var sources = {
    "*": {
        type: "source",
        doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
    }
};
var source = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var source_vector = {
    type: {
        required: true,
        type: "enum",
        values: {
            vector: {
                doc: "A vector tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."
    },
    volatile: {
        type: "boolean",
        "default": false,
        doc: "A setting to determine whether a source's tiles are cached locally.",
        "sdk-support": {
            "basic functionality": {
                android: "9.3.0",
                ios: "5.10.0"
            }
        }
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster = {
    type: {
        required: true,
        type: "enum",
        values: {
            raster: {
                doc: "A raster tile source."
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    scheme: {
        type: "enum",
        values: {
            xyz: {
                doc: "Slippy map tilenames scheme."
            },
            tms: {
                doc: "OSGeo spec scheme."
            }
        },
        "default": "xyz",
        doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    volatile: {
        type: "boolean",
        "default": false,
        doc: "A setting to determine whether a source's tiles are cached locally.",
        "sdk-support": {
            "basic functionality": {
                android: "9.3.0",
                ios: "5.10.0"
            }
        }
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_raster_dem = {
    type: {
        required: true,
        type: "enum",
        values: {
            "raster-dem": {
                doc: "A RGB-encoded raster DEM source"
            }
        },
        doc: "The type of the source."
    },
    url: {
        type: "string",
        doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
    },
    tiles: {
        type: "array",
        value: "string",
        doc: "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    bounds: {
        type: "array",
        value: "number",
        length: 4,
        "default": [-180, -85.051129, 180, 85.051129],
        doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
    },
    minzoom: {
        type: "number",
        "default": 0,
        doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    maxzoom: {
        type: "number",
        "default": 22,
        doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    tileSize: {
        type: "number",
        "default": 512,
        units: "pixels",
        doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    encoding: {
        type: "enum",
        values: {
            terrarium: {
                doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
            },
            mapbox: {
                doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
            }
        },
        "default": "mapbox",
        doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
    },
    volatile: {
        type: "boolean",
        "default": false,
        doc: "A setting to determine whether a source's tiles are cached locally.",
        "sdk-support": {
            "basic functionality": {
                android: "9.3.0",
                ios: "5.10.0"
            }
        }
    },
    "*": {
        type: "*",
        doc: "Other keys to configure the data source."
    }
};
var source_geojson = {
    type: {
        required: true,
        type: "enum",
        values: {
            geojson: {
                doc: "A GeoJSON data source."
            }
        },
        doc: "The data type of the GeoJSON source."
    },
    data: {
        type: "*",
        doc: "A URL to a GeoJSON file, or inline GeoJSON."
    },
    maxzoom: {
        type: "number",
        "default": 18,
        doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    },
    attribution: {
        type: "string",
        doc: "Contains an attribution to be displayed when the map is shown to a user."
    },
    buffer: {
        type: "number",
        "default": 128,
        maximum: 512,
        minimum: 0,
        doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
    },
    filter: {
        type: "*",
        doc: "An expression for filtering features prior to processing them for rendering."
    },
    tolerance: {
        type: "number",
        "default": 0.375,
        doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    },
    cluster: {
        type: "boolean",
        "default": false,
        doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
    },
    clusterRadius: {
        type: "number",
        "default": 50,
        minimum: 0,
        doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
    },
    clusterMaxZoom: {
        type: "number",
        doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15."
    },
    clusterMinPoints: {
        type: "number",
        doc: "Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`."
    },
    clusterProperties: {
        type: "*",
        doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\"property_name\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\"+\"` or `\"max\"`) â it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{\"sum\": [\"+\", [\"get\", \"scalerank\"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\"accumulated\"]` value, e.g.:\n`{\"sum\": [[\"+\", [\"accumulated\"], [\"get\", \"sum\"]], [\"get\", \"scalerank\"]]}`"
    },
    lineMetrics: {
        type: "boolean",
        "default": false,
        doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
    },
    generateId: {
        type: "boolean",
        "default": false,
        doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
    },
    promoteId: {
        type: "promoteId",
        doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
    }
};
var source_video = {
    type: {
        required: true,
        type: "enum",
        values: {
            video: {
                doc: "A video data source."
            }
        },
        doc: "The data type of the video source."
    },
    urls: {
        required: true,
        type: "array",
        value: "string",
        doc: "URLs to video content in order of preferred format."
    },
    coordinates: {
        required: true,
        doc: "Corners of video specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var source_image = {
    type: {
        required: true,
        type: "enum",
        values: {
            image: {
                doc: "An image data source."
            }
        },
        doc: "The data type of the image source."
    },
    url: {
        required: true,
        type: "string",
        doc: "URL that points to an image."
    },
    coordinates: {
        required: true,
        doc: "Corners of image specified in longitude, latitude pairs.",
        type: "array",
        length: 4,
        value: {
            type: "array",
            length: 2,
            value: "number",
            doc: "A single longitude, latitude pair."
        }
    }
};
var layer = {
    id: {
        type: "string",
        doc: "Unique layer name.",
        required: true
    },
    type: {
        type: "enum",
        values: {
            fill: {
                doc: "A filled polygon with an optional stroked border.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            line: {
                doc: "A stroked line.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            symbol: {
                doc: "An icon or a text label.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            circle: {
                doc: "A filled circle.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            heatmap: {
                doc: "A heatmap.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.41.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            "fill-extrusion": {
                doc: "An extruded (3D) polygon.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.27.0",
                        android: "5.1.0",
                        ios: "3.6.0",
                        macos: "0.5.0"
                    }
                }
            },
            raster: {
                doc: "Raster map textures such as satellite imagery.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            hillshade: {
                doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.43.0",
                        android: "6.0.0",
                        ios: "4.0.0",
                        macos: "0.7.0"
                    }
                }
            },
            background: {
                doc: "The background color or pattern of the map.",
                "sdk-support": {
                    "basic functionality": {
                        js: "0.10.0",
                        android: "2.0.1",
                        ios: "2.0.0",
                        macos: "0.1.0"
                    }
                }
            },
            sky: {
                doc: "A spherical dome around the map that is always rendered behind all other layers.",
                "sdk-support": {
                    "basic functionality": {
                        js: "2.0.0",
                        ios: "10.0.0",
                        android: "10.0.0"
                    }
                }
            }
        },
        doc: "Rendering type of this layer.",
        required: true
    },
    metadata: {
        type: "*",
        doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    source: {
        type: "string",
        doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
    },
    "source-layer": {
        type: "string",
        doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
    },
    minzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
    },
    maxzoom: {
        type: "number",
        minimum: 0,
        maximum: 24,
        doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
    },
    filter: {
        type: "filter",
        doc: "An expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `[\"feature-state\", ...]` expression is not supported in filter expressions.  The `[\"pitch\"]` and `[\"distance-from-center\"]` expressions are supported only for filter expressions on the symbol layer."
    },
    layout: {
        type: "layout",
        doc: "Layout properties for the layer."
    },
    paint: {
        type: "paint",
        doc: "Default paint properties for this layer."
    }
};
var layout = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"];
var layout_background = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_sky = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_fill = {
    "fill-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0",
                android: "9.1.0",
                ios: "5.8.0",
                macos: "0.15.0"
            },
            "data-driven styling": {
                js: "1.2.0",
                android: "9.1.0",
                ios: "5.8.0",
                macos: "0.15.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_circle = {
    "circle-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0",
                android: "9.2.0",
                ios: "5.9.0",
                macos: "0.16.0"
            },
            "data-driven styling": {
                js: "1.2.0",
                android: "9.2.0",
                ios: "5.9.0",
                macos: "0.16.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_heatmap = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_line = {
    "line-cap": {
        type: "enum",
        values: {
            butt: {
                doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
            },
            round: {
                doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            square: {
                doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            }
        },
        "default": "butt",
        doc: "The display of line endings.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "2.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "line-join": {
        type: "enum",
        values: {
            bevel: {
                doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
            },
            round: {
                doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
            },
            miter: {
                doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
            }
        },
        "default": "miter",
        doc: "The display of lines when joining.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "line-miter-limit": {
        type: "number",
        "default": 2,
        doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
        requires: [{
            "line-join": "miter"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-round-limit": {
        type: "number",
        "default": 1.05,
        doc: "Used to automatically convert round joins to miter joins for shallow angles.",
        requires: [{
            "line-join": "round"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "1.2.0",
                android: "9.1.0",
                ios: "5.8.0",
                macos: "0.15.0"
            },
            "data-driven styling": {
                js: "1.2.0",
                android: "9.1.0",
                ios: "5.8.0",
                macos: "0.15.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_symbol = {
    "symbol-placement": {
        type: "enum",
        values: {
            point: {
                doc: "The label is placed at the point where the geometry is located."
            },
            line: {
                doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
            },
            "line-center": {
                doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
            }
        },
        "default": "point",
        doc: "Label placement relative to its geometry.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`line-center` value": {
                js: "0.47.0",
                android: "6.4.0",
                ios: "4.3.0",
                macos: "0.10.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-spacing": {
        type: "number",
        "default": 250,
        minimum: 1,
        units: "pixels",
        doc: "Distance between two symbol anchors.",
        requires: [{
            "symbol-placement": "line"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-avoid-edges": {
        type: "boolean",
        "default": false,
        doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "symbol-sort-key": {
        type: "number",
        doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
        "sdk-support": {
            "basic functionality": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.53.0",
                android: "7.4.0",
                ios: "4.11.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "symbol-z-order": {
        type: "enum",
        values: {
            auto: {
                doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
            },
            "viewport-y": {
                doc: "Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
            },
            source: {
                doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data."
            }
        },
        "default": "auto",
        doc: "Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.49.0",
                android: "6.6.0",
                ios: "4.5.0",
                macos: "0.12.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the icon.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
            },
            viewport: {
                doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-size": {
        type: "number",
        "default": 1,
        minimum: 0,
        units: "factor of the original icon size",
        doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-text-fit": {
        type: "enum",
        values: {
            none: {
                doc: "The icon is displayed at its intrinsic aspect ratio."
            },
            width: {
                doc: "The icon is scaled in the x-dimension to fit the width of the text."
            },
            height: {
                doc: "The icon is scaled in the y-dimension to fit the height of the text."
            },
            both: {
                doc: "The icon is scaled in both x- and y-dimensions."
            }
        },
        "default": "none",
        doc: "Scales the icon to fit around the associated text.",
        requires: ["icon-image", "text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            },
            "stretchable icons": {
                js: "1.6.0",
                android: "9.2.0",
                ios: "5.8.0",
                macos: "0.15.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-text-fit-padding": {
        type: "array",
        value: "number",
        length: 4,
        "default": [0, 0, 0, 0],
        units: "pixels",
        doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
        requires: ["icon-image", "text-field", {
            "icon-text-fit": ["both", "width", "height"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-image": {
        type: "resolvedImage",
        doc: "Name of image in sprite to use for drawing an image background.",
        tokens: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the icon clockwise.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-keep-upright": {
        type: "boolean",
        "default": false,
        doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
        requires: ["icon-image", {
            "icon-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-offset": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the icon is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the icon is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the icon is placed closest to the anchor."
            },
            top: {
                doc: "The top of the icon is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the icon is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the icon is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the icon is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the icon is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the icon is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the icon placed closest to the anchor.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "icon-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The icon is aligned to the plane of the map."
            },
            viewport: {
                doc: "The icon is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `icon-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of icon when map is pitched.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The text is aligned to the plane of the map."
            },
            viewport: {
                doc: "The text is aligned to the plane of the viewport."
            },
            auto: {
                doc: "Automatically matches the value of `text-rotation-alignment`."
            }
        },
        "default": "auto",
        doc: "Orientation of text when map is pitched.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotation-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
            },
            viewport: {
                doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
            },
            auto: {
                doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
            }
        },
        "default": "auto",
        doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "`auto` value": {
                js: "0.25.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-field": {
        type: "formatted",
        "default": "",
        tokens: true,
        doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-font": {
        type: "array",
        value: "string",
        "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
        doc: "Font stack to use for displaying text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-size": {
        type: "number",
        "default": 16,
        minimum: 0,
        units: "pixels",
        doc: "Font size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-width": {
        type: "number",
        "default": 10,
        minimum: 0,
        units: "ems",
        doc: "The maximum line width for text wrapping.",
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-line-height": {
        type: "number",
        "default": 1.2,
        units: "ems",
        doc: "Text leading value for multi-line text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "2.3.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-letter-spacing": {
        type: "number",
        "default": 0,
        units: "ems",
        doc: "Text tracking amount.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.40.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-justify": {
        type: "enum",
        values: {
            auto: {
                doc: "The text is aligned towards the anchor position."
            },
            left: {
                doc: "The text is aligned to the left."
            },
            center: {
                doc: "The text is centered."
            },
            right: {
                doc: "The text is aligned to the right."
            }
        },
        "default": "center",
        doc: "Text justification options.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            },
            auto: {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-radial-offset": {
        type: "number",
        units: "ems",
        "default": 0,
        doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            },
            "data-driven styling": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        requires: ["text-field"],
        "property-type": "data-driven",
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        }
    },
    "text-variable-anchor": {
        type: "array",
        value: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        requires: ["text-field", {
            "symbol-placement": ["point"]
        }],
        doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.54.0",
                android: "7.4.0",
                ios: "4.10.0",
                macos: "0.14.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-anchor": {
        type: "enum",
        values: {
            center: {
                doc: "The center of the text is placed closest to the anchor."
            },
            left: {
                doc: "The left side of the text is placed closest to the anchor."
            },
            right: {
                doc: "The right side of the text is placed closest to the anchor."
            },
            top: {
                doc: "The top of the text is placed closest to the anchor."
            },
            bottom: {
                doc: "The bottom of the text is placed closest to the anchor."
            },
            "top-left": {
                doc: "The top left corner of the text is placed closest to the anchor."
            },
            "top-right": {
                doc: "The top right corner of the text is placed closest to the anchor."
            },
            "bottom-left": {
                doc: "The bottom left corner of the text is placed closest to the anchor."
            },
            "bottom-right": {
                doc: "The bottom right corner of the text is placed closest to the anchor."
            }
        },
        "default": "center",
        doc: "Part of the text placed closest to the anchor.",
        requires: ["text-field", {
            "!": "text-variable-anchor"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-max-angle": {
        type: "number",
        "default": 45,
        units: "degrees",
        doc: "Maximum angle change between adjacent characters.",
        requires: ["text-field", {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-writing-mode": {
        type: "array",
        value: "enum",
        values: {
            horizontal: {
                doc: "If a text's language supports horizontal writing mode, symbols would be laid out horizontally."
            },
            vertical: {
                doc: "If a text's language supports vertical writing mode, symbols would be laid out vertically."
            }
        },
        doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnât support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "1.3.0",
                android: "8.3.0",
                ios: "5.3.0",
                macos: "0.15.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        units: "degrees",
        doc: "Rotates the text clockwise.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-padding": {
        type: "number",
        "default": 2,
        minimum: 0,
        units: "pixels",
        doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-keep-upright": {
        type: "boolean",
        "default": true,
        doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
        requires: ["text-field", {
            "text-rotation-alignment": "map"
        }, {
            "symbol-placement": ["line", "line-center"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-transform": {
        type: "enum",
        values: {
            none: {
                doc: "The text is not altered."
            },
            uppercase: {
                doc: "Forces all letters to be displayed in uppercase."
            },
            lowercase: {
                doc: "Forces all letters to be displayed in lowercase."
            }
        },
        "default": "none",
        doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-offset": {
        type: "array",
        doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
        value: "number",
        units: "ems",
        length: 2,
        "default": [0, 0],
        requires: ["text-field", {
            "!": "text-radial-offset"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.35.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature"]
        },
        "property-type": "data-driven"
    },
    "text-allow-overlap": {
        type: "boolean",
        "default": false,
        doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-ignore-placement": {
        type: "boolean",
        "default": false,
        doc: "If true, other symbols can be visible even if they collide with the text.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-optional": {
        type: "boolean",
        "default": false,
        doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
        requires: ["text-field", "icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_raster = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        "property-type": "constant"
    }
};
var layout_hillshade = {
    visibility: {
        type: "enum",
        values: {
            visible: {
                doc: "The layer is shown."
            },
            none: {
                doc: "The layer is not shown."
            }
        },
        "default": "visible",
        doc: "Whether this layer is displayed.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        "property-type": "constant"
    }
};
var filter = {
    type: "array",
    value: "*",
    doc: "A filter selects specific features from a layer."
};
var filter_symbol = {
    type: "boolean",
    doc: "Expression which determines whether or not to display a symbol. Symbols support dynamic filtering, meaning this expression can use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    "default": false,
    transition: false,
    "property-type": "data-driven",
    expression: {
        interpolated: false,
        parameters: ["zoom", "feature", "pitch", "distance-from-center"]
    }
};
var filter_fill = {
    type: "boolean",
    doc: "Expression which determines whether or not to display a polygon. Fill layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    "default": false,
    transition: false,
    "property-type": "data-driven",
    expression: {
        interpolated: false,
        parameters: ["zoom", "feature"]
    }
};
var filter_line = {
    type: "boolean",
    doc: "Expression which determines whether or not to display a Polygon or LineString. Line layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    "default": false,
    transition: false,
    "property-type": "data-driven",
    expression: {
        interpolated: false,
        parameters: ["zoom", "feature"]
    }
};
var filter_circle = {
    type: "boolean",
    doc: "Expression which determines whether or not to display a circle. Circle layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    "default": false,
    transition: false,
    "property-type": "data-driven",
    expression: {
        interpolated: false,
        parameters: ["zoom", "feature"]
    }
};
var filter_heatmap = {
    type: "boolean",
    doc: "Expression used to determine whether a point is being displayed or not. Heatmap layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
    "default": false,
    transition: false,
    "property-type": "data-driven",
    expression: {
        interpolated: false,
        parameters: ["zoom", "feature"]
    }
};
var filter_operator = {
    type: "enum",
    values: {
        "==": {
            doc: "`[\"==\", key, value]` equality: `feature[key] = value`"
        },
        "!=": {
            doc: "`[\"!=\", key, value]` inequality: `feature[key] â  value`"
        },
        ">": {
            doc: "`[\">\", key, value]` greater than: `feature[key] > value`"
        },
        ">=": {
            doc: "`[\">=\", key, value]` greater than or equal: `feature[key] â¥ value`"
        },
        "<": {
            doc: "`[\"<\", key, value]` less than: `feature[key] < value`"
        },
        "<=": {
            doc: "`[\"<=\", key, value]` less than or equal: `feature[key] â¤ value`"
        },
        "in": {
            doc: "`[\"in\", key, v0, ..., vn]` set inclusion: `feature[key] â {v0, ..., vn}`"
        },
        "!in": {
            doc: "`[\"!in\", key, v0, ..., vn]` set exclusion: `feature[key] â {v0, ..., vn}`"
        },
        all: {
            doc: "`[\"all\", f0, ..., fn]` logical `AND`: `f0 â§ ... â§ fn`"
        },
        any: {
            doc: "`[\"any\", f0, ..., fn]` logical `OR`: `f0 â¨ ... â¨ fn`"
        },
        none: {
            doc: "`[\"none\", f0, ..., fn]` logical `NOR`: `Â¬f0 â§ ... â§ Â¬fn`"
        },
        has: {
            doc: "`[\"has\", key]` `feature[key]` exists"
        },
        "!has": {
            doc: "`[\"!has\", key]` `feature[key]` does not exist"
        },
        within: {
            doc: "`[\"within\", object]` feature geometry is within object geometry"
        }
    },
    doc: "The filter operator."
};
var geometry_type = {
    type: "enum",
    values: {
        Point: {
            doc: "Filter to point geometries."
        },
        LineString: {
            doc: "Filter to line geometries."
        },
        Polygon: {
            doc: "Filter to polygon geometries."
        }
    },
    doc: "The geometry type for the filter to select."
};
var function_stop = {
    type: "array",
    minimum: 0,
    maximum: 24,
    value: ["number", "color"],
    length: 2,
    doc: "Zoom level and value pair."
};
var expression = {
    type: "array",
    value: "*",
    minimum: 1,
    doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
};
var expression_name = {
    doc: "",
    type: "enum",
    values: {
        "let": {
            doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\"var\", \"variable_name\"].",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "var": {
            doc: "References variable bound using \"let\".",
            group: "Variable binding",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        literal: {
            doc: "Provides a literal array or object value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        array: {
            doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        at: {
            doc: "Retrieves an item from an array.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "in": {
            doc: "Determines whether an item exists in an array or a substring exists in a string. In the specific case when the second and third arguments are string literals, you must wrap at least one of them in a [`literal`](#types-literal) expression to hint correct interpretation to the [type system](#type-system).",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.6.0",
                    android: "9.1.0",
                    ios: "5.8.0",
                    macos: "0.15.0"
                }
            }
        },
        "index-of": {
            doc: "Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        },
        slice: {
            doc: "Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "1.10.0"
                }
            }
        },
        "case": {
            doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        match: {
            doc: "Selects the output for which the label value matches the input value, or the fallback value if no match is found. The input can be any expression (for example, `[\"get\", \"building_type\"]`). Each label must be unique, and must be either:\n - a single literal value; or\n - an array of literal values, the values of which must be all strings or all numbers (for example `[100, 101]` or `[\"c\", \"b\"]`).\n\nThe input matches if any of the values in the array matches using strict equality, similar to the `\"in\"` operator.\nIf the input type does not match the type of the labels, the result will be the fallback value.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        coalesce: {
            doc: "Evaluates each expression in turn until the first valid value is obtained. Invalid values are `null` and [`'image'`](#types-image) expressions that are unavailable in the style. If all values are invalid, `coalesce` returns the first value listed.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        step: {
            doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        interpolate: {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). The `input` may be any numeric expression (e.g., `[\"get\", \"population\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `[\"linear\"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\n- `[\"exponential\", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `[\"cubic-bezier\", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "interpolate-hcl": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        "interpolate-lab": {
            doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\"stops\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",
            group: "Ramps, scales, curves",
            "sdk-support": {
                "basic functionality": {
                    js: "0.49.0"
                }
            }
        },
        ln2: {
            doc: "Returns mathematical constant ln(2).",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        pi: {
            doc: "Returns the mathematical constant pi.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        e: {
            doc: "Returns the mathematical constant e.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "typeof": {
            doc: "Returns a string describing the type of the given value.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        string: {
            doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        number: {
            doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        boolean: {
            doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        object: {
            doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        collator: {
            doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        format: {
            doc: "Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`'image'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\n- `\"text-font\"`: Overrides the font stack specified by the root layout property.\n- `\"text-color\"`: Overrides the color specified by the root paint property.\n- `\"font-scale\"`: Applies a scaling factor on `text-size` as specified by the root layout property.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-font": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "font-scale": {
                    js: "0.48.0",
                    android: "6.7.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                },
                "text-color": {
                    js: "1.3.0",
                    android: "7.3.0",
                    ios: "4.10.0",
                    macos: "0.14.0"
                },
                image: {
                    js: "1.6.0",
                    android: "8.6.0",
                    ios: "5.7.0",
                    macos: "0.15.0"
                }
            }
        },
        image: {
            doc: "Returns a [`ResolvedImage`](/mapbox-gl-js/style-spec/types/#resolvedimage) for use in [`icon-image`](/mapbox-gl-js/style-spec/layers/#layout-symbol-icon-image), `*-pattern` entries, and as a section in the [`'format'`](#types-format) expression. A [`'coalesce'`](#coalesce) expression containing `image` expressions will evaluate to the first listed image that is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `'image'` argument.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "1.4.0",
                    android: "8.6.0",
                    ios: "5.7.0",
                    macos: "0.15.0"
                }
            }
        },
        "number-format": {
            doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.54.0",
                    android: "8.4.0",
                    ios: "5.4.0",
                    macos: "0.15.0"
                }
            }
        },
        "to-string": {
            doc: "Converts the input value to a string. If the input is `null`, the result is `\"\"`. If the input is a [`boolean`](#types-boolean), the result is `\"true\"` or `\"false\"`. If the input is a number, it is converted to a string as specified by the [\"NumberToString\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a [`color`](#color), it is converted to a string of the form `\"rgba(r,g,b,a)\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. If the input is an [`'image'`](#types-image) expression, `'to-string'` returns the image name. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-number": {
            doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\"ToNumber Applied to the String Type\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-boolean": {
            doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-rgba": {
            doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "to-color": {
            doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
            group: "Types",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgb: {
            doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        rgba: {
            doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
            group: "Color",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        get: {
            doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns `null` if the requested property is missing.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        has: {
            doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        length: {
            doc: "Returns the length of an array or string.",
            group: "Lookup",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        properties: {
            doc: "Returns the feature properties object.  Note that in some cases, it may be more efficient to use `[\"get\", \"property_name\"]` directly.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "feature-state": {
            doc: "Retrieves a property value from the current feature's state. Returns `null` if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.46.0"
                }
            }
        },
        "geometry-type": {
            doc: "Returns the feature's geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`. `Multi*` feature types are only returned in GeoJSON sources. When working with vector tile sources, use the singular forms.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        id: {
            doc: "Returns the feature's id, if it has one.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        zoom: {
            doc: "Returns the current zoom level.  Note that in style layout and paint properties, [\"zoom\"] may only appear as the input to a top-level \"step\" or \"interpolate\" expression.",
            group: "Camera",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        pitch: {
            doc: "Returns the current pitch in degrees. `[\"pitch\"]` may only be used in the `filter` expression for a `symbol` layer.",
            group: "Camera",
            "sdk-support": {
                "basic functionality": {
                    js: "2.6.0"
                }
            }
        },
        "distance-from-center": {
            doc: "Returns the distance of a `symbol` instance from the center of the map. The distance is measured in pixels divided by the height of the map container. It measures 0 at the center, decreases towards the camera and increase away from the camera. For example, if the height of the map is 1000px, a value of -1 means 1000px away from the center towards the camera, and a value of 1 means a distance of 1000px away from the camera from the center. `[\"distance-from-center\"]` may only be used in the `filter` expression for a `symbol` layer.",
            group: "Camera",
            "sdk-support": {
                "basic functionality": {
                    js: "2.6.0"
                }
            }
        },
        "heatmap-density": {
            doc: "Returns the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
            group: "Heatmap",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "line-progress": {
            doc: "Returns the progress along a gradient line. Can only be used in the `line-gradient` property.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.6.0",
                    macos: "0.12.0"
                }
            }
        },
        "sky-radial-progress": {
            doc: "Returns the distance of a point on the sky from the sun position. Returns 0 at sun position and 1 when the distance reaches `sky-gradient-radius`. Can only be used in the `sky-gradient` property.",
            group: "sky",
            "sdk-support": {
                "basic functionality": {
                    js: "2.0.0",
                    ios: "10.0.0",
                    android: "10.0.0"
                }
            }
        },
        accumulated: {
            doc: "Returns the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
            group: "Feature data",
            "sdk-support": {
                "basic functionality": {
                    js: "0.53.0",
                    android: "8.4.0",
                    ios: "5.5.0",
                    macos: "0.15.0"
                }
            }
        },
        "+": {
            doc: "Returns the sum of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "*": {
            doc: "Returns the product of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "-": {
            doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "/": {
            doc: "Returns the result of floating point division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "%": {
            doc: "Returns the remainder after integer division of the first input by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "^": {
            doc: "Returns the result of raising the first input to the power specified by the second.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sqrt: {
            doc: "Returns the square root of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.42.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log10: {
            doc: "Returns the base-ten logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ln: {
            doc: "Returns the natural logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        log2: {
            doc: "Returns the base-two logarithm of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        sin: {
            doc: "Returns the sine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        cos: {
            doc: "Returns the cosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        tan: {
            doc: "Returns the tangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        asin: {
            doc: "Returns the arcsine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        acos: {
            doc: "Returns the arccosine of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        atan: {
            doc: "Returns the arctangent of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        min: {
            doc: "Returns the minimum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        max: {
            doc: "Returns the maximum value of the inputs.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        round: {
            doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\"round\", -1.5]` evaluates to -2.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        abs: {
            doc: "Returns the absolute value of the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        ceil: {
            doc: "Returns the smallest integer that is greater than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        floor: {
            doc: "Returns the largest integer that is less than or equal to the input.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        distance: {
            doc: "Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.",
            group: "Math",
            "sdk-support": {
                "basic functionality": {
                    android: "9.2.0",
                    ios: "5.9.0",
                    macos: "0.16.0"
                }
            }
        },
        "==": {
            doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "!=": {
            doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">": {
            doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<": {
            doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        ">=": {
            doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        "<=": {
            doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                },
                collator: {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        },
        all: {
            doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        any: {
            doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "!": {
            doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        within: {
            doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line's endpoint is on the boundary.",
            group: "Decision",
            "sdk-support": {
                "basic functionality": {
                    js: "1.9.0",
                    android: "9.1.0",
                    ios: "5.8.0",
                    macos: "0.15.0"
                }
            }
        },
        "is-supported-script": {
            doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.6.0"
                }
            }
        },
        upcase: {
            doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        downcase: {
            doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        concat: {
            doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.41.0",
                    android: "6.0.0",
                    ios: "4.0.0",
                    macos: "0.7.0"
                }
            }
        },
        "resolved-locale": {
            doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
            group: "String",
            "sdk-support": {
                "basic functionality": {
                    js: "0.45.0",
                    android: "6.5.0",
                    ios: "4.2.0",
                    macos: "0.9.0"
                }
            }
        }
    }
};
var fog = {
    range: {
        type: "array",
        "default": [0.5, 10],
        minimum: -20,
        maximum: 20,
        length: 2,
        value: "number",
        "property-type": "data-constant",
        transition: true,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        doc: "The start and end distance range in which fog fades from fully transparent to fully opaque. The distance to the point at the center of the map is defined as zero, so that negative range values are closer to the camera, and positive values are farther away.",
        example: [0.5, 10],
        "sdk-support": {
            "basic functionality": {
                js: "2.3.0"
            }
        }
    },
    color: {
        type: "color",
        "property-type": "data-constant",
        "default": "#ffffff",
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "The color of the fog. Using opacity is recommended only for smoothly transitioning fog on/off as anything less than 100% opacity results in more tiles loaded and drawn.",
        "sdk-support": {
            "basic functionality": {
                js: "2.3.0"
            }
        }
    },
    "horizon-blend": {
        type: "number",
        "property-type": "data-constant",
        "default": 0.1,
        minimum: 0,
        maximum: 1,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Horizon blend applies a smooth fade from the color of the fog to the color of the sky. A value of zero leaves a sharp transition from fog to sky. Increasing the value blends the color of fog into increasingly high angles of the sky.",
        "sdk-support": {
            "basic functionality": {
                js: "2.3.0"
            }
        }
    }
};
var light = {
    anchor: {
        type: "enum",
        "default": "viewport",
        values: {
            map: {
                doc: "The position of the light source is aligned to the rotation of the map."
            },
            viewport: {
                doc: "The position of the light source is aligned to the rotation of the viewport."
            }
        },
        "property-type": "data-constant",
        transition: false,
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        doc: "Whether extruded geometries are lit relative to the map or viewport.",
        example: "map",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    position: {
        type: "array",
        "default": [1.15, 210, 30],
        length: 3,
        value: "number",
        "property-type": "data-constant",
        transition: true,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0Â° (0Â° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0Â° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0Â°, directly above, to 180Â°, directly below).",
        example: [1.5, 90, 80],
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    color: {
        type: "color",
        "property-type": "data-constant",
        "default": "#ffffff",
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Color tint for lighting extruded geometries.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    },
    intensity: {
        type: "number",
        "property-type": "data-constant",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
        "sdk-support": {
            "basic functionality": {
                js: "0.27.0",
                android: "5.1.0",
                ios: "3.6.0",
                macos: "0.5.0"
            }
        }
    }
};
var projection = {
    name: {
        type: "enum",
        values: {
            albers: {
                doc: "An Albers equal-area projection centered on the continental United States. You can configure the projection for a different region by setting `center` and `parallels` properties. You may want to set max bounds to constrain the map to the relevant region."
            },
            equalEarth: {
                doc: "An Equal Earth projection."
            },
            equirectangular: {
                doc: "An Equirectangular projection. This projection is very similar to the Plate CarrÃ©e projection."
            },
            lambertConformalConic: {
                doc: "A Lambert conformal conic projection. You can configure the projection for a region by setting `center` and `parallels` properties. You may want to set max bounds to constrain the map to the relevant region."
            },
            mercator: {
                doc: "The Mercator projection is the default projection."
            },
            naturalEarth: {
                doc: "A Natural Earth projection."
            },
            winkelTripel: {
                doc: "A Winkel Tripel projection."
            }
        },
        "default": "mercator",
        doc: "The name of the projection to be used for rendering the map.",
        required: true,
        "sdk-support": {
            "basic functionality": {
                js: "2.6.0"
            }
        }
    },
    center: {
        type: "array",
        length: 2,
        value: "number",
        "property-type": "data-constant",
        transition: false,
        doc: "The reference longitude and latitude of the projection. `center` takes the form of [lng, lat]. This property is only configurable for conic projections (Albers and Lambert Conformal Conic). All other projections are centered on [0, 0].",
        example: [-96, 37.5],
        requires: [{
            name: ["albers", "lambertConformalConic"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "2.6.0"
            }
        }
    },
    parallels: {
        type: "array",
        length: 2,
        value: "number",
        "property-type": "data-constant",
        transition: false,
        doc: "The standard parallels of the projection, denoting the desired latitude range with minimal distortion. `parallels` takes the form of [lat0, lat1]. This property is only configurable for conic projections (Albers and Lambert Conformal Conic).",
        example: [29.5, 45.5],
        requires: [{
            name: ["albers", "lambertConformalConic"]
        }],
        "sdk-support": {
            "basic functionality": {
                js: "2.6.0"
            }
        }
    }
};
var terrain = {
    source: {
        type: "string",
        doc: "Name of a source of `raster_dem` type to be used for terrain elevation.",
        required: true,
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        }
    },
    exaggeration: {
        type: "number",
        "property-type": "data-constant",
        "default": 1,
        minimum: 0,
        maximum: 1000,
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        transition: true,
        doc: "Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.",
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        }
    }
};
var paint = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"];
var paint_fill = {
    "fill-antialias": {
        type: "boolean",
        "default": true,
        doc: "Whether or not the fill should be antialiased.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.21.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-color": {
        type: "color",
        "default": "#000000",
        doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-outline-color": {
        type: "color",
        doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
        transition: true,
        requires: [{
            "!": "fill-pattern"
        }, {
            "fill-antialias": true
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.19.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "fill-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The fill is translated relative to the map."
            },
            viewport: {
                doc: "The fill is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `fill-translate`.",
        "default": "map",
        requires: ["fill-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "fill-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    }
};
var paint_line = {
    "line-opacity": {
        type: "number",
        doc: "The opacity at which the line will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-color": {
        type: "color",
        doc: "The color with which the line will be drawn.",
        "default": "#000000",
        transition: true,
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.23.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The line is translated relative to the map."
            },
            viewport: {
                doc: "The line is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `line-translate`.",
        "default": "map",
        requires: ["line-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "line-width": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Stroke thickness.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-gap-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-offset": {
        type: "number",
        "default": 0,
        doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
        transition: true,
        units: "pixels",
        "sdk-support": {
            "basic functionality": {
                js: "0.12.1",
                android: "3.0.0",
                ios: "3.1.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Blur applied to the line, in pixels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "line-dasharray": {
        type: "array",
        value: "number",
        doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        minimum: 0,
        transition: true,
        units: "line widths",
        requires: [{
            "!": "line-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "2.3.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    },
    "line-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.49.0",
                android: "6.5.0",
                macos: "0.11.0",
                ios: "4.4.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        },
        "property-type": "cross-faded-data-driven"
    },
    "line-gradient": {
        type: "color",
        doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\"lineMetrics\": true`.",
        transition: false,
        requires: [{
            "!": "line-pattern"
        }, {
            source: "geojson",
            has: {
                lineMetrics: true
            }
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.45.0",
                android: "6.5.0",
                ios: "4.4.0",
                macos: "0.11.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["line-progress"]
        },
        "property-type": "color-ramp"
    }
};
var paint_circle = {
    "circle-radius": {
        type: "number",
        "default": 5,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Circle radius.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-color": {
        type: "color",
        "default": "#000000",
        doc: "The fill color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.18.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-blur": {
        type: "number",
        "default": 0,
        doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-opacity": {
        type: "number",
        doc: "The opacity at which the circle will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.20.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is translated relative to the map."
            },
            viewport: {
                doc: "The circle is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `circle-translate`.",
        "default": "map",
        requires: ["circle-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-scale": {
        type: "enum",
        values: {
            map: {
                doc: "Circles are scaled according to their apparent distance to the camera."
            },
            viewport: {
                doc: "Circles are not scaled."
            }
        },
        "default": "map",
        doc: "Controls the scaling behavior of the circle when the map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.21.0",
                android: "4.2.0",
                ios: "3.4.0",
                macos: "0.2.1"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-pitch-alignment": {
        type: "enum",
        values: {
            map: {
                doc: "The circle is aligned to the plane of the map."
            },
            viewport: {
                doc: "The circle is aligned to the plane of the viewport."
            }
        },
        "default": "viewport",
        doc: "Orientation of circle when map is pitched.",
        "sdk-support": {
            "basic functionality": {
                js: "0.39.0",
                android: "5.2.0",
                ios: "3.7.0",
                macos: "0.6.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "circle-stroke-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-color": {
        type: "color",
        "default": "#000000",
        doc: "The stroke color of the circle.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "circle-stroke-opacity": {
        type: "number",
        doc: "The opacity of the circle's stroke.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            },
            "data-driven styling": {
                js: "0.29.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    }
};
var paint_heatmap = {
    "heatmap-radius": {
        type: "number",
        "default": 30,
        minimum: 1,
        transition: true,
        units: "pixels",
        doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed. `queryRenderedFeatures` on heatmap layers will return points within this radius.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-weight": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: false,
        doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "heatmap-intensity": {
        type: "number",
        "default": 1,
        minimum: 0,
        transition: true,
        doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "heatmap-color": {
        type: "color",
        "default": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"],
        doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\"heatmap-density\"]` as input.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["heatmap-density"]
        },
        "property-type": "color-ramp"
    },
    "heatmap-opacity": {
        type: "number",
        doc: "The global opacity at which the heatmap layer will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.41.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_symbol = {
    "icon-opacity": {
        doc: "The opacity at which the icon will be drawn.",
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-color": {
        type: "color",
        "default": "#000000",
        transition: true,
        doc: "The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the icon outline.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Fade out the halo towards the outside.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "icon-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["icon-image"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "icon-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "Icons are translated relative to the map."
            },
            viewport: {
                doc: "Icons are translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `icon-translate`.",
        "default": "map",
        requires: ["icon-image", "icon-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-opacity": {
        type: "number",
        doc: "The opacity at which the text will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-color": {
        type: "color",
        doc: "The color with which the text will be drawn.",
        "default": "#000000",
        transition: true,
        overridable: true,
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-color": {
        type: "color",
        "default": "rgba(0, 0, 0, 0)",
        transition: true,
        doc: "The color of the text's halo, which helps it stand out from backgrounds.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-width": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-halo-blur": {
        type: "number",
        "default": 0,
        minimum: 0,
        transition: true,
        units: "pixels",
        doc: "The halo's fadeout distance towards the outside.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {
                js: "0.33.0",
                android: "5.0.0",
                ios: "3.5.0",
                macos: "0.4.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom", "feature", "feature-state"]
        },
        "property-type": "data-driven"
    },
    "text-translate": {
        type: "array",
        value: "number",
        length: 2,
        "default": [0, 0],
        transition: true,
        units: "pixels",
        doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
        requires: ["text-field"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "text-translate-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The text is translated relative to the map."
            },
            viewport: {
                doc: "The text is translated relative to the viewport."
            }
        },
        doc: "Controls the frame of reference for `text-translate`.",
        "default": "map",
        requires: ["text-field", "text-translate"],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_raster = {
    "raster-opacity": {
        type: "number",
        doc: "The opacity at which the image will be drawn.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-hue-rotate": {
        type: "number",
        "default": 0,
        period: 360,
        transition: true,
        units: "degrees",
        doc: "Rotates hues around the color wheel.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-min": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
        "default": 0,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-brightness-max": {
        type: "number",
        doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
        "default": 1,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-saturation": {
        type: "number",
        doc: "Increase or reduce the saturation of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-contrast": {
        type: "number",
        doc: "Increase or reduce the contrast of the image.",
        "default": 0,
        minimum: -1,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-resampling": {
        type: "enum",
        doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
        values: {
            linear: {
                doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
            },
            nearest: {
                doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
            }
        },
        "default": "linear",
        "sdk-support": {
            "basic functionality": {
                js: "0.47.0",
                android: "6.3.0",
                ios: "4.2.0",
                macos: "0.9.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "raster-fade-duration": {
        type: "number",
        "default": 300,
        minimum: 0,
        transition: false,
        units: "milliseconds",
        doc: "Fade duration when a new tile is added.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_hillshade = {
    "hillshade-illumination-direction": {
        type: "number",
        "default": 335,
        minimum: 0,
        maximum: 359,
        doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
        transition: false,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-illumination-anchor": {
        type: "enum",
        values: {
            map: {
                doc: "The hillshade illumination is relative to the north direction."
            },
            viewport: {
                doc: "The hillshade illumination is relative to the top of the viewport."
            }
        },
        "default": "viewport",
        doc: "Direction of light source when map is rotated.",
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-exaggeration": {
        type: "number",
        doc: "Intensity of the hillshade",
        "default": 0.5,
        minimum: 0,
        maximum: 1,
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-shadow-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color of areas that face away from the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-highlight-color": {
        type: "color",
        "default": "#FFFFFF",
        doc: "The shading color of areas that faces towards the light source.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "hillshade-accent-color": {
        type: "color",
        "default": "#000000",
        doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.43.0",
                android: "6.0.0",
                ios: "4.0.0",
                macos: "0.7.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_background = {
    "background-color": {
        type: "color",
        "default": "#000000",
        doc: "The color with which the background will be drawn.",
        transition: true,
        requires: [{
            "!": "background-pattern"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "background-pattern": {
        type: "resolvedImage",
        transition: true,
        doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "cross-faded"
    },
    "background-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity at which the background will be drawn.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "0.10.0",
                android: "2.0.1",
                ios: "2.0.0",
                macos: "0.1.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var paint_sky = {
    "sky-type": {
        type: "enum",
        values: {
            gradient: {
                doc: "Renders the sky with a gradient that can be configured with `sky-gradient-radius` and `sky-gradient`."
            },
            atmosphere: {
                doc: "Renders the sky with a simulated atmospheric scattering algorithm, the sun direction can be attached to the light position or explicitly set through `sky-atmosphere-sun`."
            }
        },
        "default": "atmosphere",
        doc: "The type of the sky",
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "sky-atmosphere-sun": {
        type: "array",
        value: "number",
        length: 2,
        units: "degrees",
        minimum: [0, 0],
        maximum: [360, 180],
        transition: false,
        doc: "Position of the sun center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the sun relative to 0Â° north, where degrees proceed clockwise. The polar angle indicates the height of the sun, where 0Â° is directly above, at zenith, and 90Â° at the horizon. When this property is ommitted, the sun center is directly inherited from the light position.",
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        requires: [{
            "sky-type": "atmosphere"
        }],
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "sky-atmosphere-sun-intensity": {
        type: "number",
        requires: [{
            "sky-type": "atmosphere"
        }],
        "default": 10,
        minimum: 0,
        maximum: 100,
        transition: false,
        doc: "Intensity of the sun as a light source in the atmosphere (on a scale from 0 to a 100). Setting higher values will brighten up the sky.",
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        "property-type": "data-constant"
    },
    "sky-gradient-center": {
        type: "array",
        requires: [{
            "sky-type": "gradient"
        }],
        value: "number",
        "default": [0, 0],
        length: 2,
        units: "degrees",
        minimum: [0, 0],
        maximum: [360, 180],
        transition: false,
        doc: "Position of the gradient center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the gradient center relative to 0Â° north, where degrees proceed clockwise. The polar angle indicates the height of the gradient center, where 0Â° is directly above, at zenith, and 90Â° at the horizon.",
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "sky-gradient-radius": {
        type: "number",
        requires: [{
            "sky-type": "gradient"
        }],
        "default": 90,
        minimum: 0,
        maximum: 180,
        transition: false,
        doc: "The angular distance (measured in degrees) from `sky-gradient-center` up to which the gradient extends. A value of 180 causes the gradient to wrap around to the opposite direction from `sky-gradient-center`.",
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        expression: {
            interpolated: false,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    },
    "sky-gradient": {
        type: "color",
        "default": ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"],
        doc: "Defines a radial color gradient with which to color the sky. The color values can be interpolated with an expression using `sky-radial-progress`. The range [0, 1] for the interpolant covers a radial distance (in degrees) of [0, `sky-gradient-radius`] centered at the position specified by `sky-gradient-center`.",
        transition: false,
        requires: [{
            "sky-type": "gradient"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            },
            "data-driven styling": {}
        },
        expression: {
            interpolated: true,
            parameters: ["sky-radial-progress"]
        },
        "property-type": "color-ramp"
    },
    "sky-atmosphere-halo-color": {
        type: "color",
        "default": "white",
        doc: "A color applied to the atmosphere sun halo. The alpha channel describes how strongly the sun halo is represented in an atmosphere sky layer.",
        transition: false,
        requires: [{
            "sky-type": "atmosphere"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        "property-type": "data-constant"
    },
    "sky-atmosphere-color": {
        type: "color",
        "default": "white",
        doc: "A color used to tweak the main atmospheric scattering coefficients. Using white applies the default coefficients giving the natural blue color to the atmosphere. This color affects how heavily the corresponding wavelength is represented during scattering. The alpha channel describes the density of the atmosphere, with 1 maximum density and 0 no density.",
        transition: false,
        requires: [{
            "sky-type": "atmosphere"
        }],
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        "property-type": "data-constant"
    },
    "sky-opacity": {
        type: "number",
        "default": 1,
        minimum: 0,
        maximum: 1,
        doc: "The opacity of the entire sky layer.",
        transition: true,
        "sdk-support": {
            "basic functionality": {
                js: "2.0.0",
                ios: "10.0.0",
                android: "10.0.0"
            }
        },
        expression: {
            interpolated: true,
            parameters: ["zoom"]
        },
        "property-type": "data-constant"
    }
};
var transition = {
    duration: {
        type: "number",
        "default": 300,
        minimum: 0,
        units: "milliseconds",
        doc: "Time allotted for transitions to complete."
    },
    delay: {
        type: "number",
        "default": 0,
        minimum: 0,
        units: "milliseconds",
        doc: "Length of time before a transition begins."
    }
};
var promoteId = {
    "*": {
        type: "string",
        doc: "A name of a feature property to use as ID for feature state."
    }
};
var v8 = {
    $version: $version,
    $root: $root,
    sources: sources,
    source: source,
    source_vector: source_vector,
    source_raster: source_raster,
    source_raster_dem: source_raster_dem,
    source_geojson: source_geojson,
    source_video: source_video,
    source_image: source_image,
    layer: layer,
    layout: layout,
    layout_background: layout_background,
    layout_sky: layout_sky,
    layout_fill: layout_fill,
    layout_circle: layout_circle,
    layout_heatmap: layout_heatmap,
    "layout_fill-extrusion": {
        visibility: {
            type: "enum",
            values: {
                visible: {
                    doc: "The layer is shown."
                },
                none: {
                    doc: "The layer is not shown."
                }
            },
            "default": "visible",
            doc: "Whether this layer is displayed.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            "property-type": "constant"
        }
    },
    layout_line: layout_line,
    layout_symbol: layout_symbol,
    layout_raster: layout_raster,
    layout_hillshade: layout_hillshade,
    filter: filter,
    filter_symbol: filter_symbol,
    filter_fill: filter_fill,
    filter_line: filter_line,
    filter_circle: filter_circle,
    "filter_fill-extrusion": {
        type: "boolean",
        doc: "Expression which determines whether or not to display a Polygon. Fill-extrusion layer does NOT support dynamic filtering, meaning this expression can NOT use the `[\"pitch\"]` and `[\"distance-from-center\"]` expressions to reference the current state of the view.",
        "default": false,
        transition: false,
        "property-type": "data-driven",
        expression: {
            interpolated: false,
            parameters: ["zoom", "feature"]
        }
    },
    filter_heatmap: filter_heatmap,
    filter_operator: filter_operator,
    geometry_type: geometry_type,
    "function": {
        expression: {
            type: "expression",
            doc: "An expression."
        },
        stops: {
            type: "array",
            doc: "An array of stops.",
            value: "function_stop"
        },
        base: {
            type: "number",
            "default": 1,
            minimum: 0,
            doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
        },
        property: {
            type: "string",
            doc: "The name of a feature property to use as the function input.",
            "default": "$zoom"
        },
        type: {
            type: "enum",
            values: {
                identity: {
                    doc: "Return the input value as the output value."
                },
                exponential: {
                    doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
                },
                interval: {
                    doc: "Return the output value of the stop just less than the function input."
                },
                categorical: {
                    doc: "Return the output value of the stop equal to the function input."
                }
            },
            doc: "The interpolation strategy to use in function evaluation.",
            "default": "exponential"
        },
        colorSpace: {
            type: "enum",
            values: {
                rgb: {
                    doc: "Use the RGB color space to interpolate color values"
                },
                lab: {
                    doc: "Use the LAB color space to interpolate color values."
                },
                hcl: {
                    doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
                }
            },
            doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
            "default": "rgb"
        },
        "default": {
            type: "*",
            required: false,
            doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
        }
    },
    function_stop: function_stop,
    expression: expression,
    expression_name: expression_name,
    fog: fog,
    light: light,
    projection: projection,
    terrain: terrain,
    paint: paint,
    paint_fill: paint_fill,
    "paint_fill-extrusion": {
        "fill-extrusion-opacity": {
            type: "number",
            "default": 1,
            minimum: 0,
            maximum: 1,
            doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-color": {
            type: "color",
            "default": "#000000",
            doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
            transition: true,
            requires: [{
                "!": "fill-extrusion-pattern"
            }],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-translate": {
            type: "array",
            value: "number",
            length: 2,
            "default": [0, 0],
            transition: true,
            units: "pixels",
            doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-translate-anchor": {
            type: "enum",
            values: {
                map: {
                    doc: "The fill extrusion is translated relative to the map."
                },
                viewport: {
                    doc: "The fill extrusion is translated relative to the viewport."
                }
            },
            doc: "Controls the frame of reference for `fill-extrusion-translate`.",
            "default": "map",
            requires: ["fill-extrusion-translate"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-pattern": {
            type: "resolvedImage",
            transition: true,
            doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.49.0",
                    android: "6.5.0",
                    macos: "0.11.0",
                    ios: "4.4.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom", "feature"]
            },
            "property-type": "cross-faded-data-driven"
        },
        "fill-extrusion-height": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude this layer.",
            transition: true,
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-base": {
            type: "number",
            "default": 0,
            minimum: 0,
            units: "meters",
            doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
            transition: true,
            requires: ["fill-extrusion-height"],
            "sdk-support": {
                "basic functionality": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                },
                "data-driven styling": {
                    js: "0.27.0",
                    android: "5.1.0",
                    ios: "3.6.0",
                    macos: "0.5.0"
                }
            },
            expression: {
                interpolated: true,
                parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-vertical-gradient": {
            type: "boolean",
            "default": true,
            doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
            transition: false,
            "sdk-support": {
                "basic functionality": {
                    js: "0.50.0",
                    android: "7.0.0",
                    ios: "4.7.0",
                    macos: "0.13.0"
                }
            },
            expression: {
                interpolated: false,
                parameters: ["zoom"]
            },
            "property-type": "data-constant"
        }
    },
    paint_line: paint_line,
    paint_circle: paint_circle,
    paint_heatmap: paint_heatmap,
    paint_symbol: paint_symbol,
    paint_raster: paint_raster,
    paint_hillshade: paint_hillshade,
    paint_background: paint_background,
    paint_sky: paint_sky,
    transition: transition,
    "property-type": {
        "data-driven": {
            type: "property-type",
            doc: "Property is interpolable and can be represented using a property expression."
        },
        "cross-faded": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."
        },
        "cross-faded-data-driven": {
            type: "property-type",
            doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."
        },
        "color-ramp": {
            type: "property-type",
            doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
        },
        "data-constant": {
            type: "property-type",
            doc: "Property is interpolable but cannot be represented using a property expression."
        },
        constant: {
            type: "property-type",
            doc: "Property is constant across all zoom levels and property values."
        }
    },
    promoteId: promoteId
};

// Note: This regex matches even invalid JSON strings, but since weâre
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we donât care since the output would be invalid anyway).
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;

var jsonStringifyPrettyCompact = function stringify(passedObj, options) {
    var indent, maxLength, replacer;

    options = options || {};
    indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);
    maxLength = indent === "" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;
    replacer = options.replacer;

    return function _stringify(obj, currentIndent, reserved) {
        // prettier-ignore
        var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;

        if (obj && typeof obj.toJSON === "function") {
            obj = obj.toJSON();
        }

        string = JSON.stringify(obj, replacer);

        if (string === undefined) {
            return string;
        }

        length = maxLength - currentIndent.length - reserved;

        if (string.length <= length) {
            prettified = string.replace(stringOrChar, function (match, stringLiteral) {
                return stringLiteral || match + " ";
            });
            if (prettified.length <= length) {
                return prettified;
            }
        }

        if (replacer != null) {
            obj = JSON.parse(string);
            replacer = undefined;
        }

        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && obj !== null) {
            nextIndent = currentIndent + indent;
            items = [];
            index = 0;

            if (Array.isArray(obj)) {
                start = "[";
                end = "]";
                length = obj.length;
                for (; index < length; index++) {
                    items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null");
                }
            } else {
                start = "{";
                end = "}";
                keys = Object.keys(obj);
                length = keys.length;
                for (; index < length; index++) {
                    key = keys[index];
                    keyPart = JSON.stringify(key) + ": ";
                    value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));
                    if (value !== undefined) {
                        items.push(keyPart + value);
                    }
                }
            }

            if (items.length > 0) {
                return [start, indent + items.join(",\n" + nextIndent), end].join("\n" + currentIndent);
            }
        }

        return string;
    }(passedObj, "", 0);
};

function sortKeysBy(obj, reference) {
    var result = {};
    for (var key in reference) {
        if (obj[key] !== undefined) {
            result[key] = obj[key];
        }
    }
    for (var _key in obj) {
        if (result[_key] === undefined) {
            result[_key] = obj[_key];
        }
    }
    return result;
}
function format(style) {
    var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

    style = sortKeysBy(style, v8.$root);
    if (style.layers) {
        style.layers = style.layers.map(function (layer) {
            return sortKeysBy(layer, v8.layer);
        });
    }
    return jsonStringifyPrettyCompact(style, { indent: space });
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
    var module = { exports: {} };
    return fn(module, module.exports), module.exports;
}

function commonjsRequire(target) {
    throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
}

/*! https://mths.be/punycode v1.3.2 by @mathias */

var punycode = createCommonjsModule(function (module, exports) {
    (function (root) {

        /** Detect free variables */
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = module && !module.nodeType && module;
        var freeGlobal = (typeof commonjsGlobal === "undefined" ? "undefined" : _typeof(commonjsGlobal)) == 'object' && commonjsGlobal;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
            root = freeGlobal;
        }

        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */
        var punycode,


        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647,
            // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            // 0x80
        delimiter = '-',
            // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            // RFC 3490 separators

        /** Error messages */
        errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
        },


        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,


        /** Temporary variable */
        key;

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error(type) {
            throw RangeError(errors[type]);
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
                result[length] = fn(array[length]);
            }
            return result;
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
            var parts = string.split('@');
            var result = '';
            if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
            }
            // Avoid `split(regex)` for IE8 compatibility. See #17.
            string = string.replace(regexSeparators, '\x2E');
            var labels = string.split('.');
            var encoded = map(labels, fn).join('.');
            return result + encoded;
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
            while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    // high surrogate, and there is a next character
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xFC00) == 0xDC00) {
                        // low surrogate
                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                    } else {
                        // unmatched surrogate; only append this code unit, in case the next
                        // code unit is the high surrogate of a surrogate pair
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        function ucs2encode(array) {
            return map(array, function (value) {
                var output = '';
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
            }).join('');
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        function digitToBasic(digit, flag) {
            //  0..25 map to ASCII a..z or A..Z
            // 26..35 map to ASCII 0..9
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * http://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        function decode(input) {
            // Don't use UCS-2
            var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,

            /** Cached calculation results */
            baseMinusT;

            // Handle the basic code points: let `basic` be the number of input code
            // points before the last delimiter, or `0` if there is none, then copy
            // the first basic code points to the output.

            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }

            for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                    error('not-basic');
                }
                output.push(input.charCodeAt(j));
            }

            // Main decoding loop: start just after the last delimiter if any basic code
            // points were copied; start at the beginning otherwise.

            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                    if (index >= inputLength) {
                        error('invalid-input');
                    }

                    digit = basicToDigit(input.charCodeAt(index++));

                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow');
                    }

                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                    if (digit < t) {
                        break;
                    }

                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error('overflow');
                    }

                    w *= baseMinusT;
                }

                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                    error('overflow');
                }

                n += floor(i / out);
                i %= out;

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
            }

            return ucs2encode(output);
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        function encode(input) {
            var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],

            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,

            /** Cached calculation results */
            handledCPCountPlusOne,
                baseMinusT,
                qMinusT;

            // Convert the input in UCS-2 to Unicode
            input = ucs2decode(input);

            // Cache the length
            inputLength = input.length;

            // Initialize the state
            n = initialN;
            delta = 0;
            bias = initialBias;

            // Handle the basic code points
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                }
            }

            handledCPCount = basicLength = output.length;

            // `handledCPCount` is the number of code points that have been handled;
            // `basicLength` is the number of basic code points.

            // Finish the basic string - if it is not empty - with a delimiter
            if (basicLength) {
                output.push(delimiter);
            }

            // Main encoding loop:
            while (handledCPCount < inputLength) {

                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];

                    if (currentValue < n && ++delta > maxInt) {
                        error('overflow');
                    }

                    if (currentValue == n) {
                        // Represent delta as a generalized variable-length integer
                        for (q = delta, k = base;; /* no condition */k += base) {
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                                break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }

                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }

                ++delta;
                ++n;
            }
            return output.join('');
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        function toUnicode(input) {
            return mapDomain(input, function (string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        function toASCII(input) {
            return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
            });
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        punycode = {
            /**
             * A string representing the current Punycode.js version number.
             * @memberOf punycode
             * @type String
             */
            'version': '1.3.2',
            /**
             * An object of methods to convert from JavaScript's internal character
             * representation (UCS-2) to Unicode code points, and back.
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode
             * @type Object
             */
            'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
            },
            'decode': decode,
            'encode': encode,
            'toASCII': toASCII,
            'toUnicode': toUnicode
        };

        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (freeExports && freeModule) {
            if (module.exports == freeExports) {
                // in Node.js or RingoJS v0.8.0+
                freeModule.exports = punycode;
            } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
            }
        } else {
            // in Rhino or a web browser
            root.punycode = punycode;
        }
    })(commonjsGlobal);
});

var util = {
    isString: function isString(arg) {
        return typeof arg === 'string';
    },
    isObject: function isObject(arg) {
        return (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && arg !== null;
    },
    isNull: function isNull(arg) {
        return arg === null;
    },
    isNullOrUndefined: function isNullOrUndefined(arg) {
        return arg == null;
    }
};

// Copyright Joyent, Inc. and other Node contributors.

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

var decode = function decode(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

        if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
        } else {
            kstr = x;
            vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
        } else if (Array.isArray(obj[k])) {
            obj[k].push(v);
        } else {
            obj[k] = [obj[k], v];
        }
    }

    return obj;
};

// Copyright Joyent, Inc. and other Node contributors.

var stringifyPrimitive = function stringifyPrimitive(v) {
    switch (typeof v === "undefined" ? "undefined" : _typeof(v)) {
        case 'string':
            return v;

        case 'boolean':
            return v ? 'true' : 'false';

        case 'number':
            return isFinite(v) ? v : '';

        default:
            return '';
    }
};

var encode = function encode(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
        obj = undefined;
    }

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object') {
        return Object.keys(obj).map(function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (Array.isArray(obj[k])) {
                return obj[k].map(function (v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
            } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
        }).join(sep);
    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var querystring = createCommonjsModule(function (module, exports) {

    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
});

var parse = urlParse;
var resolve = urlResolve;
var resolveObject = urlResolveObject;
var format$1 = urlFormat;

var Url_1 = Url;

function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that never have a hostname.
hostlessProtocol = {
    'javascript': true,
    'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};

function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url) return url;

    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === "undefined" ? "undefined" : _typeof(url)));
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf('?'),
        splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, '/');
    url = uSplit.join(splitter);

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1));
                } else {
                    this.query = this.search.substr(1);
                }
            } else if (parseQueryString) {
                this.search = '';
                this.query = {};
            }
            return this;
        }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
        }
    }

    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
            // atSign can be anywhere.
            atSign = rest.lastIndexOf('@');
        } else {
            // atSign must be in auth portion.
            // http://a@b/c@d => host:b auth:a path:/c@d
            atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) hostEnd = rest.length;

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) continue;
                if (!part.match(hostnamePartPattern)) {
                    var newpart = '';
                    for (var j = 0, k = part.length; j < k; j++) {
                        if (part.charCodeAt(j) > 127) {
                            // we replace non-ASCII char with a temporary placeholder
                            // we need this to make sure size of hostname is not
                            // broken by replacing non-ASCII by nothing
                            newpart += 'x';
                        } else {
                            newpart += part[j];
                        }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                            validParts.push(bit[1]);
                            notHost.unshift(bit[2]);
                        }
                        if (notHost.length) {
                            rest = '/' + notHost.join('.') + rest;
                        }
                        this.hostname = validParts.join('.');
                        break;
                    }
                }
            }
        }

        if (this.hostname.length > hostnameMaxLen) {
            this.hostname = '';
        } else {
            // hostnames are always lower case.
            this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== '/') {
                rest = '/' + rest;
            }
        }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1) continue;
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
                esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
        }
    }

    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
            this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
    } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
    }
    if (rest) this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = '/';
    }

    //to support http.request
    if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (util.isString(obj)) obj = urlParse(obj);
    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
    return obj.format();
}

Url.prototype.format = function () {
    var auth = this.auth || '';
    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
    }

    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

    if (this.host) {
        host = auth + this.host;
    } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
        if (this.port) {
            host += ':' + this.port;
        }
    }

    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
    }

    var search = this.search || query && '?' + query || '';

    if (protocol && protocol.substr(-1) !== ':') protocol += ':';

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }

    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
    if (search && search.charAt(0) !== '?') search = '?' + search;

    pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
    if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
    }

    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
    }

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
        result.href = result.format();
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== 'protocol') result[rkey] = relative[rkey];
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
    }

    if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
            }
            result.href = result.format();
            return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || '').split('/');
            while (relPath.length && !(relative.host = relPath.shift())) {}
            if (!relative.host) relative.host = '';
            if (!relative.hostname) relative.hostname = '';
            if (relPath[0] !== '') relPath.unshift('');
            if (relPath.length < 2) relPath.unshift('');
            result.pathname = relPath.join('/');
        } else {
            result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
            var p = result.pathname || '';
            var s = result.search || '';
            result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }

    var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
        mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
            if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
                if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
            }
            relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }

    if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === '' ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
            result.path = '/' + result.search;
        } else {
            result.path = null;
        }
        result.href = result.format();
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
            srcPath.splice(i, 1);
        } else if (last === '..') {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift('..');
        }
    }

    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
    }

    if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
        srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || result.host && srcPath.length;

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
    }

    if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
    } else {
        result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
};

Url.prototype.parseHost = function () {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
        port = port[0];
        if (port !== ':') {
            this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
    }
    if (host) this.hostname = host;
};

var url = {
    parse: parse,
    resolve: resolve,
    resolveObject: resolveObject,
    format: format$1,
    Url: Url_1
};

function getPropertyReference(propertyName) {
    for (var i = 0; i < v8.layout.length; i++) {
        for (var key in v8[v8.layout[i]]) {
            if (key === propertyName) return v8[v8.layout[i]][key];
        }
    }
    for (var _i = 0; _i < v8.paint.length; _i++) {
        for (var _key2 in v8[v8.paint[_i]]) {
            if (_key2 === propertyName) return v8[v8.paint[_i]][_key2];
        }
    }
    return null;
}
function eachSource(style, callback) {
    for (var k in style.sources) {
        callback(style.sources[k]);
    }
}
function eachLayer(style, callback) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = style.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _layer = _step.value;

            callback(_layer);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function eachProperty(style, options, callback) {
    function inner(layer, propertyType) {
        var properties = layer[propertyType];
        if (!properties) return;
        Object.keys(properties).forEach(function (key) {
            callback({
                path: [layer.id, propertyType, key],
                key: key,
                value: properties[key],
                reference: getPropertyReference(key),
                set: function set(x) {
                    properties[key] = x;
                }
            });
        });
    }
    eachLayer(style, function (layer) {
        if (options.paint) {
            inner(layer, 'paint');
        }
        if (options.layout) {
            inner(layer, 'layout');
        }
    });
}

function eachLayout(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('layout') === 0) {
            callback(layer[k], k);
        }
    }
}
function eachPaint(layer, callback) {
    for (var k in layer) {
        if (k.indexOf('paint') === 0) {
            callback(layer[k], k);
        }
    }
}
function resolveConstant(style, value) {
    if (typeof value === 'string' && value[0] === '@') {
        return resolveConstant(style, style.constants[value]);
    } else {
        return value;
    }
}
function isFunction(value) {
    return Array.isArray(value.stops);
}
function renameProperty(obj, from, to) {
    obj[to] = obj[from];
    delete obj[from];
}
function migrateToV8(style) {
    style.version = 8;
    eachSource(style, function (source) {
        if (source.type === 'video' && source.url !== undefined) {
            renameProperty(source, 'url', 'urls');
        }
        if (source.type === 'video') {
            source.coordinates.forEach(function (coord) {
                return coord.reverse();
            });
        }
    });
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['symbol-min-distance'] !== undefined) {
                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');
            }
        });
        eachPaint(layer, function (paint) {
            if (paint['background-image'] !== undefined) {
                renameProperty(paint, 'background-image', 'background-pattern');
            }
            if (paint['line-image'] !== undefined) {
                renameProperty(paint, 'line-image', 'line-pattern');
            }
            if (paint['fill-image'] !== undefined) {
                renameProperty(paint, 'fill-image', 'fill-pattern');
            }
        });
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (property) {
        var value = resolveConstant(style, property.value);
        if (isFunction(value)) {
            value.stops.forEach(function (stop) {
                stop[1] = resolveConstant(style, stop[1]);
            });
        }
        property.set(value);
    });
    delete style.constants;
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            delete layout['text-max-size'];
            delete layout['icon-max-size'];
        });
        eachPaint(layer, function (paint) {
            if (paint['text-size']) {
                if (!layer.layout) layer.layout = {};
                layer.layout['text-size'] = paint['text-size'];
                delete paint['text-size'];
            }
            if (paint['icon-size']) {
                if (!layer.layout) layer.layout = {};
                layer.layout['icon-size'] = paint['icon-size'];
                delete paint['icon-size'];
            }
        });
    });
    function migrateFontstackURL(input) {
        var inputParsed = url.parse(input);
        var inputPathnameParts = inputParsed.pathname.split('/');
        if (inputParsed.protocol !== 'mapbox:') {
            return input;
        } else if (inputParsed.hostname === 'fontstack') {
            return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';
        } else if (inputParsed.hostname === 'fonts') {
            return "mapbox://fonts/" + inputPathnameParts[2] + "/{fontstack}/{range}.pbf";
        } else ;
    }
    if (style.glyphs) {
        style.glyphs = migrateFontstackURL(style.glyphs);
    }
    function migrateFontStack(font) {
        function splitAndTrim(string) {
            return string.split(',').map(function (s) {
                return s.trim();
            });
        }
        if (Array.isArray(font)) {
            return font;
        } else if (typeof font === 'string') {
            return splitAndTrim(font);
        } else if ((typeof font === "undefined" ? "undefined" : _typeof(font)) === 'object') {
            font.stops.forEach(function (stop) {
                stop[1] = splitAndTrim(stop[1]);
            });
            return font;
        } else {
            throw new Error('unexpected font value');
        }
    }
    eachLayer(style, function (layer) {
        eachLayout(layer, function (layout) {
            if (layout['text-font']) {
                layout['text-font'] = migrateFontStack(layout['text-font']);
            }
        });
    });
    var firstSymbolLayer = 0;
    for (var i = style.layers.length - 1; i >= 0; i--) {
        var _layer2 = style.layers[i];
        if (_layer2.type !== 'symbol') {
            firstSymbolLayer = i + 1;
            break;
        }
    }
    var symbolLayers = style.layers.splice(firstSymbolLayer);
    symbolLayers.reverse();
    style.layers = style.layers.concat(symbolLayers);
    return style;
}

function extend(output) {
    for (var _len = arguments.length, inputs = Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {
        inputs[_key3 - 1] = arguments[_key3];
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = inputs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var input = _step2.value;

            for (var k in input) {
                output[k] = input[k];
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return output;
}

var ParsingError = function (_Error) {
    _inherits(ParsingError, _Error);

    function ParsingError(key, message) {
        _classCallCheck(this, ParsingError);

        var _this = _possibleConstructorReturn(this, (ParsingError.__proto__ || Object.getPrototypeOf(ParsingError)).call(this, message));

        _this.message = message;
        _this.key = key;
        return _this;
    }

    return ParsingError;
}(Error);

var Scope = function () {
    function Scope(parent) {
        var bindings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        _classCallCheck(this, Scope);

        this.parent = parent;
        this.bindings = {};
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = bindings[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _ref = _step3.value;

                var _ref2 = _slicedToArray(_ref, 2);

                var name = _ref2[0];
                var _expression = _ref2[1];

                this.bindings[name] = _expression;
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }
    }

    _createClass(Scope, [{
        key: "concat",
        value: function concat(bindings) {
            return new Scope(this, bindings);
        }
    }, {
        key: "get",
        value: function get(name) {
            if (this.bindings[name]) {
                return this.bindings[name];
            }
            if (this.parent) {
                return this.parent.get(name);
            }
            throw new Error(name + " not found in scope.");
        }
    }, {
        key: "has",
        value: function has(name) {
            if (this.bindings[name]) return true;
            return this.parent ? this.parent.has(name) : false;
        }
    }]);

    return Scope;
}();

var NullType = { kind: 'null' };
var NumberType = { kind: 'number' };
var StringType = { kind: 'string' };
var BooleanType = { kind: 'boolean' };
var ColorType = { kind: 'color' };
var ObjectType = { kind: 'object' };
var ValueType = { kind: 'value' };
var ErrorType = { kind: 'error' };
var CollatorType = { kind: 'collator' };
var FormattedType = { kind: 'formatted' };
var ResolvedImageType = { kind: 'resolvedImage' };
function array(itemType, N) {
    return {
        kind: 'array',
        itemType: itemType,
        N: N
    };
}
function toString(type) {
    if (type.kind === 'array') {
        var itemType = toString(type.itemType);
        return typeof type.N === 'number' ? "array<" + itemType + ", " + type.N + ">" : type.itemType.kind === 'value' ? 'array' : "array<" + itemType + ">";
    } else {
        return type.kind;
    }
}
var valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array(ValueType), ResolvedImageType];
function _checkSubtype(expected, t) {
    if (t.kind === 'error') {
        return null;
    } else if (expected.kind === 'array') {
        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !_checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
            return null;
        }
    } else if (expected.kind === t.kind) {
        return null;
    } else if (expected.kind === 'value') {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = valueMemberTypes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var memberType = _step4.value;

                if (!_checkSubtype(memberType, t)) {
                    return null;
                }
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }
    }
    return "Expected " + toString(expected) + " but found " + toString(t) + " instead.";
}
function isValidType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        return t.kind === provided.kind;
    });
}
function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
        if (t === 'null') {
            return provided === null;
        } else if (t === 'array') {
            return Array.isArray(provided);
        } else if (t === 'object') {
            return provided && !Array.isArray(provided) && (typeof provided === "undefined" ? "undefined" : _typeof(provided)) === 'object';
        } else {
            return t === (typeof provided === "undefined" ? "undefined" : _typeof(provided));
        }
    });
}

var csscolorparser = createCommonjsModule(function (module, exports) {
    // (c) Dean McNamee <dean@gmail.com>, 2012.
    //
    // https://github.com/deanm/css-color-parser-js
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    // IN THE SOFTWARE.

    // http://www.w3.org/TR/css3-color/
    var kCSSColorTable = {
        "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
        "rebeccapurple": [102, 51, 153, 1],
        "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1] };

    function clamp_css_byte(i) {
        // Clamp to integer 0 .. 255.
        i = Math.round(i); // Seems to be what Chrome does (vs truncation).
        return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clamp_css_float(f) {
        // Clamp to float 0.0 .. 1.0.
        return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parse_css_int(str) {
        // int or percentage.
        if (str[str.length - 1] === '%') return clamp_css_byte(parseFloat(str) / 100 * 255);
        return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {
        // float or percentage.
        if (str[str.length - 1] === '%') return clamp_css_float(parseFloat(str) / 100);
        return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
        if (h < 0) h += 1;else if (h > 1) h -= 1;

        if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1) return m2;
        if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        return m1;
    }

    function parseCSSColor(css_str) {
        // Remove all whitespace, not compliant, but should just be more accepting.
        var str = css_str.replace(/ /g, '').toLowerCase();

        // Color keywords (and transparent) lookup.
        if (str in kCSSColorTable) return kCSSColorTable[str].slice(); // dup.

        // #abc and #abc123 syntax.
        if (str[0] === '#') {
            if (str.length === 4) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.
                return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];
            } else if (str.length === 7) {
                var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.
                return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
            }

            return null;
        }

        var op = str.indexOf('('),
            ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op + 1, ep - (op + 1)).split(',');
            var alpha = 1; // To allow case fallthrough.
            switch (fname) {
                case 'rgba':
                    if (params.length !== 4) return null;
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'rgb':
                    if (params.length !== 3) return null;
                    return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];
                case 'hsla':
                    if (params.length !== 4) return null;
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'hsl':
                    if (params.length !== 3) return null;
                    var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
                    // NOTE(deanm): According to the CSS spec s/l should only be
                    // percentages, but we don't bother and let float or percentage.
                    var s = parse_css_float(params[1]);
                    var l = parse_css_float(params[2]);
                    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
                default:
                    return null;
            }
        }

        return null;
    }

    try {
        exports.parseCSSColor = parseCSSColor;
    } catch (e) {}
});

var Color = function () {
    function Color(r, g, b) {
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        _classCallCheck(this, Color);

        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }

    _createClass(Color, [{
        key: "toString",
        value: function toString() {
            var _toArray = this.toArray(),
                _toArray2 = _slicedToArray(_toArray, 4),
                r = _toArray2[0],
                g = _toArray2[1],
                b = _toArray2[2],
                a = _toArray2[3];

            return "rgba(" + Math.round(r) + "," + Math.round(g) + "," + Math.round(b) + "," + a + ")";
        }
    }, {
        key: "toArray",
        value: function toArray() {
            var r = this.r,
                g = this.g,
                b = this.b,
                a = this.a;

            return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];
        }
    }], [{
        key: "parse",
        value: function parse(input) {
            if (!input) {
                return undefined;
            }
            if (input instanceof Color) {
                return input;
            }
            if (typeof input !== 'string') {
                return undefined;
            }
            var rgba = csscolorparser.parseCSSColor(input);
            if (!rgba) {
                return undefined;
            }
            return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
        }
    }]);

    return Color;
}();

Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);
Color.blue = new Color(0, 0, 1, 1);

var Collator = function () {
    function Collator(caseSensitive, diacriticSensitive, locale) {
        _classCallCheck(this, Collator);

        if (caseSensitive) this.sensitivity = diacriticSensitive ? 'variant' : 'case';else this.sensitivity = diacriticSensitive ? 'accent' : 'base';
        this.locale = locale;
        this.collator = new Intl.Collator(this.locale ? this.locale : [], {
            sensitivity: this.sensitivity,
            usage: 'search'
        });
    }

    _createClass(Collator, [{
        key: "compare",
        value: function compare(lhs, rhs) {
            return this.collator.compare(lhs, rhs);
        }
    }, {
        key: "resolvedLocale",
        value: function resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
    }]);

    return Collator;
}();

var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
    _classCallCheck(this, FormattedSection);

    this.text = text;
    this.image = image;
    this.scale = scale;
    this.fontStack = fontStack;
    this.textColor = textColor;
};

var Formatted = function () {
    function Formatted(sections) {
        _classCallCheck(this, Formatted);

        this.sections = sections;
    }

    _createClass(Formatted, [{
        key: "isEmpty",
        value: function isEmpty() {
            if (this.sections.length === 0) return true;
            return !this.sections.some(function (section) {
                return section.text.length !== 0 || section.image && section.image.name.length !== 0;
            });
        }
    }, {
        key: "toString",
        value: function toString() {
            if (this.sections.length === 0) return '';
            return this.sections.map(function (section) {
                return section.text;
            }).join('');
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var serialized = ['format'];
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = this.sections[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var section = _step5.value;

                    if (section.image) {
                        serialized.push(['image', section.image.name]);
                        continue;
                    }
                    serialized.push(section.text);
                    var options = {};
                    if (section.fontStack) {
                        options['text-font'] = ['literal', section.fontStack.split(',')];
                    }
                    if (section.scale) {
                        options['font-scale'] = section.scale;
                    }
                    if (section.textColor) {
                        options['text-color'] = ['rgba'].concat(section.textColor.toArray());
                    }
                    serialized.push(options);
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }

            return serialized;
        }
    }], [{
        key: "fromString",
        value: function fromString(unformatted) {
            return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
        }
    }, {
        key: "factory",
        value: function factory(text) {
            if (text instanceof Formatted) {
                return text;
            } else {
                return Formatted.fromString(text);
            }
        }
    }]);

    return Formatted;
}();

var ResolvedImage = function () {
    function ResolvedImage(options) {
        _classCallCheck(this, ResolvedImage);

        this.name = options.name;
        this.available = options.available;
    }

    _createClass(ResolvedImage, [{
        key: "toString",
        value: function toString() {
            return this.name;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ['image', this.name];
        }
    }], [{
        key: "fromString",
        value: function fromString(name) {
            if (!name) return null;
            return new ResolvedImage({
                name: name,
                available: false
            });
        }
    }]);

    return ResolvedImage;
}();

function validateRGBA(r, g, b, a) {
    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
        var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
        return "Invalid rgba value [" + value.join(', ') + "]: 'r', 'g', and 'b' must be between 0 and 255.";
    }
    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
        return "Invalid rgba value [" + [r, g, b, a].join(', ') + "]: 'a' must be between 0 and 1.";
    }
    return null;
}
function isValue(mixed) {
    if (mixed === null) {
        return true;
    } else if (typeof mixed === 'string') {
        return true;
    } else if (typeof mixed === 'boolean') {
        return true;
    } else if (typeof mixed === 'number') {
        return true;
    } else if (mixed instanceof Color) {
        return true;
    } else if (mixed instanceof Collator) {
        return true;
    } else if (mixed instanceof Formatted) {
        return true;
    } else if (mixed instanceof ResolvedImage) {
        return true;
    } else if (Array.isArray(mixed)) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
            for (var _iterator6 = mixed[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var item = _step6.value;

                if (!isValue(item)) {
                    return false;
                }
            }
        } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                }
            } finally {
                if (_didIteratorError6) {
                    throw _iteratorError6;
                }
            }
        }

        return true;
    } else if ((typeof mixed === "undefined" ? "undefined" : _typeof(mixed)) === 'object') {
        for (var key in mixed) {
            if (!isValue(mixed[key])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
function typeOf(value) {
    if (value === null) {
        return NullType;
    } else if (typeof value === 'string') {
        return StringType;
    } else if (typeof value === 'boolean') {
        return BooleanType;
    } else if (typeof value === 'number') {
        return NumberType;
    } else if (value instanceof Color) {
        return ColorType;
    } else if (value instanceof Collator) {
        return CollatorType;
    } else if (value instanceof Formatted) {
        return FormattedType;
    } else if (value instanceof ResolvedImage) {
        return ResolvedImageType;
    } else if (Array.isArray(value)) {
        var length = value.length;
        var itemType = void 0;
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
            for (var _iterator7 = value[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var item = _step7.value;

                var t = typeOf(item);
                if (!itemType) {
                    itemType = t;
                } else if (itemType === t) {
                    continue;
                } else {
                    itemType = ValueType;
                    break;
                }
            }
        } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                }
            } finally {
                if (_didIteratorError7) {
                    throw _iteratorError7;
                }
            }
        }

        return array(itemType || ValueType, length);
    } else {
        return ObjectType;
    }
}
function toString$1(value) {
    var type = typeof value === "undefined" ? "undefined" : _typeof(value);
    if (value === null) {
        return '';
    } else if (type === 'string' || type === 'number' || type === 'boolean') {
        return String(value);
    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
        return value.toString();
    } else {
        return JSON.stringify(value);
    }
}

var Literal = function () {
    function Literal(type, value) {
        _classCallCheck(this, Literal);

        this.type = type;
        this.value = value;
    }

    _createClass(Literal, [{
        key: "evaluate",
        value: function evaluate() {
            return this.value;
        }
    }, {
        key: "eachChild",
        value: function eachChild() {}
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return true;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            if (this.type.kind === 'array' || this.type.kind === 'object') {
                return ['literal', this.value];
            } else if (this.value instanceof Color) {
                return ['rgba'].concat(this.value.toArray());
            } else if (this.value instanceof Formatted) {
                return this.value.serialize();
            } else {
                return this.value;
            }
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 2) return context.error("'literal' expression requires exactly one argument, but found " + (args.length - 1) + " instead.");
            if (!isValue(args[1])) return context.error("invalid value");
            var value = args[1];
            var type = typeOf(value);
            var expected = context.expectedType;
            if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
                type = expected;
            }
            return new Literal(type, value);
        }
    }]);

    return Literal;
}();

var RuntimeError = function () {
    function RuntimeError(message) {
        _classCallCheck(this, RuntimeError);

        this.name = 'ExpressionEvaluationError';
        this.message = message;
    }

    _createClass(RuntimeError, [{
        key: "toJSON",
        value: function toJSON() {
            return this.message;
        }
    }]);

    return RuntimeError;
}();

var types = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};

var Assertion = function () {
    function Assertion(type, args) {
        _classCallCheck(this, Assertion);

        this.type = type;
        this.args = args;
    }

    _createClass(Assertion, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            for (var i = 0; i < this.args.length; i++) {
                var value = this.args[i].evaluate(ctx);
                var _error = _checkSubtype(this.type, typeOf(value));
                if (!_error) {
                    return value;
                } else if (i === this.args.length - 1) {
                    throw new RuntimeError("Expected value to be of type " + toString(this.type) + ", but found " + toString(typeOf(value)) + " instead.");
                }
            }
            return null;
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            this.args.forEach(fn);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.args.every(function (arg) {
                return arg.outputDefined();
            });
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var type = this.type;
            var serialized = [type.kind];
            if (type.kind === 'array') {
                var itemType = type.itemType;
                if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
                    serialized.push(itemType.kind);
                    var N = type.N;
                    if (typeof N === 'number' || this.args.length > 1) {
                        serialized.push(N);
                    }
                }
            }
            return serialized.concat(this.args.map(function (arg) {
                return arg.serialize();
            }));
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length < 2) return context.error("Expected at least one argument.");
            var i = 1;
            var type = void 0;
            var name = args[0];
            if (name === 'array') {
                var itemType = void 0;
                if (args.length > 2) {
                    var _type = args[1];
                    if (typeof _type !== 'string' || !(_type in types) || _type === 'object') return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
                    itemType = types[_type];
                    i++;
                } else {
                    itemType = ValueType;
                }
                var N = void 0;
                if (args.length > 3) {
                    if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                        return context.error('The length argument to "array" must be a positive integer literal', 2);
                    }
                    N = args[2];
                    i++;
                }
                type = array(itemType, N);
            } else {
                type = types[name];
            }
            var parsed = [];
            for (; i < args.length; i++) {
                var input = context.parse(args[i], i, ValueType);
                if (!input) return null;
                parsed.push(input);
            }
            return new Assertion(type, parsed);
        }
    }]);

    return Assertion;
}();

var FormatExpression = function () {
    function FormatExpression(sections) {
        _classCallCheck(this, FormatExpression);

        this.type = FormattedType;
        this.sections = sections;
    }

    _createClass(FormatExpression, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var evaluateSection = function evaluateSection(section) {
                var evaluatedContent = section.content.evaluate(ctx);
                if (typeOf(evaluatedContent) === ResolvedImageType) {
                    return new FormattedSection('', evaluatedContent, null, null, null);
                }
                return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
            };
            return new Formatted(this.sections.map(evaluateSection));
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = this.sections[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var section = _step8.value;

                    fn(section.content);
                    if (section.scale) {
                        fn(section.scale);
                    }
                    if (section.font) {
                        fn(section.font);
                    }
                    if (section.textColor) {
                        fn(section.textColor);
                    }
                }
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var serialized = ['format'];
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
                for (var _iterator9 = this.sections[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var section = _step9.value;

                    serialized.push(section.content.serialize());
                    var options = {};
                    if (section.scale) {
                        options['font-scale'] = section.scale.serialize();
                    }
                    if (section.font) {
                        options['text-font'] = section.font.serialize();
                    }
                    if (section.textColor) {
                        options['text-color'] = section.textColor.serialize();
                    }
                    serialized.push(options);
                }
            } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }
                } finally {
                    if (_didIteratorError9) {
                        throw _iteratorError9;
                    }
                }
            }

            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length < 2) {
                return context.error("Expected at least one argument.");
            }
            var firstArg = args[1];
            if (!Array.isArray(firstArg) && (typeof firstArg === "undefined" ? "undefined" : _typeof(firstArg)) === 'object') {
                return context.error("First argument must be an image or text section.");
            }
            var sections = [];
            var nextTokenMayBeObject = false;
            for (var i = 1; i <= args.length - 1; ++i) {
                var arg = args[i];
                if (nextTokenMayBeObject && (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === 'object' && !Array.isArray(arg)) {
                    nextTokenMayBeObject = false;
                    var scale = null;
                    if (arg['font-scale']) {
                        scale = context.parse(arg['font-scale'], 1, NumberType);
                        if (!scale) return null;
                    }
                    var font = null;
                    if (arg['text-font']) {
                        font = context.parse(arg['text-font'], 1, array(StringType));
                        if (!font) return null;
                    }
                    var textColor = null;
                    if (arg['text-color']) {
                        textColor = context.parse(arg['text-color'], 1, ColorType);
                        if (!textColor) return null;
                    }
                    var lastExpression = sections[sections.length - 1];
                    lastExpression.scale = scale;
                    lastExpression.font = font;
                    lastExpression.textColor = textColor;
                } else {
                    var content = context.parse(args[i], 1, ValueType);
                    if (!content) return null;
                    var kind = content.type.kind;
                    if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') return context.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                    nextTokenMayBeObject = true;
                    sections.push({
                        content: content,
                        scale: null,
                        font: null,
                        textColor: null
                    });
                }
            }
            return new FormatExpression(sections);
        }
    }]);

    return FormatExpression;
}();

var ImageExpression = function () {
    function ImageExpression(input) {
        _classCallCheck(this, ImageExpression);

        this.type = ResolvedImageType;
        this.input = input;
    }

    _createClass(ImageExpression, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var evaluatedImageName = this.input.evaluate(ctx);
            var value = ResolvedImage.fromString(evaluatedImageName);
            if (value && ctx.availableImages) value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
            return value;
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.input);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ['image', this.input.serialize()];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 2) {
                return context.error("Expected two arguments.");
            }
            var name = context.parse(args[1], 1, StringType);
            if (!name) return context.error("No image name provided.");
            return new ImageExpression(name);
        }
    }]);

    return ImageExpression;
}();

var types$1 = {
    'to-boolean': BooleanType,
    'to-color': ColorType,
    'to-number': NumberType,
    'to-string': StringType
};

var Coercion = function () {
    function Coercion(type, args) {
        _classCallCheck(this, Coercion);

        this.type = type;
        this.args = args;
    }

    _createClass(Coercion, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            if (this.type.kind === 'boolean') {
                return Boolean(this.args[0].evaluate(ctx));
            } else if (this.type.kind === 'color') {
                var input = void 0;
                var _error2 = void 0;
                var _iteratorNormalCompletion10 = true;
                var _didIteratorError10 = false;
                var _iteratorError10 = undefined;

                try {
                    for (var _iterator10 = this.args[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                        var arg = _step10.value;

                        input = arg.evaluate(ctx);
                        _error2 = null;
                        if (input instanceof Color) {
                            return input;
                        } else if (typeof input === 'string') {
                            var c = ctx.parseColor(input);
                            if (c) return c;
                        } else if (Array.isArray(input)) {
                            if (input.length < 3 || input.length > 4) {
                                _error2 = "Invalid rbga value " + JSON.stringify(input) + ": expected an array containing either three or four numeric values.";
                            } else {
                                _error2 = validateRGBA(input[0], input[1], input[2], input[3]);
                            }
                            if (!_error2) {
                                return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError10 = true;
                    _iteratorError10 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion10 && _iterator10.return) {
                            _iterator10.return();
                        }
                    } finally {
                        if (_didIteratorError10) {
                            throw _iteratorError10;
                        }
                    }
                }

                throw new RuntimeError(_error2 || "Could not parse color from value '" + (typeof input === 'string' ? input : String(JSON.stringify(input))) + "'");
            } else if (this.type.kind === 'number') {
                var value = null;
                var _iteratorNormalCompletion11 = true;
                var _didIteratorError11 = false;
                var _iteratorError11 = undefined;

                try {
                    for (var _iterator11 = this.args[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                        var _arg = _step11.value;

                        value = _arg.evaluate(ctx);
                        if (value === null) return 0;
                        var num = Number(value);
                        if (isNaN(num)) continue;
                        return num;
                    }
                } catch (err) {
                    _didIteratorError11 = true;
                    _iteratorError11 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion11 && _iterator11.return) {
                            _iterator11.return();
                        }
                    } finally {
                        if (_didIteratorError11) {
                            throw _iteratorError11;
                        }
                    }
                }

                throw new RuntimeError("Could not convert " + JSON.stringify(value) + " to number.");
            } else if (this.type.kind === 'formatted') {
                return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));
            } else if (this.type.kind === 'resolvedImage') {
                return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));
            } else {
                return toString$1(this.args[0].evaluate(ctx));
            }
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            this.args.forEach(fn);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.args.every(function (arg) {
                return arg.outputDefined();
            });
        }
    }, {
        key: "serialize",
        value: function serialize() {
            if (this.type.kind === 'formatted') {
                return new FormatExpression([{
                    content: this.args[0],
                    scale: null,
                    font: null,
                    textColor: null
                }]).serialize();
            }
            if (this.type.kind === 'resolvedImage') {
                return new ImageExpression(this.args[0]).serialize();
            }
            var serialized = ["to-" + this.type.kind];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length < 2) return context.error("Expected at least one argument.");
            var name = args[0];
            if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) return context.error("Expected one argument.");
            var type = types$1[name];
            var parsed = [];
            for (var i = 1; i < args.length; i++) {
                var input = context.parse(args[i], i, ValueType);
                if (!input) return null;
                parsed.push(input);
            }
            return new Coercion(type, parsed);
        }
    }]);

    return Coercion;
}();

var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

var EvaluationContext = function () {
    function EvaluationContext() {
        _classCallCheck(this, EvaluationContext);

        this.globals = null;
        this.feature = null;
        this.featureState = null;
        this.formattedSection = null;
        this._parseColorCache = {};
        this.availableImages = null;
        this.canonical = null;
        this.featureTileCoord = null;
        this.featureDistanceData = null;
    }

    _createClass(EvaluationContext, [{
        key: "id",
        value: function id() {
            return this.feature && 'id' in this.feature ? this.feature.id : null;
        }
    }, {
        key: "geometryType",
        value: function geometryType() {
            return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
        }
    }, {
        key: "geometry",
        value: function geometry() {
            return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
        }
    }, {
        key: "canonicalID",
        value: function canonicalID() {
            return this.canonical;
        }
    }, {
        key: "properties",
        value: function properties() {
            return this.feature && this.feature.properties || {};
        }
    }, {
        key: "distanceFromCenter",
        value: function distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
                var c = this.featureDistanceData.center;
                var scale = this.featureDistanceData.scale;
                var _featureTileCoord = this.featureTileCoord,
                    x = _featureTileCoord.x,
                    y = _featureTileCoord.y;

                var dX = x * scale - c[0];
                var dY = y * scale - c[1];
                var bX = this.featureDistanceData.bearing[0];
                var bY = this.featureDistanceData.bearing[1];
                var dist = bX * dX + bY * dY;
                return dist;
            }
            return 0;
        }
    }, {
        key: "parseColor",
        value: function parseColor(input) {
            var cached = this._parseColorCache[input];
            if (!cached) {
                cached = this._parseColorCache[input] = Color.parse(input);
            }
            return cached;
        }
    }]);

    return EvaluationContext;
}();

var CompoundExpression = function () {
    function CompoundExpression(name, type, evaluate, args) {
        _classCallCheck(this, CompoundExpression);

        this.name = name;
        this.type = type;
        this._evaluate = evaluate;
        this.args = args;
    }

    _createClass(CompoundExpression, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            return this._evaluate(ctx, this.args);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            this.args.forEach(fn);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return [this.name].concat(this.args.map(function (arg) {
                return arg.serialize();
            }));
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            var op = args[0];
            var definition = CompoundExpression.definitions[op];
            if (!definition) {
                return context.error("Unknown expression \"" + op + "\". If you wanted a literal array, use [\"literal\", [...]].", 0);
            }
            var type = Array.isArray(definition) ? definition[0] : definition.type;
            var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
            var overloads = availableOverloads.filter(function (_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1),
                    signature = _ref4[0];

                return !Array.isArray(signature) || signature.length === args.length - 1;
            });
            var signatureContext = null;
            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
                for (var _iterator12 = overloads[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                    var _ref5 = _step12.value;

                    var _ref6 = _slicedToArray(_ref5, 2);

                    var params = _ref6[0];
                    var evaluate = _ref6[1];

                    signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);
                    var parsedArgs = [];
                    var argParseFailed = false;
                    for (var _i2 = 1; _i2 < args.length; _i2++) {
                        var arg = args[_i2];
                        var expectedType = Array.isArray(params) ? params[_i2 - 1] : params.type;
                        var _parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
                        if (!_parsed) {
                            argParseFailed = true;
                            break;
                        }
                        parsedArgs.push(_parsed);
                    }
                    if (argParseFailed) {
                        continue;
                    }
                    if (Array.isArray(params)) {
                        if (params.length !== parsedArgs.length) {
                            signatureContext.error("Expected " + params.length + " arguments, but found " + parsedArgs.length + " instead.");
                            continue;
                        }
                    }
                    for (var _i3 = 0; _i3 < parsedArgs.length; _i3++) {
                        var _expected = Array.isArray(params) ? params[_i3] : params.type;
                        var _arg2 = parsedArgs[_i3];
                        signatureContext.concat(_i3 + 1).checkSubtype(_expected, _arg2.type);
                    }
                    if (signatureContext.errors.length === 0) {
                        return new CompoundExpression(op, type, evaluate, parsedArgs);
                    }
                }
            } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion12 && _iterator12.return) {
                        _iterator12.return();
                    }
                } finally {
                    if (_didIteratorError12) {
                        throw _iteratorError12;
                    }
                }
            }

            if (overloads.length === 1) {
                var _context$errors;

                (_context$errors = context.errors).push.apply(_context$errors, _toConsumableArray(signatureContext.errors));
            } else {
                var expected = overloads.length ? overloads : availableOverloads;
                var signatures = expected.map(function (_ref7) {
                    var _ref8 = _slicedToArray(_ref7, 1),
                        params = _ref8[0];

                    return stringifySignature(params);
                }).join(' | ');
                var actualTypes = [];
                for (var i = 1; i < args.length; i++) {
                    var parsed = context.parse(args[i], 1 + actualTypes.length);
                    if (!parsed) return null;
                    actualTypes.push(toString(parsed.type));
                }
                context.error("Expected arguments of type " + signatures + ", but found (" + actualTypes.join(', ') + ") instead.");
            }
            return null;
        }
    }, {
        key: "register",
        value: function register(registry, definitions) {
            CompoundExpression.definitions = definitions;
            for (var name in definitions) {
                registry[name] = CompoundExpression;
            }
        }
    }]);

    return CompoundExpression;
}();

function stringifySignature(signature) {
    if (Array.isArray(signature)) {
        return "(" + signature.map(toString).join(', ') + ")";
    } else {
        return "(" + toString(signature.type) + "...)";
    }
}

var CollatorExpression = function () {
    function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
        _classCallCheck(this, CollatorExpression);

        this.type = CollatorType;
        this.locale = locale;
        this.caseSensitive = caseSensitive;
        this.diacriticSensitive = diacriticSensitive;
    }

    _createClass(CollatorExpression, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.caseSensitive);
            fn(this.diacriticSensitive);
            if (this.locale) {
                fn(this.locale);
            }
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var options = {};
            options['case-sensitive'] = this.caseSensitive.serialize();
            options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
            if (this.locale) {
                options['locale'] = this.locale.serialize();
            }
            return ['collator', options];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 2) return context.error("Expected one argument.");
            var options = args[1];
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) return context.error("Collator options argument must be an object.");
            var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
            if (!caseSensitive) return null;
            var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
            if (!diacriticSensitive) return null;
            var locale = null;
            if (options['locale']) {
                locale = context.parse(options['locale'], 1, StringType);
                if (!locale) return null;
            }
            return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
        }
    }]);

    return CollatorExpression;
}();

var EXTENT = 8192;
function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
}
function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0]) return false;
    if (bbox1[2] >= bbox2[2]) return false;
    if (bbox1[1] <= bbox2[1]) return false;
    if (bbox1[3] >= bbox2[3]) return false;
    return true;
}
function getTileCoordinates(p, canonical) {
    var x = mercatorXfromLng(p[0]);
    var y = mercatorYfromLat(p[1]);
    var tilesAtZoom = Math.pow(2, canonical.z);
    return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];
}
function onBoundary(p, p1, p2) {
    var x1 = p[0] - p1[0];
    var y1 = p[1] - p1[1];
    var x2 = p[0] - p2[0];
    var y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
function pointWithinPolygon(point, rings) {
    var inside = false;
    for (var i = 0, len = rings.length; i < len; i++) {
        var ring = rings[i];
        for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
            if (onBoundary(point, ring[j], ring[j + 1])) return false;
            if (rayIntersect(point, ring[j], ring[j + 1])) inside = !inside;
        }
    }
    return inside;
}
function pointWithinPolygons(point, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (pointWithinPolygon(point, polygons[i])) return true;
    }
    return false;
}
function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}
function twoSided(p1, p2, q1, q2) {
    var x1 = p1[0] - q1[0];
    var y1 = p1[1] - q1[1];
    var x2 = p2[0] - q1[0];
    var y2 = p2[1] - q1[1];
    var x3 = q2[0] - q1[0];
    var y3 = q2[1] - q1[1];
    var det1 = x1 * y3 - x3 * y1;
    var det2 = x2 * y3 - x3 * y2;
    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) return true;
    return false;
}
function lineIntersectLine(a, b, c, d) {
    var vectorP = [b[0] - a[0], b[1] - a[1]];
    var vectorQ = [d[0] - c[0], d[1] - c[1]];
    if (perp(vectorQ, vectorP) === 0) return false;
    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) return true;
    return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
    var _iteratorNormalCompletion13 = true;
    var _didIteratorError13 = false;
    var _iteratorError13 = undefined;

    try {
        for (var _iterator13 = polygon[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var ring = _step13.value;

            for (var j = 0; j < ring.length - 1; ++j) {
                if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
                    return true;
                }
            }
        }
    } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion13 && _iterator13.return) {
                _iterator13.return();
            }
        } finally {
            if (_didIteratorError13) {
                throw _iteratorError13;
            }
        }
    }

    return false;
}
function lineStringWithinPolygon(line, polygon) {
    for (var i = 0; i < line.length; ++i) {
        if (!pointWithinPolygon(line[i], polygon)) {
            return false;
        }
    }
    for (var _i4 = 0; _i4 < line.length - 1; ++_i4) {
        if (lineIntersectPolygon(line[_i4], line[_i4 + 1], polygon)) {
            return false;
        }
    }
    return true;
}
function lineStringWithinPolygons(line, polygons) {
    for (var i = 0; i < polygons.length; i++) {
        if (lineStringWithinPolygon(line, polygons[i])) return true;
    }
    return false;
}
function getTilePolygon(coordinates, bbox, canonical) {
    var polygon = [];
    for (var i = 0; i < coordinates.length; i++) {
        var ring = [];
        for (var j = 0; j < coordinates[i].length; j++) {
            var coord = getTileCoordinates(coordinates[i][j], canonical);
            updateBBox(bbox, coord);
            ring.push(coord);
        }
        polygon.push(ring);
    }
    return polygon;
}
function getTilePolygons(coordinates, bbox, canonical) {
    var polygons = [];
    for (var i = 0; i < coordinates.length; i++) {
        var polygon = getTilePolygon(coordinates[i], bbox, canonical);
        polygons.push(polygon);
    }
    return polygons;
}
function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
        var halfWorldSize = worldSize * 0.5;
        var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
        if (shift === 0) {
            shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
        }
        p[0] += shift;
    }
    updateBBox(bbox, p);
}
function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tilePoints = [];
    var _iteratorNormalCompletion14 = true;
    var _didIteratorError14 = false;
    var _iteratorError14 = undefined;

    try {
        for (var _iterator14 = geometry[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var points = _step14.value;
            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
                for (var _iterator15 = points[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                    var point = _step15.value;

                    var p = [point.x + shifts[0], point.y + shifts[1]];
                    updatePoint(p, pointBBox, polyBBox, worldSize);
                    tilePoints.push(p);
                }
            } catch (err) {
                _didIteratorError15 = true;
                _iteratorError15 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion15 && _iterator15.return) {
                        _iterator15.return();
                    }
                } finally {
                    if (_didIteratorError15) {
                        throw _iteratorError15;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion14 && _iterator14.return) {
                _iterator14.return();
            }
        } finally {
            if (_didIteratorError14) {
                throw _iteratorError14;
            }
        }
    }

    return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tileLines = [];
    var _iteratorNormalCompletion16 = true;
    var _didIteratorError16 = false;
    var _iteratorError16 = undefined;

    try {
        for (var _iterator16 = geometry[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var line = _step16.value;

            var tileLine = [];
            var _iteratorNormalCompletion19 = true;
            var _didIteratorError19 = false;
            var _iteratorError19 = undefined;

            try {
                for (var _iterator19 = line[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                    var point = _step19.value;

                    var _p = [point.x + shifts[0], point.y + shifts[1]];
                    updateBBox(lineBBox, _p);
                    tileLine.push(_p);
                }
            } catch (err) {
                _didIteratorError19 = true;
                _iteratorError19 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion19 && _iterator19.return) {
                        _iterator19.return();
                    }
                } finally {
                    if (_didIteratorError19) {
                        throw _iteratorError19;
                    }
                }
            }

            tileLines.push(tileLine);
        }
    } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion16 && _iterator16.return) {
                _iterator16.return();
            }
        } finally {
            if (_didIteratorError16) {
                throw _iteratorError16;
            }
        }
    }

    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
        resetBBox(lineBBox);
        var _iteratorNormalCompletion17 = true;
        var _didIteratorError17 = false;
        var _iteratorError17 = undefined;

        try {
            for (var _iterator17 = tileLines[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                var _line = _step17.value;
                var _iteratorNormalCompletion18 = true;
                var _didIteratorError18 = false;
                var _iteratorError18 = undefined;

                try {
                    for (var _iterator18 = _line[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                        var p = _step18.value;

                        updatePoint(p, lineBBox, polyBBox, worldSize);
                    }
                } catch (err) {
                    _didIteratorError18 = true;
                    _iteratorError18 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion18 && _iterator18.return) {
                            _iterator18.return();
                        }
                    } finally {
                        if (_didIteratorError18) {
                            throw _iteratorError18;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError17 = true;
            _iteratorError17 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion17 && _iterator17.return) {
                    _iterator17.return();
                }
            } finally {
                if (_didIteratorError17) {
                    throw _iteratorError17;
                }
            }
        }
    }
    return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
    var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) return false;
        var _iteratorNormalCompletion20 = true;
        var _didIteratorError20 = false;
        var _iteratorError20 = undefined;

        try {
            for (var _iterator20 = tilePoints[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                var point = _step20.value;

                if (!pointWithinPolygon(point, tilePolygon)) return false;
            }
        } catch (err) {
            _didIteratorError20 = true;
            _iteratorError20 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion20 && _iterator20.return) {
                    _iterator20.return();
                }
            } finally {
                if (_didIteratorError20) {
                    throw _iteratorError20;
                }
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var _tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) return false;
        var _iteratorNormalCompletion21 = true;
        var _didIteratorError21 = false;
        var _iteratorError21 = undefined;

        try {
            for (var _iterator21 = _tilePoints[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                var _point = _step21.value;

                if (!pointWithinPolygons(_point, tilePolygons)) return false;
            }
        } catch (err) {
            _didIteratorError21 = true;
            _iteratorError21 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion21 && _iterator21.return) {
                    _iterator21.return();
                }
            } finally {
                if (_didIteratorError21) {
                    throw _iteratorError21;
                }
            }
        }
    }
    return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
    var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();
    if (polygonGeometry.type === 'Polygon') {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) return false;
        var _iteratorNormalCompletion22 = true;
        var _didIteratorError22 = false;
        var _iteratorError22 = undefined;

        try {
            for (var _iterator22 = tileLines[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var line = _step22.value;

                if (!lineStringWithinPolygon(line, tilePolygon)) return false;
            }
        } catch (err) {
            _didIteratorError22 = true;
            _iteratorError22 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion22 && _iterator22.return) {
                    _iterator22.return();
                }
            } finally {
                if (_didIteratorError22) {
                    throw _iteratorError22;
                }
            }
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var _tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) return false;
        var _iteratorNormalCompletion23 = true;
        var _didIteratorError23 = false;
        var _iteratorError23 = undefined;

        try {
            for (var _iterator23 = _tileLines[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                var _line2 = _step23.value;

                if (!lineStringWithinPolygons(_line2, tilePolygons)) return false;
            }
        } catch (err) {
            _didIteratorError23 = true;
            _iteratorError23 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion23 && _iterator23.return) {
                    _iterator23.return();
                }
            } finally {
                if (_didIteratorError23) {
                    throw _iteratorError23;
                }
            }
        }
    }
    return true;
}

var Within = function () {
    function Within(geojson, geometries) {
        _classCallCheck(this, Within);

        this.type = BooleanType;
        this.geojson = geojson;
        this.geometries = geometries;
    }

    _createClass(Within, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            if (ctx.geometry() != null && ctx.canonicalID() != null) {
                if (ctx.geometryType() === 'Point') {
                    return pointsWithinPolygons(ctx, this.geometries);
                } else if (ctx.geometryType() === 'LineString') {
                    return linesWithinPolygons(ctx, this.geometries);
                }
            }
            return false;
        }
    }, {
        key: "eachChild",
        value: function eachChild() {}
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return true;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ['within', this.geojson];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 2) return context.error("'within' expression requires exactly one argument, but found " + (args.length - 1) + " instead.");
            if (isValue(args[1])) {
                var geojson = args[1];
                if (geojson.type === 'FeatureCollection') {
                    for (var i = 0; i < geojson.features.length; ++i) {
                        var type = geojson.features[i].geometry.type;
                        if (type === 'Polygon' || type === 'MultiPolygon') {
                            return new Within(geojson, geojson.features[i].geometry);
                        }
                    }
                } else if (geojson.type === 'Feature') {
                    var _type2 = geojson.geometry.type;
                    if (_type2 === 'Polygon' || _type2 === 'MultiPolygon') {
                        return new Within(geojson, geojson.geometry);
                    }
                } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
                    return new Within(geojson, geojson);
                }
            }
            return context.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
    }]);

    return Within;
}();

function isFeatureConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'get' && e.args.length === 1) {
            return false;
        } else if (e.name === 'feature-state') {
            return false;
        } else if (e.name === 'has' && e.args.length === 1) {
            return false;
        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
            return false;
        } else if (/^filter-/.test(e.name)) {
            return false;
        }
    }
    if (e instanceof Within) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isFeatureConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isStateConstant(e) {
    if (e instanceof CompoundExpression) {
        if (e.name === 'feature-state') {
            return false;
        }
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isStateConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
        return false;
    }
    var result = true;
    e.eachChild(function (arg) {
        if (result && !isGlobalPropertyConstant(arg, properties)) {
            result = false;
        }
    });
    return result;
}

var Var = function () {
    function Var(name, boundExpression) {
        _classCallCheck(this, Var);

        this.type = boundExpression.type;
        this.name = name;
        this.boundExpression = boundExpression;
    }

    _createClass(Var, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            return this.boundExpression.evaluate(ctx);
        }
    }, {
        key: "eachChild",
        value: function eachChild() {}
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ['var', this.name];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 2 || typeof args[1] !== 'string') return context.error("'var' expression requires exactly one string literal argument.");
            var name = args[1];
            if (!context.scope.has(name)) {
                return context.error("Unknown variable \"" + name + "\". Make sure \"" + name + "\" has been bound in an enclosing \"let\" expression before using it.", 1);
            }
            return new Var(name, context.scope.get(name));
        }
    }]);

    return Var;
}();

var ParsingContext = function () {
    function ParsingContext(registry) {
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var expectedType = arguments[2];
        var scope = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Scope();
        var errors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

        _classCallCheck(this, ParsingContext);

        this.registry = registry;
        this.path = path;
        this.key = path.map(function (part) {
            return "[" + part + "]";
        }).join('');
        this.scope = scope;
        this.errors = errors;
        this.expectedType = expectedType;
    }

    _createClass(ParsingContext, [{
        key: "parse",
        value: function parse(expr, index, expectedType, bindings) {
            var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

            if (index) {
                return this.concat(index, expectedType, bindings)._parse(expr, options);
            }
            return this._parse(expr, options);
        }
    }, {
        key: "_parse",
        value: function _parse(expr, options) {
            if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
                expr = ['literal', expr];
            }
            function annotate(parsed, type, typeAnnotation) {
                if (typeAnnotation === 'assert') {
                    return new Assertion(type, [parsed]);
                } else if (typeAnnotation === 'coerce') {
                    return new Coercion(type, [parsed]);
                } else {
                    return parsed;
                }
            }
            if (Array.isArray(expr)) {
                if (expr.length === 0) {
                    return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
                }
                var op = expr[0];
                if (typeof op !== 'string') {
                    this.error("Expression name must be a string, but found " + (typeof op === "undefined" ? "undefined" : _typeof(op)) + " instead. If you wanted a literal array, use [\"literal\", [...]].", 0);
                    return null;
                }
                var Expr = this.registry[op];
                if (Expr) {
                    var parsed = Expr.parse(expr, this);
                    if (!parsed) return null;
                    if (this.expectedType) {
                        var expected = this.expectedType;
                        var actual = parsed.type;
                        if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
                            parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
                        } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
                            parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
                        } else if (this.checkSubtype(expected, actual)) {
                            return null;
                        }
                    }
                    if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
                        var ec = new EvaluationContext();
                        try {
                            parsed = new Literal(parsed.type, parsed.evaluate(ec));
                        } catch (e) {
                            this.error(e.message);
                            return null;
                        }
                    }
                    return parsed;
                }
                return this.error("Unknown expression \"" + op + "\". If you wanted a literal array, use [\"literal\", [...]].", 0);
            } else if (typeof expr === 'undefined') {
                return this.error("'undefined' value invalid. Use null instead.");
            } else if ((typeof expr === "undefined" ? "undefined" : _typeof(expr)) === 'object') {
                return this.error("Bare objects invalid. Use [\"literal\", {...}] instead.");
            } else {
                return this.error("Expected an array, but found " + (typeof expr === "undefined" ? "undefined" : _typeof(expr)) + " instead.");
            }
        }
    }, {
        key: "concat",
        value: function concat(index, expectedType, bindings) {
            var path = typeof index === 'number' ? this.path.concat(index) : this.path;
            var scope = bindings ? this.scope.concat(bindings) : this.scope;
            return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
        }
    }, {
        key: "error",
        value: function error(_error3) {
            for (var _len2 = arguments.length, keys = Array(_len2 > 1 ? _len2 - 1 : 0), _key4 = 1; _key4 < _len2; _key4++) {
                keys[_key4 - 1] = arguments[_key4];
            }

            var key = "" + this.key + keys.map(function (k) {
                return "[" + k + "]";
            }).join('');
            this.errors.push(new ParsingError(key, _error3));
        }
    }, {
        key: "checkSubtype",
        value: function checkSubtype(expected, t) {
            var error = _checkSubtype(expected, t);
            if (error) this.error(error);
            return error;
        }
    }]);

    return ParsingContext;
}();

function isConstant(expression) {
    if (expression instanceof Var) {
        return isConstant(expression.boundExpression);
    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
        return false;
    } else if (expression instanceof CollatorExpression) {
        return false;
    } else if (expression instanceof Within) {
        return false;
    }
    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
    var childrenConstant = true;
    expression.eachChild(function (child) {
        if (isTypeAnnotation) {
            childrenConstant = childrenConstant && isConstant(child);
        } else {
            childrenConstant = childrenConstant && child instanceof Literal;
        }
    });
    if (!childrenConstant) {
        return false;
    }
    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'sky-radial-progress', 'accumulated', 'is-supported-script', 'pitch', 'distance-from-center']);
}

function findStopLessThanOrEqualTo(stops, input) {
    var lastIndex = stops.length - 1;
    var lowerIndex = 0;
    var upperIndex = lastIndex;
    var currentIndex = 0;
    var currentValue = void 0,
        nextValue = void 0;
    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
            if (currentIndex === lastIndex || input < nextValue) {
                return currentIndex;
            }
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        } else {
            throw new RuntimeError('Input is not a number.');
        }
    }
    return 0;
}

var Step = function () {
    function Step(type, input, stops) {
        _classCallCheck(this, Step);

        this.type = type;
        this.input = input;
        this.labels = [];
        this.outputs = [];
        var _iteratorNormalCompletion24 = true;
        var _didIteratorError24 = false;
        var _iteratorError24 = undefined;

        try {
            for (var _iterator24 = stops[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                var _ref9 = _step24.value;

                var _ref10 = _slicedToArray(_ref9, 2);

                var label = _ref10[0];
                var _expression2 = _ref10[1];

                this.labels.push(label);
                this.outputs.push(_expression2);
            }
        } catch (err) {
            _didIteratorError24 = true;
            _iteratorError24 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion24 && _iterator24.return) {
                    _iterator24.return();
                }
            } finally {
                if (_didIteratorError24) {
                    throw _iteratorError24;
                }
            }
        }
    }

    _createClass(Step, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var labels = this.labels;
            var outputs = this.outputs;
            if (labels.length === 1) {
                return outputs[0].evaluate(ctx);
            }
            var value = this.input.evaluate(ctx);
            if (value <= labels[0]) {
                return outputs[0].evaluate(ctx);
            }
            var stopCount = labels.length;
            if (value >= labels[stopCount - 1]) {
                return outputs[stopCount - 1].evaluate(ctx);
            }
            var index = findStopLessThanOrEqualTo(labels, value);
            return outputs[index].evaluate(ctx);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.input);
            var _iteratorNormalCompletion25 = true;
            var _didIteratorError25 = false;
            var _iteratorError25 = undefined;

            try {
                for (var _iterator25 = this.outputs[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                    var _expression3 = _step25.value;

                    fn(_expression3);
                }
            } catch (err) {
                _didIteratorError25 = true;
                _iteratorError25 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion25 && _iterator25.return) {
                        _iterator25.return();
                    }
                } finally {
                    if (_didIteratorError25) {
                        throw _iteratorError25;
                    }
                }
            }
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.outputs.every(function (out) {
                return out.outputDefined();
            });
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var serialized = ['step', this.input.serialize()];
            for (var i = 0; i < this.labels.length; i++) {
                if (i > 0) {
                    serialized.push(this.labels[i]);
                }
                serialized.push(this.outputs[i].serialize());
            }
            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length - 1 < 4) {
                return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
            }
            if ((args.length - 1) % 2 !== 0) {
                return context.error("Expected an even number of arguments.");
            }
            var input = context.parse(args[1], 1, NumberType);
            if (!input) return null;
            var stops = [];
            var outputType = null;
            if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            for (var i = 1; i < args.length; i += 2) {
                var label = i === 1 ? -Infinity : args[i];
                var value = args[i + 1];
                var labelKey = i;
                var valueKey = i + 1;
                if (typeof label !== 'number') {
                    return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
                }
                if (stops.length && stops[stops.length - 1][0] >= label) {
                    return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
                }
                var parsed = context.parse(value, valueKey, outputType);
                if (!parsed) return null;
                outputType = outputType || parsed.type;
                stops.push([label, parsed]);
            }
            return new Step(outputType, input, stops);
        }
    }]);

    return Step;
}();

/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */


var unitbezier = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function (t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function (t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function (x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function (x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

function number(a, b, t) {
    return a * (1 - t) + b * t;
}
function color(from, to, t) {
    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}
function array$1(from, to, t) {
    return from.map(function (d, i) {
        return number(d, to[i], t);
    });
}

var interpolate = /*#__PURE__*/Object.freeze({
    __proto__: null,
    number: number,
    color: color,
    array: array$1
});

var Xn = 0.95047,
    Yn = 1,
    Zn = 1.08883,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1,
    deg2rad = Math.PI / 180,
    rad2deg = 180 / Math.PI;
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor.r),
        a = rgb2xyz(rgbColor.g),
        l = rgb2xyz(rgbColor.b),
        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),
        z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
        l: 116 * y - 16,
        a: 500 * (x - y),
        b: 200 * (y - z),
        alpha: rgbColor.a
    };
}
function labToRgb(labColor) {
    var y = (labColor.l + 16) / 116,
        x = isNaN(labColor.a) ? y : y + labColor.a / 500,
        z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}
function interpolateLab(from, to, t) {
    return {
        l: number(from.l, to.l, t),
        a: number(from.a, to.a, t),
        b: number(from.b, to.b, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
function rgbToHcl(rgbColor) {
    var _rgbToLab = rgbToLab(rgbColor),
        l = _rgbToLab.l,
        a = _rgbToLab.a,
        b = _rgbToLab.b;

    var h = Math.atan2(b, a) * rad2deg;
    return {
        h: h < 0 ? h + 360 : h,
        c: Math.sqrt(a * a + b * b),
        l: l,
        alpha: rgbColor.a
    };
}
function hclToRgb(hclColor) {
    var h = hclColor.h * deg2rad,
        c = hclColor.c,
        l = hclColor.l;
    return labToRgb({
        l: l,
        a: Math.cos(h) * c,
        b: Math.sin(h) * c,
        alpha: hclColor.alpha
    });
}
function interpolateHue(a, b, t) {
    var d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}
function interpolateHcl(from, to, t) {
    return {
        h: interpolateHue(from.h, to.h, t),
        c: number(from.c, to.c, t),
        l: number(from.l, to.l, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
var lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
};
var hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
};

var colorSpaces = /*#__PURE__*/Object.freeze({
    __proto__: null,
    lab: lab,
    hcl: hcl
});

var Interpolate = function () {
    function Interpolate(type, operator, interpolation, input, stops) {
        _classCallCheck(this, Interpolate);

        this.type = type;
        this.operator = operator;
        this.interpolation = interpolation;
        this.input = input;
        this.labels = [];
        this.outputs = [];
        var _iteratorNormalCompletion26 = true;
        var _didIteratorError26 = false;
        var _iteratorError26 = undefined;

        try {
            for (var _iterator26 = stops[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
                var _ref11 = _step26.value;

                var _ref12 = _slicedToArray(_ref11, 2);

                var label = _ref12[0];
                var _expression4 = _ref12[1];

                this.labels.push(label);
                this.outputs.push(_expression4);
            }
        } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion26 && _iterator26.return) {
                    _iterator26.return();
                }
            } finally {
                if (_didIteratorError26) {
                    throw _iteratorError26;
                }
            }
        }
    }

    _createClass(Interpolate, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var labels = this.labels;
            var outputs = this.outputs;
            if (labels.length === 1) {
                return outputs[0].evaluate(ctx);
            }
            var value = this.input.evaluate(ctx);
            if (value <= labels[0]) {
                return outputs[0].evaluate(ctx);
            }
            var stopCount = labels.length;
            if (value >= labels[stopCount - 1]) {
                return outputs[stopCount - 1].evaluate(ctx);
            }
            var index = findStopLessThanOrEqualTo(labels, value);
            var lower = labels[index];
            var upper = labels[index + 1];
            var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
            var outputLower = outputs[index].evaluate(ctx);
            var outputUpper = outputs[index + 1].evaluate(ctx);
            if (this.operator === 'interpolate') {
                return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);
            } else if (this.operator === 'interpolate-hcl') {
                return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
            } else {
                return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
            }
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.input);
            var _iteratorNormalCompletion27 = true;
            var _didIteratorError27 = false;
            var _iteratorError27 = undefined;

            try {
                for (var _iterator27 = this.outputs[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                    var _expression5 = _step27.value;

                    fn(_expression5);
                }
            } catch (err) {
                _didIteratorError27 = true;
                _iteratorError27 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion27 && _iterator27.return) {
                        _iterator27.return();
                    }
                } finally {
                    if (_didIteratorError27) {
                        throw _iteratorError27;
                    }
                }
            }
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.outputs.every(function (out) {
                return out.outputDefined();
            });
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var interpolation = void 0;
            if (this.interpolation.name === 'linear') {
                interpolation = ['linear'];
            } else if (this.interpolation.name === 'exponential') {
                if (this.interpolation.base === 1) {
                    interpolation = ['linear'];
                } else {
                    interpolation = ['exponential', this.interpolation.base];
                }
            } else {
                interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
            }
            var serialized = [this.operator, interpolation, this.input.serialize()];
            for (var i = 0; i < this.labels.length; i++) {
                serialized.push(this.labels[i], this.outputs[i].serialize());
            }
            return serialized;
        }
    }], [{
        key: "interpolationFactor",
        value: function interpolationFactor(interpolation, input, lower, upper) {
            var t = 0;
            if (interpolation.name === 'exponential') {
                t = exponentialInterpolation(input, interpolation.base, lower, upper);
            } else if (interpolation.name === 'linear') {
                t = exponentialInterpolation(input, 1, lower, upper);
            } else if (interpolation.name === 'cubic-bezier') {
                var c = interpolation.controlPoints;
                var ub = new unitbezier(c[0], c[1], c[2], c[3]);
                t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
            }
            return t;
        }
    }, {
        key: "parse",
        value: function parse(args, context) {
            var _args = _toArray3(args),
                operator = _args[0],
                interpolation = _args[1],
                input = _args[2],
                rest = _args.slice(3);

            if (!Array.isArray(interpolation) || interpolation.length === 0) {
                return context.error("Expected an interpolation type expression.", 1);
            }
            if (interpolation[0] === 'linear') {
                interpolation = { name: 'linear' };
            } else if (interpolation[0] === 'exponential') {
                var base = interpolation[1];
                if (typeof base !== 'number') return context.error("Exponential interpolation requires a numeric base.", 1, 1);
                interpolation = {
                    name: 'exponential',
                    base: base
                };
            } else if (interpolation[0] === 'cubic-bezier') {
                var controlPoints = interpolation.slice(1);
                if (controlPoints.length !== 4 || controlPoints.some(function (t) {
                    return typeof t !== 'number' || t < 0 || t > 1;
                })) {
                    return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
                }
                interpolation = {
                    name: 'cubic-bezier',
                    controlPoints: controlPoints
                };
            } else {
                return context.error("Unknown interpolation type " + String(interpolation[0]), 1, 0);
            }
            if (args.length - 1 < 4) {
                return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
            }
            if ((args.length - 1) % 2 !== 0) {
                return context.error("Expected an even number of arguments.");
            }
            input = context.parse(input, 2, NumberType);
            if (!input) return null;
            var stops = [];
            var outputType = null;
            if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
                outputType = ColorType;
            } else if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            for (var i = 0; i < rest.length; i += 2) {
                var label = rest[i];
                var value = rest[i + 1];
                var labelKey = i + 3;
                var valueKey = i + 4;
                if (typeof label !== 'number') {
                    return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
                }
                if (stops.length && stops[stops.length - 1][0] >= label) {
                    return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
                }
                var parsed = context.parse(value, valueKey, outputType);
                if (!parsed) return null;
                outputType = outputType || parsed.type;
                stops.push([label, parsed]);
            }
            if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
                return context.error("Type " + toString(outputType) + " is not interpolatable.");
            }
            return new Interpolate(outputType, operator, interpolation, input, stops);
        }
    }]);

    return Interpolate;
}();

function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var Coalesce = function () {
    function Coalesce(type, args) {
        _classCallCheck(this, Coalesce);

        this.type = type;
        this.args = args;
    }

    _createClass(Coalesce, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var result = null;
            var argCount = 0;
            var requestedImageName = void 0;
            var _iteratorNormalCompletion28 = true;
            var _didIteratorError28 = false;
            var _iteratorError28 = undefined;

            try {
                for (var _iterator28 = this.args[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                    var arg = _step28.value;

                    argCount++;
                    result = arg.evaluate(ctx);
                    if (result && result instanceof ResolvedImage && !result.available) {
                        if (!requestedImageName) {
                            requestedImageName = result.name;
                        }
                        result = null;
                        if (argCount === this.args.length) {
                            result = requestedImageName;
                        }
                    }
                    if (result !== null) break;
                }
            } catch (err) {
                _didIteratorError28 = true;
                _iteratorError28 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion28 && _iterator28.return) {
                        _iterator28.return();
                    }
                } finally {
                    if (_didIteratorError28) {
                        throw _iteratorError28;
                    }
                }
            }

            return result;
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            this.args.forEach(fn);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.args.every(function (arg) {
                return arg.outputDefined();
            });
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var serialized = ['coalesce'];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length < 2) {
                return context.error('Expectected at least one argument.');
            }
            var outputType = null;
            var expectedType = context.expectedType;
            if (expectedType && expectedType.kind !== 'value') {
                outputType = expectedType;
            }
            var parsedArgs = [];
            var _iteratorNormalCompletion29 = true;
            var _didIteratorError29 = false;
            var _iteratorError29 = undefined;

            try {
                for (var _iterator29 = args.slice(1)[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
                    var arg = _step29.value;

                    var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
                    if (!parsed) return null;
                    outputType = outputType || parsed.type;
                    parsedArgs.push(parsed);
                }
            } catch (err) {
                _didIteratorError29 = true;
                _iteratorError29 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion29 && _iterator29.return) {
                        _iterator29.return();
                    }
                } finally {
                    if (_didIteratorError29) {
                        throw _iteratorError29;
                    }
                }
            }

            var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
                return _checkSubtype(expectedType, arg.type);
            });
            return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
        }
    }]);

    return Coalesce;
}();

var Let = function () {
    function Let(bindings, result) {
        _classCallCheck(this, Let);

        this.type = result.type;
        this.bindings = [].concat(bindings);
        this.result = result;
    }

    _createClass(Let, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            return this.result.evaluate(ctx);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            var _iteratorNormalCompletion30 = true;
            var _didIteratorError30 = false;
            var _iteratorError30 = undefined;

            try {
                for (var _iterator30 = this.bindings[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                    var binding = _step30.value;

                    fn(binding[1]);
                }
            } catch (err) {
                _didIteratorError30 = true;
                _iteratorError30 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion30 && _iterator30.return) {
                        _iterator30.return();
                    }
                } finally {
                    if (_didIteratorError30) {
                        throw _iteratorError30;
                    }
                }
            }

            fn(this.result);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.result.outputDefined();
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var serialized = ['let'];
            var _iteratorNormalCompletion31 = true;
            var _didIteratorError31 = false;
            var _iteratorError31 = undefined;

            try {
                for (var _iterator31 = this.bindings[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
                    var _ref13 = _step31.value;

                    var _ref14 = _slicedToArray(_ref13, 2);

                    var name = _ref14[0];
                    var expr = _ref14[1];

                    serialized.push(name, expr.serialize());
                }
            } catch (err) {
                _didIteratorError31 = true;
                _iteratorError31 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion31 && _iterator31.return) {
                        _iterator31.return();
                    }
                } finally {
                    if (_didIteratorError31) {
                        throw _iteratorError31;
                    }
                }
            }

            serialized.push(this.result.serialize());
            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length < 4) return context.error("Expected at least 3 arguments, but found " + (args.length - 1) + " instead.");
            var bindings = [];
            for (var i = 1; i < args.length - 1; i += 2) {
                var name = args[i];
                if (typeof name !== 'string') {
                    return context.error("Expected string, but found " + (typeof name === "undefined" ? "undefined" : _typeof(name)) + " instead.", i);
                }
                if (/[^a-zA-Z0-9_]/.test(name)) {
                    return context.error("Variable names must contain only alphanumeric characters or '_'.", i);
                }
                var value = context.parse(args[i + 1], i + 1);
                if (!value) return null;
                bindings.push([name, value]);
            }
            var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
            if (!result) return null;
            return new Let(bindings, result);
        }
    }]);

    return Let;
}();

var At = function () {
    function At(type, index, input) {
        _classCallCheck(this, At);

        this.type = type;
        this.index = index;
        this.input = input;
    }

    _createClass(At, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var index = this.index.evaluate(ctx);
            var array = this.input.evaluate(ctx);
            if (index < 0) {
                throw new RuntimeError("Array index out of bounds: " + index + " < 0.");
            }
            if (index >= array.length) {
                throw new RuntimeError("Array index out of bounds: " + index + " > " + (array.length - 1) + ".");
            }
            if (index !== Math.floor(index)) {
                throw new RuntimeError("Array index must be an integer, but found " + index + " instead.");
            }
            return array[index];
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.index);
            fn(this.input);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ['at', this.index.serialize(), this.input.serialize()];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 3) return context.error("Expected 2 arguments, but found " + (args.length - 1) + " instead.");
            var index = context.parse(args[1], 1, NumberType);
            var input = context.parse(args[2], 2, array(context.expectedType || ValueType));
            if (!index || !input) return null;
            var t = input.type;
            return new At(t.itemType, index, input);
        }
    }]);

    return At;
}();

var In = function () {
    function In(needle, haystack) {
        _classCallCheck(this, In);

        this.type = BooleanType;
        this.needle = needle;
        this.haystack = haystack;
    }

    _createClass(In, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var needle = this.needle.evaluate(ctx);
            var haystack = this.haystack.evaluate(ctx);
            if (!haystack) return false;
            if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
                throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString(typeOf(needle)) + " instead.");
            }
            if (!isValidNativeType(haystack, ['string', 'array'])) {
                throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString(typeOf(haystack)) + " instead.");
            }
            return haystack.indexOf(needle) >= 0;
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.needle);
            fn(this.haystack);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return true;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ['in', this.needle.serialize(), this.haystack.serialize()];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 3) {
                return context.error("Expected 2 arguments, but found " + (args.length - 1) + " instead.");
            }
            var needle = context.parse(args[1], 1, ValueType);
            var haystack = context.parse(args[2], 2, ValueType);
            if (!needle || !haystack) return null;
            if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
                return context.error("Expected first argument to be of type boolean, string, number or null, but found " + toString(needle.type) + " instead");
            }
            return new In(needle, haystack);
        }
    }]);

    return In;
}();

var IndexOf = function () {
    function IndexOf(needle, haystack, fromIndex) {
        _classCallCheck(this, IndexOf);

        this.type = NumberType;
        this.needle = needle;
        this.haystack = haystack;
        this.fromIndex = fromIndex;
    }

    _createClass(IndexOf, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var needle = this.needle.evaluate(ctx);
            var haystack = this.haystack.evaluate(ctx);
            if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
                throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString(typeOf(needle)) + " instead.");
            }
            if (!isValidNativeType(haystack, ['string', 'array'])) {
                throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString(typeOf(haystack)) + " instead.");
            }
            if (this.fromIndex) {
                var fromIndex = this.fromIndex.evaluate(ctx);
                return haystack.indexOf(needle, fromIndex);
            }
            return haystack.indexOf(needle);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.needle);
            fn(this.haystack);
            if (this.fromIndex) {
                fn(this.fromIndex);
            }
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            if (this.fromIndex != null && this.fromIndex !== undefined) {
                var fromIndex = this.fromIndex.serialize();
                return ['index-of', this.needle.serialize(), this.haystack.serialize(), fromIndex];
            }
            return ['index-of', this.needle.serialize(), this.haystack.serialize()];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length <= 2 || args.length >= 5) {
                return context.error("Expected 3 or 4 arguments, but found " + (args.length - 1) + " instead.");
            }
            var needle = context.parse(args[1], 1, ValueType);
            var haystack = context.parse(args[2], 2, ValueType);
            if (!needle || !haystack) return null;
            if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
                return context.error("Expected first argument to be of type boolean, string, number or null, but found " + toString(needle.type) + " instead");
            }
            if (args.length === 4) {
                var fromIndex = context.parse(args[3], 3, NumberType);
                if (!fromIndex) return null;
                return new IndexOf(needle, haystack, fromIndex);
            } else {
                return new IndexOf(needle, haystack);
            }
        }
    }]);

    return IndexOf;
}();

var Match = function () {
    function Match(inputType, outputType, input, cases, outputs, otherwise) {
        _classCallCheck(this, Match);

        this.inputType = inputType;
        this.type = outputType;
        this.input = input;
        this.cases = cases;
        this.outputs = outputs;
        this.otherwise = otherwise;
    }

    _createClass(Match, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var input = this.input.evaluate(ctx);
            var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
            return output.evaluate(ctx);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.input);
            this.outputs.forEach(fn);
            fn(this.otherwise);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.outputs.every(function (out) {
                return out.outputDefined();
            }) && this.otherwise.outputDefined();
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var _this2 = this;

            var serialized = ['match', this.input.serialize()];
            var sortedLabels = Object.keys(this.cases).sort();
            var groupedByOutput = [];
            var outputLookup = {};
            var _iteratorNormalCompletion32 = true;
            var _didIteratorError32 = false;
            var _iteratorError32 = undefined;

            try {
                for (var _iterator32 = sortedLabels[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
                    var label = _step32.value;

                    var outputIndex = outputLookup[this.cases[label]];
                    if (outputIndex === undefined) {
                        outputLookup[this.cases[label]] = groupedByOutput.length;
                        groupedByOutput.push([this.cases[label], [label]]);
                    } else {
                        groupedByOutput[outputIndex][1].push(label);
                    }
                }
            } catch (err) {
                _didIteratorError32 = true;
                _iteratorError32 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion32 && _iterator32.return) {
                        _iterator32.return();
                    }
                } finally {
                    if (_didIteratorError32) {
                        throw _iteratorError32;
                    }
                }
            }

            var coerceLabel = function coerceLabel(label) {
                return _this2.inputType.kind === 'number' ? Number(label) : label;
            };
            var _iteratorNormalCompletion33 = true;
            var _didIteratorError33 = false;
            var _iteratorError33 = undefined;

            try {
                for (var _iterator33 = groupedByOutput[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
                    var _ref15 = _step33.value;

                    var _ref16 = _slicedToArray(_ref15, 2);

                    var outputIndex = _ref16[0];
                    var labels = _ref16[1];

                    if (labels.length === 1) {
                        serialized.push(coerceLabel(labels[0]));
                    } else {
                        serialized.push(labels.map(coerceLabel));
                    }
                    serialized.push(this.outputs[outputIndex].serialize());
                }
            } catch (err) {
                _didIteratorError33 = true;
                _iteratorError33 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion33 && _iterator33.return) {
                        _iterator33.return();
                    }
                } finally {
                    if (_didIteratorError33) {
                        throw _iteratorError33;
                    }
                }
            }

            serialized.push(this.otherwise.serialize());
            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length < 5) return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
            if (args.length % 2 !== 1) return context.error("Expected an even number of arguments.");
            var inputType = void 0;
            var outputType = void 0;
            if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            var cases = {};
            var outputs = [];
            for (var i = 2; i < args.length - 1; i += 2) {
                var labels = args[i];
                var value = args[i + 1];
                if (!Array.isArray(labels)) {
                    labels = [labels];
                }
                var labelContext = context.concat(i);
                if (labels.length === 0) {
                    return labelContext.error('Expected at least one branch label.');
                }
                var _iteratorNormalCompletion34 = true;
                var _didIteratorError34 = false;
                var _iteratorError34 = undefined;

                try {
                    for (var _iterator34 = labels[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
                        var label = _step34.value;

                        if (typeof label !== 'number' && typeof label !== 'string') {
                            return labelContext.error("Branch labels must be numbers or strings.");
                        } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                            return labelContext.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
                        } else if (typeof label === 'number' && Math.floor(label) !== label) {
                            return labelContext.error("Numeric branch labels must be integer values.");
                        } else if (!inputType) {
                            inputType = typeOf(label);
                        } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                            return null;
                        }
                        if (typeof cases[String(label)] !== 'undefined') {
                            return labelContext.error('Branch labels must be unique.');
                        }
                        cases[String(label)] = outputs.length;
                    }
                } catch (err) {
                    _didIteratorError34 = true;
                    _iteratorError34 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion34 && _iterator34.return) {
                            _iterator34.return();
                        }
                    } finally {
                        if (_didIteratorError34) {
                            throw _iteratorError34;
                        }
                    }
                }

                var result = context.parse(value, i, outputType);
                if (!result) return null;
                outputType = outputType || result.type;
                outputs.push(result);
            }
            var input = context.parse(args[1], 1, ValueType);
            if (!input) return null;
            var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
            if (!otherwise) return null;
            if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
                return null;
            }
            return new Match(inputType, outputType, input, cases, outputs, otherwise);
        }
    }]);

    return Match;
}();

var Case = function () {
    function Case(type, branches, otherwise) {
        _classCallCheck(this, Case);

        this.type = type;
        this.branches = branches;
        this.otherwise = otherwise;
    }

    _createClass(Case, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var _iteratorNormalCompletion35 = true;
            var _didIteratorError35 = false;
            var _iteratorError35 = undefined;

            try {
                for (var _iterator35 = this.branches[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
                    var _ref17 = _step35.value;

                    var _ref18 = _slicedToArray(_ref17, 2);

                    var test = _ref18[0];
                    var _expression6 = _ref18[1];

                    if (test.evaluate(ctx)) {
                        return _expression6.evaluate(ctx);
                    }
                }
            } catch (err) {
                _didIteratorError35 = true;
                _iteratorError35 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion35 && _iterator35.return) {
                        _iterator35.return();
                    }
                } finally {
                    if (_didIteratorError35) {
                        throw _iteratorError35;
                    }
                }
            }

            return this.otherwise.evaluate(ctx);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            var _iteratorNormalCompletion36 = true;
            var _didIteratorError36 = false;
            var _iteratorError36 = undefined;

            try {
                for (var _iterator36 = this.branches[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
                    var _ref19 = _step36.value;

                    var _ref20 = _slicedToArray(_ref19, 2);

                    var test = _ref20[0];
                    var _expression7 = _ref20[1];

                    fn(test);
                    fn(_expression7);
                }
            } catch (err) {
                _didIteratorError36 = true;
                _iteratorError36 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion36 && _iterator36.return) {
                        _iterator36.return();
                    }
                } finally {
                    if (_didIteratorError36) {
                        throw _iteratorError36;
                    }
                }
            }

            fn(this.otherwise);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return this.branches.every(function (_ref21) {
                var _ref22 = _slicedToArray(_ref21, 2),
                    _ = _ref22[0],
                    out = _ref22[1];

                return out.outputDefined();
            }) && this.otherwise.outputDefined();
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var serialized = ['case'];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length < 4) return context.error("Expected at least 3 arguments, but found only " + (args.length - 1) + ".");
            if (args.length % 2 !== 0) return context.error("Expected an odd number of arguments.");
            var outputType = void 0;
            if (context.expectedType && context.expectedType.kind !== 'value') {
                outputType = context.expectedType;
            }
            var branches = [];
            for (var i = 1; i < args.length - 1; i += 2) {
                var test = context.parse(args[i], i, BooleanType);
                if (!test) return null;
                var result = context.parse(args[i + 1], i + 1, outputType);
                if (!result) return null;
                branches.push([test, result]);
                outputType = outputType || result.type;
            }
            var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
            if (!otherwise) return null;
            return new Case(outputType, branches, otherwise);
        }
    }]);

    return Case;
}();

var Slice = function () {
    function Slice(type, input, beginIndex, endIndex) {
        _classCallCheck(this, Slice);

        this.type = type;
        this.input = input;
        this.beginIndex = beginIndex;
        this.endIndex = endIndex;
    }

    _createClass(Slice, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var input = this.input.evaluate(ctx);
            var beginIndex = this.beginIndex.evaluate(ctx);
            if (!isValidNativeType(input, ['string', 'array'])) {
                throw new RuntimeError("Expected first argument to be of type array or string, but found " + toString(typeOf(input)) + " instead.");
            }
            if (this.endIndex) {
                var endIndex = this.endIndex.evaluate(ctx);
                return input.slice(beginIndex, endIndex);
            }
            return input.slice(beginIndex);
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.input);
            fn(this.beginIndex);
            if (this.endIndex) {
                fn(this.endIndex);
            }
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            if (this.endIndex != null && this.endIndex !== undefined) {
                var endIndex = this.endIndex.serialize();
                return ['slice', this.input.serialize(), this.beginIndex.serialize(), endIndex];
            }
            return ['slice', this.input.serialize(), this.beginIndex.serialize()];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length <= 2 || args.length >= 5) {
                return context.error("Expected 3 or 4 arguments, but found " + (args.length - 1) + " instead.");
            }
            var input = context.parse(args[1], 1, ValueType);
            var beginIndex = context.parse(args[2], 2, NumberType);
            if (!input || !beginIndex) return null;
            if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {
                return context.error("Expected first argument to be of type array or string, but found " + toString(input.type) + " instead");
            }
            if (args.length === 4) {
                var endIndex = context.parse(args[3], 3, NumberType);
                if (!endIndex) return null;
                return new Slice(input.type, input, beginIndex, endIndex);
            } else {
                return new Slice(input.type, input, beginIndex);
            }
        }
    }]);

    return Slice;
}();

function isComparableType(op, type) {
    if (op === '==' || op === '!=') {
        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
    } else {
        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
    }
}
function eq(ctx, a, b) {
    return a === b;
}
function neq(ctx, a, b) {
    return a !== b;
}
function lt(ctx, a, b) {
    return a < b;
}
function gt(ctx, a, b) {
    return a > b;
}
function lteq(ctx, a, b) {
    return a <= b;
}
function gteq(ctx, a, b) {
    return a >= b;
}
function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
}
function makeComparison(op, compareBasic, compareWithCollator) {
    var isOrderComparison = op !== '==' && op !== '!=';
    return function () {
        function Comparison(lhs, rhs, collator) {
            _classCallCheck(this, Comparison);

            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
        }

        _createClass(Comparison, [{
            key: "evaluate",
            value: function evaluate(ctx) {
                var lhs = this.lhs.evaluate(ctx);
                var rhs = this.rhs.evaluate(ctx);
                if (isOrderComparison && this.hasUntypedArgument) {
                    var _lt = typeOf(lhs);
                    var rt = typeOf(rhs);
                    if (_lt.kind !== rt.kind || !(_lt.kind === 'string' || _lt.kind === 'number')) {
                        throw new RuntimeError("Expected arguments for \"" + op + "\" to be (string, string) or (number, number), but found (" + _lt.kind + ", " + rt.kind + ") instead.");
                    }
                }
                if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                    var _lt2 = typeOf(lhs);
                    var _rt = typeOf(rhs);
                    if (_lt2.kind !== 'string' || _rt.kind !== 'string') {
                        return compareBasic(ctx, lhs, rhs);
                    }
                }
                return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
            }
        }, {
            key: "eachChild",
            value: function eachChild(fn) {
                fn(this.lhs);
                fn(this.rhs);
                if (this.collator) {
                    fn(this.collator);
                }
            }
        }, {
            key: "outputDefined",
            value: function outputDefined() {
                return true;
            }
        }, {
            key: "serialize",
            value: function serialize() {
                var serialized = [op];
                this.eachChild(function (child) {
                    serialized.push(child.serialize());
                });
                return serialized;
            }
        }], [{
            key: "parse",
            value: function parse(args, context) {
                if (args.length !== 3 && args.length !== 4) return context.error("Expected two or three arguments.");
                var op = args[0];
                var lhs = context.parse(args[1], 1, ValueType);
                if (!lhs) return null;
                if (!isComparableType(op, lhs.type)) {
                    return context.concat(1).error("\"" + op + "\" comparisons are not supported for type '" + toString(lhs.type) + "'.");
                }
                var rhs = context.parse(args[2], 2, ValueType);
                if (!rhs) return null;
                if (!isComparableType(op, rhs.type)) {
                    return context.concat(2).error("\"" + op + "\" comparisons are not supported for type '" + toString(rhs.type) + "'.");
                }
                if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                    return context.error("Cannot compare types '" + toString(lhs.type) + "' and '" + toString(rhs.type) + "'.");
                }
                if (isOrderComparison) {
                    if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
                        lhs = new Assertion(rhs.type, [lhs]);
                    } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
                        rhs = new Assertion(lhs.type, [rhs]);
                    }
                }
                var collator = null;
                if (args.length === 4) {
                    if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                        return context.error("Cannot use collator to compare non-string types.");
                    }
                    collator = context.parse(args[3], 3, CollatorType);
                    if (!collator) return null;
                }
                return new Comparison(lhs, rhs, collator);
            }
        }]);

        return Comparison;
    }();
}
var Equals = makeComparison('==', eq, eqCollate);
var NotEquals = makeComparison('!=', neq, neqCollate);
var LessThan = makeComparison('<', lt, ltCollate);
var GreaterThan = makeComparison('>', gt, gtCollate);
var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

var NumberFormat = function () {
    function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
        _classCallCheck(this, NumberFormat);

        this.type = StringType;
        this.number = number;
        this.locale = locale;
        this.currency = currency;
        this.minFractionDigits = minFractionDigits;
        this.maxFractionDigits = maxFractionDigits;
    }

    _createClass(NumberFormat, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
                style: this.currency ? 'currency' : 'decimal',
                currency: this.currency ? this.currency.evaluate(ctx) : undefined,
                minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
                maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
            }).format(this.number.evaluate(ctx));
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.number);
            if (this.locale) {
                fn(this.locale);
            }
            if (this.currency) {
                fn(this.currency);
            }
            if (this.minFractionDigits) {
                fn(this.minFractionDigits);
            }
            if (this.maxFractionDigits) {
                fn(this.maxFractionDigits);
            }
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var options = {};
            if (this.locale) {
                options['locale'] = this.locale.serialize();
            }
            if (this.currency) {
                options['currency'] = this.currency.serialize();
            }
            if (this.minFractionDigits) {
                options['min-fraction-digits'] = this.minFractionDigits.serialize();
            }
            if (this.maxFractionDigits) {
                options['max-fraction-digits'] = this.maxFractionDigits.serialize();
            }
            return ['number-format', this.number.serialize(), options];
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 3) return context.error("Expected two arguments.");
            var number = context.parse(args[1], 1, NumberType);
            if (!number) return null;
            var options = args[2];
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || Array.isArray(options)) return context.error("NumberFormat options argument must be an object.");
            var locale = null;
            if (options['locale']) {
                locale = context.parse(options['locale'], 1, StringType);
                if (!locale) return null;
            }
            var currency = null;
            if (options['currency']) {
                currency = context.parse(options['currency'], 1, StringType);
                if (!currency) return null;
            }
            var minFractionDigits = null;
            if (options['min-fraction-digits']) {
                minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
                if (!minFractionDigits) return null;
            }
            var maxFractionDigits = null;
            if (options['max-fraction-digits']) {
                maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
                if (!maxFractionDigits) return null;
            }
            return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
        }
    }]);

    return NumberFormat;
}();

var Length = function () {
    function Length(input) {
        _classCallCheck(this, Length);

        this.type = NumberType;
        this.input = input;
    }

    _createClass(Length, [{
        key: "evaluate",
        value: function evaluate(ctx) {
            var input = this.input.evaluate(ctx);
            if (typeof input === 'string') {
                return input.length;
            } else if (Array.isArray(input)) {
                return input.length;
            } else {
                throw new RuntimeError("Expected value to be of type string or array, but found " + toString(typeOf(input)) + " instead.");
            }
        }
    }, {
        key: "eachChild",
        value: function eachChild(fn) {
            fn(this.input);
        }
    }, {
        key: "outputDefined",
        value: function outputDefined() {
            return false;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            var serialized = ['length'];
            this.eachChild(function (child) {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    }], [{
        key: "parse",
        value: function parse(args, context) {
            if (args.length !== 2) return context.error("Expected 1 argument, but found " + (args.length - 1) + " instead.");
            var input = context.parse(args[1], 1);
            if (!input) return null;
            if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') return context.error("Expected argument of type string or array, but found " + toString(input.type) + " instead.");
            return new Length(input);
        }
    }]);

    return Length;
}();

var expressions = {
    '==': Equals,
    '!=': NotEquals,
    '>': GreaterThan,
    '<': LessThan,
    '>=': GreaterThanOrEqual,
    '<=': LessThanOrEqual,
    'array': Assertion,
    'at': At,
    'boolean': Assertion,
    'case': Case,
    'coalesce': Coalesce,
    'collator': CollatorExpression,
    'format': FormatExpression,
    'image': ImageExpression,
    'in': In,
    'index-of': IndexOf,
    'interpolate': Interpolate,
    'interpolate-hcl': Interpolate,
    'interpolate-lab': Interpolate,
    'length': Length,
    'let': Let,
    'literal': Literal,
    'match': Match,
    'number': Assertion,
    'number-format': NumberFormat,
    'object': Assertion,
    'slice': Slice,
    'step': Step,
    'string': Assertion,
    'to-boolean': Coercion,
    'to-color': Coercion,
    'to-number': Coercion,
    'to-string': Coercion,
    'var': Var,
    'within': Within
};
function rgba(ctx, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 4),
        r = _ref24[0],
        g = _ref24[1],
        b = _ref24[2],
        a = _ref24[3];

    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    var alpha = a ? a.evaluate(ctx) : 1;
    var error = validateRGBA(r, g, b, alpha);
    if (error) throw new RuntimeError(error);
    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}
function has(key, obj) {
    return key in obj;
}
function get(key, obj) {
    var v = obj[key];
    return typeof v === 'undefined' ? null : v;
}
function binarySearch(v, a, i, j) {
    while (i <= j) {
        var m = i + j >> 1;
        if (a[m] === v) return true;
        if (a[m] > v) j = m - 1;else i = m + 1;
    }
    return false;
}
function varargs(type) {
    return { type: type };
}
CompoundExpression.register(expressions, {
    'error': [ErrorType, [StringType], function (ctx, _ref25) {
        var _ref26 = _slicedToArray(_ref25, 1),
            v = _ref26[0];

        throw new RuntimeError(v.evaluate(ctx));
    }],
    'typeof': [StringType, [ValueType], function (ctx, _ref27) {
        var _ref28 = _slicedToArray(_ref27, 1),
            v = _ref28[0];

        return toString(typeOf(v.evaluate(ctx)));
    }],
    'to-rgba': [array(NumberType, 4), [ColorType], function (ctx, _ref29) {
        var _ref30 = _slicedToArray(_ref29, 1),
            v = _ref30[0];

        return v.evaluate(ctx).toArray();
    }],
    'rgb': [ColorType, [NumberType, NumberType, NumberType], rgba],
    'rgba': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],
    'has': {
        type: BooleanType,
        overloads: [[[StringType], function (ctx, _ref31) {
            var _ref32 = _slicedToArray(_ref31, 1),
                key = _ref32[0];

            return has(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, _ref33) {
            var _ref34 = _slicedToArray(_ref33, 2),
                key = _ref34[0],
                obj = _ref34[1];

            return has(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'get': {
        type: ValueType,
        overloads: [[[StringType], function (ctx, _ref35) {
            var _ref36 = _slicedToArray(_ref35, 1),
                key = _ref36[0];

            return get(key.evaluate(ctx), ctx.properties());
        }], [[StringType, ObjectType], function (ctx, _ref37) {
            var _ref38 = _slicedToArray(_ref37, 2),
                key = _ref38[0],
                obj = _ref38[1];

            return get(key.evaluate(ctx), obj.evaluate(ctx));
        }]]
    },
    'feature-state': [ValueType, [StringType], function (ctx, _ref39) {
        var _ref40 = _slicedToArray(_ref39, 1),
            key = _ref40[0];

        return get(key.evaluate(ctx), ctx.featureState || {});
    }],
    'properties': [ObjectType, [], function (ctx) {
        return ctx.properties();
    }],
    'geometry-type': [StringType, [], function (ctx) {
        return ctx.geometryType();
    }],
    'id': [ValueType, [], function (ctx) {
        return ctx.id();
    }],
    'zoom': [NumberType, [], function (ctx) {
        return ctx.globals.zoom;
    }],
    'pitch': [NumberType, [], function (ctx) {
        return ctx.globals.pitch || 0;
    }],
    'distance-from-center': [NumberType, [], function (ctx) {
        return ctx.distanceFromCenter();
    }],
    'heatmap-density': [NumberType, [], function (ctx) {
        return ctx.globals.heatmapDensity || 0;
    }],
    'line-progress': [NumberType, [], function (ctx) {
        return ctx.globals.lineProgress || 0;
    }],
    'sky-radial-progress': [NumberType, [], function (ctx) {
        return ctx.globals.skyRadialProgress || 0;
    }],
    'accumulated': [ValueType, [], function (ctx) {
        return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
    }],
    '+': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 0;
        var _iteratorNormalCompletion37 = true;
        var _didIteratorError37 = false;
        var _iteratorError37 = undefined;

        try {
            for (var _iterator37 = args[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
                var arg = _step37.value;

                result += arg.evaluate(ctx);
            }
        } catch (err) {
            _didIteratorError37 = true;
            _iteratorError37 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion37 && _iterator37.return) {
                    _iterator37.return();
                }
            } finally {
                if (_didIteratorError37) {
                    throw _iteratorError37;
                }
            }
        }

        return result;
    }],
    '*': [NumberType, varargs(NumberType), function (ctx, args) {
        var result = 1;
        var _iteratorNormalCompletion38 = true;
        var _didIteratorError38 = false;
        var _iteratorError38 = undefined;

        try {
            for (var _iterator38 = args[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
                var arg = _step38.value;

                result *= arg.evaluate(ctx);
            }
        } catch (err) {
            _didIteratorError38 = true;
            _iteratorError38 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion38 && _iterator38.return) {
                    _iterator38.return();
                }
            } finally {
                if (_didIteratorError38) {
                    throw _iteratorError38;
                }
            }
        }

        return result;
    }],
    '-': {
        type: NumberType,
        overloads: [[[NumberType, NumberType], function (ctx, _ref41) {
            var _ref42 = _slicedToArray(_ref41, 2),
                a = _ref42[0],
                b = _ref42[1];

            return a.evaluate(ctx) - b.evaluate(ctx);
        }], [[NumberType], function (ctx, _ref43) {
            var _ref44 = _slicedToArray(_ref43, 1),
                a = _ref44[0];

            return -a.evaluate(ctx);
        }]]
    },
    '/': [NumberType, [NumberType, NumberType], function (ctx, _ref45) {
        var _ref46 = _slicedToArray(_ref45, 2),
            a = _ref46[0],
            b = _ref46[1];

        return a.evaluate(ctx) / b.evaluate(ctx);
    }],
    '%': [NumberType, [NumberType, NumberType], function (ctx, _ref47) {
        var _ref48 = _slicedToArray(_ref47, 2),
            a = _ref48[0],
            b = _ref48[1];

        return a.evaluate(ctx) % b.evaluate(ctx);
    }],
    'ln2': [NumberType, [], function () {
        return Math.LN2;
    }],
    'pi': [NumberType, [], function () {
        return Math.PI;
    }],
    'e': [NumberType, [], function () {
        return Math.E;
    }],
    '^': [NumberType, [NumberType, NumberType], function (ctx, _ref49) {
        var _ref50 = _slicedToArray(_ref49, 2),
            b = _ref50[0],
            e = _ref50[1];

        return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
    }],
    'sqrt': [NumberType, [NumberType], function (ctx, _ref51) {
        var _ref52 = _slicedToArray(_ref51, 1),
            x = _ref52[0];

        return Math.sqrt(x.evaluate(ctx));
    }],
    'log10': [NumberType, [NumberType], function (ctx, _ref53) {
        var _ref54 = _slicedToArray(_ref53, 1),
            n = _ref54[0];

        return Math.log(n.evaluate(ctx)) / Math.LN10;
    }],
    'ln': [NumberType, [NumberType], function (ctx, _ref55) {
        var _ref56 = _slicedToArray(_ref55, 1),
            n = _ref56[0];

        return Math.log(n.evaluate(ctx));
    }],
    'log2': [NumberType, [NumberType], function (ctx, _ref57) {
        var _ref58 = _slicedToArray(_ref57, 1),
            n = _ref58[0];

        return Math.log(n.evaluate(ctx)) / Math.LN2;
    }],
    'sin': [NumberType, [NumberType], function (ctx, _ref59) {
        var _ref60 = _slicedToArray(_ref59, 1),
            n = _ref60[0];

        return Math.sin(n.evaluate(ctx));
    }],
    'cos': [NumberType, [NumberType], function (ctx, _ref61) {
        var _ref62 = _slicedToArray(_ref61, 1),
            n = _ref62[0];

        return Math.cos(n.evaluate(ctx));
    }],
    'tan': [NumberType, [NumberType], function (ctx, _ref63) {
        var _ref64 = _slicedToArray(_ref63, 1),
            n = _ref64[0];

        return Math.tan(n.evaluate(ctx));
    }],
    'asin': [NumberType, [NumberType], function (ctx, _ref65) {
        var _ref66 = _slicedToArray(_ref65, 1),
            n = _ref66[0];

        return Math.asin(n.evaluate(ctx));
    }],
    'acos': [NumberType, [NumberType], function (ctx, _ref67) {
        var _ref68 = _slicedToArray(_ref67, 1),
            n = _ref68[0];

        return Math.acos(n.evaluate(ctx));
    }],
    'atan': [NumberType, [NumberType], function (ctx, _ref69) {
        var _ref70 = _slicedToArray(_ref69, 1),
            n = _ref70[0];

        return Math.atan(n.evaluate(ctx));
    }],
    'min': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.min.apply(Math, _toConsumableArray(args.map(function (arg) {
            return arg.evaluate(ctx);
        })));
    }],
    'max': [NumberType, varargs(NumberType), function (ctx, args) {
        return Math.max.apply(Math, _toConsumableArray(args.map(function (arg) {
            return arg.evaluate(ctx);
        })));
    }],
    'abs': [NumberType, [NumberType], function (ctx, _ref71) {
        var _ref72 = _slicedToArray(_ref71, 1),
            n = _ref72[0];

        return Math.abs(n.evaluate(ctx));
    }],
    'round': [NumberType, [NumberType], function (ctx, _ref73) {
        var _ref74 = _slicedToArray(_ref73, 1),
            n = _ref74[0];

        var v = n.evaluate(ctx);
        return v < 0 ? -Math.round(-v) : Math.round(v);
    }],
    'floor': [NumberType, [NumberType], function (ctx, _ref75) {
        var _ref76 = _slicedToArray(_ref75, 1),
            n = _ref76[0];

        return Math.floor(n.evaluate(ctx));
    }],
    'ceil': [NumberType, [NumberType], function (ctx, _ref77) {
        var _ref78 = _slicedToArray(_ref77, 1),
            n = _ref78[0];

        return Math.ceil(n.evaluate(ctx));
    }],
    'filter-==': [BooleanType, [StringType, ValueType], function (ctx, _ref79) {
        var _ref80 = _slicedToArray(_ref79, 2),
            k = _ref80[0],
            v = _ref80[1];

        return ctx.properties()[k.value] === v.value;
    }],
    'filter-id-==': [BooleanType, [ValueType], function (ctx, _ref81) {
        var _ref82 = _slicedToArray(_ref81, 1),
            v = _ref82[0];

        return ctx.id() === v.value;
    }],
    'filter-type-==': [BooleanType, [StringType], function (ctx, _ref83) {
        var _ref84 = _slicedToArray(_ref83, 1),
            v = _ref84[0];

        return ctx.geometryType() === v.value;
    }],
    'filter-<': [BooleanType, [StringType, ValueType], function (ctx, _ref85) {
        var _ref86 = _slicedToArray(_ref85, 2),
            k = _ref86[0],
            v = _ref86[1];

        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter-id-<': [BooleanType, [ValueType], function (ctx, _ref87) {
        var _ref88 = _slicedToArray(_ref87, 1),
            v = _ref88[0];

        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a < b;
    }],
    'filter->': [BooleanType, [StringType, ValueType], function (ctx, _ref89) {
        var _ref90 = _slicedToArray(_ref89, 2),
            k = _ref90[0],
            v = _ref90[1];

        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-id->': [BooleanType, [ValueType], function (ctx, _ref91) {
        var _ref92 = _slicedToArray(_ref91, 1),
            v = _ref92[0];

        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a > b;
    }],
    'filter-<=': [BooleanType, [StringType, ValueType], function (ctx, _ref93) {
        var _ref94 = _slicedToArray(_ref93, 2),
            k = _ref94[0],
            v = _ref94[1];

        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter-id-<=': [BooleanType, [ValueType], function (ctx, _ref95) {
        var _ref96 = _slicedToArray(_ref95, 1),
            v = _ref96[0];

        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a <= b;
    }],
    'filter->=': [BooleanType, [StringType, ValueType], function (ctx, _ref97) {
        var _ref98 = _slicedToArray(_ref97, 2),
            k = _ref98[0],
            v = _ref98[1];

        var a = ctx.properties()[k.value];
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-id->=': [BooleanType, [ValueType], function (ctx, _ref99) {
        var _ref100 = _slicedToArray(_ref99, 1),
            v = _ref100[0];

        var a = ctx.id();
        var b = v.value;
        return (typeof a === "undefined" ? "undefined" : _typeof(a)) === (typeof b === "undefined" ? "undefined" : _typeof(b)) && a >= b;
    }],
    'filter-has': [BooleanType, [ValueType], function (ctx, _ref101) {
        var _ref102 = _slicedToArray(_ref101, 1),
            k = _ref102[0];

        return k.value in ctx.properties();
    }],
    'filter-has-id': [BooleanType, [], function (ctx) {
        return ctx.id() !== null && ctx.id() !== undefined;
    }],
    'filter-type-in': [BooleanType, [array(StringType)], function (ctx, _ref103) {
        var _ref104 = _slicedToArray(_ref103, 1),
            v = _ref104[0];

        return v.value.indexOf(ctx.geometryType()) >= 0;
    }],
    'filter-id-in': [BooleanType, [array(ValueType)], function (ctx, _ref105) {
        var _ref106 = _slicedToArray(_ref105, 1),
            v = _ref106[0];

        return v.value.indexOf(ctx.id()) >= 0;
    }],
    'filter-in-small': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref107) {
        var _ref108 = _slicedToArray(_ref107, 2),
            k = _ref108[0],
            v = _ref108[1];

        return v.value.indexOf(ctx.properties()[k.value]) >= 0;
    }],
    'filter-in-large': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref109) {
        var _ref110 = _slicedToArray(_ref109, 2),
            k = _ref110[0],
            v = _ref110[1];

        return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
    }],
    'all': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, _ref111) {
            var _ref112 = _slicedToArray(_ref111, 2),
                a = _ref112[0],
                b = _ref112[1];

            return a.evaluate(ctx) && b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            var _iteratorNormalCompletion39 = true;
            var _didIteratorError39 = false;
            var _iteratorError39 = undefined;

            try {
                for (var _iterator39 = args[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
                    var arg = _step39.value;

                    if (!arg.evaluate(ctx)) return false;
                }
            } catch (err) {
                _didIteratorError39 = true;
                _iteratorError39 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion39 && _iterator39.return) {
                        _iterator39.return();
                    }
                } finally {
                    if (_didIteratorError39) {
                        throw _iteratorError39;
                    }
                }
            }

            return true;
        }]]
    },
    'any': {
        type: BooleanType,
        overloads: [[[BooleanType, BooleanType], function (ctx, _ref113) {
            var _ref114 = _slicedToArray(_ref113, 2),
                a = _ref114[0],
                b = _ref114[1];

            return a.evaluate(ctx) || b.evaluate(ctx);
        }], [varargs(BooleanType), function (ctx, args) {
            var _iteratorNormalCompletion40 = true;
            var _didIteratorError40 = false;
            var _iteratorError40 = undefined;

            try {
                for (var _iterator40 = args[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
                    var arg = _step40.value;

                    if (arg.evaluate(ctx)) return true;
                }
            } catch (err) {
                _didIteratorError40 = true;
                _iteratorError40 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion40 && _iterator40.return) {
                        _iterator40.return();
                    }
                } finally {
                    if (_didIteratorError40) {
                        throw _iteratorError40;
                    }
                }
            }

            return false;
        }]]
    },
    '!': [BooleanType, [BooleanType], function (ctx, _ref115) {
        var _ref116 = _slicedToArray(_ref115, 1),
            b = _ref116[0];

        return !b.evaluate(ctx);
    }],
    'is-supported-script': [BooleanType, [StringType], function (ctx, _ref117) {
        var _ref118 = _slicedToArray(_ref117, 1),
            s = _ref118[0];

        var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
        if (isSupportedScript) {
            return isSupportedScript(s.evaluate(ctx));
        }
        return true;
    }],
    'upcase': [StringType, [StringType], function (ctx, _ref119) {
        var _ref120 = _slicedToArray(_ref119, 1),
            s = _ref120[0];

        return s.evaluate(ctx).toUpperCase();
    }],
    'downcase': [StringType, [StringType], function (ctx, _ref121) {
        var _ref122 = _slicedToArray(_ref121, 1),
            s = _ref122[0];

        return s.evaluate(ctx).toLowerCase();
    }],
    'concat': [StringType, varargs(ValueType), function (ctx, args) {
        return args.map(function (arg) {
            return toString$1(arg.evaluate(ctx));
        }).join('');
    }],
    'resolved-locale': [StringType, [CollatorType], function (ctx, _ref123) {
        var _ref124 = _slicedToArray(_ref123, 1),
            collator = _ref124[0];

        return collator.evaluate(ctx).resolvedLocale();
    }]
});

function success(value) {
    return {
        result: 'success',
        value: value
    };
}
function error(value) {
    return {
        result: 'error',
        value: value
    };
}

function supportsPropertyExpression(spec) {
    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
}
function supportsZoomExpression(spec) {
    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
}
function supportsInterpolation(spec) {
    return !!spec.expression && spec.expression.interpolated;
}

function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val === "undefined" ? "undefined" : _typeof(val);
    }
}

function isFunction$1(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && value !== null && !Array.isArray(value);
}
function identityFunction(x) {
    return x;
}
function createFunction(parameters, propertySpec) {
    var isColor = propertySpec.type === 'color';
    var zoomAndFeatureDependent = parameters.stops && _typeof(parameters.stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');
    if (isColor) {
        parameters = extend({}, parameters);
        if (parameters.stops) {
            parameters.stops = parameters.stops.map(function (stop) {
                return [stop[0], Color.parse(stop[1])];
            });
        }
        if (parameters.default) {
            parameters.default = Color.parse(parameters.default);
        } else {
            parameters.default = Color.parse(propertySpec.default);
        }
    }
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {
        throw new Error("Unknown color space: " + parameters.colorSpace);
    }
    var innerFun = void 0;
    var hashedStops = void 0;
    var categoricalKeyType = void 0;
    if (type === 'exponential') {
        innerFun = evaluateExponentialFunction;
    } else if (type === 'interval') {
        innerFun = evaluateIntervalFunction;
    } else if (type === 'categorical') {
        innerFun = evaluateCategoricalFunction;
        hashedStops = Object.create(null);
        var _iteratorNormalCompletion41 = true;
        var _didIteratorError41 = false;
        var _iteratorError41 = undefined;

        try {
            for (var _iterator41 = parameters.stops[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
                var stop = _step41.value;

                hashedStops[stop[0]] = stop[1];
            }
        } catch (err) {
            _didIteratorError41 = true;
            _iteratorError41 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion41 && _iterator41.return) {
                    _iterator41.return();
                }
            } finally {
                if (_didIteratorError41) {
                    throw _iteratorError41;
                }
            }
        }

        categoricalKeyType = _typeof(parameters.stops[0][0]);
    } else if (type === 'identity') {
        innerFun = evaluateIdentityFunction;
    } else {
        throw new Error("Unknown function type \"" + type + "\"");
    }
    if (zoomAndFeatureDependent) {
        var featureFunctions = {};
        var zoomStops = [];
        for (var s = 0; s < parameters.stops.length; s++) {
            var _stop = parameters.stops[s];
            var zoom = _stop[0].zoom;
            if (featureFunctions[zoom] === undefined) {
                featureFunctions[zoom] = {
                    zoom: zoom,
                    type: parameters.type,
                    property: parameters.property,
                    default: parameters.default,
                    stops: []
                };
                zoomStops.push(zoom);
            }
            featureFunctions[zoom].stops.push([_stop[0].value, _stop[1]]);
        }
        var featureFunctionStops = [];
        var _iteratorNormalCompletion42 = true;
        var _didIteratorError42 = false;
        var _iteratorError42 = undefined;

        try {
            for (var _iterator42 = zoomStops[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
                var z = _step42.value;

                featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);
            }
        } catch (err) {
            _didIteratorError42 = true;
            _iteratorError42 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion42 && _iterator42.return) {
                    _iterator42.return();
                }
            } finally {
                if (_didIteratorError42) {
                    throw _iteratorError42;
                }
            }
        }

        var interpolationType = { name: 'linear' };
        return {
            kind: 'composite',
            interpolationType: interpolationType,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),
            zoomStops: featureFunctionStops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(_ref125, properties) {
                var zoom = _ref125.zoom;

                return evaluateExponentialFunction({
                    stops: featureFunctionStops,
                    base: parameters.base
                }, propertySpec, zoom).evaluate(zoom, properties);
            }
        };
    } else if (zoomDependent) {
        var _interpolationType = type === 'exponential' ? {
            name: 'exponential',
            base: parameters.base !== undefined ? parameters.base : 1
        } : null;
        return {
            kind: 'camera',
            interpolationType: _interpolationType,
            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, _interpolationType),
            zoomStops: parameters.stops.map(function (s) {
                return s[0];
            }),
            evaluate: function evaluate(_ref126) {
                var zoom = _ref126.zoom;
                return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);
            }
        };
    } else {
        return {
            kind: 'source',
            evaluate: function evaluate(_, feature) {
                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;
                if (value === undefined) {
                    return coalesce(parameters.default, propertySpec.default);
                }
                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);
            }
        };
    }
}
function coalesce(a, b, c) {
    if (a !== undefined) return a;
    if (b !== undefined) return b;
    if (c !== undefined) return c;
}
function evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {
    var evaluated = (typeof input === "undefined" ? "undefined" : _typeof(input)) === keyType ? hashedStops[input] : undefined;
    return coalesce(evaluated, parameters.default, propertySpec.default);
}
function evaluateIntervalFunction(parameters, propertySpec, input) {
    if (getType(input) !== 'number') return coalesce(parameters.default, propertySpec.default);
    var n = parameters.stops.length;
    if (n === 1) return parameters.stops[0][1];
    if (input <= parameters.stops[0][0]) return parameters.stops[0][1];
    if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    return parameters.stops[index][1];
}
function evaluateExponentialFunction(parameters, propertySpec, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;
    if (getType(input) !== 'number') return coalesce(parameters.default, propertySpec.default);
    var n = parameters.stops.length;
    if (n === 1) return parameters.stops[0][1];
    if (input <= parameters.stops[0][0]) return parameters.stops[0][1];
    if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];
    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {
        return stop[0];
    }), input);
    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);
    var outputLower = parameters.stops[index][1];
    var outputUpper = parameters.stops[index + 1][1];
    var interp = interpolate[propertySpec.type] || identityFunction;
    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
        var colorspace = colorSpaces[parameters.colorSpace];
        interp = function interp(a, b) {
            return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));
        };
    }
    if (typeof outputLower.evaluate === 'function') {
        return {
            evaluate: function evaluate() {
                for (var _len3 = arguments.length, args = Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {
                    args[_key5] = arguments[_key5];
                }

                var evaluatedLower = outputLower.evaluate.apply(undefined, args);
                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);
                if (evaluatedLower === undefined || evaluatedUpper === undefined) {
                    return undefined;
                }
                return interp(evaluatedLower, evaluatedUpper, t);
            }
        };
    }
    return interp(outputLower, outputUpper, t);
}
function evaluateIdentityFunction(parameters, propertySpec, input) {
    if (propertySpec.type === 'color') {
        input = Color.parse(input);
    } else if (propertySpec.type === 'formatted') {
        input = Formatted.fromString(input.toString());
    } else if (propertySpec.type === 'resolvedImage') {
        input = ResolvedImage.fromString(input.toString());
    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {
        input = undefined;
    }
    return coalesce(input, parameters.default, propertySpec.default);
}
function interpolationFactor(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}

var StyleExpression = function () {
    function StyleExpression(expression, propertySpec) {
        _classCallCheck(this, StyleExpression);

        this.expression = expression;
        this._warningHistory = {};
        this._evaluator = new EvaluationContext();
        this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
        this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
    }

    _createClass(StyleExpression, [{
        key: "evaluateWithoutErrorHandling",
        value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {
            this._evaluator.globals = globals;
            this._evaluator.feature = feature;
            this._evaluator.featureState = featureState;
            this._evaluator.canonical = canonical;
            this._evaluator.availableImages = availableImages || null;
            this._evaluator.formattedSection = formattedSection;
            this._evaluator.featureTileCoord = featureTileCoord || null;
            this._evaluator.featureDistanceData = featureDistanceData || null;
            return this.expression.evaluate(this._evaluator);
        }
    }, {
        key: "evaluate",
        value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {
            this._evaluator.globals = globals;
            this._evaluator.feature = feature || null;
            this._evaluator.featureState = featureState || null;
            this._evaluator.canonical = canonical;
            this._evaluator.availableImages = availableImages || null;
            this._evaluator.formattedSection = formattedSection || null;
            this._evaluator.featureTileCoord = featureTileCoord || null;
            this._evaluator.featureDistanceData = featureDistanceData || null;
            try {
                var val = this.expression.evaluate(this._evaluator);
                if (val === null || val === undefined || typeof val === 'number' && val !== val) {
                    return this._defaultValue;
                }
                if (this._enumValues && !(val in this._enumValues)) {
                    throw new RuntimeError("Expected value to be one of " + Object.keys(this._enumValues).map(function (v) {
                        return JSON.stringify(v);
                    }).join(', ') + ", but found " + JSON.stringify(val) + " instead.");
                }
                return val;
            } catch (e) {
                if (!this._warningHistory[e.message]) {
                    this._warningHistory[e.message] = true;
                    if (typeof console !== 'undefined') {
                        console.warn(e.message);
                    }
                }
                return this._defaultValue;
            }
        }
    }]);

    return StyleExpression;
}();

function isExpression(expression) {
    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;
}
function createExpression(expression, propertySpec) {
    var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);
    if (!parsed) {
        return error(parser.errors);
    }
    return success(new StyleExpression(parsed, propertySpec));
}

var ZoomConstantExpression = function () {
    function ZoomConstantExpression(kind, expression) {
        _classCallCheck(this, ZoomConstantExpression);

        this.kind = kind;
        this._styleExpression = expression;
        this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
    }

    _createClass(ZoomConstantExpression, [{
        key: "evaluateWithoutErrorHandling",
        value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
            return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
        }
    }, {
        key: "evaluate",
        value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
            return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
        }
    }]);

    return ZoomConstantExpression;
}();

var ZoomDependentExpression = function () {
    function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
        _classCallCheck(this, ZoomDependentExpression);

        this.kind = kind;
        this.zoomStops = zoomStops;
        this._styleExpression = expression;
        this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
        this.interpolationType = interpolationType;
    }

    _createClass(ZoomDependentExpression, [{
        key: "evaluateWithoutErrorHandling",
        value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
            return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
        }
    }, {
        key: "evaluate",
        value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
            return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
        }
    }, {
        key: "interpolationFactor",
        value: function interpolationFactor(input, lower, upper) {
            if (this.interpolationType) {
                return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
            } else {
                return 0;
            }
        }
    }]);

    return ZoomDependentExpression;
}();

function createPropertyExpression(expression, propertySpec) {
    expression = createExpression(expression, propertySpec);
    if (expression.result === 'error') {
        return expression;
    }
    var parsed = expression.value.expression;
    var isFeatureConstant$1 = isFeatureConstant(parsed);
    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
        return error([new ParsingError('', 'data expressions not supported')]);
    }
    var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom', 'pitch', 'distance-from-center']);
    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
        return error([new ParsingError('', 'zoom expressions not supported')]);
    }
    var zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve && !isZoomConstant) {
        return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    } else if (zoomCurve instanceof ParsingError) {
        return error([zoomCurve]);
    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
        return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
    }
    if (!zoomCurve) {
        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
    }
    var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;
    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
}

var StylePropertyFunction = function () {
    function StylePropertyFunction(parameters, specification) {
        _classCallCheck(this, StylePropertyFunction);

        this._parameters = parameters;
        this._specification = specification;
        extend(this, createFunction(this._parameters, this._specification));
    }

    _createClass(StylePropertyFunction, null, [{
        key: "deserialize",
        value: function deserialize(serialized) {
            return new StylePropertyFunction(serialized._parameters, serialized._specification);
        }
    }, {
        key: "serialize",
        value: function serialize(input) {
            return {
                _parameters: input._parameters,
                _specification: input._specification
            };
        }
    }]);

    return StylePropertyFunction;
}();

function normalizePropertyExpression(value, specification) {
    if (isFunction$1(value)) {
        return new StylePropertyFunction(value, specification);
    } else if (isExpression(value)) {
        var _expression8 = createPropertyExpression(value, specification);
        if (_expression8.result === 'error') {
            throw new Error(_expression8.value.map(function (err) {
                return err.key + ": " + err.message;
            }).join(', '));
        }
        return _expression8.value;
    } else {
        var constant = value;
        if (typeof value === 'string' && specification.type === 'color') {
            constant = Color.parse(value);
        }
        return {
            kind: 'constant',
            evaluate: function evaluate() {
                return constant;
            }
        };
    }
}
function findZoomCurve(expression) {
    var result = null;
    if (expression instanceof Let) {
        result = findZoomCurve(expression.result);
    } else if (expression instanceof Coalesce) {
        var _iteratorNormalCompletion43 = true;
        var _didIteratorError43 = false;
        var _iteratorError43 = undefined;

        try {
            for (var _iterator43 = expression.args[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
                var arg = _step43.value;

                result = findZoomCurve(arg);
                if (result) {
                    break;
                }
            }
        } catch (err) {
            _didIteratorError43 = true;
            _iteratorError43 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion43 && _iterator43.return) {
                    _iterator43.return();
                }
            } finally {
                if (_didIteratorError43) {
                    throw _iteratorError43;
                }
            }
        }
    } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {
        result = expression;
    }
    if (result instanceof ParsingError) {
        return result;
    }
    expression.eachChild(function (child) {
        var childResult = findZoomCurve(child);
        if (childResult instanceof ParsingError) {
            result = childResult;
        } else if (!result && childResult) {
            result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
        } else if (result && childResult && result !== childResult) {
            result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
        }
    });
    return result;
}
function getExpectedType(spec) {
    var types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType,
        formatted: FormattedType,
        resolvedImage: ResolvedImageType
    };
    if (spec.type === 'array') {
        return array(types[spec.value] || ValueType, spec.length);
    }
    return types[spec.type];
}
function getDefaultValue(spec) {
    if (spec.type === 'color' && isFunction$1(spec.default)) {
        return new Color(0, 0, 0, 0);
    } else if (spec.type === 'color') {
        return Color.parse(spec.default) || null;
    } else if (spec.default === undefined) {
        return null;
    } else {
        return spec.default;
    }
}

function convertLiteral(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' ? ['literal', value] : value;
}
function convertFunction(parameters, propertySpec) {
    var stops = parameters.stops;
    if (!stops) {
        return convertIdentityFunction(parameters, propertySpec);
    }
    var zoomAndFeatureDependent = stops && _typeof(stops[0][0]) === 'object';
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    stops = stops.map(function (stop) {
        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {
            return [stop[0], convertTokenString(stop[1])];
        }
        return [stop[0], convertLiteral(stop[1])];
    });
    if (zoomAndFeatureDependent) {
        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
    } else if (zoomDependent) {
        return convertZoomFunction(parameters, propertySpec, stops);
    } else {
        return convertPropertyFunction(parameters, propertySpec, stops);
    }
}
function convertIdentityFunction(parameters, propertySpec) {
    var get = ['get', parameters.property];
    if (parameters.default === undefined) {
        return propertySpec.type === 'string' ? ['string', get] : get;
    } else if (propertySpec.type === 'enum') {
        return ['match', get, Object.keys(propertySpec.values), get, parameters.default];
    } else {
        var _expression9 = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters.default)];
        if (propertySpec.type === 'array') {
            _expression9.splice(1, 0, propertySpec.value, propertySpec.length || null);
        }
        return _expression9;
    }
}
function getInterpolateOperator(parameters) {
    switch (parameters.colorSpace) {
        case 'hcl':
            return 'interpolate-hcl';
        case 'lab':
            return 'interpolate-lab';
        default:
            return 'interpolate';
    }
}
function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
    var featureFunctionParameters = {};
    var featureFunctionStops = {};
    var zoomStops = [];
    for (var s = 0; s < stops.length; s++) {
        var stop = stops[s];
        var zoom = stop[0].zoom;
        if (featureFunctionParameters[zoom] === undefined) {
            featureFunctionParameters[zoom] = {
                zoom: zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default
            };
            featureFunctionStops[zoom] = [];
            zoomStops.push(zoom);
        }
        featureFunctionStops[zoom].push([stop[0].value, stop[1]]);
    }
    var functionType = getFunctionType({}, propertySpec);
    if (functionType === 'exponential') {
        var _expression10 = [getInterpolateOperator(parameters), ['linear'], ['zoom']];
        var _iteratorNormalCompletion44 = true;
        var _didIteratorError44 = false;
        var _iteratorError44 = undefined;

        try {
            for (var _iterator44 = zoomStops[Symbol.iterator](), _step44; !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
                var z = _step44.value;

                var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
                appendStopPair(_expression10, z, output, false);
            }
        } catch (err) {
            _didIteratorError44 = true;
            _iteratorError44 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion44 && _iterator44.return) {
                    _iterator44.return();
                }
            } finally {
                if (_didIteratorError44) {
                    throw _iteratorError44;
                }
            }
        }

        return _expression10;
    } else {
        var _expression11 = ['step', ['zoom']];
        var _iteratorNormalCompletion45 = true;
        var _didIteratorError45 = false;
        var _iteratorError45 = undefined;

        try {
            for (var _iterator45 = zoomStops[Symbol.iterator](), _step45; !(_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done); _iteratorNormalCompletion45 = true) {
                var _z = _step45.value;

                var _output = convertPropertyFunction(featureFunctionParameters[_z], propertySpec, featureFunctionStops[_z]);
                appendStopPair(_expression11, _z, _output, true);
            }
        } catch (err) {
            _didIteratorError45 = true;
            _iteratorError45 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion45 && _iterator45.return) {
                    _iterator45.return();
                }
            } finally {
                if (_didIteratorError45) {
                    throw _iteratorError45;
                }
            }
        }

        fixupDegenerateStepCurve(_expression11);
        return _expression11;
    }
}
function coalesce$1(a, b) {
    if (a !== undefined) return a;
    if (b !== undefined) return b;
}
function getFallback(parameters, propertySpec) {
    var defaultValue = convertLiteral(coalesce$1(parameters.default, propertySpec.default));
    if (defaultValue === undefined && propertySpec.type === 'resolvedImage') {
        return '';
    }
    return defaultValue;
}
function convertPropertyFunction(parameters, propertySpec, stops) {
    var type = getFunctionType(parameters, propertySpec);
    var get = ['get', parameters.property];
    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {
        var _expression12 = ['case'];
        var _iteratorNormalCompletion46 = true;
        var _didIteratorError46 = false;
        var _iteratorError46 = undefined;

        try {
            for (var _iterator46 = stops[Symbol.iterator](), _step46; !(_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done); _iteratorNormalCompletion46 = true) {
                var stop = _step46.value;

                _expression12.push(['==', get, stop[0]], stop[1]);
            }
        } catch (err) {
            _didIteratorError46 = true;
            _iteratorError46 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion46 && _iterator46.return) {
                    _iterator46.return();
                }
            } finally {
                if (_didIteratorError46) {
                    throw _iteratorError46;
                }
            }
        }

        _expression12.push(getFallback(parameters, propertySpec));
        return _expression12;
    } else if (type === 'categorical') {
        var _expression13 = ['match', get];
        var _iteratorNormalCompletion47 = true;
        var _didIteratorError47 = false;
        var _iteratorError47 = undefined;

        try {
            for (var _iterator47 = stops[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
                var _stop2 = _step47.value;

                appendStopPair(_expression13, _stop2[0], _stop2[1], false);
            }
        } catch (err) {
            _didIteratorError47 = true;
            _iteratorError47 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion47 && _iterator47.return) {
                    _iterator47.return();
                }
            } finally {
                if (_didIteratorError47) {
                    throw _iteratorError47;
                }
            }
        }

        _expression13.push(getFallback(parameters, propertySpec));
        return _expression13;
    } else if (type === 'interval') {
        var _expression14 = ['step', ['number', get]];
        var _iteratorNormalCompletion48 = true;
        var _didIteratorError48 = false;
        var _iteratorError48 = undefined;

        try {
            for (var _iterator48 = stops[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
                var _stop3 = _step48.value;

                appendStopPair(_expression14, _stop3[0], _stop3[1], true);
            }
        } catch (err) {
            _didIteratorError48 = true;
            _iteratorError48 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion48 && _iterator48.return) {
                    _iterator48.return();
                }
            } finally {
                if (_didIteratorError48) {
                    throw _iteratorError48;
                }
            }
        }

        fixupDegenerateStepCurve(_expression14);
        return parameters.default === undefined ? _expression14 : ['case', ['==', ['typeof', get], 'number'], _expression14, convertLiteral(parameters.default)];
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        var _expression15 = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], ['number', get]];
        var _iteratorNormalCompletion49 = true;
        var _didIteratorError49 = false;
        var _iteratorError49 = undefined;

        try {
            for (var _iterator49 = stops[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {
                var _stop4 = _step49.value;

                appendStopPair(_expression15, _stop4[0], _stop4[1], false);
            }
        } catch (err) {
            _didIteratorError49 = true;
            _iteratorError49 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion49 && _iterator49.return) {
                    _iterator49.return();
                }
            } finally {
                if (_didIteratorError49) {
                    throw _iteratorError49;
                }
            }
        }

        return parameters.default === undefined ? _expression15 : ['case', ['==', ['typeof', get], 'number'], _expression15, convertLiteral(parameters.default)];
    } else {
        throw new Error("Unknown property function type " + type);
    }
}
function convertZoomFunction(parameters, propertySpec, stops) {
    var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['zoom'];

    var type = getFunctionType(parameters, propertySpec);
    var expression = void 0;
    var isStep = false;
    if (type === 'interval') {
        expression = ['step', input];
        isStep = true;
    } else if (type === 'exponential') {
        var base = parameters.base !== undefined ? parameters.base : 1;
        expression = [getInterpolateOperator(parameters), base === 1 ? ['linear'] : ['exponential', base], input];
    } else {
        throw new Error("Unknown zoom function type \"" + type + "\"");
    }
    var _iteratorNormalCompletion50 = true;
    var _didIteratorError50 = false;
    var _iteratorError50 = undefined;

    try {
        for (var _iterator50 = stops[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
            var stop = _step50.value;

            appendStopPair(expression, stop[0], stop[1], isStep);
        }
    } catch (err) {
        _didIteratorError50 = true;
        _iteratorError50 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion50 && _iterator50.return) {
                _iterator50.return();
            }
        } finally {
            if (_didIteratorError50) {
                throw _iteratorError50;
            }
        }
    }

    fixupDegenerateStepCurve(expression);
    return expression;
}
function fixupDegenerateStepCurve(expression) {
    if (expression[0] === 'step' && expression.length === 3) {
        expression.push(0);
        expression.push(expression[3]);
    }
}
function appendStopPair(curve, input, output, isStep) {
    if (curve.length > 3 && input === curve[curve.length - 2]) {
        return;
    }
    if (!(isStep && curve.length === 2)) {
        curve.push(input);
    }
    curve.push(output);
}
function getFunctionType(parameters, propertySpec) {
    if (parameters.type) {
        return parameters.type;
    } else {
        return propertySpec.expression.interpolated ? 'exponential' : 'interval';
    }
}
function convertTokenString(s) {
    var result = ['concat'];
    var re = /{([^{}]+)}/g;
    var pos = 0;
    for (var match = re.exec(s); match !== null; match = re.exec(s)) {
        var literal = s.slice(pos, re.lastIndex - match[0].length);
        pos = re.lastIndex;
        if (literal.length > 0) result.push(literal);
        result.push(['get', match[1]]);
    }
    if (result.length === 1) {
        return s;
    }
    if (pos < s.length) {
        result.push(s.slice(pos));
    } else if (result.length === 2) {
        return ['to-string', result[1]];
    }
    return result;
}

function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
}
function deepUnbundle(value) {
    if (Array.isArray(value)) {
        return value.map(deepUnbundle);
    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
        var unbundledValue = {};
        for (var key in value) {
            unbundledValue[key] = deepUnbundle(value[key]);
        }
        return unbundledValue;
    }
    return unbundle(value);
}

function isExpressionFilter(filter) {
    if (filter === true || filter === false) {
        return true;
    }
    if (!Array.isArray(filter) || filter.length === 0) {
        return false;
    }
    switch (filter[0]) {
        case 'has':
            return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
        case 'in':
            return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
        case '!in':
        case '!has':
        case 'none':
            return false;
        case '==':
        case '!=':
        case '>':
        case '>=':
        case '<':
        case '<=':
            return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);
        case 'any':
        case 'all':
            var _iteratorNormalCompletion51 = true;
            var _didIteratorError51 = false;
            var _iteratorError51 = undefined;

            try {
                for (var _iterator51 = filter.slice(1)[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {
                    var f = _step51.value;

                    if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                        return false;
                    }
                }
            } catch (err) {
                _didIteratorError51 = true;
                _iteratorError51 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion51 && _iterator51.return) {
                        _iterator51.return();
                    }
                } finally {
                    if (_didIteratorError51) {
                        throw _iteratorError51;
                    }
                }
            }

            return true;
        default:
            return true;
    }
}
function createFilter(filter) {
    var layerType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fill';

    if (filter === null || filter === undefined) {
        return {
            filter: function filter() {
                return true;
            },
            needGeometry: false,
            needFeature: false
        };
    }
    if (!isExpressionFilter(filter)) {
        filter = convertFilter(filter);
    }
    var filterExp = filter;
    var staticFilter = true;
    try {
        staticFilter = extractStaticFilter(filterExp);
    } catch (e) {
        console.warn("Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n" + JSON.stringify(filterExp, null, 2) + "\n        ");
    }
    var filterSpec = v8["filter_" + layerType];
    var compiledStaticFilter = createExpression(staticFilter, filterSpec);
    var filterFunc = null;
    if (compiledStaticFilter.result === 'error') {
        throw new Error(compiledStaticFilter.value.map(function (err) {
            return err.key + ": " + err.message;
        }).join(', '));
    } else {
        filterFunc = function filterFunc(globalProperties, feature, canonical) {
            return compiledStaticFilter.value.evaluate(globalProperties, feature, {}, canonical);
        };
    }
    var dynamicFilterFunc = null;
    var needFeature = null;
    if (staticFilter !== filterExp) {
        var compiledDynamicFilter = createExpression(filterExp, filterSpec);
        if (compiledDynamicFilter.result === 'error') {
            throw new Error(compiledDynamicFilter.value.map(function (err) {
                return err.key + ": " + err.message;
            }).join(', '));
        } else {
            dynamicFilterFunc = function dynamicFilterFunc(globalProperties, feature, canonical, featureTileCoord, featureDistanceData) {
                return compiledDynamicFilter.value.evaluate(globalProperties, feature, {}, canonical, undefined, undefined, featureTileCoord, featureDistanceData);
            };
            needFeature = !isFeatureConstant(compiledDynamicFilter.value.expression);
        }
    }
    filterFunc = filterFunc;
    var needGeometry = geometryNeeded(staticFilter);
    return {
        filter: filterFunc,
        dynamicFilter: dynamicFilterFunc ? dynamicFilterFunc : undefined,
        needGeometry: needGeometry,
        needFeature: !!needFeature
    };
}
function extractStaticFilter(filter) {
    if (!isDynamicFilter(filter)) {
        return filter;
    }
    var result = deepUnbundle(filter);
    unionDynamicBranches(result);
    result = collapseDynamicBooleanExpressions(result);
    return result;
}
function collapseDynamicBooleanExpressions(expression) {
    if (!Array.isArray(expression)) {
        return expression;
    }
    var collapsed = collapsedExpression(expression);
    if (collapsed === true) {
        return collapsed;
    } else {
        return collapsed.map(function (subExpression) {
            return collapseDynamicBooleanExpressions(subExpression);
        });
    }
}
function unionDynamicBranches(filter) {
    var isBranchingDynamically = false;
    var branches = [];
    if (filter[0] === 'case') {
        for (var i = 1; i < filter.length - 1; i += 2) {
            isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[i]);
            branches.push(filter[i + 1]);
        }
        branches.push(filter[filter.length - 1]);
    } else if (filter[0] === 'match') {
        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);
        for (var _i5 = 2; _i5 < filter.length - 1; _i5 += 2) {
            branches.push(filter[_i5 + 1]);
        }
        branches.push(filter[filter.length - 1]);
    } else if (filter[0] === 'step') {
        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);
        for (var _i6 = 1; _i6 < filter.length - 1; _i6 += 2) {
            branches.push(filter[_i6 + 1]);
        }
    }
    if (isBranchingDynamically) {
        filter.length = 0;
        filter.push.apply(filter, ['any'].concat(branches));
    }
    for (var _i7 = 1; _i7 < filter.length; _i7++) {
        unionDynamicBranches(filter[_i7]);
    }
}
function isDynamicFilter(filter) {
    if (!Array.isArray(filter)) {
        return false;
    }
    if (isRootExpressionDynamic(filter[0])) {
        return true;
    }
    for (var i = 1; i < filter.length; i++) {
        var child = filter[i];
        if (isDynamicFilter(child)) {
            return true;
        }
    }
    return false;
}
function isRootExpressionDynamic(expression) {
    return expression === 'pitch' || expression === 'distance-from-center';
}
var dynamicConditionExpressions = new Set(['in', '==', '!=', '>', '>=', '<', '<=', 'to-boolean']);
function collapsedExpression(expression) {
    if (dynamicConditionExpressions.has(expression[0])) {
        for (var i = 1; i < expression.length; i++) {
            var param = expression[i];
            if (isDynamicFilter(param)) {
                return true;
            }
        }
    }
    return expression;
}
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function geometryNeeded(filter) {
    if (!Array.isArray(filter)) return false;
    if (filter[0] === 'within') return true;
    for (var index = 1; index < filter.length; index++) {
        if (geometryNeeded(filter[index])) return true;
    }
    return false;
}
function convertFilter(filter) {
    if (!filter) return true;
    var op = filter[0];
    if (filter.length <= 1) return op !== 'any';
    var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : op === 'within' ? filter : true;
    return converted;
}
function convertComparisonOp(property, value, op) {
    switch (property) {
        case '$type':
            return ["filter-type-" + op, value];
        case '$id':
            return ["filter-id-" + op, value];
        default:
            return ["filter-" + op, property, value];
    }
}
function convertDisjunctionOp(filters) {
    return ['any'].concat(filters.map(convertFilter));
}
function convertInOp(property, values) {
    if (values.length === 0) {
        return false;
    }
    switch (property) {
        case '$type':
            return ["filter-type-in", ['literal', values]];
        case '$id':
            return ["filter-id-in", ['literal', values]];
        default:
            if (values.length > 200 && !values.some(function (v) {
                return (typeof v === "undefined" ? "undefined" : _typeof(v)) !== _typeof(values[0]);
            })) {
                return ['filter-in-large', property, ['literal', values.sort(compare)]];
            } else {
                return ['filter-in-small', property, ['literal', values]];
            }
    }
}
function convertHasOp(property) {
    switch (property) {
        case '$type':
            return true;
        case '$id':
            return ["filter-has-id"];
        default:
            return ["filter-has", property];
    }
}
function convertNegation(filter) {
    return ['!', filter];
}

function convertFilter$1(filter) {
    return _convertFilter(filter, {});
}
function _convertFilter(filter, expectedTypes) {
    if (isExpressionFilter(filter)) {
        return filter;
    }
    if (!filter) return true;
    var op = filter[0];
    if (filter.length <= 1) return op !== 'any';
    var converted = void 0;
    if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {
        var _filter = _slicedToArray(filter, 3),
            property = _filter[1],
            value = _filter[2];

        converted = convertComparisonOp$1(property, value, op, expectedTypes);
    } else if (op === 'any') {
        var children = filter.slice(1).map(function (f) {
            var types = {};
            var child = _convertFilter(f, types);
            var typechecks = runtimeTypeChecks(types);
            return typechecks === true ? child : ['case', typechecks, child, false];
        });
        return ['any'].concat(children);
    } else if (op === 'all') {
        var _ref127;

        var _children = filter.slice(1).map(function (f) {
            return _convertFilter(f, expectedTypes);
        });
        return _children.length > 1 ? ['all'].concat(_children) : (_ref127 = []).concat.apply(_ref127, _toConsumableArray(_children));
    } else if (op === 'none') {
        return ['!', _convertFilter(['any'].concat(filter.slice(1)), {})];
    } else if (op === 'in') {
        converted = convertInOp$1(filter[1], filter.slice(2));
    } else if (op === '!in') {
        converted = convertInOp$1(filter[1], filter.slice(2), true);
    } else if (op === 'has') {
        converted = convertHasOp$1(filter[1]);
    } else if (op === '!has') {
        converted = ['!', convertHasOp$1(filter[1])];
    } else {
        converted = true;
    }
    return converted;
}
function runtimeTypeChecks(expectedTypes) {
    var conditions = [];
    for (var property in expectedTypes) {
        var _get = property === '$id' ? ['id'] : ['get', property];
        conditions.push(['==', ['typeof', _get], expectedTypes[property]]);
    }
    if (conditions.length === 0) return true;
    if (conditions.length === 1) return conditions[0];
    return ['all'].concat(conditions);
}
function convertComparisonOp$1(property, value, op, expectedTypes) {
    var get = void 0;
    if (property === '$type') {
        return [op, ['geometry-type'], value];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    if (expectedTypes && value !== null) {
        var type = typeof value === "undefined" ? "undefined" : _typeof(value);
        expectedTypes[property] = type;
    }
    if (op === '==' && property !== '$id' && value === null) {
        return ['all', ['has', property], ['==', get, null]];
    } else if (op === '!=' && property !== '$id' && value === null) {
        return ['any', ['!', ['has', property]], ['!=', get, null]];
    }
    return [op, get, value];
}
function convertInOp$1(property, values) {
    var negate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (values.length === 0) return negate;
    var get = void 0;
    if (property === '$type') {
        get = ['geometry-type'];
    } else if (property === '$id') {
        get = ['id'];
    } else {
        get = ['get', property];
    }
    var uniformTypes = true;
    var type = _typeof(values[0]);
    var _iteratorNormalCompletion52 = true;
    var _didIteratorError52 = false;
    var _iteratorError52 = undefined;

    try {
        for (var _iterator52 = values[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
            var value = _step52.value;

            if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== type) {
                uniformTypes = false;
                break;
            }
        }
    } catch (err) {
        _didIteratorError52 = true;
        _iteratorError52 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion52 && _iterator52.return) {
                _iterator52.return();
            }
        } finally {
            if (_didIteratorError52) {
                throw _iteratorError52;
            }
        }
    }

    if (uniformTypes && (type === 'string' || type === 'number')) {
        var uniqueValues = values.sort().filter(function (v, i) {
            return i === 0 || values[i - 1] !== v;
        });
        return ['match', get, uniqueValues, !negate, negate];
    }
    return [negate ? 'all' : 'any'].concat(values.map(function (v) {
        return [negate ? '!=' : '==', get, v];
    }));
}
function convertHasOp$1(property) {
    if (property === '$type') {
        return true;
    } else if (property === '$id') {
        return ['!=', ['id'], null];
    } else {
        return ['has', property];
    }
}

function migrateToExpressions(style) {
    var converted = [];
    eachLayer(style, function (layer) {
        if (layer.filter) {
            layer.filter = convertFilter$1(layer.filter);
        }
    });
    eachProperty(style, {
        paint: true,
        layout: true
    }, function (_ref128) {
        var path = _ref128.path,
            value = _ref128.value,
            reference = _ref128.reference,
            set = _ref128.set;

        if (isExpression(value)) return;
        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && !Array.isArray(value)) {
            set(convertFunction(value, reference));
            converted.push(path.join('.'));
        } else if (reference.tokens && typeof value === 'string') {
            set(convertTokenString(value));
        }
    });
    return style;
}

function migrate(style) {
    var migrated = false;
    if (style.version === 7) {
        style = migrateToV8(style);
        migrated = true;
    }
    if (style.version === 8) {
        migrated = migrateToExpressions(style);
        migrated = true;
    }
    if (!migrated) {
        throw new Error('cannot migrate from', style.version);
    }
    return style;
}

function composite(style) {
    var styleIDs = [];
    var sourceIDs = [];
    var compositedSourceLayers = [];
    for (var id in style.sources) {
        var _source = style.sources[id];
        if (_source.type !== 'vector') continue;
        var match = /^mapbox:\/\/(.*)/.exec(_source.url);
        if (!match) continue;
        styleIDs.push(id);
        sourceIDs.push(match[1]);
    }
    if (styleIDs.length < 2) return style;
    styleIDs.forEach(function (id) {
        delete style.sources[id];
    });
    var compositeID = sourceIDs.join(',');
    style.sources[compositeID] = {
        'type': 'vector',
        'url': "mapbox://" + compositeID
    };
    style.layers.forEach(function (layer) {
        if (styleIDs.indexOf(layer.source) >= 0) {
            layer.source = compositeID;
            if ('source-layer' in layer) {
                if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {
                    throw new Error('Conflicting source layer names');
                } else {
                    compositedSourceLayers.push(layer['source-layer']);
                }
            }
        }
    });
    return style;
}

var refProperties = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];

function deref(layer, parent) {
    var result = {};
    for (var k in layer) {
        if (k !== 'ref') {
            result[k] = layer[k];
        }
    }
    refProperties.forEach(function (k) {
        if (k in parent) {
            result[k] = parent[k];
        }
    });
    return result;
}
function derefLayers(layers) {
    layers = layers.slice();
    var map = Object.create(null);
    for (var i = 0; i < layers.length; i++) {
        map[layers[i].id] = layers[i];
    }
    for (var _i8 = 0; _i8 < layers.length; _i8++) {
        if ('ref' in layers[_i8]) {
            layers[_i8] = deref(layers[_i8], map[layers[_i8].ref]);
        }
    }
    return layers;
}

function deepEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) return false;
        for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) return false;
        }
        return true;
    }
    if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === 'object' && a !== null && b !== null) {
        if (!((typeof b === "undefined" ? "undefined" : _typeof(b)) === 'object')) return false;
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) return false;
        for (var key in a) {
            if (!deepEqual(a[key], b[key])) return false;
        }
        return true;
    }
    return a === b;
}

var operations = {
    setStyle: 'setStyle',
    addLayer: 'addLayer',
    removeLayer: 'removeLayer',
    setPaintProperty: 'setPaintProperty',
    setLayoutProperty: 'setLayoutProperty',
    setFilter: 'setFilter',
    addSource: 'addSource',
    removeSource: 'removeSource',
    setGeoJSONSourceData: 'setGeoJSONSourceData',
    setLayerZoomRange: 'setLayerZoomRange',
    setLayerProperty: 'setLayerProperty',
    setCenter: 'setCenter',
    setZoom: 'setZoom',
    setBearing: 'setBearing',
    setPitch: 'setPitch',
    setSprite: 'setSprite',
    setGlyphs: 'setGlyphs',
    setTransition: 'setTransition',
    setLight: 'setLight',
    setTerrain: 'setTerrain',
    setFog: 'setFog',
    setProjection: 'setProjection'
};
function addSource(sourceId, after, commands) {
    commands.push({
        command: operations.addSource,
        args: [sourceId, after[sourceId]]
    });
}
function removeSource(sourceId, commands, sourcesRemoved) {
    commands.push({
        command: operations.removeSource,
        args: [sourceId]
    });
    sourcesRemoved[sourceId] = true;
}
function updateSource(sourceId, after, commands, sourcesRemoved) {
    removeSource(sourceId, commands, sourcesRemoved);
    addSource(sourceId, after, commands);
}
function canUpdateGeoJSON(before, after, sourceId) {
    var prop = void 0;
    for (prop in before[sourceId]) {
        if (!before[sourceId].hasOwnProperty(prop)) continue;
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    for (prop in after[sourceId]) {
        if (!after[sourceId].hasOwnProperty(prop)) continue;
        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {
            return false;
        }
    }
    return true;
}
function diffSources(before, after, commands, sourcesRemoved) {
    before = before || {};
    after = after || {};
    var sourceId = void 0;
    for (sourceId in before) {
        if (!before.hasOwnProperty(sourceId)) continue;
        if (!after.hasOwnProperty(sourceId)) {
            removeSource(sourceId, commands, sourcesRemoved);
        }
    }
    for (sourceId in after) {
        if (!after.hasOwnProperty(sourceId)) continue;
        if (!before.hasOwnProperty(sourceId)) {
            addSource(sourceId, after, commands);
        } else if (!deepEqual(before[sourceId], after[sourceId])) {
            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {
                commands.push({
                    command: operations.setGeoJSONSourceData,
                    args: [sourceId, after[sourceId].data]
                });
            } else {
                updateSource(sourceId, after, commands, sourcesRemoved);
            }
        }
    }
}
function diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {
    before = before || {};
    after = after || {};
    var prop = void 0;
    for (prop in before) {
        if (!before.hasOwnProperty(prop)) continue;
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
    for (prop in after) {
        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) continue;
        if (!deepEqual(before[prop], after[prop])) {
            commands.push({
                command: command,
                args: [layerId, prop, after[prop], klass]
            });
        }
    }
}
function pluckId(layer) {
    return layer.id;
}
function indexById(group, layer) {
    group[layer.id] = layer;
    return group;
}
function diffLayers(before, after, commands) {
    before = before || [];
    after = after || [];
    var beforeOrder = before.map(pluckId);
    var afterOrder = after.map(pluckId);
    var beforeIndex = before.reduce(indexById, {});
    var afterIndex = after.reduce(indexById, {});
    var tracker = beforeOrder.slice();
    var clean = Object.create(null);
    var i = void 0,
        d = void 0,
        layerId = void 0,
        beforeLayer = void 0,
        afterLayer = void 0,
        insertBeforeLayerId = void 0,
        prop = void 0;
    for (i = 0, d = 0; i < beforeOrder.length; i++) {
        layerId = beforeOrder[i];
        if (!afterIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.indexOf(layerId, d), 1);
        } else {
            d++;
        }
    }
    for (i = 0, d = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[afterOrder.length - 1 - i];
        if (tracker[tracker.length - 1 - i] === layerId) continue;
        if (beforeIndex.hasOwnProperty(layerId)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);
        } else {
            d++;
        }
        insertBeforeLayerId = tracker[tracker.length - i];
        commands.push({
            command: operations.addLayer,
            args: [afterIndex[layerId], insertBeforeLayerId]
        });
        tracker.splice(tracker.length - i, 0, layerId);
        clean[layerId] = true;
    }
    for (i = 0; i < afterOrder.length; i++) {
        layerId = afterOrder[i];
        beforeLayer = beforeIndex[layerId];
        afterLayer = afterIndex[layerId];
        if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) continue;
        if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !deepEqual(beforeLayer.type, afterLayer.type)) {
            commands.push({
                command: operations.removeLayer,
                args: [layerId]
            });
            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];
            commands.push({
                command: operations.addLayer,
                args: [afterLayer, insertBeforeLayerId]
            });
            continue;
        }
        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);
        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);
        if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {
            commands.push({
                command: operations.setFilter,
                args: [layerId, afterLayer.filter]
            });
        }
        if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {
            commands.push({
                command: operations.setLayerZoomRange,
                args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]
            });
        }
        for (prop in beforeLayer) {
            if (!beforeLayer.hasOwnProperty(prop)) continue;
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
        for (prop in afterLayer) {
            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) continue;
            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;
            if (prop.indexOf('paint.') === 0) {
                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);
            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {
                commands.push({
                    command: operations.setLayerProperty,
                    args: [layerId, prop, afterLayer[prop]]
                });
            }
        }
    }
}
function diffStyles(before, after) {
    if (!before) return [{
        command: operations.setStyle,
        args: [after]
    }];
    var commands = [];
    try {
        if (!deepEqual(before.version, after.version)) {
            return [{
                command: operations.setStyle,
                args: [after]
            }];
        }
        if (!deepEqual(before.center, after.center)) {
            commands.push({
                command: operations.setCenter,
                args: [after.center]
            });
        }
        if (!deepEqual(before.zoom, after.zoom)) {
            commands.push({
                command: operations.setZoom,
                args: [after.zoom]
            });
        }
        if (!deepEqual(before.bearing, after.bearing)) {
            commands.push({
                command: operations.setBearing,
                args: [after.bearing]
            });
        }
        if (!deepEqual(before.pitch, after.pitch)) {
            commands.push({
                command: operations.setPitch,
                args: [after.pitch]
            });
        }
        if (!deepEqual(before.sprite, after.sprite)) {
            commands.push({
                command: operations.setSprite,
                args: [after.sprite]
            });
        }
        if (!deepEqual(before.glyphs, after.glyphs)) {
            commands.push({
                command: operations.setGlyphs,
                args: [after.glyphs]
            });
        }
        if (!deepEqual(before.transition, after.transition)) {
            commands.push({
                command: operations.setTransition,
                args: [after.transition]
            });
        }
        if (!deepEqual(before.light, after.light)) {
            commands.push({
                command: operations.setLight,
                args: [after.light]
            });
        }
        if (!deepEqual(before.fog, after.fog)) {
            commands.push({
                command: operations.setFog,
                args: [after.fog]
            });
        }
        if (!deepEqual(before.projection, after.projection)) {
            commands.push({
                command: operations.setProjection,
                args: [after.projection]
            });
        }
        var sourcesRemoved = {};
        var removeOrAddSourceCommands = [];
        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);
        var beforeLayers = [];
        if (before.layers) {
            before.layers.forEach(function (layer) {
                if (sourcesRemoved[layer.source]) {
                    commands.push({
                        command: operations.removeLayer,
                        args: [layer.id]
                    });
                } else {
                    beforeLayers.push(layer);
                }
            });
        }
        var beforeTerrain = before.terrain;
        if (beforeTerrain) {
            if (sourcesRemoved[beforeTerrain.source]) {
                commands.push({
                    command: operations.setTerrain,
                    args: [undefined]
                });
                beforeTerrain = undefined;
            }
        }
        commands = commands.concat(removeOrAddSourceCommands);
        if (!deepEqual(beforeTerrain, after.terrain)) {
            commands.push({
                command: operations.setTerrain,
                args: [after.terrain]
            });
        }
        diffLayers(beforeLayers, after.layers, commands);
    } catch (e) {
        console.warn('Unable to compute style diff:', e);
        commands = [{
            command: operations.setStyle,
            args: [after]
        }];
    }
    return commands;
}

var ValidationError = function ValidationError(key, value, message, identifier) {
    _classCallCheck(this, ValidationError);

    this.message = (key ? key + ": " : '') + message;
    if (identifier) this.identifier = identifier;
    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
};

var ParsingError$1 = function ParsingError$1(error) {
    _classCallCheck(this, ParsingError$1);

    this.error = error;
    this.message = error.message;
    var match = error.message.match(/line (\d+)/);
    this.line = match ? parseInt(match[1], 10) : 0;
};

function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    if (constants) {
        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
    } else {
        return [];
    }
}

function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var elementSpecs = options.valueSpec || {};
    var elementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];
    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, "object expected, " + type + " found")];
    }
    for (var objectKey in object) {
        var elementSpecKey = objectKey.split('.')[0];
        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];
        var validateElement = void 0;
        if (elementValidators[elementSpecKey]) {
            validateElement = elementValidators[elementSpecKey];
        } else if (elementSpecs[elementSpecKey]) {
            validateElement = validate;
        } else if (elementValidators['*']) {
            validateElement = elementValidators['*'];
        } else if (elementSpecs['*']) {
            validateElement = validate;
        } else {
            errors.push(new ValidationError(key, object[objectKey], "unknown property \"" + objectKey + "\""));
            continue;
        }
        errors = errors.concat(validateElement({
            key: (key ? key + "." : key) + objectKey,
            value: object[objectKey],
            valueSpec: elementSpec,
            style: style,
            styleSpec: styleSpec,
            object: object,
            objectKey: objectKey
        }, object));
    }
    for (var _elementSpecKey in elementSpecs) {
        if (elementValidators[_elementSpecKey]) {
            continue;
        }
        if (elementSpecs[_elementSpecKey].required && elementSpecs[_elementSpecKey]['default'] === undefined && object[_elementSpecKey] === undefined) {
            errors.push(new ValidationError(key, object, "missing required property \"" + _elementSpecKey + "\""));
        }
    }
    return errors;
}

function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;
    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, "array expected, " + getType(array) + " found")];
    }
    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, "array length " + arraySpec.length + " expected, length " + array.length + " found")];
    }
    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, "array length at least " + arraySpec['min-length'] + " expected, length " + array.length + " found")];
    }
    var arrayElementSpec = {
        'type': arraySpec.value,
        'values': arraySpec.values,
        'minimum': arraySpec.minimum,
        'maximum': arraySpec.maximum
    };
    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }
    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }
    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + "[" + i + "]"
        }));
    }
    return errors;
}

function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);
    if (type === 'number' && value !== value) {
        type = 'NaN';
    }
    if (type !== 'number') {
        return [new ValidationError(key, value, "number expected, " + type + " found")];
    }
    if ('minimum' in valueSpec) {
        var specMin = valueSpec.minimum;
        if (getType(valueSpec.minimum) === 'array') {
            var i = options.arrayIndex;
            specMin = valueSpec.minimum[i];
        }
        if (value < specMin) {
            return [new ValidationError(key, value, value + " is less than the minimum value " + specMin)];
        }
    }
    if ('maximum' in valueSpec) {
        var specMax = valueSpec.maximum;
        if (getType(valueSpec.maximum) === 'array') {
            var _i9 = options.arrayIndex;
            specMax = valueSpec.maximum[_i9];
        }
        if (value > specMax) {
            return [new ValidationError(key, value, value + " is greater than the maximum value " + specMax)];
        }
    }
    return [];
}

function validateFunction(options) {
    var functionValueSpec = options.valueSpec;
    var functionType = unbundle(options.value.type);
    var stopKeyType = void 0;
    var stopDomainValues = {};
    var previousStopDomainValue = void 0;
    var previousStopDomainZoom = void 0;
    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;
    var isPropertyFunction = !isZoomFunction;
    var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';
    var errors = validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            stops: validateFunctionStops,
            default: validateFunctionDefault
        }
    });
    if (functionType === 'identity' && isZoomFunction) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
    }
    if (functionType !== 'identity' && !options.value.stops) {
        errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
    }
    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));
    }
    if (options.styleSpec.$version >= 8) {
        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
        }
    }
    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {
        errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
    }
    return errors;
    function validateFunctionStops(options) {
        if (functionType === 'identity') {
            return [new ValidationError(options.key, options.value, 'identity function may not have a "stops" property')];
        }
        var errors = [];
        var value = options.value;
        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));
        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }
        return errors;
    }
    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;
        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, "array expected, " + getType(value) + " found")];
        }
        if (value.length !== 2) {
            return [new ValidationError(key, value, "array length 2 expected, length " + value.length + " found")];
        }
        if (isZoomAndPropertyFunction) {
            if (getType(value[0]) !== 'object') {
                return [new ValidationError(key, value, "object expected, " + getType(value[0]) + " found")];
            }
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];
            }
            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
                previousStopDomainZoom = unbundle(value[0].zoom);
                previousStopDomainValue = undefined;
                stopDomainValues = {};
            }
            errors = errors.concat(validateObject({
                key: key + "[0]",
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: {
                    zoom: validateNumber,
                    value: validateStopDomainValue
                }
            }));
        } else {
            errors = errors.concat(validateStopDomainValue({
                key: key + "[0]",
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }, value));
        }
        if (isExpression(deepUnbundle(value[1]))) {
            return errors.concat([new ValidationError(key + "[1]", value[1], 'expressions are not allowed in function stops.')]);
        }
        return errors.concat(validate({
            key: key + "[1]",
            value: value[1],
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));
    }
    function validateStopDomainValue(options, stop) {
        var type = getType(options.value);
        var value = unbundle(options.value);
        var reportValue = options.value !== null ? options.value : stop;
        if (!stopKeyType) {
            stopKeyType = type;
        } else if (type !== stopKeyType) {
            return [new ValidationError(options.key, reportValue, type + " stop domain type must match previous stop domain type " + stopKeyType)];
        }
        if (type !== 'number' && type !== 'string' && type !== 'boolean') {
            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];
        }
        if (type !== 'number' && functionType !== 'categorical') {
            var message = "number expected, " + type + " found";
            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {
                message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
            }
            return [new ValidationError(options.key, reportValue, message)];
        }
        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {
            return [new ValidationError(options.key, reportValue, "integer expected, found " + value)];
        }
        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];
        } else {
            previousStopDomainValue = value;
        }
        if (functionType === 'categorical' && value in stopDomainValues) {
            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];
        } else {
            stopDomainValues[value] = true;
        }
        return [];
    }
    function validateFunctionDefault(options) {
        return validate({
            key: options.key,
            value: options.value,
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        });
    }
}

function validateExpression(options) {
    var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);
    if (expression.result === 'error') {
        return expression.value.map(function (error) {
            return new ValidationError("" + options.key + error.key, options.value, error.message);
        });
    }
    var expressionObj = expression.value.expression || expression.value._styleExpression.expression;
    if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && !expressionObj.outputDefined()) {
        return [new ValidationError(options.key, options.value, "Invalid data expression for \"" + options.propertyKey + "\". Output values must be contained as literals within the expression.")];
    }
    if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {
        return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
    }
    if (options.expressionContext === 'filter') {
        return disallowedFilterParameters(expressionObj, options);
    }
    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {
        if (!isGlobalPropertyConstant(expressionObj, ['zoom', 'feature-state'])) {
            return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
        }
        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {
            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
        }
    }
    return [];
}
function disallowedFilterParameters(e, options) {
    var disallowedParameters = new Set(['zoom', 'feature-state', 'pitch', 'distance-from-center']);
    var _iteratorNormalCompletion53 = true;
    var _didIteratorError53 = false;
    var _iteratorError53 = undefined;

    try {
        for (var _iterator53 = options.valueSpec.expression.parameters[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
            var param = _step53.value;

            disallowedParameters.delete(param);
        }
    } catch (err) {
        _didIteratorError53 = true;
        _iteratorError53 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion53 && _iterator53.return) {
                _iterator53.return();
            }
        } finally {
            if (_didIteratorError53) {
                throw _iteratorError53;
            }
        }
    }

    if (disallowedParameters.size === 0) {
        return [];
    }
    var errors = [];
    if (e instanceof CompoundExpression) {
        if (disallowedParameters.has(e.name)) {
            return [new ValidationError(options.key, options.value, "[\"" + e.name + "\"] expression is not supported in a filter for a " + options.object.type + " layer with id: " + options.object.id)];
        }
    }
    e.eachChild(function (arg) {
        errors.push.apply(errors, _toConsumableArray(disallowedFilterParameters(arg, options)));
    });
    return errors;
}

function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'boolean') {
        return [new ValidationError(key, value, "boolean expected, " + type + " found")];
    }
    return [];
}

function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, "color expected, " + type + " found")];
    }
    if (csscolorparser.parseCSSColor(value) === null) {
        return [new ValidationError(key, value, "color expected, \"" + value + "\" found")];
    }
    return [];
}

function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];
    if (Array.isArray(valueSpec.values)) {
        if (valueSpec.values.indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, "expected one of [" + valueSpec.values.join(', ') + "], " + JSON.stringify(value) + " found"));
        }
    } else {
        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
            errors.push(new ValidationError(key, value, "expected one of [" + Object.keys(valueSpec.values).join(', ') + "], " + JSON.stringify(value) + " found"));
        }
    }
    return errors;
}

function validateFilter(options) {
    if (isExpressionFilter(deepUnbundle(options.value))) {
        var layerType = deepUnbundle(options.layerType);
        return validateExpression(extend({}, options, {
            expressionContext: 'filter',
            valueSpec: options.styleSpec["filter_" + (layerType || 'fill')]
        }));
    } else {
        return validateNonExpressionFilter(options);
    }
}
function validateNonExpressionFilter(options) {
    var value = options.value;
    var key = options.key;
    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, "array expected, " + getType(value) + " found")];
    }
    var styleSpec = options.styleSpec;
    var type = void 0;
    var errors = [];
    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }
    errors = errors.concat(validateEnum({
        key: key + "[0]",
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));
    switch (unbundle(value[0])) {
        case '<':
        case '<=':
        case '>':
        case '>=':
            if (value.length >= 2 && unbundle(value[1]) === '$type') {
                errors.push(new ValidationError(key, value, "\"$type\" cannot be use with operator \"" + value[0] + "\""));
            }
        case '==':
        case '!=':
            if (value.length !== 3) {
                errors.push(new ValidationError(key, value, "filter array for operator \"" + value[0] + "\" must have 3 elements"));
            }
        case 'in':
        case '!in':
            if (value.length >= 2) {
                type = getType(value[1]);
                if (type !== 'string') {
                    errors.push(new ValidationError(key + "[1]", value[1], "string expected, " + type + " found"));
                }
            }
            for (var i = 2; i < value.length; i++) {
                type = getType(value[i]);
                if (unbundle(value[1]) === '$type') {
                    errors = errors.concat(validateEnum({
                        key: key + "[" + i + "]",
                        value: value[i],
                        valueSpec: styleSpec.geometry_type,
                        style: options.style,
                        styleSpec: options.styleSpec
                    }));
                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                    errors.push(new ValidationError(key + "[" + i + "]", value[i], "string, number, or boolean expected, " + type + " found"));
                }
            }
            break;
        case 'any':
        case 'all':
        case 'none':
            for (var _i10 = 1; _i10 < value.length; _i10++) {
                errors = errors.concat(validateNonExpressionFilter({
                    key: key + "[" + _i10 + "]",
                    value: value[_i10],
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            }
            break;
        case 'has':
        case '!has':
            type = getType(value[1]);
            if (value.length !== 2) {
                errors.push(new ValidationError(key, value, "filter array for \"" + value[0] + "\" operator must have 2 elements"));
            } else if (type !== 'string') {
                errors.push(new ValidationError(key + "[1]", value[1], "string expected, " + type + " found"));
            }
            break;
        case 'within':
            type = getType(value[1]);
            if (value.length !== 2) {
                errors.push(new ValidationError(key, value, "filter array for \"" + value[0] + "\" operator must have 2 elements"));
            } else if (type !== 'object') {
                errors.push(new ValidationError(key + "[1]", value[1], "object expected, " + type + " found"));
            }
            break;
    }
    return errors;
}

function validateProperty(options, propertyType) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec[propertyType + "_" + options.layerType];
    if (!layerSpec) return [];
    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });
    }
    var valueSpec = options.valueSpec || layerSpec[propertyKey];
    if (!valueSpec) {
        return [new ValidationError(key, value, "unknown property \"" + propertyKey + "\"")];
    }
    var tokenMatch = void 0;
    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
        return [new ValidationError(key, value, "\"" + propertyKey + "\" does not support interpolation syntax\n" + ("Use an identity property function instead: `{ \"type\": \"identity\", \"property\": " + JSON.stringify(tokenMatch[1]) + " }`."))];
    }
    var errors = [];
    if (options.layerType === 'symbol') {
        if (propertyKey === 'text-field' && style && !style.glyphs) {
            errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
        }
        if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {
            errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
        }
    }
    return errors.concat(validate({
        key: options.key,
        value: value,
        valueSpec: valueSpec,
        style: style,
        styleSpec: styleSpec,
        expressionContext: 'property',
        propertyType: propertyType,
        propertyKey: propertyKey
    }));
}

function validatePaintProperty(options) {
    return validateProperty(options, 'paint');
}

function validateLayoutProperty(options) {
    return validateProperty(options, 'layout');
}

function validateLayer(options) {
    var errors = [];
    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);
    if (layer.id) {
        var layerId = unbundle(layer.id);
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === layerId) {
                errors.push(new ValidationError(key, layer.id, "duplicate layer id \"" + layer.id + "\", previously used at line " + otherLayer.id.__line__));
            }
        }
    }
    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], "\"" + p + "\" is prohibited for ref layers"));
            }
        });
        var parent = void 0;
        style.layers.forEach(function (layer) {
            if (unbundle(layer.id) === ref) parent = layer;
        });
        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, "ref layer \"" + ref + "\" not found"));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (!(type === 'background' || type === 'sky')) {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var _source2 = style.sources && style.sources[layer.source];
            var sourceType = _source2 && unbundle(_source2.type);
            if (!_source2) {
                errors.push(new ValidationError(key, layer.source, "source \"" + layer.source + "\" not found"));
            } else if (sourceType === 'vector' && type === 'raster') {
                errors.push(new ValidationError(key, layer.source, "layer \"" + layer.id + "\" requires a raster source"));
            } else if (sourceType === 'raster' && type !== 'raster') {
                errors.push(new ValidationError(key, layer.source, "layer \"" + layer.id + "\" requires a vector source"));
            } else if (sourceType === 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, "layer \"" + layer.id + "\" must specify a \"source-layer\""));
            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {
                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \'hillshade\'.'));
            } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !_source2.lineMetrics)) {
                errors.push(new ValidationError(key, layer, "layer \"" + layer.id + "\" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled."));
            }
        }
    }
    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            '*': function _() {
                return [];
            },
            type: function type() {
                return validate({
                    key: key + ".type",
                    value: layer.type,
                    valueSpec: styleSpec.layer.type,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    object: layer,
                    objectKey: 'type'
                });
            },
            filter: function filter(options) {
                return validateFilter(extend({ layerType: type }, options));
            },
            layout: function layout(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validateLayoutProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            },
            paint: function paint(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function _(options) {
                            return validatePaintProperty(extend({ layerType: type }, options));
                        }
                    }
                });
            }
        }
    }));
    return errors;
}

function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);
    if (type !== 'string') {
        return [new ValidationError(key, value, "string expected, " + type + " found")];
    }
    return [];
}

var objectElementValidators = { promoteId: validatePromoteId };
function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;
    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }
    var type = unbundle(value.type);
    var errors = void 0;
    switch (type) {
        case 'vector':
        case 'raster':
        case 'raster-dem':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec["source_" + type.replace('-', '_')],
                style: options.style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            return errors;
        case 'geojson':
            errors = validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_geojson,
                style: style,
                styleSpec: styleSpec,
                objectElementValidators: objectElementValidators
            });
            if (value.cluster) {
                for (var prop in value.clusterProperties) {
                    var _errors, _errors2;

                    var _value$clusterPropert = _slicedToArray(value.clusterProperties[prop], 2),
                        operator = _value$clusterPropert[0],
                        mapExpr = _value$clusterPropert[1];

                    var reduceExpr = typeof operator === 'string' ? [operator, ['accumulated'], ['get', prop]] : operator;
                    (_errors = errors).push.apply(_errors, _toConsumableArray(validateExpression({
                        key: key + "." + prop + ".map",
                        value: mapExpr,
                        expressionContext: 'cluster-map'
                    })));
                    (_errors2 = errors).push.apply(_errors2, _toConsumableArray(validateExpression({
                        key: key + "." + prop + ".reduce",
                        value: reduceExpr,
                        expressionContext: 'cluster-reduce'
                    })));
                }
            }
            return errors;
        case 'video':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_video,
                style: style,
                styleSpec: styleSpec
            });
        case 'image':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_image,
                style: style,
                styleSpec: styleSpec
            });
        case 'canvas':
            return [new ValidationError(key, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", 'source.canvas')];
        default:
            return validateEnum({
                key: key + ".type",
                value: value.type,
                valueSpec: {
                    values: ['vector', 'raster', 'raster-dem', 'geojson', 'video', 'image']
                },
                style: style,
                styleSpec: styleSpec
            });
    }
}
function validatePromoteId(_ref129) {
    var key = _ref129.key,
        value = _ref129.value;

    if (getType(value) === 'string') {
        return validateString({
            key: key,
            value: value
        });
    } else {
        var errors = [];
        for (var prop in value) {
            errors.push.apply(errors, _toConsumableArray(validateString({
                key: key + "." + prop,
                value: value[prop]
            })));
        }
        return errors;
    }
}

function validateLight(options) {
    var light = options.value;
    var styleSpec = options.styleSpec;
    var lightSpec = styleSpec.light;
    var style = options.style;
    var errors = [];
    var rootType = getType(light);
    if (light === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('light', light, "object expected, " + rootType + " found")]);
        return errors;
    }
    for (var key in light) {
        var transitionMatch = key.match(/^(.*)-transition$/);
        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (lightSpec[key]) {
            errors = errors.concat(validate({
                key: key,
                value: light[key],
                valueSpec: lightSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(key, light[key], "unknown property \"" + key + "\"")]);
        }
    }
    return errors;
}

function validateTerrain(options) {
    var terrain = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var terrainSpec = styleSpec.terrain;
    var errors = [];
    var rootType = getType(terrain);
    if (terrain === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('terrain', terrain, "object expected, " + rootType + " found")]);
        return errors;
    }
    for (var _key6 in terrain) {
        var transitionMatch = _key6.match(/^(.*)-transition$/);
        if (transitionMatch && terrainSpec[transitionMatch[1]] && terrainSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: _key6,
                value: terrain[_key6],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (terrainSpec[_key6]) {
            errors = errors.concat(validate({
                key: _key6,
                value: terrain[_key6],
                valueSpec: terrainSpec[_key6],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(_key6, terrain[_key6], "unknown property \"" + _key6 + "\"")]);
        }
    }
    if (!terrain.source) {
        errors.push(new ValidationError(key, terrain, "terrain is missing required property \"source\""));
    } else {
        var _source3 = style.sources && style.sources[terrain.source];
        var sourceType = _source3 && unbundle(_source3.type);
        if (!_source3) {
            errors.push(new ValidationError(key, terrain.source, "source \"" + terrain.source + "\" not found"));
        } else if (sourceType !== 'raster-dem') {
            errors.push(new ValidationError(key, terrain.source, "terrain cannot be used with a source of type " + sourceType + ", it only be used with a \"raster-dem\" source type"));
        }
    }
    return errors;
}

function validateFog(options) {
    var fog = options.value;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var fogSpec = styleSpec.fog;
    var errors = [];
    var rootType = getType(fog);
    if (fog === undefined) {
        return errors;
    } else if (rootType !== 'object') {
        errors = errors.concat([new ValidationError('fog', fog, "object expected, " + rootType + " found")]);
        return errors;
    }
    for (var key in fog) {
        var transitionMatch = key.match(/^(.*)-transition$/);
        if (transitionMatch && fogSpec[transitionMatch[1]] && fogSpec[transitionMatch[1]].transition) {
            errors = errors.concat(validate({
                key: key,
                value: fog[key],
                valueSpec: styleSpec.transition,
                style: style,
                styleSpec: styleSpec
            }));
        } else if (fogSpec[key]) {
            errors = errors.concat(validate({
                key: key,
                value: fog[key],
                valueSpec: fogSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        } else {
            errors = errors.concat([new ValidationError(key, fog[key], "unknown property \"" + key + "\"")]);
        }
    }
    return errors;
}

function validateFormatted(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

function validateImage(options) {
    if (validateString(options).length === 0) {
        return [];
    }
    return validateExpression(options);
}

function validateProjection(options) {
    var projection = options.value;
    var styleSpec = options.styleSpec;
    var projectionSpec = styleSpec.projection;
    var style = options.style;
    var errors = [];
    var rootType = getType(projection);
    if (rootType === 'object') {
        for (var key in projection) {
            errors = errors.concat(validate({
                key: key,
                value: projection[key],
                valueSpec: projectionSpec[key],
                style: style,
                styleSpec: styleSpec
            }));
        }
    } else if (rootType !== 'string') {
        errors = errors.concat([new ValidationError('projection', projection, "object or string expected, " + rootType + " found")]);
    }
    return errors;
}

var VALIDATORS = {
    '*': function _() {
        return [];
    },

    'array': validateArray,
    'boolean': validateBoolean,
    'number': validateNumber,
    'color': validateColor,
    'constants': validateConstants,
    'enum': validateEnum,
    'filter': validateFilter,
    'function': validateFunction,
    'layer': validateLayer,
    'object': validateObject,
    'source': validateSource,
    'light': validateLight,
    'terrain': validateTerrain,
    'fog': validateFog,
    'string': validateString,
    'formatted': validateFormatted,
    'resolvedImage': validateImage,
    'projection': validateProjection
};
function validate(options) {
    var value = options.value;
    var valueSpec = options.valueSpec;
    var styleSpec = options.styleSpec;
    if (valueSpec.expression && isFunction$1(unbundle(value))) {
        return validateFunction(options);
    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
        return validateExpression(options);
    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);
    } else {
        var valid = validateObject(extend({}, options, { valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec }));
        return valid;
    }
}

function validateGlyphsURL(options) {
    var value = options.value;
    var key = options.key;
    var errors = validateString(options);
    if (errors.length) return errors;
    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }
    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }
    return errors;
}

function validateStyleMin(style) {
    var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;

    var errors = [];
    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL,
            '*': function _() {
                return [];
            }
        }
    }));
    if (style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }
    return sortErrors(errors);
}
validateStyleMin.source = wrapCleanErrors(validateSource);
validateStyleMin.light = wrapCleanErrors(validateLight);
validateStyleMin.terrain = wrapCleanErrors(validateTerrain);
validateStyleMin.fog = wrapCleanErrors(validateFog);
validateStyleMin.layer = wrapCleanErrors(validateLayer);
validateStyleMin.filter = wrapCleanErrors(validateFilter);
validateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);
validateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);
function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}
function wrapCleanErrors(inner) {
    return function () {
        for (var _len4 = arguments.length, args = Array(_len4), _key7 = 0; _key7 < _len4; _key7++) {
            args[_key7] = arguments[_key7];
        }

        return sortErrors(inner.apply(this, args));
    };
}

/* parser generated by jison 0.4.15 */

var jsonlint = createCommonjsModule(function (module, exports) {
    /*
      Returns a Parser object of the following structure:
    
      Parser: {
        yy: {}
      }
    
      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),
    
        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),
    
            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },
    
            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }
    
    
      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }
    
    
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = function () {
        var o = function o(k, v, _o, l) {
            for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
        },
            $V0 = [1, 12],
            $V1 = [1, 13],
            $V2 = [1, 9],
            $V3 = [1, 10],
            $V4 = [1, 11],
            $V5 = [1, 14],
            $V6 = [1, 15],
            $V7 = [14, 18, 22, 24],
            $V8 = [18, 22],
            $V9 = [22, 24];
        var parser = { trace: function trace() {},
            yy: {},
            symbols_: { "error": 2, "JSONString": 3, "STRING": 4, "JSONNumber": 5, "NUMBER": 6, "JSONNullLiteral": 7, "NULL": 8, "JSONBooleanLiteral": 9, "TRUE": 10, "FALSE": 11, "JSONText": 12, "JSONValue": 13, "EOF": 14, "JSONObject": 15, "JSONArray": 16, "{": 17, "}": 18, "JSONMemberList": 19, "JSONMember": 20, ":": 21, ",": 22, "[": 23, "]": 24, "JSONElementList": 25, "$accept": 0, "$end": 1 },
            terminals_: { 2: "error", 4: "STRING", 6: "NUMBER", 8: "NULL", 10: "TRUE", 11: "FALSE", 14: "EOF", 17: "{", 18: "}", 21: ":", 22: ",", 23: "[", 24: "]" },
            productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
                /* this == yyval */

                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        // replace escaped characters with actual character
                        this.$ = new String(yytext.replace(/\\(\\|")/g, "$" + "1").replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\v/g, '\v').replace(/\\f/g, '\f').replace(/\\b/g, '\b'));
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 2:

                        this.$ = new Number(yytext);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 3:

                        this.$ = null;

                        break;
                    case 4:

                        this.$ = new Boolean(true);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 5:

                        this.$ = new Boolean(false);
                        this.$.__line__ = this._$.first_line;

                        break;
                    case 6:
                        return this.$ = $$[$0 - 1];
                    case 13:
                        this.$ = {};Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 14:case 19:
                        this.$ = $$[$0 - 1];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 15:
                        this.$ = [$$[$0 - 2], $$[$0]];
                        break;
                    case 16:
                        this.$ = {};this.$[$$[$0][0]] = $$[$0][1];
                        break;
                    case 17:
                        this.$ = $$[$0 - 2];$$[$0 - 2][$$[$0][0]] = $$[$0][1];
                        break;
                    case 18:
                        this.$ = [];Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: false
                        });
                        break;
                    case 20:
                        this.$ = [$$[$0]];
                        break;
                    case 21:
                        this.$ = $$[$0 - 2];$$[$0 - 2].push($$[$0]);
                        break;
                }
            },
            table: [{ 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 12: 1, 13: 2, 15: 7, 16: 8, 17: $V5, 23: $V6 }, { 1: [3] }, { 14: [1, 16] }, o($V7, [2, 7]), o($V7, [2, 8]), o($V7, [2, 9]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), o($V7, [2, 3]), o($V7, [2, 4]), o($V7, [2, 5]), o([14, 18, 21, 22, 24], [2, 1]), o($V7, [2, 2]), { 3: 20, 4: $V0, 18: [1, 17], 19: 18, 20: 19 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 23, 15: 7, 16: 8, 17: $V5, 23: $V6, 24: [1, 21], 25: 22 }, { 1: [2, 6] }, o($V7, [2, 13]), { 18: [1, 24], 22: [1, 25] }, o($V8, [2, 16]), { 21: [1, 26] }, o($V7, [2, 18]), { 22: [1, 28], 24: [1, 27] }, o($V9, [2, 20]), o($V7, [2, 14]), { 3: 20, 4: $V0, 20: 29 }, { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 30, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V7, [2, 19]), { 3: 5, 4: $V0, 5: 6, 6: $V1, 7: 3, 8: $V2, 9: 4, 10: $V3, 11: $V4, 13: 31, 15: 7, 16: 8, 17: $V5, 23: $V6 }, o($V8, [2, 17]), o($V8, [2, 15]), o($V9, [2, 21])],
            defaultActions: { 16: [2, 6] },
            parseError: function parseError(str, hash) {
                if (hash.recoverable) {
                    this.trace(str);
                } else {
                    throw new Error(str);
                }
            },
            parse: function parse(input) {
                var self = this,
                    stack = [0],
                    vstack = [null],
                    lstack = [],
                    table = this.table,
                    yytext = '',
                    yylineno = 0,
                    yyleng = 0,
                    TERROR = 2,
                    EOF = 1;
                var args = lstack.slice.call(arguments, 1);
                var lexer = Object.create(this.lexer);
                var sharedState = { yy: {} };
                for (var k in this.yy) {
                    if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                        sharedState.yy[k] = this.yy[k];
                    }
                }
                lexer.setInput(input, sharedState.yy);
                sharedState.yy.lexer = lexer;
                sharedState.yy.parser = this;
                if (typeof lexer.yylloc == 'undefined') {
                    lexer.yylloc = {};
                }
                var yyloc = lexer.yylloc;
                lstack.push(yyloc);
                var ranges = lexer.options && lexer.options.ranges;
                if (typeof sharedState.yy.parseError === 'function') {
                    this.parseError = sharedState.yy.parseError;
                } else {
                    this.parseError = Object.getPrototypeOf(this).parseError;
                }

                function lex() {
                    var token;
                    token = lexer.lex() || EOF;
                    if (typeof token !== 'number') {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol,
                    state,
                    action,
                    r,
                    yyval = {},
                    p,
                    len,
                    newState,
                    expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == 'undefined') {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                        var errStr = '';
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push('\'' + this.terminals_[p] + '\'');
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(lexer.yytext);
                            lstack.push(lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            {
                                yyleng = lexer.yyleng;
                                yytext = lexer.yytext;
                                yylineno = lexer.yylineno;
                                yyloc = lexer.yylloc;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {
                                first_line: lstack[lstack.length - (len || 1)].first_line,
                                last_line: lstack[lstack.length - 1].last_line,
                                first_column: lstack[lstack.length - (len || 1)].first_column,
                                last_column: lstack[lstack.length - 1].last_column
                            };
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                            if (typeof r !== 'undefined') {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            } };
        /* generated by jison-lex 0.3.4 */
        var lexer = function () {
            var lexer = {

                EOF: 1,

                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },

                // resets the lexer, sets new input
                setInput: function setInput(input, yy) {
                    this.yy = yy || this.yy || {};
                    this._input = input;
                    this._more = this._backtrack = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = {
                        first_line: 1,
                        first_column: 0,
                        last_line: 1,
                        last_column: 0
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [0, 0];
                    }
                    this.offset = 0;
                    return this;
                },

                // consumes and returns one char from the input
                input: function input() {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) {
                        this.yylloc.range[1]++;
                    }

                    this._input = this._input.slice(1);
                    return ch;
                },

                // unshifts one char (or a string) into the input
                unput: function unput(ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);

                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);

                    if (lines.length - 1) {
                        this.yylineno -= lines.length - 1;
                    }
                    var r = this.yylloc.range;

                    this.yylloc = {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                    };

                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    this.yyleng = this.yytext.length;
                    return this;
                },

                // When called from action, caches matched text and appends it on next action
                more: function more() {
                    this._more = true;
                    return this;
                },

                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function reject() {
                    if (this.options.backtrack_lexer) {
                        this._backtrack = true;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                    return this;
                },

                // retain first n characters of the match
                less: function less(n) {
                    this.unput(this.match.slice(n));
                },

                // displays already matched input, i.e. for error messages
                pastInput: function pastInput() {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },

                // displays upcoming input, i.e. for error messages
                upcomingInput: function upcomingInput() {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },

                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function showPosition() {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },

                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function test_match(match, indexed_rule) {
                    var token, lines, backup;

                    if (this.options.backtrack_lexer) {
                        // save context
                        backup = {
                            yylineno: this.yylineno,
                            yylloc: {
                                first_line: this.yylloc.first_line,
                                last_line: this.last_line,
                                first_column: this.yylloc.first_column,
                                last_column: this.yylloc.last_column
                            },
                            yytext: this.yytext,
                            match: this.match,
                            matches: this.matches,
                            matched: this.matched,
                            yyleng: this.yyleng,
                            offset: this.offset,
                            _more: this._more,
                            _input: this._input,
                            yy: this.yy,
                            conditionStack: this.conditionStack.slice(0),
                            done: this.done
                        };
                        if (this.options.ranges) {
                            backup.yylloc.range = this.yylloc.range.slice(0);
                        }
                    }

                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno += lines.length;
                    }
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._backtrack = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) {
                        this.done = false;
                    }
                    if (token) {
                        return token;
                    } else if (this._backtrack) {
                        // recover context
                        for (var k in backup) {
                            this[k] = backup[k];
                        }
                        return false; // rule action called reject() implying the next rule should be tested instead.
                    }
                    return false;
                },

                // return next match in input
                next: function next() {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) {
                        this.done = true;
                    }

                    var token, match, tempMatch, index;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (this.options.backtrack_lexer) {
                                token = this.test_match(tempMatch, rules[i]);
                                if (token !== false) {
                                    return token;
                                } else if (this._backtrack) {
                                    match = false;
                                    continue; // rule action called reject() implying a rule MISmatch.
                                } else {
                                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                    return false;
                                }
                            } else if (!this.options.flex) {
                                break;
                            }
                        }
                    }
                    if (match) {
                        token = this.test_match(match, rules[index]);
                        if (token !== false) {
                            return token;
                        }
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                },

                // return next match that has a token
                lex: function lex() {
                    var r = this.next();
                    if (r) {
                        return r;
                    } else {
                        return this.lex();
                    }
                },

                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },

                // pop the previously active lexer condition state off the condition stack
                popState: function popState() {
                    var n = this.conditionStack.length - 1;
                    if (n > 0) {
                        return this.conditionStack.pop();
                    } else {
                        return this.conditionStack[0];
                    }
                },

                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function _currentRules() {
                    if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    } else {
                        return this.conditions["INITIAL"].rules;
                    }
                },

                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function topState(n) {
                    n = this.conditionStack.length - 1 - Math.abs(n || 0);
                    if (n >= 0) {
                        return this.conditionStack[n];
                    } else {
                        return "INITIAL";
                    }
                },

                // alias for begin(condition)
                pushState: function pushState(condition) {
                    this.begin(condition);
                },

                // return the number of states currently on the stack
                stateStackSize: function stateStackSize() {
                    return this.conditionStack.length;
                },
                options: {},
                performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    switch ($avoiding_name_collisions) {
                        case 0:
                            /* skip whitespace */
                            break;
                        case 1:
                            return 6;
                        case 2:
                            yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);return 4;
                        case 3:
                            return 17;
                        case 4:
                            return 18;
                        case 5:
                            return 23;
                        case 6:
                            return 24;
                        case 7:
                            return 22;
                        case 8:
                            return 21;
                        case 9:
                            return 10;
                        case 10:
                            return 11;
                        case 11:
                            return 8;
                        case 12:
                            return 14;
                        case 13:
                            return 'INVALID';
                    }
                },
                rules: [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/],
                conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "inclusive": true } }
            };
            return lexer;
        }();
        parser.lexer = lexer;
        function Parser() {
            this.yy = {};
        }
        Parser.prototype = parser;parser.Parser = Parser;
        return new Parser();
    }();

    if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
        exports.parser = parser;
        exports.Parser = parser.Parser;
        exports.parse = function () {
            return parser.parse.apply(parser, arguments);
        };
    }
});

function readStyle(style) {
    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {
        try {
            return jsonlint.parse(style.toString());
        } catch (e) {
            throw new ParsingError$1(e);
        }
    }
    return style;
}

function validateStyle(style) {
    var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;

    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    return validateStyleMin(s, styleSpec);
}

var SUPPORTED_SPEC_VERSION = 8;
var MAX_SOURCES_IN_STYLE = 15;
function isValid(value, regex) {
    if (!value || getType(value) !== 'string') return true;
    return !!value.match(regex);
}
function getSourceCount(source) {
    if (source.url) {
        return source.url.split(',').length;
    } else {
        return 0;
    }
}
function getAllowedKeyErrors(obj, keys, path) {
    var allowed = new Set(keys);
    var errors = [];
    Object.keys(obj).forEach(function (k) {
        if (!allowed.has(k)) {
            var prop = path ? path + "." + k : null;
            errors.push(new ValidationError(prop, obj[k], "Unsupported property \"" + k + "\""));
        }
    });
    return errors;
}
var acceptedSourceTypes = new Set(['vector', 'raster', 'raster-dem']);
function getSourceErrors(source, i) {
    var errors = [];
    var sourceKeys = ['type', 'url', 'tileSize'];
    errors.push.apply(errors, _toConsumableArray(getAllowedKeyErrors(source, sourceKeys, 'source')));
    if (!acceptedSourceTypes.has(String(source.type))) {
        errors.push(new ValidationError("sources[" + i + "].type", source.type, "Expected one of [" + Array.from(acceptedSourceTypes).join(', ') + "]"));
    }
    var sourceUrlPattern = /^mapbox:\/\/([^/]*)$/;
    if (!source.url || !isValid(source.url, sourceUrlPattern)) {
        errors.push(new ValidationError("sources[" + i + "].url", source.url, 'Expected a valid Mapbox tileset url'));
    }
    return errors;
}
function getSourcesErrors(sources) {
    var errors = [];
    var count = 0;
    Object.keys(sources).forEach(function (s, i) {
        var sourceErrors = getSourceErrors(sources[s], i);
        if (!sourceErrors.length) {
            count = count + getSourceCount(sources[s]);
        }
        errors.push.apply(errors, _toConsumableArray(sourceErrors));
    });
    if (count > MAX_SOURCES_IN_STYLE) {
        errors.push(new ValidationError('sources', null, "Styles must contain " + MAX_SOURCES_IN_STYLE + " or fewer sources"));
    }
    return errors;
}
function getRootErrors(style, specKeys) {
    var errors = [];
    var optionalRootProperties = ['owner', 'id', 'cacheControl', 'draft', 'created', 'modified', 'visibility', 'protected'];
    var allowedKeyErrors = getAllowedKeyErrors(style, [].concat(_toConsumableArray(specKeys), optionalRootProperties));
    errors.push.apply(errors, _toConsumableArray(allowedKeyErrors));
    if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {
        errors.push(new ValidationError('version', style.version, "Style version must be " + SUPPORTED_SPEC_VERSION));
    }
    var glyphUrlPattern = /^mapbox:\/\/fonts\/([^/]*)\/{fontstack}\/{range}.pbf$/;
    if (!isValid(style.glyphs, glyphUrlPattern)) {
        errors.push(new ValidationError('glyphs', style.glyphs, 'Styles must reference glyphs hosted by Mapbox'));
    }
    var spriteUrlPattern = /^mapbox:\/\/sprites\/([^/]*)\/([^/]*)\/?([^/]*)?$/;
    if (!isValid(style.sprite, spriteUrlPattern)) {
        errors.push(new ValidationError('sprite', style.sprite, 'Styles must reference sprites hosted by Mapbox'));
    }
    var visibilityPattern = /^(public|private)$/;
    if (!isValid(style.visibility, visibilityPattern)) {
        errors.push(new ValidationError('visibility', style.visibility, 'Style visibility must be public or private'));
    }
    if (style.protected !== undefined && getType(style.protected) !== 'boolean') {
        errors.push(new ValidationError('protected', style.protected, 'Style protection must be true or false'));
    }
    return errors;
}
function validateMapboxApiSupported(style) {
    var s = style;
    try {
        s = readStyle(s);
    } catch (e) {
        return [e];
    }
    var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));
    if (s.sources) {
        errors = errors.concat(getSourcesErrors(s.sources));
    }
    return errors;
}

var expression$1 = {
    StyleExpression: StyleExpression,
    isExpression: isExpression,
    isExpressionFilter: isExpressionFilter,
    createExpression: createExpression,
    createPropertyExpression: createPropertyExpression,
    normalizePropertyExpression: normalizePropertyExpression,
    ZoomConstantExpression: ZoomConstantExpression,
    ZoomDependentExpression: ZoomDependentExpression,
    StylePropertyFunction: StylePropertyFunction
};
var styleFunction = {
    convertFunction: convertFunction,
    createFunction: createFunction,
    isFunction: isFunction$1
};
var visit = {
    eachSource: eachSource,
    eachLayer: eachLayer,
    eachProperty: eachProperty
};
validateStyle.parsed = validateStyle;
validateStyle.latest = validateStyle;

exports.Color = Color;
exports.ParsingError = ParsingError$1;
exports.ValidationError = ValidationError;
exports.composite = composite;
exports.convertFilter = convertFilter$1;
exports.derefLayers = derefLayers;
exports.diff = diffStyles;
exports.expression = expression$1;
exports.featureFilter = createFilter;
exports.format = format;
exports.function = styleFunction;
exports.latest = v8;
exports.migrate = migrate;
exports.v8 = v8;
exports.validate = validateStyle;
exports.validateMapboxApiSupported = validateMapboxApiSupported;
exports.visit = visit;
//# sourceMappingURL=index.es.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/mapbox-to-css-font/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mapbox-to-css-font/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fontWeights = {
  thin: 100,
  hairline: 100,
  'ultra-light': 100,
  'extra-light': 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  'semi-bold': 600,
  'demi-bold': 600,
  bold: 700,
  heavy: 800,
  black: 800,
  'extra-bold': 800,
  'ultra-black': 900,
  'extra-black': 900,
  'ultra-bold': 900,
  'heavy-black': 900,
  fat: 900,
  poster: 900
};
var sp = ' ';
var italicRE = /(italic|oblique)$/i;

var fontCache = {};

module.exports = function (fonts, size, lineHeight) {
  var cssData = fontCache[fonts];
  if (!cssData) {
    if (!Array.isArray(fonts)) {
      fonts = [fonts];
    }
    var weight = 400;
    var style = 'normal';
    var fontFamilies = [];
    var haveWeight, haveStyle;
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      var parts = font.split(' ');
      var maybeWeight = parts[parts.length - 1].toLowerCase();
      if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {
        style = haveStyle ? style : maybeWeight;
        parts.pop();
        maybeWeight = parts[parts.length - 1].toLowerCase();
      } else if (italicRE.test(maybeWeight)) {
        maybeWeight = maybeWeight.replace(italicRE, '');
        style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, '');
      }
      for (var w in fontWeights) {
        if (maybeWeight == w || maybeWeight == w.replace('-', '') || maybeWeight == w.replace('-', sp)) {
          weight = haveWeight ? weight : fontWeights[w];
          parts.pop();
          break;
        }
      }
      if (!haveWeight && typeof maybeWeight == 'number') {
        weight = maybeWeight;
      }
      var fontFamily = parts.join(sp).replace('Klokantech Noto Sans', 'Noto Sans');
      if (fontFamily.indexOf(sp) !== -1) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies.push(fontFamily);
    }
    // CSS font property: font-style font-weight font-size/line-height font-family
    cssData = fontCache[fonts] = [style, weight, fontFamilies];
  }
  return cssData[0] + sp + cssData[1] + sp + size + 'px' + (lineHeight ? '/' + lineHeight : '') + sp + cssData[2];
};

/***/ }),

/***/ "./node_modules/ol/AssertionError.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/AssertionError.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @param {number} code Error code.
 */
var AssertionError = function AssertionError(code) {

  var path = _index.VERSION ? _index.VERSION.split('-')[0] : 'latest';

  /**
   * @type {string}
   */
  this.message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';

  /**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */
  this.code = code;

  this.name = 'AssertionError';
}; /**
    * @module ol/AssertionError
    */


(0, _index.inherits)(AssertionError, Error);

exports.default = AssertionError;

/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _functions = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");

/**
 * Objects that need to clean up after themselves.
 * @constructor
 */
var Disposable = function Disposable() {};

/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */
/**
 * @module ol/Disposable
 */
Disposable.prototype.disposed_ = false;

/**
 * Clean up.
 */
Disposable.prototype.dispose = function () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
Disposable.prototype.disposeInternal = _functions.UNDEFINED;
exports.default = Disposable;

/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _Tile = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _TileState = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _dom = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");

var _events = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");

var _EventType = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord,
 * module:ol/TileState, string, ?string, module:ol/Tile~LoadFunction)} TileClass
 * @api
 */

/**
 * @constructor
 * @extends {module:ol/Tile}
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/TileState} state State.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.
 * @param {module:ol/Tile~Options=} opt_options Tile options.
 */
/**
 * @module ol/ImageTile
 */
var ImageTile = function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

  _Tile2.default.call(this, tileCoord, state, opt_options);

  /**
   * @private
   * @type {?string}
   */
  this.crossOrigin_ = crossOrigin;

  /**
   * Image URI
   *
   * @private
   * @type {string}
   */
  this.src_ = src;

  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */
  this.image_ = new Image();
  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }

  /**
   * @private
   * @type {Array.<module:ol/events~EventsKey>}
   */
  this.imageListenerKeys_ = null;

  /**
   * @private
   * @type {module:ol/Tile~LoadFunction}
   */
  this.tileLoadFunction_ = tileLoadFunction;
};

(0, _index.inherits)(ImageTile, _Tile2.default);

/**
 * @inheritDoc
 */
ImageTile.prototype.disposeInternal = function () {
  if (this.state == _TileState2.default.LOADING) {
    this.unlistenImage_();
    this.image_ = getBlankImage();
  }
  if (this.interimTile) {
    this.interimTile.dispose();
  }
  this.state = _TileState2.default.ABORT;
  this.changed();
  _Tile2.default.prototype.disposeInternal.call(this);
};

/**
 * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
 * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
 * @api
 */
ImageTile.prototype.getImage = function () {
  return this.image_;
};

/**
 * @inheritDoc
 */
ImageTile.prototype.getKey = function () {
  return this.src_;
};

/**
 * Tracks loading or read errors.
 *
 * @private
 */
ImageTile.prototype.handleImageError_ = function () {
  this.state = _TileState2.default.ERROR;
  this.unlistenImage_();
  this.image_ = getBlankImage();
  this.changed();
};

/**
 * Tracks successful image load.
 *
 * @private
 */
ImageTile.prototype.handleImageLoad_ = function () {
  if (this.image_.naturalWidth && this.image_.naturalHeight) {
    this.state = _TileState2.default.LOADED;
  } else {
    this.state = _TileState2.default.EMPTY;
  }
  this.unlistenImage_();
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
ImageTile.prototype.load = function () {
  if (this.state == _TileState2.default.ERROR) {
    this.state = _TileState2.default.IDLE;
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  if (this.state == _TileState2.default.IDLE) {
    this.state = _TileState2.default.LOADING;
    this.changed();
    this.imageListenerKeys_ = [(0, _events.listenOnce)(this.image_, _EventType2.default.ERROR, this.handleImageError_, this), (0, _events.listenOnce)(this.image_, _EventType2.default.LOAD, this.handleImageLoad_, this)];
    this.tileLoadFunction_(this, this.src_);
  }
};

/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */
ImageTile.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events.unlistenByKey);
  this.imageListenerKeys_ = null;
};

/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  var ctx = (0, _dom.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

exports.default = ImageTile;

/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getChangeEventType = getChangeEventType;

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _ObjectEventType = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");

var _ObjectEventType2 = _interopRequireDefault(_ObjectEventType);

var _Observable = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");

var _Observable2 = _interopRequireDefault(_Observable);

var _Event = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");

var _Event2 = _interopRequireDefault(_Event);

var _obj = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of
 * this type.
 *
 * @param {string} type The event type.
 * @param {string} key The property name.
 * @param {*} oldValue The old value for `key`.
 * @extends {module:ol/events/Event}
 * @constructor
 */
var ObjectEvent = function ObjectEvent(type, key, oldValue) {
  _Event2.default.call(this, type);

  /**
   * The name of the property whose value is changing.
   * @type {string}
   * @api
   */
  this.key = key;

  /**
   * The old value. To get the new value use `e.target.get(e.key)` where
   * `e` is the event object.
   * @type {*}
   * @api
   */
  this.oldValue = oldValue;
}; /**
    * @module ol/Object
    */

(0, _index.inherits)(ObjectEvent, _Event2.default);

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @constructor
 * @extends {module:ol/Observable}
 * @param {Object.<string, *>=} opt_values An object with key-value pairs.
 * @fires module:ol/Object~ObjectEvent
 * @api
 */
var BaseObject = function BaseObject(opt_values) {
  _Observable2.default.call(this);

  // Call {@link module:ol~getUid} to ensure that the order of objects' ids is
  // the same as the order in which they were created.  This also helps to
  // ensure that object properties are always added in the same order, which
  // helps many JavaScript engines generate faster code.
  (0, _index.getUid)(this);

  /**
   * @private
   * @type {!Object.<string, *>}
   */
  this.values_ = {};

  if (opt_values !== undefined) {
    this.setProperties(opt_values);
  }
};

(0, _index.inherits)(BaseObject, _Observable2.default);

/**
 * @type {Object.<string, string>}
 */
var changeEventTypeCache = {};

/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ? changeEventTypeCache[key] : changeEventTypeCache[key] = 'change:' + key;
}

/**
 * Gets a value.
 * @param {string} key Key name.
 * @return {*} Value.
 * @api
 */
BaseObject.prototype.get = function (key) {
  var value = void 0;
  if (this.values_.hasOwnProperty(key)) {
    value = this.values_[key];
  }
  return value;
};

/**
 * Get a list of object property names.
 * @return {Array.<string>} List of property names.
 * @api
 */
BaseObject.prototype.getKeys = function () {
  return Object.keys(this.values_);
};

/**
 * Get an object of all property names and values.
 * @return {Object.<string, *>} Object.
 * @api
 */
BaseObject.prototype.getProperties = function () {
  return (0, _obj.assign)({}, this.values_);
};

/**
 * @param {string} key Key name.
 * @param {*} oldValue Old value.
 */
BaseObject.prototype.notify = function (key, oldValue) {
  var eventType = void 0;
  eventType = getChangeEventType(key);
  this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  eventType = _ObjectEventType2.default.PROPERTYCHANGE;
  this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
};

/**
 * Sets a value.
 * @param {string} key Key name.
 * @param {*} value Value.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
BaseObject.prototype.set = function (key, value, opt_silent) {
  if (opt_silent) {
    this.values_[key] = value;
  } else {
    var oldValue = this.values_[key];
    this.values_[key] = value;
    if (oldValue !== value) {
      this.notify(key, oldValue);
    }
  }
};

/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * @param {Object.<string, *>} values Values.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
BaseObject.prototype.setProperties = function (values, opt_silent) {
  for (var key in values) {
    this.set(key, values[key], opt_silent);
  }
};

/**
 * Unsets a property.
 * @param {string} key Key name.
 * @param {boolean=} opt_silent Unset without triggering an event.
 * @api
 */
BaseObject.prototype.unset = function (key, opt_silent) {
  if (key in this.values_) {
    var oldValue = this.values_[key];
    delete this.values_[key];
    if (!opt_silent) {
      this.notify(key, oldValue);
    }
  }
};

exports.default = BaseObject;

/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
exports.default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object~ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};

/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unByKey = unByKey;

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _events = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");

var _EventTarget = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");

var _EventTarget2 = _interopRequireDefault(_EventTarget);

var _EventType = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @constructor
 * @extends {module:ol/events/EventTarget}
 * @fires module:ol/events/Event~Event
 * @struct
 * @api
 */
/**
 * @module ol/Observable
 */
var Observable = function Observable() {

  _EventTarget2.default.call(this);

  /**
   * @private
   * @type {number}
   */
  this.revision_ = 0;
};

(0, _index.inherits)(Observable, _EventTarget2.default);

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      (0, _events.unlistenByKey)(key[i]);
    }
  } else {
    (0, _events.unlistenByKey)( /** @type {module:ol/events~EventsKey} */key);
  }
}

/**
 * Increases the revision counter and dispatches a 'change' event.
 * @api
 */
Observable.prototype.changed = function () {
  ++this.revision_;
  this.dispatchEvent(_EventType2.default.CHANGE);
};

/**
 * Dispatches an event and calls all listeners listening for events
 * of this type. The event parameter can either be a string or an
 * Object with a `type` property.
 *
 * @param {{type: string,
 *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|
 *     module:ol/events/Event|string} event Event object.
 * @function
 * @api
 */
Observable.prototype.dispatchEvent;

/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * @return {number} Revision.
 * @api
 */
Observable.prototype.getRevision = function () {
  return this.revision_;
};

/**
 * Listen for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.on = function (type, listener) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = (0, _events.listen)(this, type[i], listener);
    }
    return keys;
  } else {
    return (0, _events.listen)(this, /** @type {string} */type, listener);
  }
};

/**
 * Listen once for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.once = function (type, listener) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = (0, _events.listenOnce)(this, type[i], listener);
    }
    return keys;
  } else {
    return (0, _events.listenOnce)(this, /** @type {string} */type, listener);
  }
};

/**
 * Unlisten for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @api
 */
Observable.prototype.un = function (type, listener) {
  if (Array.isArray(type)) {
    for (var i = 0, ii = type.length; i < ii; ++i) {
      (0, _events.unlisten)(this, type[i], listener);
    }
    return;
  } else {
    (0, _events.unlisten)(this, /** @type {string} */type, listener);
  }
};
exports.default = Observable;

/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _TileState = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _easing = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");

var _EventTarget = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");

var _EventTarget2 = _interopRequireDefault(_EventTarget);

var _EventType = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments.
 *
 * @typedef {function(module:ol/Tile, string)} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(module:ol/tilecoord~TileCoord, number,
 *           module:ol/proj/Projection): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @constructor
 * @abstract
 * @extends {module:ol/events/EventTarget}
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/TileState} state State.
 * @param {module:ol/Tile~Options=} opt_options Tile options.
 */
var Tile = function Tile(tileCoord, state, opt_options) {
  _EventTarget2.default.call(this);

  var options = opt_options ? opt_options : {};

  /**
   * @type {module:ol/tilecoord~TileCoord}
   */
  this.tileCoord = tileCoord;

  /**
   * @protected
   * @type {module:ol/TileState}
   */
  this.state = state;

  /**
   * An "interim" tile for this tile. The interim tile may be used while this
   * one is loading, for "smooth" transitions when changing params/dimensions
   * on the source.
   * @type {module:ol/Tile}
   */
  this.interimTile = null;

  /**
   * A key assigned to the tile. This is used by the tile source to determine
   * if this tile can effectively be used, or if a new tile should be created
   * and this one be used as an interim tile for this new tile.
   * @type {string}
   */
  this.key = '';

  /**
   * The duration for the opacity transition.
   * @type {number}
   */
  this.transition_ = options.transition === undefined ? 250 : options.transition;

  /**
   * Lookup of start times for rendering transitions.  If the start time is
   * equal to -1, the transition is complete.
   * @type {Object.<number, number>}
   */
  this.transitionStarts_ = {};
}; /**
    * @module ol/Tile
    */


(0, _index.inherits)(Tile, _EventTarget2.default);

/**
 * @protected
 */
Tile.prototype.changed = function () {
  this.dispatchEvent(_EventType2.default.CHANGE);
};

/**
 * @return {string} Key.
 */
Tile.prototype.getKey = function () {
  return this.key + '/' + this.tileCoord;
};

/**
 * Get the interim tile most suitable for rendering using the chain of interim
 * tiles. This corresponds to the  most recent tile that has been loaded, if no
 * such tile exists, the original tile is returned.
 * @return {!module:ol/Tile} Best tile for rendering.
 */
Tile.prototype.getInterimTile = function () {
  if (!this.interimTile) {
    //empty chain
    return this;
  }
  var tile = this.interimTile;

  // find the first loaded tile and return it. Since the chain is sorted in
  // decreasing order of creation time, there is no need to search the remainder
  // of the list (all those tiles correspond to older requests and will be
  // cleaned up by refreshInterimChain)
  do {
    if (tile.getState() == _TileState2.default.LOADED) {
      return tile;
    }
    tile = tile.interimTile;
  } while (tile);

  // we can not find a better tile
  return this;
};

/**
 * Goes through the chain of interim tiles and discards sections of the chain
 * that are no longer relevant.
 */
Tile.prototype.refreshInterimChain = function () {
  if (!this.interimTile) {
    return;
  }

  var tile = this.interimTile;
  var prev = this;

  do {
    if (tile.getState() == _TileState2.default.LOADED) {
      //we have a loaded tile, we can discard the rest of the list
      //we would could abort any LOADING tile request
      //older than this tile (i.e. any LOADING tile following this entry in the chain)
      tile.interimTile = null;
      break;
    } else if (tile.getState() == _TileState2.default.LOADING) {
      //keep this LOADING tile any loaded tiles later in the chain are
      //older than this tile, so we're still interested in the request
      prev = tile;
    } else if (tile.getState() == _TileState2.default.IDLE) {
      //the head of the list is the most current tile, we don't need
      //to start any other requests for this chain
      prev.interimTile = tile.interimTile;
    } else {
      prev = tile;
    }
    tile = prev.interimTile;
  } while (tile);
};

/**
 * Get the tile coordinate for this tile.
 * @return {module:ol/tilecoord~TileCoord} The tile coordinate.
 * @api
 */
Tile.prototype.getTileCoord = function () {
  return this.tileCoord;
};

/**
 * @return {module:ol/TileState} State.
 */
Tile.prototype.getState = function () {
  return this.state;
};

/**
 * @param {module:ol/TileState} state State.
 */
Tile.prototype.setState = function (state) {
  this.state = state;
  this.changed();
};

/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @abstract
 * @api
 */
Tile.prototype.load = function () {};

/**
 * Get the alpha value for rendering.
 * @param {number} id An id for the renderer.
 * @param {number} time The render frame time.
 * @return {number} A number between 0 and 1.
 */
Tile.prototype.getAlpha = function (id, time) {
  if (!this.transition_) {
    return 1;
  }

  var start = this.transitionStarts_[id];
  if (!start) {
    start = time;
    this.transitionStarts_[id] = start;
  } else if (start === -1) {
    return 1;
  }

  var delta = time - start + 1000 / 60; // avoid rendering at 0
  if (delta >= this.transition_) {
    return 1;
  }
  return (0, _easing.easeIn)(delta / this.transition_);
};

/**
 * Determine if a tile is in an alpha transition.  A tile is considered in
 * transition if tile.getAlpha() has not yet been called or has been called
 * and returned 1.
 * @param {number} id An id for the renderer.
 * @return {boolean} The tile is in transition.
 */
Tile.prototype.inTransition = function (id) {
  if (!this.transition_) {
    return false;
  }
  return this.transitionStarts_[id] !== -1;
};

/**
 * Mark a transition as complete.
 * @param {number} id An id for the renderer.
 */
Tile.prototype.endTransition = function (id) {
  if (this.transition_) {
    this.transitionStarts_[id] = -1;
  }
};
exports.default = Tile;

/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileCache.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index.js */ "./node_modules/ol/index.js");

var _LRUCache = __webpack_require__(/*! ./structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");

var _LRUCache2 = _interopRequireDefault(_LRUCache);

var _tilecoord = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {module:ol/structs/LRUCache.<module:ol/Tile>}
 * @param {number=} opt_highWaterMark High water mark.
 * @struct
 */
var TileCache = function TileCache(opt_highWaterMark) {

  _LRUCache2.default.call(this, opt_highWaterMark);
}; /**
    * @module ol/TileCache
    */


(0, _index.inherits)(TileCache, _LRUCache2.default);

/**
 * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
 */
TileCache.prototype.expireCache = function (usedTiles) {
  while (this.canExpireCache()) {
    var tile = this.peekLast();
    var zKey = tile.tileCoord[0].toString();
    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
      break;
    } else {
      this.pop().dispose();
    }
  }
};

/**
 * Prune all tiles from the cache that don't have the same z as the newest tile.
 */
TileCache.prototype.pruneExceptNewestZ = function () {
  if (this.getCount() === 0) {
    return;
  }
  var key = this.peekFirstKey();
  var tileCoord = (0, _tilecoord.fromKey)(key);
  var z = tileCoord[0];
  this.forEach(function (tile) {
    if (tile.tileCoord[0] !== z) {
      this.remove((0, _tilecoord.getKey)(tile.tileCoord));
      tile.dispose();
    }
  }, this);
};
exports.default = TileCache;

/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
/**
 * @module ol/TileRange
 */
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 *
 * @constructor
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @struct
 */
var TileRange = function TileRange(minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;
};

/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {module:ol/TileRange=} tileRange TileRange.
 * @return {module:ol/TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
TileRange.prototype.contains = function (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
TileRange.prototype.containsTileRange = function (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
TileRange.prototype.containsXY = function (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
TileRange.prototype.equals = function (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 */
TileRange.prototype.extend = function (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
 * @return {number} Height.
 */
TileRange.prototype.getHeight = function () {
  return this.maxY - this.minY + 1;
};

/**
 * @return {module:ol/size~Size} Size.
 */
TileRange.prototype.getSize = function () {
  return [this.getWidth(), this.getHeight()];
};

/**
 * @return {number} Width.
 */
TileRange.prototype.getWidth = function () {
  return this.maxX - this.minX + 1;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */
TileRange.prototype.intersects = function (tileRange) {
  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
};
exports.default = TileRange;

/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
exports.default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
};

/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binarySearch = binarySearch;
exports.numberSafeCompareFunction = numberSafeCompareFunction;
exports.includes = includes;
exports.linearFindNearest = linearFindNearest;
exports.reverseSubArray = reverseSubArray;
exports.extend = extend;
exports.remove = remove;
exports.find = find;
exports.equals = equals;
exports.stableSort = stableSort;
exports.findIndex = findIndex;
exports.isSorted = isSorted;
/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid = void 0,
      cmp = void 0;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}

/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}

/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}

/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i = void 0;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
}

/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {!Array.<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}

/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
  var length = arr.length >>> 0;
  var value = void 0;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
}

/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */
function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i = void 0;
  for (i = 0; i < length; i++) {
    tmp[i] = { index: i, value: arr[i] };
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}

/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
  var index = void 0;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}

/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}

/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

var _AssertionError = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");

var _AssertionError2 = _interopRequireDefault(_AssertionError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError2.default(errorCode);
  }
} /**
   * @module ol/asserts
   */

/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCanvasContext2D = createCanvasContext2D;
exports.outerWidth = outerWidth;
exports.outerHeight = outerHeight;
exports.replaceNode = replaceNode;
exports.removeNode = removeNode;
exports.removeChildren = removeChildren;
/**
 * @module ol/dom
 */

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height) {
  var canvas = /** @type {HTMLCanvasElement} */document.createElement('CANVAS');
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return (/** @type {CanvasRenderingContext2D} */canvas.getContext('2d')
  );
}

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.easeIn = easeIn;
exports.easeOut = easeOut;
exports.inAndOut = inAndOut;
exports.linear = linear;
exports.upAndDown = upAndDown;
/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}

/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}

/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}

/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}

/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bindListener = bindListener;
exports.findListener = findListener;
exports.getListeners = getListeners;
exports.listen = listen;
exports.listenOnce = listenOnce;
exports.unlisten = unlisten;
exports.unlistenByKey = unlistenByKey;
exports.unlistenAll = unlistenAll;

var _obj = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");

/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {Object} [bindTo]
 * @property {module:ol/events~ListenerFunction} [boundListener]
 * @property {boolean} callOnce
 * @property {number} [deleteIndex]
 * @property {module:ol/events~ListenerFunction} listener
 * @property {EventTarget|module:ol/events/EventTarget} target
 * @property {string} type
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function(module:ol/events/Event)|function(module:ol/events/Event): boolean} ListenerFunction
 * @api
 */

/**
 * @param {module:ol/events~EventsKey} listenerObj Listener object.
 * @return {module:ol/events~ListenerFunction} Bound listener.
 */
function bindListener(listenerObj) {
  var boundListener = function boundListener(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
}

/**
 * Finds the matching {@link module:ol/events~EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!module:ol/events~EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link module:ol/events~unlistenByKey}.
 * @return {module:ol/events~EventsKey|undefined} The matching listener object.
 */
/**
 * @module ol/events
 */
function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj = void 0;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
}

/**
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<module:ol/events~EventsKey>|undefined} Listeners.
 */
function getListeners(target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
}

/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @return {!Object.<string, Array.<module:ol/events~EventsKey>>} Map of
 *     listeners by event type.
 */
function getListenerMap(target) {
  var listenerMap = target.ol_lm;
  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
}

/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @param {string} type Type.
 */
function removeListeners(target, type) {
  var listeners = getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);
      (0, _obj.clear)(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = target.ol_lm;
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
}

/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {module:ol/events~EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  var listenerMap = getListenerMap(target);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = findListener(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {module:ol/events~EventsKey} */{
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    };
    target.addEventListener(type, bindListener(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
}

/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {module:ol/events~EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}

/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link module:ol/events~listen} call.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
function unlisten(target, type, listener, opt_this) {
  var listeners = getListeners(target, type);
  if (listeners) {
    var listenerObj = findListener(listeners, listener, opt_this, true);
    if (listenerObj) {
      unlistenByKey(listenerObj);
    }
  }
}

/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {module:ol/events~EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);
    var listeners = getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        removeListeners(key.target, key.type);
      }
    }
    (0, _obj.clear)(key);
  }
}

/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 */
function unlistenAll(target) {
  var listenerMap = getListenerMap(target);
  for (var type in listenerMap) {
    removeListeners(target, type);
  }
}

/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopPropagation = stopPropagation;
exports.preventDefault = preventDefault;
/**
 * @module ol/events/Event
 */
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/EventTarget~EventTarget}.
 *
 * @constructor
 * @param {string} type Type.
 */
var Event = function Event(type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @function
 * @api
 */
Event.prototype.preventDefault =

/**
 * Stop event propagation.
 * @function
 * @api
 */
Event.prototype.stopPropagation = function () {
  this.propagationStopped = true;
};

/**
 * @param {Event|module:ol/events/Event} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}

/**
 * @param {Event|module:ol/events/Event} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

exports.default = Event;

/***/ }),

/***/ "./node_modules/ol/events/EventTarget.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/events/EventTarget.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _Disposable = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");

var _Disposable2 = _interopRequireDefault(_Disposable);

var _events = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");

var _functions = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");

var _Event = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");

var _Event2 = _interopRequireDefault(_Event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {EventTarget|module:ol/events/EventTarget} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {module:ol/Disposable}
 */
var EventTarget = function EventTarget() {

  _Disposable2.default.call(this);

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.pendingRemovals_ = {};

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.dispatching_ = {};

  /**
   * @private
   * @type {!Object.<string, Array.<module:ol/events~ListenerFunction>>}
   */
  this.listeners_ = {};
}; /**
    * @module ol/events/EventTarget
    */


(0, _index.inherits)(EventTarget, _Disposable2.default);

/**
 * @param {string} type Type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 */
EventTarget.prototype.addEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }
  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};

/**
 * @param {{type: string,
 *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|module:ol/events/Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */
EventTarget.prototype.dispatchEvent = function (event) {
  var evt = typeof event === 'string' ? new _Event2.default(event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate = void 0;
  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }
    ++this.dispatching_[type];
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    --this.dispatching_[type];
    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];
      while (pendingRemovals--) {
        this.removeEventListener(type, _functions.UNDEFINED);
      }
      delete this.dispatching_[type];
    }
    return propagate;
  }
};

/**
 * @inheritDoc
 */
EventTarget.prototype.disposeInternal = function () {
  (0, _events.unlistenAll)(this);
};

/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<module:ol/events~ListenerFunction>} Listeners.
 */
EventTarget.prototype.getListeners = function (type) {
  return this.listeners_[type];
};

/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */
EventTarget.prototype.hasListener = function (opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};

/**
 * @param {string} type Type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 */
EventTarget.prototype.removeEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (listeners) {
    var index = listeners.indexOf(listener);
    if (type in this.pendingRemovals_) {
      // make listener a no-op, and remove later in #dispatchEvent()
      listeners[index] = _functions.UNDEFINED;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);
      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};
exports.default = EventTarget;

/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
exports.default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~Event#change
   * @api
   */
  CHANGE: 'change',

  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
};

/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boundingExtent = boundingExtent;
exports.buffer = buffer;
exports.clone = clone;
exports.closestSquaredDistanceXY = closestSquaredDistanceXY;
exports.containsCoordinate = containsCoordinate;
exports.containsExtent = containsExtent;
exports.containsXY = containsXY;
exports.coordinateRelationship = coordinateRelationship;
exports.createEmpty = createEmpty;
exports.createOrUpdate = createOrUpdate;
exports.createOrUpdateEmpty = createOrUpdateEmpty;
exports.createOrUpdateFromCoordinate = createOrUpdateFromCoordinate;
exports.createOrUpdateFromCoordinates = createOrUpdateFromCoordinates;
exports.createOrUpdateFromFlatCoordinates = createOrUpdateFromFlatCoordinates;
exports.createOrUpdateFromRings = createOrUpdateFromRings;
exports.equals = equals;
exports.extend = extend;
exports.extendCoordinate = extendCoordinate;
exports.extendCoordinates = extendCoordinates;
exports.extendFlatCoordinates = extendFlatCoordinates;
exports.extendRings = extendRings;
exports.extendXY = extendXY;
exports.forEachCorner = forEachCorner;
exports.getArea = getArea;
exports.getBottomLeft = getBottomLeft;
exports.getBottomRight = getBottomRight;
exports.getCenter = getCenter;
exports.getCorner = getCorner;
exports.getEnlargedArea = getEnlargedArea;
exports.getForViewAndSize = getForViewAndSize;
exports.getHeight = getHeight;
exports.getIntersectionArea = getIntersectionArea;
exports.getIntersection = getIntersection;
exports.getMargin = getMargin;
exports.getSize = getSize;
exports.getTopLeft = getTopLeft;
exports.getTopRight = getTopRight;
exports.getWidth = getWidth;
exports.intersects = intersects;
exports.isEmpty = isEmpty;
exports.returnOrUpdate = returnOrUpdate;
exports.scaleFromCenter = scaleFromCenter;
exports.intersectsSegment = intersectsSegment;
exports.applyTransform = applyTransform;

var _asserts = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

var _Corner = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");

var _Corner2 = _interopRequireDefault(_Corner);

var _Relationship = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");

var _Relationship2 = _interopRequireDefault(_Relationship);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array.<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @return {module:ol/extent~Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @private
 * @return {module:ol/extent~Extent} Extent.
 */
/**
 * @module ol/extent
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}

/**
 * Return extent increased by the provided value.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
}

/**
 * Creates a clone of an extent.
 *
 * @param {module:ol/extent~Extent} extent Extent to clone.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} The clone.
 */
function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  var dx = void 0,
      dy = void 0;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}

/**
 * Get the relationship between a coordinate and extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
 * @return {module:ol/extent/Relationship} The relationship (bitwise compare with
 *     module:ol/extent/Relationship~Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _Relationship2.default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | _Relationship2.default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | _Relationship2.default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _Relationship2.default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | _Relationship2.default.ABOVE;
  }
  if (relationship === _Relationship2.default.UNKNOWN) {
    relationship = _Relationship2.default.INTERSECTING;
  }
  return relationship;
}

/**
 * Create an empty extent.
 * @return {module:ol/extent~Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}

/**
 * Create a new empty extent or make the provided one empty.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}

/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}

/**
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}

/**
 * Determine if two extents are equivalent.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}

/**
 * Modify an extent to include another extent.
 * @param {module:ol/extent~Extent} extent1 The extent to be modified.
 * @param {module:ol/extent~Extent} extent2 The extent that will be included in the first.
 * @return {module:ol/extent~Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {function(this:T, module:ol/coordinate~Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
function forEachCorner(extent, callback, opt_this) {
  var val = void 0;
  val = callback.call(opt_this, getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}

/**
 * Get the size of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  var area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}

/**
 * Get the bottom left coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}

/**
 * Get the bottom right coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}

/**
 * Get the center coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}

/**
 * Get a corner coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/extent/Corner} corner Corner.
 * @return {module:ol/coordinate~Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  var coordinate = void 0;
  if (corner === _Corner2.default.BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _Corner2.default.BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _Corner2.default.TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _Corner2.default.TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    (0, _asserts.assert)(false, 13); // Invalid corner
  }
  return (
    /** @type {!module:ol/coordinate~Coordinate} */coordinate
  );
}

/**
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}

/**
 * @param {module:ol/coordinate~Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {module:ol/size~Size} size Size.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}

/**
 * Get the height of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}

/**
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}

/**
 * Get the intersection of two extents.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @param {module:ol/extent~Extent=} opt_extent Optional extent to populate with intersection.
 * @return {module:ol/extent~Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}

/**
 * Get the size (width, height) of an extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @return {module:ol/size~Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}

/**
 * Get the top left coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}

/**
 * Get the top right coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}

/**
 * Get the width of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}

/**
 * Determine if one extent intersects another.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}

/**
 * Determine if an extent is empty.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @param {module:ol/coordinate~Coordinate} start Segment start coordinate.
 * @param {module:ol/coordinate~Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);
  if (startRel === _Relationship2.default.INTERSECTING || endRel === _Relationship2.default.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x = void 0,
        y = void 0;
    if (!!(endRel & _Relationship2.default.ABOVE) && !(startRel & _Relationship2.default.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _Relationship2.default.RIGHT) && !(startRel & _Relationship2.default.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _Relationship2.default.BELOW) && !(startRel & _Relationship2.default.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _Relationship2.default.LEFT) && !(startRel & _Relationship2.default.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
}

/**
 * Apply a transform function to the extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/proj~TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent) {
  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _boundingExtentXYs(xs, ys, opt_extent);
}

/***/ }),

/***/ "./node_modules/ol/extent/Corner.js":
/*!******************************************!*\
  !*** ./node_modules/ol/extent/Corner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
exports.default = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};

/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
exports.default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUE = TRUE;
exports.FALSE = FALSE;
exports.UNDEFINED = UNDEFINED;
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @returns {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */
function UNDEFINED() {}

/***/ }),

/***/ "./node_modules/ol/geom/GeometryType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/GeometryType.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
exports.default = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};

/***/ }),

/***/ "./node_modules/ol/index.js":
/*!**********************************!*\
  !*** ./node_modules/ol/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = exports.WEBGL_EXTENSIONS = exports.WEBGL_MAX_TEXTURE_SIZE = exports.HAS_WEBGL = exports.DEBUG_WEBGL = undefined;
exports.inherits = inherits;
exports.getUid = getUid;

var _webgl = __webpack_require__(/*! ./webgl.js */ "./node_modules/ol/webgl.js");

/**
 * An array with two elements, representing a pixel. The first element is the
 * x-coordinate, the second the y-coordinate of the pixel.
 * @typedef {Array.<number>} Pixel
 * @api
 */

/**
 * Include debuggable shader sources.  Default is `true`. This should be set to
 * `false` for production builds.
 * TODO: move to a separate ol-webgl package
 * @type {boolean}
 */
var DEBUG_WEBGL = exports.DEBUG_WEBGL = true;

/**
 * TODO: move to a separate ol-webgl package
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @type {number|undefined}
 */
/**
 * @module ol
 */

var WEBGL_MAX_TEXTURE_SIZE = void 0; // value is set below


/**
 * TODO: move to a separate ol-webgl package
 * List of supported WebGL extensions.
 * @type {Array.<string>}
 */
var WEBGL_EXTENSIONS = void 0; // value is set below


/**
 * TODO: move to a separate ol-webgl package
 * WebGL is available.
 * @type {boolean}
 */
var HAS_WEBGL = false;

if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
  try {
    var canvas = /** @type {HTMLCanvasElement} */document.createElement('CANVAS');
    var gl = (0, _webgl.getContext)(canvas, { failIfMajorPerformanceCaveat: true });
    if (gl) {
      exports.HAS_WEBGL = HAS_WEBGL = true;
      exports.WEBGL_MAX_TEXTURE_SIZE = WEBGL_MAX_TEXTURE_SIZE = /** @type {number} */gl.getParameter(gl.MAX_TEXTURE_SIZE);
      exports.WEBGL_EXTENSIONS = WEBGL_EXTENSIONS = gl.getSupportedExtensions();
    }
  } catch (e) {
    // pass
  }
}

exports.HAS_WEBGL = HAS_WEBGL;
exports.WEBGL_MAX_TEXTURE_SIZE = WEBGL_MAX_TEXTURE_SIZE;
exports.WEBGL_EXTENSIONS = WEBGL_EXTENSIONS;

/**
 * OpenLayers version.
 * @type {string}
 */

var VERSION = exports.VERSION = 'v4.6.4';

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */
function inherits(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = ++uidCounter_);
}

/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cosh = undefined;
exports.clamp = clamp;
exports.roundUpToPowerOfTwo = roundUpToPowerOfTwo;
exports.squaredSegmentDistance = squaredSegmentDistance;
exports.squaredDistance = squaredDistance;
exports.solveLinearSystem = solveLinearSystem;
exports.toDegrees = toDegrees;
exports.toRadians = toRadians;
exports.modulo = modulo;
exports.lerp = lerp;

var _asserts = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
/**
 * @module ol/math
 */
var cosh = exports.cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh = void 0;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use itâ¦
    cosh = Math.cosh;
  } else {
    // â¦ else, use the reference implementation of MDN:
    cosh = function cosh(x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}();

/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
function roundUpToPowerOfTwo(x) {
  (0, _asserts.assert)(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
}

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.getValues = getValues;
exports.isEmpty = isEmpty;
/**
 * @module ol/obj
 */

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = exports.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};

/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}

/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
function getValues(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
}

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  var property = void 0;
  for (property in object) {
    return false;
  }
  return !property;
}

/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.METERS_PER_UNIT = undefined;
exports.cloneTransform = cloneTransform;
exports.identityTransform = identityTransform;
exports.addProjection = addProjection;
exports.addProjections = addProjections;
exports.get = get;
exports.getPointResolution = getPointResolution;
exports.addEquivalentProjections = addEquivalentProjections;
exports.addEquivalentTransforms = addEquivalentTransforms;
exports.clearAllProjections = clearAllProjections;
exports.createProjection = createProjection;
exports.createTransformFromCoordinateTransform = createTransformFromCoordinateTransform;
exports.addCoordinateTransforms = addCoordinateTransforms;
exports.fromLonLat = fromLonLat;
exports.toLonLat = toLonLat;
exports.equivalent = equivalent;
exports.getTransformFromProjections = getTransformFromProjections;
exports.getTransform = getTransform;
exports.transform = transform;
exports.transformExtent = transformExtent;
exports.transformWithProjections = transformWithProjections;
exports.addCommon = addCommon;

var _sphere = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");

var _extent = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _epsg = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");

var _epsg2 = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");

var _Projection = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");

var _Projection2 = _interopRequireDefault(_Projection);

var _Units = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

var _projections = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");

var projections = _interopRequireWildcard(_projections);

var _transforms = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {module:ol/proj/Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array.<number>, Array.<number>=, number=): Array.<number>} TransformFunction
 * @api
 */

exports.METERS_PER_UNIT = _Units.METERS_PER_UNIT;

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the {@link http://proj4js.org/}
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * {@link https://epsg.io/}, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */

function cloneTransform(input, opt_output, opt_dimension) {
  var output = void 0;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
}

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {module:ol/proj/Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  projections.add(projection.getCode(), projection);
  (0, _transforms.add)(projection, projection, cloneTransform);
}

/**
 * @param {Array.<module:ol/proj/Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {module:ol/proj~ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {module:ol/proj/Projection} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  var projection = null;
  if (projectionLike instanceof _Projection2.default) {
    projection = projectionLike;
  } else if (typeof projectionLike === 'string') {
    var code = projectionLike;
    projection = projections.get(code);
  }
  return projection;
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {module:ol/proj~ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {module:ol/coordinate~Coordinate} point Point to find adjusted resolution at.
 * @param {module:ol/proj/Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution = void 0;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == _Units2.default.DEGREES && !opt_units || opt_units == _Units2.default.DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var _toEPSG = getTransformFromProjections(projection, get('EPSG:4326'));
      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = _toEPSG(vertices, vertices, 2);
      var width = (0, _sphere.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = (0, _sphere.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ? _Units.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<module:ol/proj/Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0, _transforms.add)(source, destination, cloneTransform);
      }
    });
  });
}

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<module:ol/proj/Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<module:ol/proj/Projection>} projections2 Projections with equal
 *     meaning.
 * @param {module:ol/proj~TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {module:ol/proj~TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0, _transforms.add)(projection1, projection2, forwardTransform);
      (0, _transforms.add)(projection2, projection1, inverseTransform);
    });
  });
}

/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  projections.clear();
  (0, _transforms.clear)();
}

/**
 * @param {module:ol/proj/Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {module:ol/proj/Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {module:ol/proj/Projection} */projection
    );
  }
}

/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} coordTransform Coordinate
 *     transform.
 * @return {module:ol/proj~TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    }
  );
}

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {module:ol/proj~ProjectionLike} source Source projection.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  (0, _transforms.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  (0, _transforms.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {module:ol/proj~ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {module:ol/coordinate~Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {module:ol/coordinate~Coordinate} coordinate Projected coordinate.
 * @param {module:ol/proj~ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {module:ol/coordinate~Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = (0, _math.modulo)(lon + 180, 360) - 180;
  }
  return lonLat;
}

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {module:ol/proj/Projection} projection1 Projection 1.
 * @param {module:ol/proj/Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {module:ol/proj/Projection} sourceProjection Source Projection object.
 * @param {module:ol/proj/Projection} destinationProjection Destination Projection
 *     object.
 * @return {module:ol/proj~TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = (0, _transforms.get)(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {module:ol/proj~ProjectionLike} source Source.
 * @param {module:ol/proj~ProjectionLike} destination Destination.
 * @return {module:ol/proj~TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/proj~ProjectionLike} source Source projection-like.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
 * @return {module:ol/coordinate~Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {module:ol/extent~Extent} extent The extent to transform.
 * @param {module:ol/proj~ProjectionLike} source Source projection-like.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
 * @return {module:ol/extent~Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination) {
  var transformFunc = getTransform(source, destination);
  return (0, _extent.applyTransform)(extent, transformFunc);
}

/**
 * Transforms the given point to the destination projection.
 *
 * @param {module:ol/coordinate~Coordinate} point Point.
 * @param {module:ol/proj/Projection} sourceProjection Source projection.
 * @param {module:ol/proj/Projection} destinationProjection Destination projection.
 * @return {module:ol/coordinate~Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_epsg.PROJECTIONS);
  addEquivalentProjections(_epsg2.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(_epsg2.PROJECTIONS, _epsg.PROJECTIONS, _epsg.fromEPSG4326, _epsg.toEPSG4326);
}

addCommon();

/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Units = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {module:ol/proj/Units|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {module:ol/extent~Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {module:ol/extent~Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, module:ol/coordinate~Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{module:ol/coordinate~Coordinate}` as arguments, and returns
 * the `{number}` resolution at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {@link module:ol/proj~setProj4}.
 *
 * @constructor
 * @param {module:ol/proj/Projection~Options} options Projection options.
 * @struct
 * @api
 */
var Projection = function Projection(options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * Units of projected coordinates. When set to `TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {module:ol/proj/Units}
   */
  this.units_ = /** @type {module:ol/proj/Units} */options.units;

  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * Extent of the world in EPSG:4326. For projections with
   * `TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
   * @private
   * @type {function(number, module:ol/coordinate~Coordinate):number|undefined}
   */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
/**
 * @module ol/proj/Projection
 */
Projection.prototype.canWrapX = function () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
Projection.prototype.getCode = function () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
Projection.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {module:ol/proj/Units} Units.
 * @api
 */
Projection.prototype.getUnits = function () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
Projection.prototype.getMetersPerUnit = function () {
  return this.metersPerUnit_ || _Units.METERS_PER_UNIT[this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
Projection.prototype.getWorldExtent = function () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *     or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *     "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */
Projection.prototype.getAxisOrientation = function () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
Projection.prototype.isGlobal = function () {
  return this.global_;
};

/**
* Set if the projection is a global projection which spans the whole world
* @param {boolean} global Whether the projection is global.
* @api
*/
Projection.prototype.setGlobal = function (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {module:ol/tilegrid/TileGrid} The default tile grid.
 */
Projection.prototype.getDefaultTileGrid = function () {
  return this.defaultTileGrid_;
};

/**
 * @param {module:ol/tilegrid/TileGrid} tileGrid The default tile grid.
 */
Projection.prototype.setDefaultTileGrid = function (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {module:ol/extent~Extent} extent Extent.
 * @api
 */
Projection.prototype.setExtent = function (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {module:ol/extent~Extent} worldExtent World extent
 *     [minlon, minlat, maxlon, maxlat].
 * @api
 */
Projection.prototype.setWorldExtent = function (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
 * for this projection.
 * @param {function(number, module:ol/coordinate~Coordinate):number} func Function
 * @api
 */
Projection.prototype.setGetPointResolution = function (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, module:ol/coordinate~Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
Projection.prototype.getPointResolutionFunc = function () {
  return this.getPointResolutionFunc_;
};
exports.default = Projection;

/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};

/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<module:ol/proj/Units, number>}
 * @api
 */
var METERS_PER_UNIT = exports.METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

exports.default = Units;

/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECTIONS = exports.WORLD_EXTENT = exports.EXTENT = exports.HALF_SIZE = exports.RADIUS = undefined;
exports.fromEPSG4326 = fromEPSG4326;
exports.toEPSG4326 = toEPSG4326;

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _Projection = __webpack_require__(/*! ../proj/Projection.js */ "./node_modules/ol/proj/Projection.js");

var _Projection2 = _interopRequireDefault(_Projection);

var _Units = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
/**
 * @module ol/proj/epsg3857
 */
var RADIUS = exports.RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
var HALF_SIZE = exports.HALF_SIZE = Math.PI * RADIUS;

/**
 * @const
 * @type {module:ol/extent~Extent}
 */
var EXTENT = exports.EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];

/**
 * @const
 * @type {module:ol/extent~Extent}
 */
var WORLD_EXTENT = exports.WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 *
 * @constructor
 * @extends {module:ol/proj/Projection}
 * @param {string} code Code.
 */
function EPSG3857Projection(code) {
  _Projection2.default.call(this, {
    code: code,
    units: _Units2.default.METERS,
    extent: EXTENT,
    global: true,
    worldExtent: WORLD_EXTENT,
    getPointResolution: function getPointResolution(resolution, point) {
      return resolution / (0, _math.cosh)(point[1] / RADIUS);
    }
  });
}
(0, _index.inherits)(EPSG3857Projection, _Projection2.default);

/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<module:ol/proj/Projection>}
 */
var PROJECTIONS = exports.PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'), new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
}

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECTIONS = exports.METERS_PER_UNIT = exports.EXTENT = exports.RADIUS = undefined;

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _Projection = __webpack_require__(/*! ../proj/Projection.js */ "./node_modules/ol/proj/Projection.js");

var _Projection2 = _interopRequireDefault(_Projection);

var _Units = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = exports.RADIUS = 6378137;

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {module:ol/extent~Extent}
 */
/**
 * @module ol/proj/epsg4326
 */
var EXTENT = exports.EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = exports.METERS_PER_UNIT = Math.PI * RADIUS / 180;

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 *
 * @constructor
 * @extends {module:ol/proj/Projection}
 * @param {string} code Code.
 * @param {string=} opt_axisOrientation Axis orientation.
 */
function EPSG4326Projection(code, opt_axisOrientation) {
  _Projection2.default.call(this, {
    code: code,
    units: _Units2.default.DEGREES,
    extent: EXTENT,
    axisOrientation: opt_axisOrientation,
    global: true,
    metersPerUnit: METERS_PER_UNIT,
    worldExtent: EXTENT
  });
}
(0, _index.inherits)(EPSG4326Projection, _Projection2.default);

/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<module:ol/proj/Projection>}
 */
var PROJECTIONS = exports.PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')];

/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.get = get;
exports.add = add;
/**
 * @module ol/proj/projections
 */

/**
 * @type {Object.<string, module:ol/proj/Projection>}
 */
var cache = {};

/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {module:ol/proj/Projection} The projection (if cached).
 */
function get(code) {
  return cache[code] || null;
}

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {module:ol/proj/Projection} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}

/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.add = add;
exports.remove = remove;
exports.get = get;

var _obj = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");

/**
 * @private
 * @type {!Object.<string, Object.<string, module:ol/proj~TransformFunction>>}
 */
var transforms = {};

/**
 * Clear the transform cache.
 */
/**
 * @module ol/proj/transforms
 */
function clear() {
  transforms = {};
}

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {module:ol/proj/Projection} source Source.
 * @param {module:ol/proj/Projection} destination Destination.
 * @param {module:ol/proj~TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {module:ol/proj/Projection} source Source projection.
 * @param {module:ol/proj/Projection} destination Destination projection.
 * @return {module:ol/proj~TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if ((0, _obj.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {module:ol/proj~TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  var transform = void 0;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}

/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSourceResolution = calculateSourceResolution;
exports.render = render;

var _dom = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");

var _extent = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _proj = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {module:ol/proj/Projection} sourceProj Source projection.
 * @param {module:ol/proj/Projection} targetProj Target projection.
 * @param {module:ol/coordinate~Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
/**
 * @module ol/reproj
 */
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {

  var sourceCenter = (0, _proj.transform)(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = (0, _proj.getPointResolution)(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || (0, _extent.containsCoordinate)(sourceExtent, sourceCenter)) {
    var compensationFactor = (0, _proj.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}

/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {module:ol/coordinate~Coordinate} New point 1 px farther from the centroid.
 */
function enlargeClipPoint(centroidX, centroidY, x, y) {
  var dX = x - centroidX;
  var dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
}

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {module:ol/extent~Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {module:ol/extent~Extent} targetExtent Target extent.
 * @param {module:ol/reproj/Triangulation} triangulation
 * Calculated triangulation.
 * @param {Array.<{extent: module:ol/extent~Extent,
 *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {

  var context = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = (0, _extent.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0, _extent.extend)(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = (0, _extent.getWidth)(sourceDataExtent);
  var canvasHeightInUnits = (0, _extent.getHeight)(sourceDataExtent);
  var stitchContext = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = (0, _extent.getWidth)(src.extent);
    var srcHeight = (0, _extent.getHeight)(src.extent);

    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = (0, _extent.getTopLeft)(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1];
    var x1 = source[1][0],
        y1 = source[1][1];
    var x2 = source[2][0],
        y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = (0, _math.solveLinearSystem)(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3;
    var centroidY = (v0 + v1 + v2) / 3;
    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();

    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);

    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();

    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}

/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _Tile = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _events = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");

var _EventType = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

var _extent = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _reproj = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");

var _Triangulation = __webpack_require__(/*! ../reproj/Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");

var _Triangulation2 = _interopRequireDefault(_Triangulation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 * @constructor
 * @extends {module:ol/Tile}
 * @param {module:ol/proj/Projection} sourceProj Source projection.
 * @param {module:ol/tilegrid/TileGrid} sourceTileGrid Source tile grid.
 * @param {module:ol/proj/Projection} targetProj Target projection.
 * @param {module:ol/tilegrid/TileGrid} targetTileGrid Target tile grid.
 * @param {module:ol/tilecoord~TileCoord} tileCoord Coordinate of the tile.
 * @param {module:ol/tilecoord~TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} gutter Gutter of the source tiles.
 * @param {module:ol/reproj/Tile~FunctionType} getTileFunction
 *     Function returning source tiles (z, x, y, pixelRatio).
 * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 */
/**
 * @module ol/reproj/Tile
 */
var ReprojTile = function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {
  _Tile2.default.call(this, tileCoord, _TileState2.default.IDLE);

  /**
   * @private
   * @type {boolean}
   */
  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   * @type {number}
   */
  this.gutter_ = gutter;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = null;

  /**
   * @private
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.sourceTileGrid_ = sourceTileGrid;

  /**
   * @private
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.targetTileGrid_ = targetTileGrid;

  /**
   * @private
   * @type {module:ol/tilecoord~TileCoord}
   */
  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

  /**
   * @private
   * @type {!Array.<module:ol/Tile>}
   */
  this.sourceTiles_ = [];

  /**
   * @private
   * @type {Array.<module:ol/events~EventsKey>}
   */
  this.sourcesListenerKeys_ = null;

  /**
   * @private
   * @type {number}
   */
  this.sourceZ_ = 0;

  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
  var maxTargetExtent = this.targetTileGrid_.getExtent();
  var maxSourceExtent = this.sourceTileGrid_.getExtent();

  var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;

  if ((0, _extent.getArea)(limitedTargetExtent) === 0) {
    // Tile is completely outside range -> EMPTY
    // TODO: is it actually correct that the source even creates the tile ?
    this.state = _TileState2.default.EMPTY;
    return;
  }

  var sourceProjExtent = sourceProj.getExtent();
  if (sourceProjExtent) {
    if (!maxSourceExtent) {
      maxSourceExtent = sourceProjExtent;
    } else {
      maxSourceExtent = (0, _extent.getIntersection)(maxSourceExtent, sourceProjExtent);
    }
  }

  var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);

  var targetCenter = (0, _extent.getCenter)(limitedTargetExtent);
  var sourceResolution = (0, _reproj.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    // invalid sourceResolution -> EMPTY
    // probably edges of the projections when no extent is defined
    this.state = _TileState2.default.EMPTY;
    return;
  }

  var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _common.ERROR_THRESHOLD;

  /**
   * @private
   * @type {!module:ol/reproj/Triangulation}
   */
  this.triangulation_ = new _Triangulation2.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);

  if (this.triangulation_.getTriangles().length === 0) {
    // no valid triangles -> EMPTY
    this.state = _TileState2.default.EMPTY;
    return;
  }

  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
  var sourceExtent = this.triangulation_.calculateSourceExtent();

  if (maxSourceExtent) {
    if (sourceProj.canWrapX()) {
      sourceExtent[1] = (0, _math.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
      sourceExtent[3] = (0, _math.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
    } else {
      sourceExtent = (0, _extent.getIntersection)(sourceExtent, maxSourceExtent);
    }
  }

  if (!(0, _extent.getArea)(sourceExtent)) {
    this.state = _TileState2.default.EMPTY;
  } else {
    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);

    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
        var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
        if (tile) {
          this.sourceTiles_.push(tile);
        }
      }
    }

    if (this.sourceTiles_.length === 0) {
      this.state = _TileState2.default.EMPTY;
    }
  }
};

(0, _index.inherits)(ReprojTile, _Tile2.default);

/**
 * @inheritDoc
 */
ReprojTile.prototype.disposeInternal = function () {
  if (this.state == _TileState2.default.LOADING) {
    this.unlistenSources_();
  }
  _Tile2.default.prototype.disposeInternal.call(this);
};

/**
 * Get the HTML Canvas element for this tile.
 * @return {HTMLCanvasElement} Canvas.
 */
ReprojTile.prototype.getImage = function () {
  return this.canvas_;
};

/**
 * @private
 */
ReprojTile.prototype.reproject_ = function () {
  var sources = [];
  this.sourceTiles_.forEach(function (tile, i, arr) {
    if (tile && tile.getState() == _TileState2.default.LOADED) {
      sources.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
        image: tile.getImage()
      });
    }
  }.bind(this));
  this.sourceTiles_.length = 0;

  if (sources.length === 0) {
    this.state = _TileState2.default.ERROR;
  } else {
    var z = this.wrappedTileCoord_[0];
    var size = this.targetTileGrid_.getTileSize(z);
    var width = typeof size === 'number' ? size : size[0];
    var height = typeof size === 'number' ? size : size[1];
    var targetResolution = this.targetTileGrid_.getResolution(z);
    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

    var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
    this.canvas_ = (0, _reproj.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);

    this.state = _TileState2.default.LOADED;
  }
  this.changed();
};

/**
 * @inheritDoc
 */
ReprojTile.prototype.load = function () {
  if (this.state == _TileState2.default.IDLE) {
    this.state = _TileState2.default.LOADING;
    this.changed();

    var leftToLoad = 0;

    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == _TileState2.default.IDLE || state == _TileState2.default.LOADING) {
        leftToLoad++;

        var sourceListenKey = (0, _events.listen)(tile, _EventType2.default.CHANGE, function (e) {
          var state = tile.getState();
          if (state == _TileState2.default.LOADED || state == _TileState2.default.ERROR || state == _TileState2.default.EMPTY) {
            (0, _events.unlistenByKey)(sourceListenKey);
            leftToLoad--;
            if (leftToLoad === 0) {
              this.unlistenSources_();
              this.reproject_();
            }
          }
        }, this);
        this.sourcesListenerKeys_.push(sourceListenKey);
      }
    }.bind(this));

    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == _TileState2.default.IDLE) {
        tile.load();
      }
    });

    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    }
  }
};

/**
 * @private
 */
ReprojTile.prototype.unlistenSources_ = function () {
  this.sourcesListenerKeys_.forEach(_events.unlistenByKey);
  this.sourcesListenerKeys_ = null;
};
exports.default = ReprojTile;

/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extent = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array.<module:ol/coordinate~Coordinate>} source
 * @property {Array.<module:ol/coordinate~Coordinate>} target
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;

/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
/**
 * @module ol/reproj/Triangulation
 */
var MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 *
 * @param {module:ol/proj/Projection} sourceProj Source projection.
 * @param {module:ol/proj/Projection} targetProj Target projection.
 * @param {module:ol/extent~Extent} targetExtent Target extent to triangulate.
 * @param {module:ol/extent~Extent} maxSourceExtent Maximal source extent that can be used.
 * @param {number} errorThreshold Acceptable error (in source units).
 * @constructor
 */
var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {module:ol/proj/Projection}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {module:ol/proj/Projection}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object.<string, module:ol/coordinate~Coordinate>} */
  var transformInvCache = {};
  var transformInv = (0, _proj.getTransform)(this.targetProj_, this.sourceProj_);

  /**
   * @param {module:ol/coordinate~Coordinate} c A coordinate.
   * @return {module:ol/coordinate~Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function (c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {module:ol/extent~Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array.<module:ol/reproj/Triangulation~Triangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0, _extent.getWidth)(maxSourceExtent) == (0, _extent.getWidth)(this.sourceProj_.getExtent());

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0, _extent.getWidth)(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0, _extent.getWidth)(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = (0, _extent.getTopLeft)(targetExtent);
  var destinationTopRight = (0, _extent.getTopRight)(targetExtent);
  var destinationBottomRight = (0, _extent.getBottomRight)(targetExtent);
  var destinationBottomLeft = (0, _extent.getBottomLeft)(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function (triangle, i, arr) {
      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function (triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];
        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if (maxX - minX < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }.bind(this));
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
 * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
 * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
 * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
 * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
 * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
 * @private
 */
Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
 * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
 * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
 * @param {module:ol/coordinate~Coordinate} d The target d coordinate.
 * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
 * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
 * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
 * @param {module:ol/coordinate~Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = (0, _extent.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ? (0, _extent.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = (0, _extent.boundingExtent)([a, b, c, d]);
      var targetCoverageX = (0, _extent.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |= targetCoverageX > MAX_TRIANGLE_WIDTH;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |= sourceCoverageX > MAX_TRIANGLE_WIDTH;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!(0, _extent.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx = void 0;
      if (wrapsX) {
        var centerSrcEstimX = ((0, _math.modulo)(aSrc[0], sourceWorldWidth) + (0, _math.modulo)(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX - (0, _math.modulo)(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {module:ol/extent~Extent} Calculated extent.
 */
Triangulation.prototype.calculateSourceExtent = function () {
  var extent = (0, _extent.createEmpty)();

  this.triangles_.forEach(function (triangle, i, arr) {
    var src = triangle.source;
    (0, _extent.extendCoordinate)(extent, src[0]);
    (0, _extent.extendCoordinate)(extent, src[1]);
    (0, _extent.extendCoordinate)(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array.<module:ol/reproj/Triangulation~Triangle>} Array of the calculated triangles.
 */
Triangulation.prototype.getTriangles = function () {
  return this.triangles_;
};
exports.default = Triangulation;

/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = exports.ERROR_THRESHOLD = 0.5;

/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */
var ENABLE_RASTER_REPROJECTION = exports.ENABLE_RASTER_REPROJECTION = true;

/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buffer = buffer;
exports.hasArea = hasArea;
exports.scale = scale;
exports.toSize = toSize;
/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array.<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {module:ol/size~Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}

/**
 * Determines if a size has a positive area.
 * @param {module:ol/size~Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}

/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {module:ol/size~Size} size Size.
 * @param {number} ratio Ratio.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} The scaled size.
 */
function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
}

/**
 * Returns an `module:ol/size~Size` array for the passed in number (meaning: square) or
 * `module:ol/size~Size` array.
 * (meaning: non-square),
 * @param {number|module:ol/size~Size} size Width and height.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} Size.
 * @api
 */
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */size;
    }
    return opt_size;
  }
}

/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _functions = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");

var _Object = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");

var _Object2 = _interopRequireDefault(_Object);

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

var _State = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");

var _State2 = _interopRequireDefault(_State);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(module:ol/PluggableMap~FrameState): (string|Array.<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'Â© Acme Inc.'`)
 * * an array of simple strings (e.g. `['Â© Acme Inc.', 'Â© Bacme Inc.']`)
 * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)
 *
 * @typedef {string|Array.<string>|module:ol/source/Source~Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {module:ol/proj~ProjectionLike} projection
 * @property {module:ol/source/State} [state]
 * @property {boolean} [wrapX]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {module:ol/Object}
 * @param {module:ol/source/Source~Options} options Source options.
 * @api
 */
var Source = function Source(options) {

  _Object2.default.call(this);

  /**
   * @private
   * @type {module:ol/proj/Projection}
   */
  this.projection_ = (0, _proj.get)(options.projection);

  /**
   * @private
   * @type {?module:ol/source/Source~Attribution}
   */
  this.attributions_ = this.adaptAttributions_(options.attributions);

  /**
   * @private
   * @type {module:ol/source/State}
   */
  this.state_ = options.state !== undefined ? options.state : _State2.default.READY;

  /**
   * @private
   * @type {boolean}
   */
  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
}; /**
    * @module ol/source/Source
    */


(0, _index.inherits)(Source, _Object2.default);

/**
 * Turns the attributions option into an attributions function.
 * @param {module:ol/source/Source~AttributionLike|undefined} attributionLike The attribution option.
 * @return {?module:ol/source/Source~Attribution} An attribution function (or null).
 */
Source.prototype.adaptAttributions_ = function (attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
};

/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
Source.prototype.forEachFeatureAtCoordinate = _functions.UNDEFINED;

/**
 * Get the attribution function for the source.
 * @return {?module:ol/source/Source~Attribution} Attribution function.
 */
Source.prototype.getAttributions = function () {
  return this.attributions_;
};

/**
 * Get the projection of the source.
 * @return {module:ol/proj/Projection} Projection.
 * @api
 */
Source.prototype.getProjection = function () {
  return this.projection_;
};

/**
 * @abstract
 * @return {Array.<number>|undefined} Resolutions.
 */
Source.prototype.getResolutions = function () {};

/**
 * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
 * @return {module:ol/source/State} State.
 * @api
 */
Source.prototype.getState = function () {
  return this.state_;
};

/**
 * @return {boolean|undefined} Wrap X.
 */
Source.prototype.getWrapX = function () {
  return this.wrapX_;
};

/**
 * Refreshes the source and finally dispatches a 'change' event.
 * @api
 */
Source.prototype.refresh = function () {
  this.changed();
};

/**
 * Set the attributions of the source.
 * @param {module:ol/source/Source~AttributionLike|undefined} attributions Attributions.
 *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,
 *     or `undefined`.
 * @api
 */
Source.prototype.setAttributions = function (attributions) {
  this.attributions_ = this.adaptAttributions_(attributions);
  this.changed();
};

/**
 * Set the state of the source.
 * @param {module:ol/source/State} state State.
 * @protected
 */
Source.prototype.setState = function (state) {
  this.state_ = state;
  this.changed();
};
exports.default = Source;

/***/ }),

/***/ "./node_modules/ol/source/State.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/State.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/source/State
 */

/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */
exports.default = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};

/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TileSourceEvent = undefined;

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _functions = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");

var _TileCache = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");

var _TileCache2 = _interopRequireDefault(_TileCache);

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _Event = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");

var _Event2 = _interopRequireDefault(_Event);

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

var _size = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");

var _Source = __webpack_require__(/*! ../source/Source.js */ "./node_modules/ol/source/Source.js");

var _Source2 = _interopRequireDefault(_Source);

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

var _tilegrid = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {number} [cacheSize]
 * @property {module:ol/extent~Extent} [extent]
 * @property {boolean} [opaque]
 * @property {number} [tilePixelRatio]
 * @property {module:ol/proj~ProjectionLike} [projection]
 * @property {module:ol/source/State} [state]
 * @property {module:ol/tilegrid/TileGrid} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @abstract
 * @extends {module:ol/source/Source}
 * @param {module:ol/source/Tile~Options=} options SourceTile source options.
 * @api
 */
/**
 * @module ol/source/Tile
 */
var TileSource = function TileSource(options) {

  _Source2.default.call(this, {
    attributions: options.attributions,
    extent: options.extent,
    projection: options.projection,
    state: options.state,
    wrapX: options.wrapX
  });

  /**
   * @private
   * @type {boolean}
   */
  this.opaque_ = options.opaque !== undefined ? options.opaque : false;

  /**
   * @private
   * @type {number}
   */
  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

  /**
   * @protected
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

  /**
   * @protected
   * @type {module:ol/TileCache}
   */
  this.tileCache = new _TileCache2.default(options.cacheSize);

  /**
   * @protected
   * @type {module:ol/size~Size}
   */
  this.tmpSize = [0, 0];

  /**
   * @private
   * @type {string}
   */
  this.key_ = '';

  /**
   * @protected
   * @type {module:ol/Tile~Options}
   */
  this.tileOptions = { transition: options.transition };
};

(0, _index.inherits)(TileSource, _Source2.default);

/**
 * @return {boolean} Can expire cache.
 */
TileSource.prototype.canExpireCache = function () {
  return this.tileCache.canExpireCache();
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
 */
TileSource.prototype.expireCache = function (projection, usedTiles) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (tileCache) {
    tileCache.expireCache(usedTiles);
  }
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @param {number} z Zoom level.
 * @param {module:ol/TileRange} tileRange Tile range.
 * @param {function(module:ol/Tile):(boolean|undefined)} callback Called with each
 *     loaded tile.  If the callback returns `false`, the tile will not be
 *     considered loaded.
 * @return {boolean} The tile range is fully covered with loaded tiles.
 */
TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (!tileCache) {
    return false;
  }

  var covered = true;
  var tile = void 0,
      tileCoordKey = void 0,
      loaded = void 0;
  for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
      loaded = false;
      if (tileCache.containsKey(tileCoordKey)) {
        tile = /** @type {!module:ol/Tile} */tileCache.get(tileCoordKey);
        loaded = tile.getState() === _TileState2.default.LOADED;
        if (loaded) {
          loaded = callback(tile) !== false;
        }
      }
      if (!loaded) {
        covered = false;
      }
    }
  }
  return covered;
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {number} Gutter.
 */
TileSource.prototype.getGutter = function (projection) {
  return 0;
};

/**
 * Return the key to be used for all tiles in the source.
 * @return {string} The key for all tiles.
 * @protected
 */
TileSource.prototype.getKey = function () {
  return this.key_;
};

/**
 * Set the value to be used as the key for all tiles in the source.
 * @param {string} key The key for tiles.
 * @protected
 */
TileSource.prototype.setKey = function (key) {
  if (this.key_ !== key) {
    this.key_ = key;
    this.changed();
  }
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {boolean} Opaque.
 */
TileSource.prototype.getOpaque = function (projection) {
  return this.opaque_;
};

/**
 * @inheritDoc
 */
TileSource.prototype.getResolutions = function () {
  return this.tileGrid.getResolutions();
};

/**
 * @abstract
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/Tile} Tile.
 */
TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {};

/**
 * Return the tile grid of the tile source.
 * @return {module:ol/tilegrid/TileGrid} Tile grid.
 * @api
 */
TileSource.prototype.getTileGrid = function () {
  return this.tileGrid;
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/tilegrid/TileGrid} Tile grid.
 */
TileSource.prototype.getTileGridForProjection = function (projection) {
  if (!this.tileGrid) {
    return (0, _tilegrid.getForProjection)(projection);
  } else {
    return this.tileGrid;
  }
};

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {module:ol/TileCache} Tile cache.
 * @protected
 */
TileSource.prototype.getTileCacheForProjection = function (projection) {
  var thisProj = this.getProjection();
  if (thisProj && !(0, _proj.equivalent)(thisProj, projection)) {
    return null;
  } else {
    return this.tileCache;
  }
};

/**
 * Get the tile pixel ratio for this source. Subclasses may override this
 * method, which is meant to return a supported pixel ratio that matches the
 * provided `pixelRatio` as close as possible.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Tile pixel ratio.
 */
TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
  return this.tilePixelRatio_;
};

/**
 * @param {number} z Z.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {module:ol/size~Size} Tile size.
 */
TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
  var tileGrid = this.getTileGridForProjection(projection);
  var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
  var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);
  if (tilePixelRatio == 1) {
    return tileSize;
  } else {
    return (0, _size.scale)(tileSize, tilePixelRatio, this.tmpSize);
  }
};

/**
 * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
 * is outside the resolution and extent range of the tile grid, `null` will be
 * returned.
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/proj/Projection=} opt_projection Projection.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate to be passed to the tileUrlFunction or
 *     null if no tile URL should be created for the passed `tileCoord`.
 */
TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
  var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
  var tileGrid = this.getTileGridForProjection(projection);
  if (this.getWrapX() && projection.isGlobal()) {
    tileCoord = (0, _tilegrid.wrapX)(tileGrid, tileCoord, projection);
  }
  return (0, _tilecoord.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
};

/**
 * @inheritDoc
 */
TileSource.prototype.refresh = function () {
  this.tileCache.clear();
  this.changed();
};

/**
 * Marks a tile coord as being used, without triggering a load.
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {module:ol/proj/Projection} projection Projection.
 */
TileSource.prototype.useTile = _functions.UNDEFINED;

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {module:ol/events/Event}
 * @param {string} type Type.
 * @param {module:ol/Tile} tile The tile.
 */
var TileSourceEvent = exports.TileSourceEvent = function TileSourceEvent(type, tile) {

  _Event2.default.call(this, type);

  /**
   * The tile related to the event.
   * @type {module:ol/Tile}
   * @api
   */
  this.tile = tile;
};
(0, _index.inherits)(TileSourceEvent, _Event2.default);

exports.default = TileSource;

/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
exports.default = {

  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile~TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile~TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile~TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

};

/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _ImageTile = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");

var _ImageTile2 = _interopRequireDefault(_ImageTile);

var _TileCache = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");

var _TileCache2 = _interopRequireDefault(_TileCache);

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _events = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");

var _EventType = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

var _proj = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");

var _Tile = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _UrlTile = __webpack_require__(/*! ../source/UrlTile.js */ "./node_modules/ol/source/UrlTile.js");

var _UrlTile2 = _interopRequireDefault(_UrlTile);

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

var _tilegrid = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {module:ol/proj~ProjectionLike} projection Projection.
 * @property {boolean} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {module:ol/source/State} [state] Source state.
 * @property {module:ol/ImageTile~TileClass} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array.<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @fires module:ol/source/Tile~TileSourceEvent
 * @extends {module:ol/source/UrlTile}
 * @param {module:ol/source/TileImage~Options=} options Image tile options.
 * @api
 */
/**
 * @module ol/source/TileImage
 */
var TileImage = function TileImage(options) {

  _UrlTile2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX,
    transition: options.transition
  });

  /**
   * @protected
   * @type {?string}
   */
  this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;

  /**
   * @protected
   * @type {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord, module:ol/TileState, string,
   *        ?string, module:ol/Tile~LoadFunction, module:ol/Tile~Options=)}
   */
  this.tileClass = options.tileClass !== undefined ? options.tileClass : _ImageTile2.default;

  /**
   * @protected
   * @type {!Object.<string, module:ol/TileCache>}
   */
  this.tileCacheForProjection = {};

  /**
   * @protected
   * @type {!Object.<string, module:ol/tilegrid/TileGrid>}
   */
  this.tileGridForProjection = {};

  /**
   * @private
   * @type {number|undefined}
   */
  this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

  /**
   * @private
   * @type {boolean}
   */
  this.renderReprojectionEdges_ = false;
};

(0, _index.inherits)(TileImage, _UrlTile2.default);

/**
 * @inheritDoc
 */
TileImage.prototype.canExpireCache = function () {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    return _UrlTile2.default.prototype.canExpireCache.call(this);
  }
  if (this.tileCache.canExpireCache()) {
    return true;
  } else {
    for (var key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
  }
  return false;
};

/**
 * @inheritDoc
 */
TileImage.prototype.expireCache = function (projection, usedTiles) {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    _UrlTile2.default.prototype.expireCache.call(this, projection, usedTiles);
    return;
  }
  var usedTileCache = this.getTileCacheForProjection(projection);

  this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
  for (var id in this.tileCacheForProjection) {
    var tileCache = this.tileCacheForProjection[id];
    tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
  }
};

/**
 * @inheritDoc
 */
TileImage.prototype.getGutter = function (projection) {
  if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
    return 0;
  } else {
    return this.getGutterInternal();
  }
};

/**
 * @protected
 * @return {number} Gutter.
 */
TileImage.prototype.getGutterInternal = function () {
  return 0;
};

/**
 * @inheritDoc
 */
TileImage.prototype.getOpaque = function (projection) {
  if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
    return false;
  } else {
    return _UrlTile2.default.prototype.getOpaque.call(this, projection);
  }
};

/**
 * @inheritDoc
 */
TileImage.prototype.getTileGridForProjection = function (projection) {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    return _UrlTile2.default.prototype.getTileGridForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (this.tileGrid && (!thisProj || (0, _proj.equivalent)(thisProj, projection))) {
    return this.tileGrid;
  } else {
    var projKey = (0, _index.getUid)(projection).toString();
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = (0, _tilegrid.getForProjection)(projection);
    }
    return (
      /** @type {!module:ol/tilegrid/TileGrid} */this.tileGridForProjection[projKey]
    );
  }
};

/**
 * @inheritDoc
 */
TileImage.prototype.getTileCacheForProjection = function (projection) {
  if (!_common.ENABLE_RASTER_REPROJECTION) {
    return _UrlTile2.default.prototype.getTileCacheForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();if (!thisProj || (0, _proj.equivalent)(thisProj, projection)) {
    return this.tileCache;
  } else {
    var projKey = (0, _index.getUid)(projection).toString();
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new _TileCache2.default(this.tileCache.highWaterMark);
    }
    return this.tileCacheForProjection[projKey];
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @param {string} key The key set on the tile.
 * @return {!module:ol/Tile} Tile.
 * @private
 */
TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
  var tileCoord = [z, x, y];
  var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
  var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
  var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _TileState2.default.IDLE : _TileState2.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
  tile.key = key;
  (0, _events.listen)(tile, _EventType2.default.CHANGE, this.handleTileChange, this);
  return tile;
};

/**
 * @inheritDoc
 */
TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  var sourceProjection = /** @type {!module:ol/proj/Projection} */this.getProjection();
  if (!_common.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || (0, _proj.equivalent)(sourceProjection, projection)) {
    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
  } else {
    var cache = this.getTileCacheForProjection(projection);
    var tileCoord = [z, x, y];
    var tile = void 0;
    var tileCoordKey = (0, _tilecoord.getKey)(tileCoord);
    if (cache.containsKey(tileCoordKey)) {
      tile = /** @type {!module:ol/Tile} */cache.get(tileCoordKey);
    }
    var key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    } else {
      var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
      var targetTileGrid = this.getTileGridForProjection(projection);
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var newTile = new _Tile2.default(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutterInternal(), function (z, x, y, pixelRatio) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
      }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
      newTile.key = key;

      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        cache.replace(tileCoordKey, newTile);
      } else {
        cache.set(tileCoordKey, newTile);
      }
      return newTile;
    }
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {!module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/Tile} Tile.
 * @protected
 */
TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
  var tile = null;
  var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
  var key = this.getKey();
  if (!this.tileCache.containsKey(tileCoordKey)) {
    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
    this.tileCache.set(tileCoordKey, tile);
  } else {
    tile = this.tileCache.get(tileCoordKey);
    if (tile.key != key) {
      // The source's params changed. If the tile has an interim tile and if we
      // can use it then we use it. Otherwise we create a new tile.  In both
      // cases we attempt to assign an interim tile to the new tile.
      var interimTile = tile;
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);

      //make the new tile the head of the list,
      if (interimTile.getState() == _TileState2.default.IDLE) {
        //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
        tile.interimTile = interimTile.interimTile;
      } else {
        tile.interimTile = interimTile;
      }
      tile.refreshInterimChain();
      this.tileCache.replace(tileCoordKey, tile);
    }
  }
  return tile;
};

/**
 * Sets whether to render reprojection edges or not (usually for debugging).
 * @param {boolean} render Render the edges.
 * @api
 */
TileImage.prototype.setRenderReprojectionEdges = function (render) {
  if (!_common.ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
    return;
  }
  this.renderReprojectionEdges_ = render;
  for (var id in this.tileCacheForProjection) {
    this.tileCacheForProjection[id].clear();
  }
  this.changed();
};

/**
 * Sets the tile grid to use when reprojecting the tiles to the given
 * projection instead of the default tile grid for the projection.
 *
 * This can be useful when the default tile grid cannot be created
 * (e.g. projection has no extent defined) or
 * for optimization reasons (custom tile size, resolutions, ...).
 *
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @param {module:ol/tilegrid/TileGrid} tilegrid Tile grid to use for the projection.
 * @api
 */
TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
  if (_common.ENABLE_RASTER_REPROJECTION) {
    var proj = (0, _proj.get)(projection);
    if (proj) {
      var projKey = (0, _index.getUid)(proj).toString();
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};

/**
 * @param {module:ol/ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}

exports.default = TileImage;

/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _TileState = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");

var _TileState2 = _interopRequireDefault(_TileState);

var _tileurlfunction = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");

var _Tile = __webpack_require__(/*! ../source/Tile.js */ "./node_modules/ol/source/Tile.js");

var _Tile2 = _interopRequireDefault(_Tile);

var _TileEventType = __webpack_require__(/*! ../source/TileEventType.js */ "./node_modules/ol/source/TileEventType.js");

var _TileEventType2 = _interopRequireDefault(_TileEventType);

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {number} [cacheSize]
 * @property {module:ol/extent~Extent} [extent]
 * @property {boolean} [opaque]
 * @property {module:ol/proj~ProjectionLike} [projection]
 * @property {module:ol/source/State} [state]
 * @property {module:ol/tilegrid/TileGrid} [tileGrid]
 * @property {module:ol/Tile~LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array.<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @constructor
 * @abstract
 * @fires module:ol/source/TileEvent
 * @extends {module:ol/source/Tile}
 * @param {module:ol/source/UrlTile~Options=} options Image tile options.
 */
/**
 * @module ol/source/UrlTile
 */
var UrlTile = function UrlTile(options) {

  _Tile2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tilePixelRatio: options.tilePixelRatio,
    wrapX: options.wrapX,
    transition: options.transition
  });

  /**
   * @protected
   * @type {module:ol/Tile~LoadFunction}
   */
  this.tileLoadFunction = options.tileLoadFunction;

  /**
   * @protected
   * @type {module:ol/Tile~UrlFunction}
   */
  this.tileUrlFunction = this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction.nullTileUrlFunction;

  /**
   * @protected
   * @type {!Array.<string>|null}
   */
  this.urls = null;

  if (options.urls) {
    this.setUrls(options.urls);
  } else if (options.url) {
    this.setUrl(options.url);
  }
  if (options.tileUrlFunction) {
    this.setTileUrlFunction(options.tileUrlFunction);
  }

  /**
   * @private
   * @type {!Object.<number, boolean>}
   */
  this.tileLoadingKeys_ = {};
};

(0, _index.inherits)(UrlTile, _Tile2.default);

/**
 * @type {module:ol/Tile~UrlFunction|undefined}
 * @protected
 */
UrlTile.prototype.fixedTileUrlFunction;

/**
 * Return the tile load function of the source.
 * @return {module:ol/Tile~LoadFunction} TileLoadFunction
 * @api
 */
UrlTile.prototype.getTileLoadFunction = function () {
  return this.tileLoadFunction;
};

/**
 * Return the tile URL function of the source.
 * @return {module:ol/Tile~UrlFunction} TileUrlFunction
 * @api
 */
UrlTile.prototype.getTileUrlFunction = function () {
  return this.tileUrlFunction;
};

/**
 * Return the URLs used for this source.
 * When a tileUrlFunction is used instead of url or urls,
 * null will be returned.
 * @return {!Array.<string>|null} URLs.
 * @api
 */
UrlTile.prototype.getUrls = function () {
  return this.urls;
};

/**
 * Handle tile change events.
 * @param {module:ol/events/Event} event Event.
 * @protected
 */
UrlTile.prototype.handleTileChange = function (event) {
  var tile = /** @type {module:ol/Tile} */event.target;
  var uid = (0, _index.getUid)(tile);
  var tileState = tile.getState();
  var type = void 0;
  if (tileState == _TileState2.default.LOADING) {
    this.tileLoadingKeys_[uid] = true;
    type = _TileEventType2.default.TILELOADSTART;
  } else if (uid in this.tileLoadingKeys_) {
    delete this.tileLoadingKeys_[uid];
    type = tileState == _TileState2.default.ERROR ? _TileEventType2.default.TILELOADERROR : tileState == _TileState2.default.LOADED || tileState == _TileState2.default.ABORT ? _TileEventType2.default.TILELOADEND : undefined;
  }
  if (type != undefined) {
    this.dispatchEvent(new _Tile.TileSourceEvent(type, tile));
  }
};

/**
 * Set the tile load function of the source.
 * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.
 * @api
 */
UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
  this.tileCache.clear();
  this.tileLoadFunction = tileLoadFunction;
  this.changed();
};

/**
 * Set the tile URL function of the source.
 * @param {module:ol/Tile~UrlFunction} tileUrlFunction Tile URL function.
 * @param {string=} opt_key Optional new tile key for the source.
 * @api
 */
UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, opt_key) {
  this.tileUrlFunction = tileUrlFunction;
  this.tileCache.pruneExceptNewestZ();
  if (typeof opt_key !== 'undefined') {
    this.setKey(opt_key);
  } else {
    this.changed();
  }
};

/**
 * Set the URL to use for requests.
 * @param {string} url URL.
 * @api
 */
UrlTile.prototype.setUrl = function (url) {
  var urls = this.urls = (0, _tileurlfunction.expandUrl)(url);
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : (0, _tileurlfunction.createFromTemplates)(urls, this.tileGrid), url);
};

/**
 * Set the URLs to use for requests.
 * @param {Array.<string>} urls URLs.
 * @api
 */
UrlTile.prototype.setUrls = function (urls) {
  this.urls = urls;
  var key = urls.join('\n');
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : (0, _tileurlfunction.createFromTemplates)(urls, this.tileGrid), key);
};

/**
 * @inheritDoc
 */
UrlTile.prototype.useTile = function (z, x, y) {
  var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};
exports.default = UrlTile;

/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _TileImage = __webpack_require__(/*! ../source/TileImage.js */ "./node_modules/ol/source/TileImage.js");

var _TileImage2 = _interopRequireDefault(_TileImage);

var _tilegrid = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {boolean} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=18] Optional max zoom level.
 * @property {number} [minZoom=0] Optional min zoom level.
 * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|module:ol/size~Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if url or urls are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array.<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 *
 * @constructor
 * @extends {module:ol/source/TileImage}
 * @param {module:ol/source/XYZ~Options=} opt_options XYZ options.
 * @api
 */
var XYZ = function XYZ(opt_options) {
  var options = opt_options || {};
  var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';

  var tileGrid = options.tileGrid !== undefined ? options.tileGrid : (0, _tilegrid.createXYZ)({
    extent: (0, _tilegrid.extentFromProjection)(projection),
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileSize: options.tileSize
  });

  _TileImage2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    opaque: options.opaque,
    projection: projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileGrid: tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });
}; /**
    * @module ol/source/XYZ
    */


(0, _index.inherits)(XYZ, _TileImage2.default);
exports.default = XYZ;

/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_RADIUS = undefined;
exports.getDistance = getDistance;
exports.getLength = getLength;
exports.getArea = getArea;
exports.offset = offset;

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _GeometryType = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");

var _GeometryType2 = _interopRequireDefault(_GeometryType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the
 * earth is used (Clarke 1866 Authalic Sphere).
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

/**
 * @module ol/sphere
 */
var DEFAULT_RADIUS = exports.DEFAULT_RADIUS = 6371008.8;

/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lat2 = (0, _math.toRadians)(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = (0, _math.toRadians)(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}

/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {module:ol/geom/Geometry} geometry A geometry.
 * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _GeometryType2.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var length = 0;
  var coordinates = void 0,
      coords = void 0,
      i = void 0,
      ii = void 0,
      j = void 0,
      jj = void 0;
  switch (type) {
    case _GeometryType2.default.POINT:
    case _GeometryType2.default.MULTI_POINT:
      {
        break;
      }
    case _GeometryType2.default.LINE_STRING:
    case _GeometryType2.default.LINEAR_RING:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        length = getLengthInternal(coordinates, radius);
        break;
      }
    case _GeometryType2.default.MULTI_LINE_STRING:
    case _GeometryType2.default.POLYGON:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += getLengthInternal(coordinates[i], radius);
        }
        break;
      }
    case _GeometryType2.default.MULTI_POLYGON:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += getLengthInternal(coords[j], radius);
          }
        }
        break;
      }
    case _GeometryType2.default.GEOMETRY_COLLECTION:
      {
        var geometries = /** @type {module:ol/geom/GeometryCollection} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += getLength(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return length;
}

/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += (0, _math.toRadians)(x2 - x1) * (2 + Math.sin((0, _math.toRadians)(y1)) + Math.sin((0, _math.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
}

/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {module:ol/geom/Geometry} geometry A geometry.
 * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _GeometryType2.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var area = 0;
  var coordinates = void 0,
      coords = void 0,
      i = void 0,
      ii = void 0,
      j = void 0,
      jj = void 0;
  switch (type) {
    case _GeometryType2.default.POINT:
    case _GeometryType2.default.MULTI_POINT:
    case _GeometryType2.default.LINE_STRING:
    case _GeometryType2.default.MULTI_LINE_STRING:
    case _GeometryType2.default.LINEAR_RING:
      {
        break;
      }
    case _GeometryType2.default.POLYGON:
      {
        coordinates = /** @type {module:ol/geom/Polygon} */geometry.getCoordinates();
        area = Math.abs(getAreaInternal(coordinates[0], radius));
        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(getAreaInternal(coordinates[i], radius));
        }
        break;
      }
    case _GeometryType2.default.MULTI_POLYGON:
      {
        coordinates = /** @type {module:ol/geom/SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(getAreaInternal(coords[0], radius));
          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }
        break;
      }
    case _GeometryType2.default.GEOMETRY_COLLECTION:
      {
        var geometries = /** @type {module:ol/geom/GeometryCollection} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += getArea(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return area;
}

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {module:ol/coordinate~Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {module:ol/coordinate~Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lon1 = (0, _math.toRadians)(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];
}

/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ../index.js */ "./node_modules/ol/index.js");

var _asserts = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");

var _EventTarget = __webpack_require__(/*! ../events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");

var _EventTarget2 = _interopRequireDefault(_EventTarget);

var _EventType = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");

var _EventType2 = _interopRequireDefault(_EventType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */

/**
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 * @constructor
 * @extends {module:ol/events/EventTarget}
 * @fires module:ol/events/Event~Event
 * @struct
 * @template T
 * @param {number=} opt_highWaterMark High water mark.
 */
/**
 * @module ol/structs/LRUCache
 */
var LRUCache = function LRUCache(opt_highWaterMark) {

  _EventTarget2.default.call(this);

  /**
   * @type {number}
   */
  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

  /**
   * @private
   * @type {number}
   */
  this.count_ = 0;

  /**
   * @private
   * @type {!Object.<string, module:ol/structs/LRUCache~Entry>}
   */
  this.entries_ = {};

  /**
   * @private
   * @type {?module:ol/structs/LRUCache~Entry}
   */
  this.oldest_ = null;

  /**
   * @private
   * @type {?module:ol/structs/LRUCache~Entry}
   */
  this.newest_ = null;
};

(0, _index.inherits)(LRUCache, _EventTarget2.default);

/**
 * @return {boolean} Can expire cache.
 */
LRUCache.prototype.canExpireCache = function () {
  return this.getCount() > this.highWaterMark;
};

/**
 * FIXME empty description for jsdoc
 */
LRUCache.prototype.clear = function () {
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
  this.dispatchEvent(_EventType2.default.CLEAR);
};

/**
 * @param {string} key Key.
 * @return {boolean} Contains key.
 */
LRUCache.prototype.containsKey = function (key) {
  return this.entries_.hasOwnProperty(key);
};

/**
 * @param {function(this: S, T, string, module:ol/structs/LRUCache): ?} f The function
 *     to call for every entry from the oldest to the newer. This function takes
 *     3 arguments (the entry value, the entry key and the LRUCache object).
 *     The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 */
LRUCache.prototype.forEach = function (f, opt_this) {
  var entry = this.oldest_;
  while (entry) {
    f.call(opt_this, entry.value_, entry.key_, this);
    entry = entry.newer;
  }
};

/**
 * @param {string} key Key.
 * @return {T} Value.
 */
LRUCache.prototype.get = function (key) {
  var entry = this.entries_[key];
  (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
  if (entry === this.newest_) {
    return entry.value_;
  } else if (entry === this.oldest_) {
    this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */this.oldest_.newer;
    this.oldest_.older = null;
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }
  entry.newer = null;
  entry.older = this.newest_;
  this.newest_.newer = entry;
  this.newest_ = entry;
  return entry.value_;
};

/**
 * Remove an entry from the cache.
 * @param {string} key The entry key.
 * @return {T} The removed entry.
 */
LRUCache.prototype.remove = function (key) {
  var entry = this.entries_[key];
  (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
  if (entry === this.newest_) {
    this.newest_ = /** @type {module:ol/structs/LRUCache~Entry} */entry.older;
    if (this.newest_) {
      this.newest_.newer = null;
    }
  } else if (entry === this.oldest_) {
    this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */entry.newer;
    if (this.oldest_) {
      this.oldest_.older = null;
    }
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }
  delete this.entries_[key];
  --this.count_;
  return entry.value_;
};

/**
 * @return {number} Count.
 */
LRUCache.prototype.getCount = function () {
  return this.count_;
};

/**
 * @return {Array.<string>} Keys.
 */
LRUCache.prototype.getKeys = function () {
  var keys = new Array(this.count_);
  var i = 0;
  var entry = void 0;
  for (entry = this.newest_; entry; entry = entry.older) {
    keys[i++] = entry.key_;
  }
  return keys;
};

/**
 * @return {Array.<T>} Values.
 */
LRUCache.prototype.getValues = function () {
  var values = new Array(this.count_);
  var i = 0;
  var entry = void 0;
  for (entry = this.newest_; entry; entry = entry.older) {
    values[i++] = entry.value_;
  }
  return values;
};

/**
 * @return {T} Last value.
 */
LRUCache.prototype.peekLast = function () {
  return this.oldest_.value_;
};

/**
 * @return {string} Last key.
 */
LRUCache.prototype.peekLastKey = function () {
  return this.oldest_.key_;
};

/**
 * Get the key of the newest item in the cache.  Throws if the cache is empty.
 * @return {string} The newest key.
 */
LRUCache.prototype.peekFirstKey = function () {
  return this.newest_.key_;
};

/**
 * @return {T} value Value.
 */
LRUCache.prototype.pop = function () {
  var entry = this.oldest_;
  delete this.entries_[entry.key_];
  if (entry.newer) {
    entry.newer.older = null;
  }
  this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */entry.newer;
  if (!this.oldest_) {
    this.newest_ = null;
  }
  --this.count_;
  return entry.value_;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
LRUCache.prototype.replace = function (key, value) {
  this.get(key); // update `newest_`
  this.entries_[key].value_ = value;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
LRUCache.prototype.set = function (key, value) {
  (0, _asserts.assert)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
  var entry = /** @type {module:ol/structs/LRUCache~Entry} */{
    key_: key,
    newer: null,
    older: this.newest_,
    value_: value
  };
  if (!this.newest_) {
    this.oldest_ = entry;
  } else {
    this.newest_.newer = entry;
  }
  this.newest_ = entry;
  this.entries_[key] = entry;
  ++this.count_;
};

/**
 * Set a maximum number of entries for the cache.
 * @param {number} size Cache size.
 * @api
 */
LRUCache.prototype.setSize = function (size) {
  this.highWaterMark = size;
};

/**
 * Prune the cache.
 */
LRUCache.prototype.prune = function () {
  while (this.canExpireCache()) {
    this.pop();
  }
};
exports.default = LRUCache;

/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.getKeyZXY = getKeyZXY;
exports.getKey = getKey;
exports.fromKey = fromKey;
exports.hash = hash;
exports.quadKey = quadKey;
exports.withinExtentAndZ = withinExtentAndZ;
/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
 * @typedef {Array.<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Tile coordinate.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}

/**
 * Get the key for a tile coord.
 * @param {module:ol/tilecoord~TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}

/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {module:ol/tilecoord~TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i = void 0,
      charCode = void 0;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {!module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange = void 0;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}

/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getForProjection = getForProjection;
exports.wrapX = wrapX;
exports.createForExtent = createForExtent;
exports.createXYZ = createXYZ;
exports.createForProjection = createForProjection;
exports.extentFromProjection = extentFromProjection;

var _common = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");

var _size = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");

var _extent = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");

var _Corner = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");

var _Corner2 = _interopRequireDefault(_Corner);

var _obj = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");

var _proj = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");

var _Units = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");

var _Units2 = _interopRequireDefault(_Units);

var _TileGrid = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");

var _TileGrid2 = _interopRequireDefault(_TileGrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/tilegrid/TileGrid} Default tile grid for the
 * passed projection.
 */
/**
 * @module ol/tilegrid
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}

/**
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!(0, _extent.containsCoordinate)(projectionExtent, center)) {
    var worldWidth = (0, _extent.getWidth)(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}

/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
 */
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _Corner2.default.TOP_LEFT;

  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _TileGrid2.default({
    extent: extent,
    origin: (0, _extent.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}

/**
 * @typedef {Object} XYZOptions
 * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the
 * provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|module:ol/size~Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {module:ol/tilegrid~XYZOptions=} opt_options Tile grid options.
 * @return {!module:ol/tilegrid/TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(opt_options) {
  var options = /** @type {module:ol/tilegrid/TileGrid~Options} */{};
  (0, _obj.assign)(options, opt_options !== undefined ? opt_options : /** @type {module:ol/tilegrid~XYZOptions} */{});
  if (options.extent === undefined) {
    options.extent = (0, _proj.get)('EPSG:3857').getExtent();
  }
  options.resolutions = resolutionsFromExtent(options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;

  return new _TileGrid2.default(options);
}

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _common.DEFAULT_MAX_ZOOM;

  var height = (0, _extent.getHeight)(extent);
  var width = (0, _extent.getWidth)(extent);

  var tileSize = (0, _size.toSize)(opt_tileSize !== undefined ? opt_tileSize : _common.DEFAULT_TILE_SIZE);
  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}

/**
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
 */
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @return {module:ol/extent~Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = (0, _proj.get)(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj.METERS_PER_UNIT[_Units2.default.DEGREES] / projection.getMetersPerUnit();
    extent = (0, _extent.createOrUpdate)(-half, -half, half, half);
  }
  return extent;
}

/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");

var _asserts = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");

var _TileRange = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");

var _TileRange2 = _interopRequireDefault(_TileRange);

var _array = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");

var _extent = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");

var _math = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");

var _size = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");

var _tilecoord = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} Options
 * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {module:ol/coordinate~Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array.<module:ol/coordinate~Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array.<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array.<module:ol/size~Size>} [sizes] Sizes.
 * @property {number|module:ol/size~Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array.<module:ol/size~Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 *
 * @constructor
 * @param {module:ol/tilegrid/TileGrid~Options} options Tile grid options.
 * @struct
 * @api
 */
/**
 * @module ol/tilegrid/TileGrid
 */
var TileGrid = function TileGrid(options) {

  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array.<number>}
   */
  this.resolutions_ = options.resolutions;
  (0, _asserts.assert)((0, _array.isSorted)(this.resolutions_, function (a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order


  // check if we've got a consistent zoom factor and origin
  var zoomFactor = void 0;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }

  /**
   * @private
   * @type {number|undefined}
   */
  this.zoomFactor_ = zoomFactor;

  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {module:ol/coordinate~Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array.<module:ol/coordinate~Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    (0, _asserts.assert)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined && !this.origin_ && !this.origins_) {
    this.origin_ = (0, _extent.getTopLeft)(extent);
  }

  (0, _asserts.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array.<number|module:ol/size~Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    (0, _asserts.assert)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|module:ol/size~Size}
   */
  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _common.DEFAULT_TILE_SIZE : null;
  (0, _asserts.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;

  /**
   * @private
   * @type {Array.<module:ol/TileRange>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {module:ol/size~Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function (size, z) {
      var tileRange = new _TileRange2.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }
};

/**
 * @private
 * @type {module:ol/tilecoord~TileCoord}
 */
var tmpTileCoord = [0, 0, 0];

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(module:ol/tilecoord~TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, module:ol/TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange = void 0,
      x = void 0,
      y = void 0;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = (0, _TileRange.createOrUpdate)(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {module:ol/extent~Extent} Extent.
 */
TileGrid.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
TileGrid.prototype.getMaxZoom = function () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
TileGrid.prototype.getMinZoom = function () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {module:ol/coordinate~Coordinate} Origin.
 * @api
 */
TileGrid.prototype.getOrigin = function (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */
TileGrid.prototype.getResolution = function (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */
TileGrid.prototype.getResolutions = function () {
  return this.resolutions_;
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {module:ol/TileRange} Tile range.
 */
TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return (0, _TileRange.createOrUpdate)(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};

/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {module:ol/TileRange} tileRange Tile range.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {module:ol/extent~Extent} Extent.
 */
TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {module:ol/TileRange=} opt_tileRange Temporary tile range object.
 * @return {module:ol/TileRange} Tile range.
 */
TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
  var tileCoord = tmpTileCoord;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return (0, _TileRange.createOrUpdate)(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {module:ol/coordinate~Coordinate} Tile center.
 */
TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/extent~Extent=} opt_extent Temporary extent object.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.  This method is for integer zoom
 * levels.  The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `module:ol/size~Size`, run the result through `module:ol/size~Size.toSize()`.
 * @param {number} z Z.
 * @return {number|module:ol/size~Size} Tile size.
 * @api
 */
TileGrid.prototype.getTileSize = function (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {module:ol/TileRange} Extent tile range for the specified zoom level.
 */
TileGrid.prototype.getFullTileRange = function (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
  var z = (0, _array.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
  return (0, _math.clamp)(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!module:ol/extent~Extent} extent Extent for this tile grid.
 * @private
 */
TileGrid.prototype.calculateTileRanges_ = function (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};
exports.default = TileGrid;

/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = exports.DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = exports.DEFAULT_TILE_SIZE = 256;

/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFromTemplate = createFromTemplate;
exports.createFromTemplates = createFromTemplates;
exports.createFromTileUrlFunctions = createFromTileUrlFunctions;
exports.nullTileUrlFunction = nullTileUrlFunction;
exports.expandUrl = expandUrl;

var _asserts = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");

var _math = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");

var _tilecoord = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");

/**
 * @param {string} template Template.
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function () {
          var y = -tileCoord[2] - 1;
          return y.toString();
        }).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          (0, _asserts.assert)(range, 55); // The {-y} placeholder requires a tile grid with extent
          var y = range.getHeight() + tileCoord[2];
          return y.toString();
        });
      }
    }
  );
}

/**
 * @param {Array.<string>} templates Templates.
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
/**
 * @module ol/tileurlfunction
 */
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}

/**
 * @param {Array.<module:ol/Tile~UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = (0, _tilecoord.hash)(tileCoord);
        var index = (0, _math.modulo)(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}

/**
 * @param {string} url URL.
 * @return {Array.<string>} Array of urls.
 */
function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode = void 0;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

/***/ }),

/***/ "./node_modules/ol/webgl.js":
/*!**********************************!*\
  !*** ./node_modules/ol/webgl.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContext = getContext;
/**
 * @module ol/webgl
 */

/**
 * Constants taken from goog.webgl
 */

/**
 * @const
 * @type {number}
 */
var ONE = exports.ONE = 1;

/**
 * @const
 * @type {number}
 */
var SRC_ALPHA = exports.SRC_ALPHA = 0x0302;

/**
 * @const
 * @type {number}
 */
var COLOR_ATTACHMENT0 = exports.COLOR_ATTACHMENT0 = 0x8CE0;

/**
 * @const
 * @type {number}
 */
var COLOR_BUFFER_BIT = exports.COLOR_BUFFER_BIT = 0x00004000;

/**
 * @const
 * @type {number}
 */
var TRIANGLES = exports.TRIANGLES = 0x0004;

/**
 * @const
 * @type {number}
 */
var TRIANGLE_STRIP = exports.TRIANGLE_STRIP = 0x0005;

/**
 * @const
 * @type {number}
 */
var ONE_MINUS_SRC_ALPHA = exports.ONE_MINUS_SRC_ALPHA = 0x0303;

/**
 * @const
 * @type {number}
 */
var ARRAY_BUFFER = exports.ARRAY_BUFFER = 0x8892;

/**
 * @const
 * @type {number}
 */
var ELEMENT_ARRAY_BUFFER = exports.ELEMENT_ARRAY_BUFFER = 0x8893;

/**
 * @const
 * @type {number}
 */
var STREAM_DRAW = exports.STREAM_DRAW = 0x88E0;

/**
 * @const
 * @type {number}
 */
var STATIC_DRAW = exports.STATIC_DRAW = 0x88E4;

/**
 * @const
 * @type {number}
 */
var DYNAMIC_DRAW = exports.DYNAMIC_DRAW = 0x88E8;

/**
 * @const
 * @type {number}
 */
var CULL_FACE = exports.CULL_FACE = 0x0B44;

/**
 * @const
 * @type {number}
 */
var BLEND = exports.BLEND = 0x0BE2;

/**
 * @const
 * @type {number}
 */
var STENCIL_TEST = exports.STENCIL_TEST = 0x0B90;

/**
 * @const
 * @type {number}
 */
var DEPTH_TEST = exports.DEPTH_TEST = 0x0B71;

/**
 * @const
 * @type {number}
 */
var SCISSOR_TEST = exports.SCISSOR_TEST = 0x0C11;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_BYTE = exports.UNSIGNED_BYTE = 0x1401;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_SHORT = exports.UNSIGNED_SHORT = 0x1403;

/**
 * @const
 * @type {number}
 */
var UNSIGNED_INT = exports.UNSIGNED_INT = 0x1405;

/**
 * @const
 * @type {number}
 */
var FLOAT = exports.FLOAT = 0x1406;

/**
 * @const
 * @type {number}
 */
var RGBA = exports.RGBA = 0x1908;

/**
 * @const
 * @type {number}
 */
var FRAGMENT_SHADER = exports.FRAGMENT_SHADER = 0x8B30;

/**
 * @const
 * @type {number}
 */
var VERTEX_SHADER = exports.VERTEX_SHADER = 0x8B31;

/**
 * @const
 * @type {number}
 */
var LINK_STATUS = exports.LINK_STATUS = 0x8B82;

/**
 * @const
 * @type {number}
 */
var LINEAR = exports.LINEAR = 0x2601;

/**
 * @const
 * @type {number}
 */
var TEXTURE_MAG_FILTER = exports.TEXTURE_MAG_FILTER = 0x2800;

/**
 * @const
 * @type {number}
 */
var TEXTURE_MIN_FILTER = exports.TEXTURE_MIN_FILTER = 0x2801;

/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_S = exports.TEXTURE_WRAP_S = 0x2802;

/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_T = exports.TEXTURE_WRAP_T = 0x2803;

/**
 * @const
 * @type {number}
 */
var TEXTURE_2D = exports.TEXTURE_2D = 0x0DE1;

/**
 * @const
 * @type {number}
 */
var TEXTURE0 = exports.TEXTURE0 = 0x84C0;

/**
 * @const
 * @type {number}
 */
var CLAMP_TO_EDGE = exports.CLAMP_TO_EDGE = 0x812F;

/**
 * @const
 * @type {number}
 */
var COMPILE_STATUS = exports.COMPILE_STATUS = 0x8B81;

/**
 * @const
 * @type {number}
 */
var FRAMEBUFFER = exports.FRAMEBUFFER = 0x8D40;

/** end of goog.webgl constants
 */

/**
 * @const
 * @type {Array.<string>}
 */
var CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];

/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
function getContext(canvas, opt_attributes) {
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
      if (context) {
        return (/** @type {!WebGLRenderingContext} */context
        );
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}

/***/ }),

/***/ "./node_modules/webfont-matcher/lib/fonts/google.js":
/*!**********************************************************!*\
  !*** ./node_modules/webfont-matcher/lib/fonts/google.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Generated by CoffeeScript 1.10.0
(function () {
  var families;

  module.exports = {
    icon: 'icons/google.svg',
    name: 'google',
    title: 'Google Fonts',
    link: 'google.com/fonts',
    getNames: function getNames() {
      return families;
    },
    getLink: function getLink(name) {
      return "https://fonts.google.com/specimen/" + name.replace(/( )/g, '+');
    },
    normalizeName: function normalizeName(name) {
      return name;
    }
  };

  families = ["ABeeZee", "Abel", "Abril Fatface", "Aclonica", "Acme", "Actor", "Adamina", "Advent Pro", "Aguafina Script", "Akronim", "Aladin", "Aldrich", "Alef", "Alegreya", "Alegreya SC", "Alegreya Sans", "Alegreya Sans SC", "Alex Brush", "Alfa Slab One", "Alice", "Alike", "Alike Angular", "Allan", "Allerta", "Allerta Stencil", "Allura", "Almendra", "Almendra Display", "Almendra SC", "Amarante", "Amaranth", "Amatic SC", "Amethysta", "Amiri", "Amita", "Anaheim", "Andada", "Andika", "Angkor", "Annie Use Your Telescope", "Anonymous Pro", "Antic", "Antic Didone", "Antic Slab", "Anton", "Arapey", "Arbutus", "Arbutus Slab", "Architects Daughter", "Archivo Black", "Archivo Narrow", "Arimo", "Arizonia", "Armata", "Artifika", "Arvo", "Arya", "Asap", "Asar", "Asset", "Astloch", "Asul", "Atomic Age", "Aubrey", "Audiowide", "Autour One", "Average", "Average Sans", "Averia Gruesa Libre", "Averia Libre", "Averia Sans Libre", "Averia Serif Libre", "Bad Script", "Balthazar", "Bangers", "Basic", "Battambang", "Baumans", "Bayon", "Belgrano", "Belleza", "BenchNine", "Bentham", "Berkshire Swash", "Bevan", "Bigelow Rules", "Bigshot One", "Bilbo", "Bilbo Swash Caps", "Biryani", "Bitter", "Black Ops One", "Bokor", "Bonbon", "Boogaloo", "Bowlby One", "Bowlby One SC", "Brawler", "Bree Serif", "Bubblegum Sans", "Bubbler One", "Buda", "Buenard", "Butcherman", "Butterfly Kids", "Cabin", "Cabin Condensed", "Cabin Sketch", "Caesar Dressing", "Cagliostro", "Calligraffitti", "Cambay", "Cambo", "Candal", "Cantarell", "Cantata One", "Cantora One", "Capriola", "Cardo", "Carme", "Carrois Gothic", "Carrois Gothic SC", "Carter One", "Catamaran", "Caudex", "Caveat", "Caveat Brush", "Cedarville Cursive", "Ceviche One", "Changa One", "Chango", "Chau Philomene One", "Chela One", "Chelsea Market", "Chenla", "Cherry Cream Soda", "Cherry Swash", "Chewy", "Chicle", "Chivo", "Chonburi", "Cinzel", "Cinzel Decorative", "Clicker Script", "Coda", "Coda Caption", "Codystar", "Combo", "Comfortaa", "Coming Soon", "Concert One", "Condiment", "Content", "Contrail One", "Convergence", "Cookie", "Copse", "Corben", "Courgette", "Cousine", "Coustard", "Covered By Your Grace", "Crafty Girls", "Creepster", "Crete Round", "Crimson Text", "Croissant One", "Crushed", "Cuprum", "Cutive", "Cutive Mono", "Damion", "Dancing Script", "Dangrek", "Dawning of a New Day", "Days One", "Dekko", "Delius", "Delius Swash Caps", "Delius Unicase", "Della Respira", "Denk One", "Devonshire", "Dhurjati", "Didact Gothic", "Diplomata", "Diplomata SC", "Domine", "Donegal One", "Doppio One", "Dorsa", "Dosis", "Dr Sugiyama", "Droid Sans", "Droid Sans Mono", "Droid Serif", "Duru Sans", "Dynalight", "EB Garamond", "Eagle Lake", "Eater", "Economica", "Eczar", "Ek Mukta", "Electrolize", "Elsie", "Elsie Swash Caps", "Emblema One", "Emilys Candy", "Engagement", "Englebert", "Enriqueta", "Erica One", "Esteban", "Euphoria Script", "Ewert", "Exo", "Exo 2", "Expletus Sans", "Fanwood Text", "Fascinate", "Fascinate Inline", "Faster One", "Fasthand", "Fauna One", "Federant", "Federo", "Felipa", "Fenix", "Finger Paint", "Fira Mono", "Fira Sans", "Fjalla One", "Fjord One", "Flamenco", "Flavors", "Fondamento", "Fontdiner Swanky", "Forum", "Francois One", "Freckle Face", "Fredericka the Great", "Fredoka One", "Freehand", "Fresca", "Frijole", "Fruktur", "Fugaz One", "GFS Didot", "GFS Neohellenic", "Gabriela", "Gafata", "Galdeano", "Galindo", "Gentium Basic", "Gentium Book Basic", "Geo", "Geostar", "Geostar Fill", "Germania One", "Gidugu", "Gilda Display", "Give You Glory", "Glass Antiqua", "Glegoo", "Gloria Hallelujah", "Goblin One", "Gochi Hand", "Gorditas", "Goudy Bookletter 1911", "Graduate", "Grand Hotel", "Gravitas One", "Great Vibes", "Griffy", "Gruppo", "Gudea", "Gurajada", "Habibi", "Halant", "Hammersmith One", "Hanalei", "Hanalei Fill", "Handlee", "Hanuman", "Happy Monkey", "Headland One", "Henny Penny", "Herr Von Muellerhoff", "Hind", "Hind Siliguri", "Hind Vadodara", "Holtwood One SC", "Homemade Apple", "Homenaje", "IM Fell DW Pica", "IM Fell DW Pica SC", "IM Fell Double Pica", "IM Fell Double Pica SC", "IM Fell English", "IM Fell English SC", "IM Fell French Canon", "IM Fell French Canon SC", "IM Fell Great Primer", "IM Fell Great Primer SC", "Iceberg", "Iceland", "Imprima", "Inconsolata", "Inder", "Indie Flower", "Inika", "Inknut Antiqua", "Irish Grover", "Istok Web", "Italiana", "Italianno", "Itim", "Jacques Francois", "Jacques Francois Shadow", "Jaldi", "Jim Nightshade", "Jockey One", "Jolly Lodger", "Josefin Sans", "Josefin Slab", "Joti One", "Judson", "Julee", "Julius Sans One", "Junge", "Jura", "Just Another Hand", "Just Me Again Down Here", "Kadwa", "Kalam", "Kameron", "Kantumruy", "Karla", "Karma", "Kaushan Script", "Kavoon", "Kdam Thmor", "Keania One", "Kelly Slab", "Kenia", "Khand", "Khmer", "Khula", "Kite One", "Knewave", "Kotta One", "Koulen", "Kranky", "Kreon", "Kristi", "Krona One", "Kurale", "La Belle Aurore", "Laila", "Lakki Reddy", "Lancelot", "Lateef", "Lato", "League Script", "Leckerli One", "Ledger", "Lekton", "Lemon", "Libre Baskerville", "Life Savers", "Lilita One", "Lily Script One", "Limelight", "Linden Hill", "Lobster", "Lobster Two", "Londrina Outline", "Londrina Shadow", "Londrina Sketch", "Londrina Solid", "Lora", "Love Ya Like A Sister", "Loved by the King", "Lovers Quarrel", "Luckiest Guy", "Lusitana", "Lustria", "Macondo", "Macondo Swash Caps", "Magra", "Maiden Orange", "Mako", "Mallanna", "Mandali", "Marcellus", "Marcellus SC", "Marck Script", "Margarine", "Marko One", "Marmelad", "Martel", "Martel Sans", "Marvel", "Mate", "Mate SC", "Maven Pro", "McLaren", "Meddon", "MedievalSharp", "Medula One", "Megrim", "Meie Script", "Merienda", "Merienda One", "Merriweather", "Merriweather Sans", "Metal", "Metal Mania", "Metamorphous", "Metrophobic", "Michroma", "Milonga", "Miltonian", "Miltonian Tattoo", "Miniver", "Miss Fajardose", "Modak", "Modern Antiqua", "Molengo", "Molle", "Monda", "Monofett", "Monoton", "Monsieur La Doulaise", "Montaga", "Montez", "Montserrat", "Montserrat Alternates", "Montserrat Subrayada", "Moul", "Moulpali", "Mountains of Christmas", "Mouse Memoirs", "Mr Bedfort", "Mr Dafoe", "Mr De Haviland", "Mrs Saint Delafield", "Mrs Sheppards", "Muli", "Mystery Quest", "NTR", "Neucha", "Neuton", "New Rocker", "News Cycle", "Niconne", "Nixie One", "Nobile", "Nokora", "Norican", "Nosifer", "Nothing You Could Do", "Noticia Text", "Noto Sans", "Noto Serif", "Nova Cut", "Nova Flat", "Nova Mono", "Nova Oval", "Nova Round", "Nova Script", "Nova Slim", "Nova Square", "Numans", "Nunito", "Odor Mean Chey", "Offside", "Old Standard TT", "Oldenburg", "Oleo Script", "Oleo Script Swash Caps", "Open Sans", "Open Sans Condensed", "Oranienbaum", "Orbitron", "Oregano", "Orienta", "Original Surfer", "Oswald", "Over the Rainbow", "Overlock", "Overlock SC", "Ovo", "Oxygen", "Oxygen Mono", "PT Mono", "PT Sans", "PT Sans Caption", "PT Sans Narrow", "PT Serif", "PT Serif Caption", "Pacifico", "Palanquin", "Palanquin Dark", "Paprika", "Parisienne", "Passero One", "Passion One", "Pathway Gothic One", "Patrick Hand", "Patrick Hand SC", "Patua One", "Paytone One", "Peddana", "Peralta", "Permanent Marker", "Petit Formal Script", "Petrona", "Philosopher", "Piedra", "Pinyon Script", "Pirata One", "Plaster", "Play", "Playball", "Playfair Display", "Playfair Display SC", "Podkova", "Poiret One", "Poller One", "Poly", "Pompiere", "Pontano Sans", "Poppins", "Port Lligat Sans", "Port Lligat Slab", "Pragati Narrow", "Prata", "Preahvihear", "Press Start 2P", "Princess Sofia", "Prociono", "Prosto One", "Puritan", "Purple Purse", "Quando", "Quantico", "Quattrocento", "Quattrocento Sans", "Questrial", "Quicksand", "Quintessential", "Qwigley", "Racing Sans One", "Radley", "Rajdhani", "Raleway", "Raleway Dots", "Ramabhadra", "Ramaraja", "Rambla", "Rammetto One", "Ranchers", "Rancho", "Ranga", "Rationale", "Ravi Prakash", "Redressed", "Reenie Beanie", "Revalia", "Rhodium Libre", "Ribeye", "Ribeye Marrow", "Righteous", "Risque", "Roboto", "Roboto Condensed", "Roboto Mono", "Roboto Slab", "Rochester", "Rock Salt", "Rokkitt", "Romanesco", "Ropa Sans", "Rosario", "Rosarivo", "Rouge Script", "Rozha One", "Rubik", "Rubik Mono One", "Rubik One", "Ruda", "Rufina", "Ruge Boogie", "Ruluko", "Rum Raisin", "Ruslan Display", "Russo One", "Ruthie", "Rye", "Sacramento", "Sahitya", "Sail", "Salsa", "Sanchez", "Sancreek", "Sansita One", "Sarala", "Sarina", "Sarpanch", "Satisfy", "Scada", "Scheherazade", "Schoolbell", "Seaweed Script", "Sevillana", "Seymour One", "Shadows Into Light", "Shadows Into Light Two", "Shanti", "Share", "Share Tech", "Share Tech Mono", "Shojumaru", "Short Stack", "Siemreap", "Sigmar One", "Signika", "Signika Negative", "Simonetta", "Sintony", "Sirin Stencil", "Six Caps", "Skranji", "Slabo 13px", "Slabo 27px", "Slackey", "Smokum", "Smythe", "Sniglet", "Snippet", "Snowburst One", "Sofadi One", "Sofia", "Sonsie One", "Sorts Mill Goudy", "Source Code Pro", "Source Sans Pro", "Source Serif Pro", "Special Elite", "Spicy Rice", "Spinnaker", "Spirax", "Squada One", "Sree Krushnadevaraya", "Stalemate", "Stalinist One", "Stardos Stencil", "Stint Ultra Condensed", "Stint Ultra Expanded", "Stoke", "Strait", "Sue Ellen Francisco", "Sumana", "Sunshiney", "Supermercado One", "Sura", "Suranna", "Suravaram", "Suwannaphum", "Swanky and Moo Moo", "Syncopate", "Tangerine", "Taprom", "Tauri", "Teko", "Telex", "Tenali Ramakrishna", "Tenor Sans", "Text Me One", "The Girl Next Door", "Tienne", "Tillana", "Timmana", "Tinos", "Titan One", "Titillium Web", "Trade Winds", "Trocchi", "Trochut", "Trykker", "Tulpen One", "Ubuntu", "Ubuntu Condensed", "Ubuntu Mono", "Ultra", "Uncial Antiqua", "Underdog", "Unica One", "UnifrakturCook", "UnifrakturMaguntia", "Unkempt", "Unlock", "Unna", "VT323", "Vampiro One", "Varela", "Varela Round", "Vast Shadow", "Vesper Libre", "Vibur", "Vidaloka", "Viga", "Voces", "Volkhov", "Vollkorn", "Voltaire", "Waiting for the Sunrise", "Wallpoet", "Walter Turncoat", "Warnes", "Wellfleet", "Wendy One", "Wire One", "Work Sans", "Yanone Kaffeesatz", "Yantramanav", "Yellowtail", "Yeseva One", "Yesteryear", "Zeyada"];
}).call(undefined);

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./olms.js":
/*!*****************!*\
  !*** ./olms.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(/*! ./index */ "./index.js");

var _stylefunction = __webpack_require__(/*! ./stylefunction */ "./stylefunction.js");

var _stylefunction2 = _interopRequireDefault(_stylefunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var olms = {
  apply: _index.apply,
  applyBackground: _index.applyBackground,
  applyStyle: _index.applyStyle,
  stylefunction: _stylefunction2.default
};
if (window) {
  window.olms = olms;
}
exports.default = olms;

/***/ }),

/***/ "./stylefunction.js":
/*!**************************!*\
  !*** ./stylefunction.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValue = getValue;

exports.default = function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, spriteImage, fonts) {
  if (!resolutions) {
    resolutions = [];
    for (var res = 78271.51696402048; resolutions.length < 21; res /= 2) {
      resolutions.push(res);
    }
  }
  if (typeof glStyle == 'string') {
    glStyle = JSON.parse(glStyle);
  }
  if (glStyle.version != 8) {
    throw new Error('glStyle version 8 required.');
  }

  var spriteImgSize = void 0;
  if (spriteImageUrl && !spriteImage) {
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function () {
      spriteImage = img;
      spriteImgSize = [img.width, img.height];
      olLayer.changed();
    };
    img.src = spriteImageUrl;
  }

  var ctx = document.createElement('CANVAS').getContext('2d');
  var measureCache = {};

  function wrapChineseText(text, maxWidth, ctx) {
    var textWidth = ctx.measureText(text).width;
    if (textWidth > maxWidth) {
      var _res = [];
      var temp = [];
      var splitText = text.split('');
      splitText.forEach(function (singleText) {
        var tempText = temp.join('') + singleText;
        if (ctx.measureText(tempText).width > maxWidth) {
          _res.push(temp.join(''));
          temp = [singleText];
        } else {
          temp.push(singleText);
        }
      });
      _res.push(temp.join(''));
      return _res;
    }
    return [text];
  }

  function wrapText(text, font, em) {
    var key = em + ',' + font + ',' + text;
    var wrappedText = measureCache[key];
    if (!wrappedText) {
      ctx.font = font;
      var oneEm = ctx.measureText('M').width;
      var width = oneEm * em;
      var words = [];
      if (/[\u4E00-\u9FA5]+/.test(text)) {
        words = wrapChineseText(text, width, ctx);
      } else {
        words = text.split(' ');
      }
      var line = '';
      var lines = [];
      for (var i = 0, ii = words.length; i < ii; ++i) {
        var word = words[i];
        if (ctx.measureText(line + word).width <= width) {
          line += (line ? ' ' : '') + word;
        } else {
          if (line) {
            lines.push(line);
          }
          line = word;
        }
      }
      if (line) {
        lines.push(line);
      }
      measureCache[key] = wrappedText = lines.join('\n');
    }
    return wrappedText;
  }

  var allLayers = (0, _mapboxGlStyleSpec.derefLayers)(glStyle.layers);

  var layersBySourceLayer = {};
  var mapboxLayers = [];
  var mapboxSource = void 0;
  for (var i = 0, ii = allLayers.length; i < ii; ++i) {
    var layer = allLayers[i];
    var layerId = layer.id;
    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {
      var sourceLayer = layer['source-layer'];
      if (!mapboxSource) {
        mapboxSource = layer.source;
      }
      var layers = layersBySourceLayer[sourceLayer];
      if (!layers) {
        layers = layersBySourceLayer[sourceLayer] = [];
      }
      layers.push({
        layer: layer,
        index: i
      });
      mapboxLayers.push(layerId);
    }
    // // TODO revisit when diffing gets added
    delete functionCache[layerId];
    delete filterCache[layerId];
  }
  var iconImageCache = {};

  var styles = [];
  var patternCache = {};

  var styleFunction = function styleFunction(feature, resolution) {
    var properties = feature.getProperties();
    feature.styleIds = feature.styleIds || {};
    var layers = layersBySourceLayer[properties.layer];
    if (!layers) {
      return;
    }
    var zoom = resolutions.indexOf(resolution);
    if (zoom == -1) {
      zoom = Math.round((0, _util.getZoomForResolution)(resolution, resolutions));
    }
    var type = types[feature.getGeometry().getType()];
    var f = {
      properties: properties,
      type: type
    };
    var stylesLength = -1;
    for (var _i = 0, _ii = layers.length; _i < _ii; ++_i) {
      var layerData = layers[_i];
      var _layer = layerData.layer;
      var _layerId = _layer.id;

      var layout = _layer.layout || emptyObj;
      var paint = _layer.paint || emptyObj;
      if (layout.visibility === 'none' || 'minzoom' in _layer && zoom < _layer.minzoom || 'maxzoom' in _layer && zoom >= _layer.maxzoom) {
        continue;
      }
      feature.styleIds[zoom] = feature.styleIds[zoom] || [];
      var filter = _layer.filter;
      var icon = void 0,
          iconImg = void 0;
      if (!filter || evaluateFilter(_layerId, filter, f, zoom)) {
        var color = void 0,
            opacity = void 0,
            fill = void 0,
            stroke = void 0,
            strokeColor = void 0,
            style = void 0;
        var index = layerData.index;
        if (type == 3 && _layer.type == 'fill') {
          opacity = getValue(_layer, 'paint', 'fill-opacity', zoom, f);
          if ('fill-pattern' in paint) {
            var iconImage = getValue(_layer, 'paint', 'fill-pattern', zoom, f);
            if (iconImage) {
              icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();
              if (spriteImage && spriteData && spriteData[icon]) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                  style = styles[stylesLength] = new _Style2.default({
                    fill: new _Fill2.default()
                  });
                }
                fill = style.getFill();
                style.setZIndex(index);
                var icon_cache_key = icon + '.' + opacity;
                var pattern = patternCache[icon_cache_key];
                if (!pattern) {
                  var spriteImageData = spriteData[icon];
                  var canvas = document.createElement('canvas');
                  canvas.width = spriteImageData.width;
                  canvas.height = spriteImageData.height;
                  var _ctx = canvas.getContext('2d');
                  _ctx.globalAlpha = opacity;
                  _ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);
                  pattern = _ctx.createPattern(canvas, 'repeat');
                  patternCache[icon_cache_key] = pattern;
                }
                fill.setColor(pattern);
              }
            }
          } else if ('fill-color' in paint) {
            color = colorWithOpacity(getValue(_layer, 'paint', 'fill-color', zoom, f), opacity);
            if (color) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  fill: new _Fill2.default()
                });
              }
              fill = style.getFill();
              fill.setColor(color);
              style.setZIndex(index);
            }
            if ('fill-outline-color' in paint) {
              strokeColor = colorWithOpacity(getValue(_layer, 'paint', 'fill-outline-color', zoom, properties), opacity);
            } else if ('fill-antialias' in paint) {
              strokeColor = color;
            }
            if (strokeColor) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setColor(strokeColor);
              stroke.setWidth(1);
              style.setZIndex(index);
            }
          }
        }
        if (type != 1 && _layer.type == 'line') {
          (function () {
            color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(_layer, 'paint', 'line-color', zoom, f), getValue(_layer, 'paint', 'line-opacity', zoom, f)) : undefined;
            var width = getValue(_layer, 'paint', 'line-width', zoom, f);
            if (color && width > 0) {
              ++stylesLength;
              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                feature.styleIds[zoom].push(_layerId);
              }
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _Style2.default({
                  stroke: new _Stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setLineCap(getValue(_layer, 'layout', 'line-cap', zoom, f));
              stroke.setLineJoin(getValue(_layer, 'layout', 'line-join', zoom, f));
              stroke.setMiterLimit(getValue(_layer, 'layout', 'line-miter-limit', zoom, f));
              stroke.setColor(color);
              stroke.setWidth(width);
              stroke.setLineDash(paint['line-dasharray'] ? getValue(_layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {
                return x * width;
              }) : null);
              style.setZIndex(index);
            }
          })();
        }

        var hasImage = false;
        var text = null;
        var skipLabel = void 0;
        if ((type == 1 || type == 2) && 'icon-image' in layout) {
          var _iconImage = getValue(_layer, 'layout', 'icon-image', zoom, f);
          if (_iconImage) {
            icon = typeof _iconImage === 'string' ? fromTemplate(_iconImage, properties) : _iconImage.toString();
            var styleGeom = undefined;
            if (spriteImage && spriteData && spriteData[icon]) {
              if (type == 2) {
                var geom = feature.getGeometry();
                // ol package and ol-debug.js only
                if (geom.getFlatMidpoint) {
                  var extent = geom.getExtent();
                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));
                  if (size > 150) {
                    //FIXME Do not hard-code a size of 150
                    styleGeom = new _Point2.default(geom.getFlatMidpoint());
                  }
                }
              }
              if (type !== 2 || styleGeom) {
                ++stylesLength;
                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
                  feature.styleIds[zoom].push(_layerId);
                }
                style = styles[stylesLength];
                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                  style = styles[stylesLength] = new _Style2.default();
                }
                style.setGeometry(styleGeom);
                var iconSize = getValue(_layer, 'layout', 'icon-size', zoom, f);
                var iconColor = paint['icon-color'] !== undefined ? getValue(_layer, 'paint', 'icon-color', zoom, f) : null;
                var iconTranslate = getValue(_layer, 'paint', 'icon-translate', zoom, f);
                var iconTranslateAnchor = getValue(_layer, 'paint', 'icon-translate-anchor', zoom, f);
                var iconAnchorValue = getValue(_layer, 'layout', 'icon-anchor', zoom, f);
                var iconOffset = getValue(_layer, 'layout', 'icon-offset', zoom, f);

                var _covertIconAnchor = covertIconAnchor(iconAnchorValue),
                    anchorOffset = _covertIconAnchor.anchorOffset,
                    _covertIconAnchor$ico = _covertIconAnchor.iconAnchor,
                    iconAnchor = _covertIconAnchor$ico === undefined ? iconAnchorValue : _covertIconAnchor$ico;

                var _icon_cache_key = icon + '.' + iconSize + '.' + iconTranslate + '.' + iconTranslateAnchor + '.' + iconAnchor + '.' + iconOffset + '.' + anchorOffset;
                if (iconColor !== null) {
                  _icon_cache_key += '.' + iconColor;
                }
                iconImg = iconImageCache[_icon_cache_key];
                if (!iconImg) {
                  var _spriteImageData = spriteData[icon];
                  var _canvas = document.createElement('canvas');
                  _canvas.width = _spriteImageData.width;
                  _canvas.height = _spriteImageData.height;
                  var _ctx2 = _canvas.getContext('2d');
                  _ctx2.drawImage(spriteImage, _spriteImageData.x, _spriteImageData.y, _spriteImageData.width, _spriteImageData.height, 0, 0, _spriteImageData.width, _spriteImageData.height);
                  var data = _ctx2.getImageData(0, 0, _canvas.width, _canvas.height);
                  if (iconColor !== null) {
                    // cut out the sprite and color it
                    color = colorWithOpacity(iconColor, 1);
                    for (var c = 0, cc = data.data.length; c < cc; c += 4) {
                      data.data[c] = color[0];
                      data.data[c + 1] = color[1];
                      data.data[c + 2] = color[2];
                    }
                  }
                  _ctx2.putImageData(data, 0, 0);
                  var translateOffset = [iconTranslate[0] / _spriteImageData.width, iconTranslate[1] / _spriteImageData.height];
                  iconImg = iconImageCache[_icon_cache_key] = new _Icon2.default({
                    img: _canvas,
                    anchorOrigin: iconAnchor,
                    anchor: [iconOffset[0] + anchorOffset[0] + translateOffset[0], iconOffset[1] + anchorOffset[1] - translateOffset[1]],
                    imgSize: [_canvas.width, _canvas.height],
                    scale: iconSize / _spriteImageData.pixelRatio
                  });
                }
                var rotateValue = getValue(_layer, 'layout', 'icon-rotate', zoom, f);
                if (rotateValue.indexOf && rotateValue.indexOf('{') === 0) {
                  rotateValue = 360 - fromTemplate(rotateValue, properties);
                }
                iconImg.setRotation((0, _util.deg2rad)(rotateValue));
                iconImg.setOpacity(getValue(_layer, 'paint', 'icon-opacity', zoom, f));
                style.setImage(iconImg);
                text = style.getText();
                style.setText(undefined);
                style.setZIndex(99999 - index);
                hasImage = true;
                skipLabel = false;
              } else {
                skipLabel = true;
              }
            }
          }
        }

        if (type == 1 && 'circle-radius' in paint) {
          ++stylesLength;
          if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
            feature.styleIds[zoom].push(_layerId);
          }
          style = styles[stylesLength];
          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
            style = styles[stylesLength] = new _Style2.default();
          }
          var circleRadius = getValue(_layer, 'paint', 'circle-radius', zoom, f);
          var circleStrokeColor = getValue(_layer, 'paint', 'circle-stroke-color', zoom, f);
          var circleColor = getValue(_layer, 'paint', 'circle-color', zoom, f);
          var circleOpacity = getValue(_layer, 'paint', 'circle-opacity', zoom, f);
          var circleStrokeWidth = getValue(_layer, 'paint', 'circle-stroke-width', zoom, f);
          var circleStrokeOpacity = getValue(_layer, 'paint', 'circle-stroke-opacity', zoom, f);
          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleOpacity + '.' + circleStrokeWidth + '.' + circleStrokeOpacity;
          iconImg = iconImageCache[cache_key];
          if (!iconImg) {
            iconImg = new _Circle2.default({
              radius: circleRadius,
              stroke: circleStrokeWidth === 0 ? undefined : new _Stroke2.default({
                width: circleStrokeWidth,
                color: colorWithOpacity(circleStrokeColor, circleStrokeOpacity)
              }),
              fill: new _Fill2.default({
                color: colorWithOpacity(circleColor, circleOpacity)
              })
            });
          }
          style.setImage(iconImg);
          text = style.getText();
          style.setText(undefined);
          style.setGeometry(undefined);
          style.setZIndex(99999 - index);
          hasImage = true;
        }

        var label = void 0;
        if ('text-field' in layout) {
          var textField = getValue(_layer, 'layout', 'text-field', zoom, f);
          label = fromTemplate(textField, properties);
        }
        if (label && !skipLabel) {
          if (!hasImage) {
            ++stylesLength;
            if (feature.styleIds[zoom].indexOf(_layerId) === -1) {
              feature.styleIds[zoom].push(_layerId);
            }
            style = styles[stylesLength];
            if (!style || !style.getText() || style.getFill() || style.getStroke()) {
              style = styles[stylesLength] = new _Style2.default();
            }
            style.setImage(undefined);
            style.setGeometry(undefined);
          }
          if (!style.getText()) {
            style.setText(text || new _Text2.default());
          }
          text = style.getText();
          var textSize = getValue(_layer, 'layout', 'text-size', zoom, f);
          var textLineHeight = getValue(_layer, 'layout', 'text-line-height', zoom, f);
          var font = (0, _mapboxToCssFont2.default)(chooseFont(getValue(_layer, 'layout', 'text-font', zoom, f)), textSize);
          var textTransform = layout['text-transform'];
          if (textTransform == 'uppercase') {
            label = label.toUpperCase();
          } else if (textTransform == 'lowercase') {
            label = label.toLowerCase();
          }
          var wrappedLabel = type == 2 ? label : wrapText(label, font, getValue(_layer, 'layout', 'text-max-width', zoom, f));
          text.setText(wrappedLabel);
          text.setFont(font);
          text.setRotation((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-rotate', zoom, f)));
          var textAnchor = getValue(_layer, 'layout', 'text-anchor', zoom, f);
          var placement = hasImage || type == 1 ? 'point' : getValue(_layer, 'layout', 'symbol-placement', zoom, f);
          text.setPlacement(placement);
          var textHaloWidth = getValue(_layer, 'paint', 'text-halo-width', zoom, f);
          var textOffset = getValue(_layer, 'layout', 'text-offset', zoom, f);
          var textTranslate = getValue(_layer, 'paint', 'text-translate', zoom, f);
          var vOffset = 0;
          var hOffset = 0;
          var textAlign = 'center';
          if (textAnchor.indexOf('left') !== -1) {
            textAlign = 'left';
            hOffset = textHaloWidth;
          } else if (textAnchor.indexOf('right') !== -1) {
            textAlign = 'right';
            hOffset = -textHaloWidth;
          }
          if (placement == 'point') {
            text.setTextAlign(textAlign);
          } else {
            text.setMaxAngle((0, _util.deg2rad)(getValue(_layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);
            text.setTextAlign();
          }
          var textBaseline = 'middle';
          if (textAnchor.indexOf('bottom') == 0) {
            textBaseline = 'bottom';
            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
          } else if (textAnchor.indexOf('top') == 0) {
            textBaseline = 'top';
            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
          }
          text.setTextBaseline(textBaseline);
          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);
          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);
          opacity = getValue(_layer, 'paint', 'text-opacity', zoom, f);
          var textColor = new _Fill2.default();

          textColor.setColor(colorWithOpacity(getValue(_layer, 'paint', 'text-color', zoom, f), opacity) || 'rgba(0,0,0,0)');
          text.setFill(textColor);
          var haloColor = colorWithOpacity(getValue(_layer, 'paint', 'text-halo-color', zoom, f), opacity);
          if (haloColor) {
            var textHalo = new _Stroke2.default();
            textHalo.setColor(haloColor);
            textHalo.setWidth(getValue(_layer, 'paint', 'text-halo-width', zoom, f));
            text.setStroke(textHalo);
          } else {
            text.setStroke(undefined);
          }
          style.setZIndex(99999 - index);
        }
      }
    }

    if (stylesLength > -1) {
      styles.length = stylesLength + 1;
      return styles;
    }
  };

  olLayer.setStyle(styleFunction);
  olLayer.set('mapbox-source', mapboxSource);
  olLayer.set('mapbox-layers', mapboxLayers);
  return styleFunction;
};

var _Style = __webpack_require__(/*! ol/style/Style */ "ol/style/Style");

var _Style2 = _interopRequireDefault(_Style);

var _Fill = __webpack_require__(/*! ol/style/Fill */ "ol/style/Fill");

var _Fill2 = _interopRequireDefault(_Fill);

var _Stroke = __webpack_require__(/*! ol/style/Stroke */ "ol/style/Stroke");

var _Stroke2 = _interopRequireDefault(_Stroke);

var _Icon = __webpack_require__(/*! ol/style/Icon */ "ol/style/Icon");

var _Icon2 = _interopRequireDefault(_Icon);

var _Text = __webpack_require__(/*! ol/style/Text */ "ol/style/Text");

var _Text2 = _interopRequireDefault(_Text);

var _Circle = __webpack_require__(/*! ol/style/Circle */ "ol/style/Circle");

var _Circle2 = _interopRequireDefault(_Circle);

var _Point = __webpack_require__(/*! ol/geom/Point */ "ol/geom/Point");

var _Point2 = _interopRequireDefault(_Point);

var _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js");

var _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ "./node_modules/mapbox-to-css-font/index.js");

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _util = __webpack_require__(/*! ./util */ "./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isFunction = _mapboxGlStyleSpec.function.isFunction; /*
                                                         ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                                                         Copyright 2016-present Boundless Spatial, Inc.
                                                         License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE
                                                         */

var convertFunction = _mapboxGlStyleSpec.function.convertFunction;
var isExpression = _mapboxGlStyleSpec.expression.isExpression;
var createPropertyExpression = _mapboxGlStyleSpec.expression.createPropertyExpression;

var types = {
  'Point': 1,
  'MultiPoint': 1,
  'LineString': 2,
  'MultiLineString': 2,
  'Polygon': 3,
  'MultiPolygon': 3
};
var expressionData = function expressionData(rawExpression, propertySpec) {
  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);
  if (compiledExpression.result === 'error') {
    throw new Error(compiledExpression.value.map(function (err) {
      return err.key + ': ' + err.message;
    }).join(', '));
  }
  return compiledExpression.value;
};

var emptyObj = {};
var zoomObj = { zoom: 0 };
var functionCache = {};

/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {string} layoutOrPaint 'layout' or 'paint'.
 * @param {string} property Feature property.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @return {?} Value.
 */
function getValue(layer, layoutOrPaint, property, zoom, feature) {
  var layerId = layer.id;
  if (!functionCache[layerId]) {
    functionCache[layerId] = {};
  }
  var functions = functionCache[layerId];
  if (!functions[property]) {
    var value = (layer[layoutOrPaint] || emptyObj)[property];
    var propertySpec = _mapboxGlStyleSpec.latest[layoutOrPaint + '_' + layer.type][property];
    if (value === undefined) {
      value = propertySpec.default;
    }
    var isExpr = isExpression(value);
    if (!isExpr && isFunction(value)) {
      value = convertFunction(value, propertySpec);
      isExpr = true;
    }
    if (isExpr) {
      var compiledExpression = expressionData(value, propertySpec);
      functions[property] = compiledExpression.evaluate.bind(compiledExpression);
    } else {
      if (propertySpec.type == 'color') {
        value = _mapboxGlStyleSpec.Color.parse(value);
      }
      functions[property] = function () {
        return value;
      };
    }
  }
  zoomObj.zoom = zoom;
  return functions[property](zoomObj, feature);
}

function covertIconAnchor(iconAnchor) {
  var anchorOffset = [0.5, 0.5];
  if (['top-left', 'top-right', 'bottom-left', 'bottom-right'].indexOf(iconAnchor) > -1) {
    anchorOffset = [0, 0];
  }
  if (iconAnchor === 'left') {
    iconAnchor = 'top-left';
    anchorOffset = [0, 0.5];
  }
  if (iconAnchor === 'right') {
    iconAnchor = 'top-left';
    anchorOffset = [1, 0.5];
  }
  if (iconAnchor === 'bottom') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 1];
  }
  if (iconAnchor === 'top') {
    iconAnchor = 'top-left';
    anchorOffset = [0.5, 0];
  }
  //center
  return {
    anchorOffset: anchorOffset,
    iconAnchor: iconAnchor
  };
}

var fontMap = {};

function chooseFont(fonts, availableFonts) {
  if (fontMap[fonts]) {
    return fontMap[fonts];
  }
  if (availableFonts) {
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      if (availableFonts.indexOf(font) != -1) {
        fontMap[fonts] = font;
        break;
      }
    }
    if (!fontMap[fonts]) {
      // fallback font
      fontMap[fonts] = fonts[fonts.length - 1];
    }
  } else {
    fontMap[fonts] = fonts[0];
  }
  return fontMap[fonts];
}

var filterCache = {};

function evaluateFilter(layerId, filter, feature, zoom) {
  if (!(layerId in filterCache)) {
    filterCache[layerId] = (0, _mapboxGlStyleSpec.featureFilter)(filter).filter;
  }
  zoomObj.zoom = zoom;
  return filterCache[layerId](zoomObj, feature);
}

function colorWithOpacity(color, opacity) {
  if (color) {
    if (color.a === 0 || opacity === 0) {
      return undefined;
    }
    var a = color.a;
    opacity = opacity === undefined ? 1 : opacity;
    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';
  }
  return color;
}

var templateRegEx = /^([^]*)\{(.*)\}([^]*)$/;

function fromTemplate(text, properties) {
  var parts = void 0;
  do {
    parts = text.match(templateRegEx);
    if (parts) {
      var value = properties[parts[2]] || '';
      text = parts[1] + value + parts[3];
    }
  } while (parts);
  return text;
}

/**
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source and applies it to the specified OpenLayers layer.
 *
 * @param {ol.layer.Vector|ol.layer.VectorTile} olLayer OpenLayers layer to
 * apply the style to. In addition to the style, the layer will get two
 * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used
 * for the layer, and `mapbox-layers` will be an array of the `id`s of the
 * `glStyle`'s layers.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} source `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,
 * 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,
 * 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,
 * 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,
 * 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,
 * 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]
 * Resolutions for mapping resolution to zoom level.
 * @param {Object} [spriteData=undefined] Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {Array<string>} [fonts=undefined] Array of available fonts, using the
 * same font names as the Mapbox Style object. If not provided, the style
 * function will always use the first font from the font array.
 * @return {ol.style.StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */

/***/ }),

/***/ "./util.js":
/*!*****************!*\
  !*** ./util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deg2rad = deg2rad;
exports.getZoomForResolution = getZoomForResolution;
function deg2rad(degrees) {
  return degrees * Math.PI / 180;
}

function getZoomForResolution(resolution, resolutions) {
  var i = 0;
  var ii = resolutions.length;
  for (; i < ii; ++i) {
    var candidate = resolutions[i];
    if (candidate < resolution && i + 1 < ii) {
      var zoomFactor = resolutions[i] / resolutions[i + 1];
      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
    }
  }
  return ii - 1;
}

/***/ }),

/***/ "ol/Map":
/*!**********************************************************************************************!*\
  !*** external {"root":["ol","Map"],"commonjs":"ol/Map","commonjs2":"ol/Map","amd":"ol/Map"} ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_Map__;

/***/ }),

/***/ "ol/Observable":
/*!**************************************************************************************************************************!*\
  !*** external {"root":["ol","Observable"],"commonjs":"ol/Observable","commonjs2":"ol/Observable","amd":"ol/Observable"} ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_Observable__;

/***/ }),

/***/ "ol/format/GeoJSON":
/*!********************************************************************************************************************************************!*\
  !*** external {"root":["ol","format","GeoJSON"],"commonjs":"ol/format/GeoJSON","commonjs2":"ol/format/GeoJSON","amd":"ol/format/GeoJSON"} ***!
  \********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_format_GeoJSON__;

/***/ }),

/***/ "ol/format/MVT":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","format","MVT"],"commonjs":"ol/format/MVT","commonjs2":"ol/format/MVT","amd":"ol/format/MVT"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_format_MVT__;

/***/ }),

/***/ "ol/geom/Point":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","geom","Point"],"commonjs":"ol/geom/Point","commonjs2":"ol/geom/Point","amd":"ol/geom/Point"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_geom_Point__;

/***/ }),

/***/ "ol/layer/Tile":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","layer","Tile"],"commonjs":"ol/layer/Tile","commonjs2":"ol/layer/Tile","amd":"ol/layer/Tile"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_layer_Tile__;

/***/ }),

/***/ "ol/layer/Vector":
/*!************************************************************************************************************************************!*\
  !*** external {"root":["ol","layer","Vector"],"commonjs":"ol/layer/Vector","commonjs2":"ol/layer/Vector","amd":"ol/layer/Vector"} ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_layer_Vector__;

/***/ }),

/***/ "ol/layer/VectorTile":
/*!****************************************************************************************************************************************************!*\
  !*** external {"root":["ol","layer","VectorTile"],"commonjs":"ol/layer/VectorTile","commonjs2":"ol/layer/VectorTile","amd":"ol/layer/VectorTile"} ***!
  \****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_layer_VectorTile__;

/***/ }),

/***/ "ol/proj":
/*!**************************************************************************************************!*\
  !*** external {"root":["ol","proj"],"commonjs":"ol/proj","commonjs2":"ol/proj","amd":"ol/proj"} ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_proj__;

/***/ }),

/***/ "ol/source/TileJSON":
/*!************************************************************************************************************************************************!*\
  !*** external {"root":["ol","source","TileJSON"],"commonjs":"ol/source/TileJSON","commonjs2":"ol/source/TileJSON","amd":"ol/source/TileJSON"} ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_source_TileJSON__;

/***/ }),

/***/ "ol/source/Vector":
/*!****************************************************************************************************************************************!*\
  !*** external {"root":["ol","source","Vector"],"commonjs":"ol/source/Vector","commonjs2":"ol/source/Vector","amd":"ol/source/Vector"} ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_source_Vector__;

/***/ }),

/***/ "ol/source/VectorTile":
/*!********************************************************************************************************************************************************!*\
  !*** external {"root":["ol","source","VectorTile"],"commonjs":"ol/source/VectorTile","commonjs2":"ol/source/VectorTile","amd":"ol/source/VectorTile"} ***!
  \********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_source_VectorTile__;

/***/ }),

/***/ "ol/style/Circle":
/*!************************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Circle"],"commonjs":"ol/style/Circle","commonjs2":"ol/style/Circle","amd":"ol/style/Circle"} ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Circle__;

/***/ }),

/***/ "ol/style/Fill":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Fill"],"commonjs":"ol/style/Fill","commonjs2":"ol/style/Fill","amd":"ol/style/Fill"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Fill__;

/***/ }),

/***/ "ol/style/Icon":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Icon"],"commonjs":"ol/style/Icon","commonjs2":"ol/style/Icon","amd":"ol/style/Icon"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Icon__;

/***/ }),

/***/ "ol/style/Stroke":
/*!************************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Stroke"],"commonjs":"ol/style/Stroke","commonjs2":"ol/style/Stroke","amd":"ol/style/Stroke"} ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Stroke__;

/***/ }),

/***/ "ol/style/Style":
/*!********************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Style"],"commonjs":"ol/style/Style","commonjs2":"ol/style/Style","amd":"ol/style/Style"} ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Style__;

/***/ }),

/***/ "ol/style/Text":
/*!****************************************************************************************************************************!*\
  !*** external {"root":["ol","style","Text"],"commonjs":"ol/style/Text","commonjs2":"ol/style/Text","amd":"ol/style/Text"} ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_style_Text__;

/***/ }),

/***/ "ol/tilegrid":
/*!******************************************************************************************************************!*\
  !*** external {"root":["ol","tilegrid"],"commonjs":"ol/tilegrid","commonjs2":"ol/tilegrid","amd":"ol/tilegrid"} ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_ol_tilegrid__;

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbG1zL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9vbG1zL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL29sbXMvLi9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvbWFwYm94LXRvLWNzcy1mb250L2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvQXNzZXJ0aW9uRXJyb3IuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VUaWxlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0RXZlbnRUeXBlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL1RpbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlU3RhdGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL2Fzc2VydHMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9kb20uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnRUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnRUeXBlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L0Nvcm5lci5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL2V4dGVudC9SZWxhdGlvbnNoaXAuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0dlb21ldHJ5VHlwZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL2luZGV4LmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvbWF0aC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL29iai5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ouanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1Byb2plY3Rpb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnMzg1Ny5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzQzMjYuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3Byb2plY3Rpb25zLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcHJvai90cmFuc2Zvcm1zLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RpbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVHJpYW5ndWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9jb21tb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9zaXplLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9TdGF0ZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUltYWdlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1VybFRpbGUuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvWFlaLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc3BoZXJlLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9MUlVDYWNoZS5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVjb29yZC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkLmpzIiwid2VicGFjazovL29sbXMvLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQvVGlsZUdyaWQuanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC90aWxldXJsZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vb2xtcy8uL25vZGVfbW9kdWxlcy9vbC93ZWJnbC5qcyIsIndlYnBhY2s6Ly9vbG1zLy4vbm9kZV9tb2R1bGVzL3dlYmZvbnQtbWF0Y2hlci9saWIvZm9udHMvZ29vZ2xlLmpzIiwid2VicGFjazovL29sbXMvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL29sbXMvLi9vbG1zLmpzIiwid2VicGFjazovL29sbXMvLi9zdHlsZWZ1bmN0aW9uLmpzIiwid2VicGFjazovL29sbXMvLi91dGlsLmpzIiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJNYXBcIl0sXCJjb21tb25qc1wiOlwib2wvTWFwXCIsXCJjb21tb25qczJcIjpcIm9sL01hcFwiLFwiYW1kXCI6XCJvbC9NYXBcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcIk9ic2VydmFibGVcIl0sXCJjb21tb25qc1wiOlwib2wvT2JzZXJ2YWJsZVwiLFwiY29tbW9uanMyXCI6XCJvbC9PYnNlcnZhYmxlXCIsXCJhbWRcIjpcIm9sL09ic2VydmFibGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcImZvcm1hdFwiLFwiR2VvSlNPTlwiXSxcImNvbW1vbmpzXCI6XCJvbC9mb3JtYXQvR2VvSlNPTlwiLFwiY29tbW9uanMyXCI6XCJvbC9mb3JtYXQvR2VvSlNPTlwiLFwiYW1kXCI6XCJvbC9mb3JtYXQvR2VvSlNPTlwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwiZm9ybWF0XCIsXCJNVlRcIl0sXCJjb21tb25qc1wiOlwib2wvZm9ybWF0L01WVFwiLFwiY29tbW9uanMyXCI6XCJvbC9mb3JtYXQvTVZUXCIsXCJhbWRcIjpcIm9sL2Zvcm1hdC9NVlRcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcImdlb21cIixcIlBvaW50XCJdLFwiY29tbW9uanNcIjpcIm9sL2dlb20vUG9pbnRcIixcImNvbW1vbmpzMlwiOlwib2wvZ2VvbS9Qb2ludFwiLFwiYW1kXCI6XCJvbC9nZW9tL1BvaW50XCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJsYXllclwiLFwiVGlsZVwiXSxcImNvbW1vbmpzXCI6XCJvbC9sYXllci9UaWxlXCIsXCJjb21tb25qczJcIjpcIm9sL2xheWVyL1RpbGVcIixcImFtZFwiOlwib2wvbGF5ZXIvVGlsZVwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwibGF5ZXJcIixcIlZlY3RvclwiXSxcImNvbW1vbmpzXCI6XCJvbC9sYXllci9WZWN0b3JcIixcImNvbW1vbmpzMlwiOlwib2wvbGF5ZXIvVmVjdG9yXCIsXCJhbWRcIjpcIm9sL2xheWVyL1ZlY3RvclwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwibGF5ZXJcIixcIlZlY3RvclRpbGVcIl0sXCJjb21tb25qc1wiOlwib2wvbGF5ZXIvVmVjdG9yVGlsZVwiLFwiY29tbW9uanMyXCI6XCJvbC9sYXllci9WZWN0b3JUaWxlXCIsXCJhbWRcIjpcIm9sL2xheWVyL1ZlY3RvclRpbGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInByb2pcIl0sXCJjb21tb25qc1wiOlwib2wvcHJvalwiLFwiY29tbW9uanMyXCI6XCJvbC9wcm9qXCIsXCJhbWRcIjpcIm9sL3Byb2pcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInNvdXJjZVwiLFwiVGlsZUpTT05cIl0sXCJjb21tb25qc1wiOlwib2wvc291cmNlL1RpbGVKU09OXCIsXCJjb21tb25qczJcIjpcIm9sL3NvdXJjZS9UaWxlSlNPTlwiLFwiYW1kXCI6XCJvbC9zb3VyY2UvVGlsZUpTT05cIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInNvdXJjZVwiLFwiVmVjdG9yXCJdLFwiY29tbW9uanNcIjpcIm9sL3NvdXJjZS9WZWN0b3JcIixcImNvbW1vbmpzMlwiOlwib2wvc291cmNlL1ZlY3RvclwiLFwiYW1kXCI6XCJvbC9zb3VyY2UvVmVjdG9yXCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJzb3VyY2VcIixcIlZlY3RvclRpbGVcIl0sXCJjb21tb25qc1wiOlwib2wvc291cmNlL1ZlY3RvclRpbGVcIixcImNvbW1vbmpzMlwiOlwib2wvc291cmNlL1ZlY3RvclRpbGVcIixcImFtZFwiOlwib2wvc291cmNlL1ZlY3RvclRpbGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInN0eWxlXCIsXCJDaXJjbGVcIl0sXCJjb21tb25qc1wiOlwib2wvc3R5bGUvQ2lyY2xlXCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL0NpcmNsZVwiLFwiYW1kXCI6XCJvbC9zdHlsZS9DaXJjbGVcIn0iLCJ3ZWJwYWNrOi8vb2xtcy9leHRlcm5hbCB7XCJyb290XCI6W1wib2xcIixcInN0eWxlXCIsXCJGaWxsXCJdLFwiY29tbW9uanNcIjpcIm9sL3N0eWxlL0ZpbGxcIixcImNvbW1vbmpzMlwiOlwib2wvc3R5bGUvRmlsbFwiLFwiYW1kXCI6XCJvbC9zdHlsZS9GaWxsXCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJzdHlsZVwiLFwiSWNvblwiXSxcImNvbW1vbmpzXCI6XCJvbC9zdHlsZS9JY29uXCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL0ljb25cIixcImFtZFwiOlwib2wvc3R5bGUvSWNvblwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwic3R5bGVcIixcIlN0cm9rZVwiXSxcImNvbW1vbmpzXCI6XCJvbC9zdHlsZS9TdHJva2VcIixcImNvbW1vbmpzMlwiOlwib2wvc3R5bGUvU3Ryb2tlXCIsXCJhbWRcIjpcIm9sL3N0eWxlL1N0cm9rZVwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwic3R5bGVcIixcIlN0eWxlXCJdLFwiY29tbW9uanNcIjpcIm9sL3N0eWxlL1N0eWxlXCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL1N0eWxlXCIsXCJhbWRcIjpcIm9sL3N0eWxlL1N0eWxlXCJ9Iiwid2VicGFjazovL29sbXMvZXh0ZXJuYWwge1wicm9vdFwiOltcIm9sXCIsXCJzdHlsZVwiLFwiVGV4dFwiXSxcImNvbW1vbmpzXCI6XCJvbC9zdHlsZS9UZXh0XCIsXCJjb21tb25qczJcIjpcIm9sL3N0eWxlL1RleHRcIixcImFtZFwiOlwib2wvc3R5bGUvVGV4dFwifSIsIndlYnBhY2s6Ly9vbG1zL2V4dGVybmFsIHtcInJvb3RcIjpbXCJvbFwiLFwidGlsZWdyaWRcIl0sXCJjb21tb25qc1wiOlwib2wvdGlsZWdyaWRcIixcImNvbW1vbmpzMlwiOlwib2wvdGlsZWdyaWRcIixcImFtZFwiOlwib2wvdGlsZWdyaWRcIn0iXSwibmFtZXMiOlsiYXBwbHlTdHlsZSIsImFwcGx5QmFja2dyb3VuZCIsImFwcGx5IiwiZ2V0TGF5ZXIiLCJnZXRTb3VyY2UiLCJhdmFpbGFibGVGb250cyIsImxvYWRGb250IiwiZm9udHMiLCJpIiwiaWkiLCJBcnJheSIsImlzQXJyYXkiLCJzdG9wcyIsImxlbmd0aCIsImdvb2dsZUZhbWlsaWVzIiwiZ29vZ2xlRm9udHMiLCJnZXROYW1lcyIsImZhbWlsaWVzIiwibWFwIiwiZm9udCIsInNwbGl0IiwicmVwbGFjZSIsImZhbWlseSIsImluZGV4T2YiLCJwdXNoIiwiZm9udFVybCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm1hcmt1cCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwicmVsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhcHBlbmRDaGlsZCIsImRlZmF1bHRGb250IiwicHJlcHJvY2VzcyIsImxheWVyIiwibGF5b3V0Iiwic3ByaXRlUmVnRXgiLCJ3aXRoUGF0aCIsInVybCIsInBhdGgiLCJ0b1Nwcml0ZVVybCIsImV4dGVuc2lvbiIsInBhcnRzIiwibWF0Y2giLCJnbFN0eWxlIiwic291cmNlIiwicmVzb2x1dGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkpTT04iLCJwYXJzZSIsInZlcnNpb24iLCJFcnJvciIsInNwcml0ZVNjYWxlIiwic3ByaXRlRGF0YSIsInNwcml0ZUltYWdlVXJsIiwic3ByaXRlIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNpemVGYWN0b3IiLCJzcHJpdGVVcmwiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsInJlc3BvbnNlIiwic3RhdHVzIiwianNvbiIsInIiLCJzcHJpdGVzSnNvbiIsInVuZGVmaW5lZCIsIm9uQ2hhbmdlIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJzdHlsZSIsInNldFN0eWxlIiwiVmVjdG9yVGlsZUxheWVyIiwiVmVjdG9yTGF5ZXIiLCJsYXllcnMiLCJpZCIsImUiLCJzZXRUaW1lb3V0Iiwic2V0QmFja2dyb3VuZCIsImJhY2tncm91bmQiLCJ0eXBlIiwidXBkYXRlU3R5bGUiLCJlbGVtZW50IiwiZ2V0VGFyZ2V0RWxlbWVudCIsInBhaW50Iiwiem9vbSIsImdldFZpZXciLCJnZXRab29tIiwiYmciLCJDb2xvciIsInRvU3RyaW5nIiwib3BhY2l0eSIsInZpc2liaWxpdHkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvbiIsInNvbWUiLCJsIiwiZ2V0U291cmNlSWRCeVJlZiIsInJlZiIsInNvdXJjZUlkIiwicHJvY2Vzc1N0eWxlIiwiYmFzZVVybCIsImhvc3QiLCJhY2Nlc3NUb2tlbiIsInZpZXciLCJnZXRDZW50ZXIiLCJzZXRDZW50ZXIiLCJjZW50ZXIiLCJzZXRab29tIiwiZml0IiwiZ2V0UHJvamVjdGlvbiIsImdldEV4dGVudCIsIm5lYXJlc3QiLCJzaXplIiwiZ2V0U2l6ZSIsImdsTGF5ZXJzIiwiZ2VvSnNvbkZvcm1hdCIsIkdlb0pTT04iLCJsYXllcklkcyIsImZpbmFsaXplTGF5ZXIiLCJhZGRMYXllciIsInNldFZpc2libGUiLCJvbmNlIiwiZ2xMYXllciIsImdsU291cmNlIiwiZ2xTb3VyY2VJZCIsIm1hcGlkIiwic291cmNlcyIsInRpbGVzIiwidGlsZUdyaWQiLCJ0aWxlU2l6ZSIsIm1heFpvb20iLCJtYXh6b29tIiwibWluWm9vbSIsIm1pbnpvb20iLCJkZWNsdXR0ZXIiLCJtYXhSZXNvbHV0aW9uIiwiZ2V0TWluWm9vbSIsImdldFJlc29sdXRpb24iLCJWZWN0b3JUaWxlU291cmNlIiwiYXR0cmlidXRpb25zIiwiYXR0cmlidXRpb24iLCJmb3JtYXQiLCJNVlQiLCJ1cmxzIiwidmlzaWJsZSIsInpJbmRleCIsInRpbGVqc29uIiwiVGlsZUpTT04iLCJrZXkiLCJnZXRTdGF0ZSIsInRpbGVKU09ORG9jIiwiZ2V0VGlsZUpTT04iLCJ0aWxlIiwiZ2V0VGlsZUdyaWQiLCJzZXRTb3VyY2UiLCJnZXRBdHRyaWJ1dGlvbnMiLCJnZXRNYXhab29tIiwic2V0TWF4UmVzb2x1dGlvbiIsImNyb3NzT3JpZ2luIiwiWFlaIiwic2V0VGlsZUxvYWRGdW5jdGlvbiIsInNyYyIsImJib3giLCJnZXRUaWxlQ29vcmRFeHRlbnQiLCJnZXRUaWxlQ29vcmQiLCJnZXRJbWFnZSIsIlRpbGVMYXllciIsImRhdGEiLCJmZWF0dXJlcyIsImdlb0pzb25VcmwiLCJyZWFkRmVhdHVyZXMiLCJmZWF0dXJlUHJvamVjdGlvbiIsIlZlY3RvclNvdXJjZSIsInNldCIsIk1hcCIsInRhcmdldCIsImEiLCJwYXRobmFtZSIsInNsaWNlIiwiam9pbiIsInN1YnN0ciIsImxheWVySWQiLCJnZXRMYXllcnMiLCJnZXRBcnJheSIsImdldCIsIiR2ZXJzaW9uIiwiJHJvb3QiLCJyZXF1aXJlZCIsInZhbHVlcyIsImRvYyIsImV4YW1wbGUiLCJuYW1lIiwibWV0YWRhdGEiLCJ2YWx1ZSIsImJlYXJpbmciLCJwZXJpb2QiLCJ1bml0cyIsInBpdGNoIiwibGlnaHQiLCJhbmNob3IiLCJjb2xvciIsImludGVuc2l0eSIsInRlcnJhaW4iLCJmb2ciLCJnbHlwaHMiLCJ0cmFuc2l0aW9uIiwiZHVyYXRpb24iLCJkZWxheSIsInByb2plY3Rpb24iLCJwYXJhbGxlbHMiLCJzb3VyY2VfdmVjdG9yIiwidmVjdG9yIiwiYm91bmRzIiwic2NoZW1lIiwieHl6IiwidG1zIiwicHJvbW90ZUlkIiwidm9sYXRpbGUiLCJhbmRyb2lkIiwiaW9zIiwic291cmNlX3Jhc3RlciIsInJhc3RlciIsInNvdXJjZV9yYXN0ZXJfZGVtIiwiZW5jb2RpbmciLCJ0ZXJyYXJpdW0iLCJtYXBib3giLCJzb3VyY2VfZ2VvanNvbiIsImdlb2pzb24iLCJidWZmZXIiLCJtYXhpbXVtIiwibWluaW11bSIsImZpbHRlciIsInRvbGVyYW5jZSIsImNsdXN0ZXIiLCJjbHVzdGVyUmFkaXVzIiwiY2x1c3Rlck1heFpvb20iLCJjbHVzdGVyTWluUG9pbnRzIiwiY2x1c3RlclByb3BlcnRpZXMiLCJsaW5lTWV0cmljcyIsImdlbmVyYXRlSWQiLCJzb3VyY2VfdmlkZW8iLCJ2aWRlbyIsImNvb3JkaW5hdGVzIiwic291cmNlX2ltYWdlIiwiaW1hZ2UiLCJmaWxsIiwianMiLCJtYWNvcyIsImxpbmUiLCJzeW1ib2wiLCJjaXJjbGUiLCJoZWF0bWFwIiwiaGlsbHNoYWRlIiwic2t5IiwibGF5b3V0X2JhY2tncm91bmQiLCJub25lIiwibGF5b3V0X3NreSIsImxheW91dF9maWxsIiwiZXhwcmVzc2lvbiIsImludGVycG9sYXRlZCIsInBhcmFtZXRlcnMiLCJsYXlvdXRfY2lyY2xlIiwibGF5b3V0X2hlYXRtYXAiLCJsYXlvdXRfbGluZSIsImJ1dHQiLCJyb3VuZCIsInNxdWFyZSIsImJldmVsIiwibWl0ZXIiLCJyZXF1aXJlcyIsImxheW91dF9zeW1ib2wiLCJwb2ludCIsImF1dG8iLCJ2aWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiYm90aCIsInRva2VucyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInVwcGVyY2FzZSIsImxvd2VyY2FzZSIsImxheW91dF9yYXN0ZXIiLCJsYXlvdXRfaGlsbHNoYWRlIiwiZmlsdGVyX3N5bWJvbCIsImZpbHRlcl9maWxsIiwiZmlsdGVyX2xpbmUiLCJmaWx0ZXJfY2lyY2xlIiwiZmlsdGVyX2hlYXRtYXAiLCJmaWx0ZXJfb3BlcmF0b3IiLCJhbGwiLCJhbnkiLCJoYXMiLCJ3aXRoaW4iLCJnZW9tZXRyeV90eXBlIiwiUG9pbnQiLCJMaW5lU3RyaW5nIiwiUG9seWdvbiIsImZ1bmN0aW9uX3N0b3AiLCJleHByZXNzaW9uX25hbWUiLCJncm91cCIsImxpdGVyYWwiLCJhcnJheSIsImF0IiwiY29hbGVzY2UiLCJzdGVwIiwiaW50ZXJwb2xhdGUiLCJsbjIiLCJwaSIsInN0cmluZyIsIm51bWJlciIsImJvb2xlYW4iLCJvYmplY3QiLCJjb2xsYXRvciIsInJnYiIsInJnYmEiLCJwcm9wZXJ0aWVzIiwiYWNjdW11bGF0ZWQiLCJzcXJ0IiwibG9nMTAiLCJsbiIsImxvZzIiLCJzaW4iLCJjb3MiLCJ0YW4iLCJhc2luIiwiYWNvcyIsImF0YW4iLCJtaW4iLCJtYXgiLCJhYnMiLCJjZWlsIiwiZmxvb3IiLCJkaXN0YW5jZSIsInVwY2FzZSIsImRvd25jYXNlIiwiY29uY2F0IiwicmFuZ2UiLCJwb3NpdGlvbiIsImFsYmVycyIsImVxdWFsRWFydGgiLCJlcXVpcmVjdGFuZ3VsYXIiLCJsYW1iZXJ0Q29uZm9ybWFsQ29uaWMiLCJtZXJjYXRvciIsIm5hdHVyYWxFYXJ0aCIsIndpbmtlbFRyaXBlbCIsImV4YWdnZXJhdGlvbiIsInBhaW50X2ZpbGwiLCJwYWludF9saW5lIiwicGFpbnRfY2lyY2xlIiwicGFpbnRfaGVhdG1hcCIsInBhaW50X3N5bWJvbCIsIm92ZXJyaWRhYmxlIiwicGFpbnRfcmFzdGVyIiwibGluZWFyIiwicGFpbnRfaGlsbHNoYWRlIiwicGFpbnRfYmFja2dyb3VuZCIsInBhaW50X3NreSIsImdyYWRpZW50IiwiYXRtb3NwaGVyZSIsInY4IiwiYmFzZSIsInByb3BlcnR5IiwiaWRlbnRpdHkiLCJleHBvbmVudGlhbCIsImludGVydmFsIiwiY2F0ZWdvcmljYWwiLCJjb2xvclNwYWNlIiwibGFiIiwiaGNsIiwiY29uc3RhbnQiLCJzdHJpbmdPckNoYXIiLCJqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdCIsInN0cmluZ2lmeSIsInBhc3NlZE9iaiIsIm9wdGlvbnMiLCJpbmRlbnQiLCJtYXhMZW5ndGgiLCJyZXBsYWNlciIsIkluZmluaXR5IiwiX3N0cmluZ2lmeSIsIm9iaiIsImN1cnJlbnRJbmRlbnQiLCJyZXNlcnZlZCIsImVuZCIsImluZGV4IiwiaXRlbXMiLCJrZXlQYXJ0Iiwia2V5cyIsIm5leHRJbmRlbnQiLCJwcmV0dGlmaWVkIiwic3RhcnQiLCJ0b0pTT04iLCJzdHJpbmdMaXRlcmFsIiwiT2JqZWN0Iiwic29ydEtleXNCeSIsInJlZmVyZW5jZSIsInJlc3VsdCIsInNwYWNlIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwiZ2xvYmFsIiwic2VsZiIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJtb2R1bGUiLCJleHBvcnRzIiwiY29tbW9uanNSZXF1aXJlIiwicHVueWNvZGUiLCJyb290IiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwibWF4SW50IiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJNYXRoIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiUmFuZ2VFcnJvciIsIm1hcERvbWFpbiIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImV4dHJhIiwiY2hhckNvZGVBdCIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJjb2RlUG9pbnQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiayIsImRlY29kZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJvdXQiLCJuIiwiYmlhcyIsImJhc2ljIiwiaiIsIm9sZGkiLCJ3IiwidCIsImJhc2VNaW51c1QiLCJsYXN0SW5kZXhPZiIsInNwbGljZSIsImVuY29kZSIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJtIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJ0b0FTQ0lJIiwiaGFzT3duUHJvcGVydHkiLCJ1dGlsIiwiaXNTdHJpbmciLCJhcmciLCJpc09iamVjdCIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIiwicHJvcCIsInByb3RvdHlwZSIsImNhbGwiLCJxcyIsInNlcCIsImVxIiwicmVnZXhwIiwibWF4S2V5cyIsImxlbiIsIngiLCJpZHgiLCJrc3RyIiwidnN0ciIsInYiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJpc0Zpbml0ZSIsImtzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicXVlcnlzdHJpbmciLCJ1cmxQYXJzZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsImZvcm1hdCQxIiwidXJsRm9ybWF0IiwiVXJsXzEiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwicG9ydCIsImhvc3RuYW1lIiwiaGFzaCIsInNlYXJjaCIsInF1ZXJ5IiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInBhcnNlUXVlcnlTdHJpbmciLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJUeXBlRXJyb3IiLCJxdWVyeUluZGV4Iiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzbGFzaFJlZ2V4IiwicmVzdCIsInRyaW0iLCJzaW1wbGVQYXRoIiwiZXhlYyIsInByb3RvIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidW5zaGlmdCIsInAiLCJoIiwiYWUiLCJlc2MiLCJlc2NhcGUiLCJxbSIsInMiLCJjaGFyQXQiLCJyZWxhdGl2ZSIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwic2hpZnQiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwicG9wIiwiYXV0aEluSG9zdCIsImxhc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJpc0Fic29sdXRlIiwiZ2V0UHJvcGVydHlSZWZlcmVuY2UiLCJwcm9wZXJ0eU5hbWUiLCJlYWNoU291cmNlIiwiY2FsbGJhY2siLCJlYWNoTGF5ZXIiLCJlYWNoUHJvcGVydHkiLCJpbm5lciIsInByb3BlcnR5VHlwZSIsImZvckVhY2giLCJlYWNoTGF5b3V0IiwiZWFjaFBhaW50IiwicmVzb2x2ZUNvbnN0YW50IiwiY29uc3RhbnRzIiwiaXNGdW5jdGlvbiIsInJlbmFtZVByb3BlcnR5IiwiZnJvbSIsInRvIiwibWlncmF0ZVRvVjgiLCJjb29yZCIsInJldmVyc2UiLCJzdG9wIiwibWlncmF0ZUZvbnRzdGFja1VSTCIsImlucHV0UGFyc2VkIiwiaW5wdXRQYXRobmFtZVBhcnRzIiwibWlncmF0ZUZvbnRTdGFjayIsInNwbGl0QW5kVHJpbSIsImZpcnN0U3ltYm9sTGF5ZXIiLCJzeW1ib2xMYXllcnMiLCJleHRlbmQiLCJpbnB1dHMiLCJQYXJzaW5nRXJyb3IiLCJtZXNzYWdlIiwiU2NvcGUiLCJwYXJlbnQiLCJiaW5kaW5ncyIsIk51bGxUeXBlIiwia2luZCIsIk51bWJlclR5cGUiLCJTdHJpbmdUeXBlIiwiQm9vbGVhblR5cGUiLCJDb2xvclR5cGUiLCJPYmplY3RUeXBlIiwiVmFsdWVUeXBlIiwiRXJyb3JUeXBlIiwiQ29sbGF0b3JUeXBlIiwiRm9ybWF0dGVkVHlwZSIsIlJlc29sdmVkSW1hZ2VUeXBlIiwiaXRlbVR5cGUiLCJOIiwidmFsdWVNZW1iZXJUeXBlcyIsImNoZWNrU3VidHlwZSIsImV4cGVjdGVkIiwibWVtYmVyVHlwZSIsImlzVmFsaWRUeXBlIiwicHJvdmlkZWQiLCJhbGxvd2VkVHlwZXMiLCJpc1ZhbGlkTmF0aXZlVHlwZSIsImNzc2NvbG9ycGFyc2VyIiwia0NTU0NvbG9yVGFibGUiLCJjbGFtcF9jc3NfYnl0ZSIsImNsYW1wX2Nzc19mbG9hdCIsImYiLCJwYXJzZV9jc3NfaW50Iiwic3RyIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwicGFyc2VfY3NzX2Zsb2F0IiwiY3NzX2h1ZV90b19yZ2IiLCJtMSIsIm0yIiwicGFyc2VDU1NDb2xvciIsImNzc19zdHIiLCJpdiIsIm9wIiwiZXAiLCJmbmFtZSIsInBhcmFtcyIsImFscGhhIiwiZyIsImIiLCJ0b0FycmF5IiwiYmxhY2siLCJ3aGl0ZSIsInRyYW5zcGFyZW50IiwicmVkIiwiYmx1ZSIsIkNvbGxhdG9yIiwiY2FzZVNlbnNpdGl2ZSIsImRpYWNyaXRpY1NlbnNpdGl2ZSIsImxvY2FsZSIsInNlbnNpdGl2aXR5IiwiSW50bCIsInVzYWdlIiwibGhzIiwicmhzIiwiY29tcGFyZSIsInJlc29sdmVkT3B0aW9ucyIsIkZvcm1hdHRlZFNlY3Rpb24iLCJ0ZXh0Iiwic2NhbGUiLCJmb250U3RhY2siLCJ0ZXh0Q29sb3IiLCJGb3JtYXR0ZWQiLCJzZWN0aW9ucyIsInNlY3Rpb24iLCJzZXJpYWxpemVkIiwidW5mb3JtYXR0ZWQiLCJmcm9tU3RyaW5nIiwiUmVzb2x2ZWRJbWFnZSIsImF2YWlsYWJsZSIsInZhbGlkYXRlUkdCQSIsImlzVmFsdWUiLCJtaXhlZCIsIml0ZW0iLCJ0eXBlT2YiLCJ0b1N0cmluZyQxIiwiTGl0ZXJhbCIsInNlcmlhbGl6ZSIsImFyZ3MiLCJjb250ZXh0IiwiZXhwZWN0ZWRUeXBlIiwiUnVudGltZUVycm9yIiwidHlwZXMiLCJBc3NlcnRpb24iLCJjdHgiLCJldmFsdWF0ZSIsImV2ZXJ5Iiwib3V0cHV0RGVmaW5lZCIsInBhcnNlZCIsIkZvcm1hdEV4cHJlc3Npb24iLCJldmFsdWF0ZVNlY3Rpb24iLCJldmFsdWF0ZWRDb250ZW50IiwiY29udGVudCIsImZpcnN0QXJnIiwibmV4dFRva2VuTWF5QmVPYmplY3QiLCJsYXN0RXhwcmVzc2lvbiIsIkltYWdlRXhwcmVzc2lvbiIsImV2YWx1YXRlZEltYWdlTmFtZSIsImF2YWlsYWJsZUltYWdlcyIsInR5cGVzJDEiLCJDb2VyY2lvbiIsIkJvb2xlYW4iLCJjIiwicGFyc2VDb2xvciIsIm51bSIsIk51bWJlciIsImlzTmFOIiwiZWFjaENoaWxkIiwiY2hpbGQiLCJnZW9tZXRyeVR5cGVzIiwiRXZhbHVhdGlvbkNvbnRleHQiLCJnbG9iYWxzIiwiZmVhdHVyZSIsImZlYXR1cmVTdGF0ZSIsImZvcm1hdHRlZFNlY3Rpb24iLCJfcGFyc2VDb2xvckNhY2hlIiwiY2Fub25pY2FsIiwiZmVhdHVyZVRpbGVDb29yZCIsImZlYXR1cmVEaXN0YW5jZURhdGEiLCJnZW9tZXRyeSIsInkiLCJkWCIsImRZIiwiYlgiLCJiWSIsImRpc3QiLCJjYWNoZWQiLCJDb21wb3VuZEV4cHJlc3Npb24iLCJfZXZhbHVhdGUiLCJkZWZpbml0aW9uIiwiZGVmaW5pdGlvbnMiLCJhdmFpbGFibGVPdmVybG9hZHMiLCJvdmVybG9hZHMiLCJzaWduYXR1cmUiLCJzaWduYXR1cmVDb250ZXh0IiwiUGFyc2luZ0NvbnRleHQiLCJyZWdpc3RyeSIsInNjb3BlIiwicGFyc2VkQXJncyIsImFyZ1BhcnNlRmFpbGVkIiwic2lnbmF0dXJlcyIsInN0cmluZ2lmeVNpZ25hdHVyZSIsImFjdHVhbFR5cGVzIiwiQ29sbGF0b3JFeHByZXNzaW9uIiwiRVhURU5UIiwidXBkYXRlQkJveCIsIm1lcmNhdG9yWGZyb21MbmciLCJsbmciLCJtZXJjYXRvcllmcm9tTGF0IiwibGF0IiwiUEkiLCJsb2ciLCJib3hXaXRoaW5Cb3giLCJiYm94MSIsImJib3gyIiwiZ2V0VGlsZUNvb3JkaW5hdGVzIiwidGlsZXNBdFpvb20iLCJwb3ciLCJ6Iiwib25Cb3VuZGFyeSIsInAxIiwicDIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInJheUludGVyc2VjdCIsInBvaW50V2l0aGluUG9seWdvbiIsInJpbmdzIiwiaW5zaWRlIiwicmluZyIsImxlbjIiLCJwb2ludFdpdGhpblBvbHlnb25zIiwicG9seWdvbnMiLCJwZXJwIiwidjEiLCJ2MiIsInR3b1NpZGVkIiwicTEiLCJxMiIsIngzIiwieTMiLCJkZXQxIiwiZGV0MiIsImxpbmVJbnRlcnNlY3RMaW5lIiwiZCIsInZlY3RvclAiLCJ2ZWN0b3JRIiwibGluZUludGVyc2VjdFBvbHlnb24iLCJwb2x5Z29uIiwibGluZVN0cmluZ1dpdGhpblBvbHlnb24iLCJsaW5lU3RyaW5nV2l0aGluUG9seWdvbnMiLCJnZXRUaWxlUG9seWdvbiIsImdldFRpbGVQb2x5Z29ucyIsInVwZGF0ZVBvaW50IiwicG9seUJCb3giLCJ3b3JsZFNpemUiLCJoYWxmV29ybGRTaXplIiwicmVzZXRCQm94IiwiZ2V0VGlsZVBvaW50cyIsInBvaW50QkJveCIsInNoaWZ0cyIsInRpbGVQb2ludHMiLCJwb2ludHMiLCJnZXRUaWxlTGluZXMiLCJsaW5lQkJveCIsInRpbGVMaW5lcyIsInRpbGVMaW5lIiwicG9pbnRzV2l0aGluUG9seWdvbnMiLCJwb2x5Z29uR2VvbWV0cnkiLCJjYW5vbmljYWxJRCIsInRpbGVQb2x5Z29uIiwidGlsZVBvbHlnb25zIiwibGluZXNXaXRoaW5Qb2x5Z29ucyIsIldpdGhpbiIsImdlb21ldHJpZXMiLCJnZW9tZXRyeVR5cGUiLCJpc0ZlYXR1cmVDb25zdGFudCIsImlzU3RhdGVDb25zdGFudCIsImlzR2xvYmFsUHJvcGVydHlDb25zdGFudCIsIlZhciIsImJvdW5kRXhwcmVzc2lvbiIsImV4cHIiLCJfcGFyc2UiLCJhbm5vdGF0ZSIsInR5cGVBbm5vdGF0aW9uIiwiRXhwciIsImFjdHVhbCIsImlzQ29uc3RhbnQiLCJlYyIsImlzVHlwZUFubm90YXRpb24iLCJjaGlsZHJlbkNvbnN0YW50IiwiZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyIsImxhc3RJbmRleCIsImxvd2VySW5kZXgiLCJ1cHBlckluZGV4IiwiY3VycmVudEluZGV4IiwibmV4dFZhbHVlIiwiU3RlcCIsIm91dHB1dHMiLCJsYWJlbCIsInN0b3BDb3VudCIsIm91dHB1dFR5cGUiLCJsYWJlbEtleSIsInZhbHVlS2V5IiwidW5pdGJlemllciIsIlVuaXRCZXppZXIiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJjeCIsImJ4IiwiYXgiLCJjeSIsImJ5IiwiYXkiLCJzYW1wbGVDdXJ2ZVgiLCJzYW1wbGVDdXJ2ZVkiLCJzYW1wbGVDdXJ2ZURlcml2YXRpdmVYIiwic29sdmVDdXJ2ZVgiLCJlcHNpbG9uIiwidDAiLCJ0MSIsInQyIiwiZDIiLCJzb2x2ZSIsImFycmF5JDEiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJYbiIsIlluIiwiWm4iLCJ0MyIsImRlZzJyYWQiLCJyYWQyZGVnIiwieHl6MmxhYiIsImxhYjJ4eXoiLCJ4eXoycmdiIiwicmdiMnh5eiIsInJnYlRvTGFiIiwicmdiQ29sb3IiLCJsYWJUb1JnYiIsImxhYkNvbG9yIiwiaW50ZXJwb2xhdGVMYWIiLCJyZ2JUb0hjbCIsImF0YW4yIiwiaGNsVG9SZ2IiLCJoY2xDb2xvciIsImludGVycG9sYXRlSHVlIiwiaW50ZXJwb2xhdGVIY2wiLCJmb3J3YXJkIiwiY29sb3JTcGFjZXMiLCJJbnRlcnBvbGF0ZSIsIm9wZXJhdG9yIiwiaW50ZXJwb2xhdGlvbiIsImxvd2VyIiwidXBwZXIiLCJpbnRlcnBvbGF0aW9uRmFjdG9yIiwib3V0cHV0TG93ZXIiLCJvdXRwdXRVcHBlciIsImNvbnRyb2xQb2ludHMiLCJleHBvbmVudGlhbEludGVycG9sYXRpb24iLCJ1YiIsImxvd2VyVmFsdWUiLCJ1cHBlclZhbHVlIiwiZGlmZmVyZW5jZSIsInByb2dyZXNzIiwiQ29hbGVzY2UiLCJhcmdDb3VudCIsInJlcXVlc3RlZEltYWdlTmFtZSIsIm5lZWRzQW5ub3RhdGlvbiIsIkxldCIsImJpbmRpbmciLCJBdCIsIkluIiwibmVlZGxlIiwiaGF5c3RhY2siLCJJbmRleE9mIiwiZnJvbUluZGV4IiwiTWF0Y2giLCJpbnB1dFR5cGUiLCJjYXNlcyIsIm90aGVyd2lzZSIsInNvcnRlZExhYmVscyIsInNvcnQiLCJncm91cGVkQnlPdXRwdXQiLCJvdXRwdXRMb29rdXAiLCJvdXRwdXRJbmRleCIsImNvZXJjZUxhYmVsIiwibGFiZWxDb250ZXh0IiwiTUFYX1NBRkVfSU5URUdFUiIsIkNhc2UiLCJicmFuY2hlcyIsIl8iLCJTbGljZSIsImJlZ2luSW5kZXgiLCJlbmRJbmRleCIsImlzQ29tcGFyYWJsZVR5cGUiLCJuZXEiLCJsdCIsImd0IiwibHRlcSIsImd0ZXEiLCJlcUNvbGxhdGUiLCJuZXFDb2xsYXRlIiwibHRDb2xsYXRlIiwiZ3RDb2xsYXRlIiwibHRlcUNvbGxhdGUiLCJndGVxQ29sbGF0ZSIsIm1ha2VDb21wYXJpc29uIiwiY29tcGFyZUJhc2ljIiwiY29tcGFyZVdpdGhDb2xsYXRvciIsImlzT3JkZXJDb21wYXJpc29uIiwiaGFzVW50eXBlZEFyZ3VtZW50IiwicnQiLCJDb21wYXJpc29uIiwiRXF1YWxzIiwiTm90RXF1YWxzIiwiTGVzc1RoYW4iLCJHcmVhdGVyVGhhbiIsIkxlc3NUaGFuT3JFcXVhbCIsIkdyZWF0ZXJUaGFuT3JFcXVhbCIsIk51bWJlckZvcm1hdCIsImN1cnJlbmN5IiwibWluRnJhY3Rpb25EaWdpdHMiLCJtYXhGcmFjdGlvbkRpZ2l0cyIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsIkxlbmd0aCIsImV4cHJlc3Npb25zIiwiYmluYXJ5U2VhcmNoIiwidmFyYXJncyIsInJlZ2lzdGVyIiwiZGlzdGFuY2VGcm9tQ2VudGVyIiwiaGVhdG1hcERlbnNpdHkiLCJsaW5lUHJvZ3Jlc3MiLCJza3lSYWRpYWxQcm9ncmVzcyIsIkxOMiIsIkUiLCJMTjEwIiwiaXNTdXBwb3J0ZWRTY3JpcHQiLCJ0b1VwcGVyQ2FzZSIsInJlc29sdmVkTG9jYWxlIiwic3VjY2VzcyIsInN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uIiwic3BlYyIsInN1cHBvcnRzWm9vbUV4cHJlc3Npb24iLCJzdXBwb3J0c0ludGVycG9sYXRpb24iLCJnZXRUeXBlIiwidmFsIiwiaXNGdW5jdGlvbiQxIiwiaWRlbnRpdHlGdW5jdGlvbiIsImNyZWF0ZUZ1bmN0aW9uIiwicHJvcGVydHlTcGVjIiwiaXNDb2xvciIsInpvb21BbmRGZWF0dXJlRGVwZW5kZW50IiwiZmVhdHVyZURlcGVuZGVudCIsInpvb21EZXBlbmRlbnQiLCJkZWZhdWx0IiwiaW5uZXJGdW4iLCJoYXNoZWRTdG9wcyIsImNhdGVnb3JpY2FsS2V5VHlwZSIsImV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbiIsImV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbiIsImV2YWx1YXRlQ2F0ZWdvcmljYWxGdW5jdGlvbiIsImNyZWF0ZSIsImV2YWx1YXRlSWRlbnRpdHlGdW5jdGlvbiIsImZlYXR1cmVGdW5jdGlvbnMiLCJ6b29tU3RvcHMiLCJmZWF0dXJlRnVuY3Rpb25TdG9wcyIsImludGVycG9sYXRpb25UeXBlIiwiYmluZCIsImtleVR5cGUiLCJldmFsdWF0ZWQiLCJpbnRlcnAiLCJjb2xvcnNwYWNlIiwiZXZhbHVhdGVkTG93ZXIiLCJldmFsdWF0ZWRVcHBlciIsIlN0eWxlRXhwcmVzc2lvbiIsIl93YXJuaW5nSGlzdG9yeSIsIl9ldmFsdWF0b3IiLCJfZGVmYXVsdFZhbHVlIiwiZ2V0RGVmYXVsdFZhbHVlIiwiX2VudW1WYWx1ZXMiLCJ3YXJuIiwiaXNFeHByZXNzaW9uIiwiY3JlYXRlRXhwcmVzc2lvbiIsInBhcnNlciIsImdldEV4cGVjdGVkVHlwZSIsIlpvb21Db25zdGFudEV4cHJlc3Npb24iLCJfc3R5bGVFeHByZXNzaW9uIiwiaXNTdGF0ZURlcGVuZGVudCIsImV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmciLCJab29tRGVwZW5kZW50RXhwcmVzc2lvbiIsImNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbiIsImlzRmVhdHVyZUNvbnN0YW50JDEiLCJpc1pvb21Db25zdGFudCIsInpvb21DdXJ2ZSIsImZpbmRab29tQ3VydmUiLCJTdHlsZVByb3BlcnR5RnVuY3Rpb24iLCJzcGVjaWZpY2F0aW9uIiwiX3BhcmFtZXRlcnMiLCJfc3BlY2lmaWNhdGlvbiIsIm5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbiIsImNoaWxkUmVzdWx0IiwiZW51bSIsImZvcm1hdHRlZCIsInJlc29sdmVkSW1hZ2UiLCJjb252ZXJ0TGl0ZXJhbCIsImNvbnZlcnRGdW5jdGlvbiIsImNvbnZlcnRJZGVudGl0eUZ1bmN0aW9uIiwiY29udmVydFRva2VuU3RyaW5nIiwiY29udmVydFpvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uIiwiY29udmVydFpvb21GdW5jdGlvbiIsImNvbnZlcnRQcm9wZXJ0eUZ1bmN0aW9uIiwiZ2V0SW50ZXJwb2xhdGVPcGVyYXRvciIsImZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnMiLCJmdW5jdGlvblR5cGUiLCJnZXRGdW5jdGlvblR5cGUiLCJhcHBlbmRTdG9wUGFpciIsImZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZSIsImNvYWxlc2NlJDEiLCJnZXRGYWxsYmFjayIsImRlZmF1bHRWYWx1ZSIsImlzU3RlcCIsImN1cnZlIiwicmUiLCJwb3MiLCJ1bmJ1bmRsZSIsInZhbHVlT2YiLCJkZWVwVW5idW5kbGUiLCJ1bmJ1bmRsZWRWYWx1ZSIsImlzRXhwcmVzc2lvbkZpbHRlciIsImNyZWF0ZUZpbHRlciIsImxheWVyVHlwZSIsIm5lZWRHZW9tZXRyeSIsIm5lZWRGZWF0dXJlIiwiY29udmVydEZpbHRlciIsImZpbHRlckV4cCIsInN0YXRpY0ZpbHRlciIsImV4dHJhY3RTdGF0aWNGaWx0ZXIiLCJmaWx0ZXJTcGVjIiwiY29tcGlsZWRTdGF0aWNGaWx0ZXIiLCJmaWx0ZXJGdW5jIiwiZ2xvYmFsUHJvcGVydGllcyIsImR5bmFtaWNGaWx0ZXJGdW5jIiwiY29tcGlsZWREeW5hbWljRmlsdGVyIiwiZ2VvbWV0cnlOZWVkZWQiLCJkeW5hbWljRmlsdGVyIiwiaXNEeW5hbWljRmlsdGVyIiwidW5pb25EeW5hbWljQnJhbmNoZXMiLCJjb2xsYXBzZUR5bmFtaWNCb29sZWFuRXhwcmVzc2lvbnMiLCJjb2xsYXBzZWQiLCJjb2xsYXBzZWRFeHByZXNzaW9uIiwic3ViRXhwcmVzc2lvbiIsImlzQnJhbmNoaW5nRHluYW1pY2FsbHkiLCJpc1Jvb3RFeHByZXNzaW9uRHluYW1pYyIsImR5bmFtaWNDb25kaXRpb25FeHByZXNzaW9ucyIsIlNldCIsInBhcmFtIiwiY29udmVydGVkIiwiY29udmVydENvbXBhcmlzb25PcCIsImNvbnZlcnROZWdhdGlvbiIsImNvbnZlcnREaXNqdW5jdGlvbk9wIiwiY29udmVydEluT3AiLCJjb252ZXJ0SGFzT3AiLCJmaWx0ZXJzIiwiY29udmVydEZpbHRlciQxIiwiX2NvbnZlcnRGaWx0ZXIiLCJleHBlY3RlZFR5cGVzIiwiY29udmVydENvbXBhcmlzb25PcCQxIiwiY2hpbGRyZW4iLCJ0eXBlY2hlY2tzIiwicnVudGltZVR5cGVDaGVja3MiLCJjb252ZXJ0SW5PcCQxIiwiY29udmVydEhhc09wJDEiLCJjb25kaXRpb25zIiwibmVnYXRlIiwidW5pZm9ybVR5cGVzIiwidW5pcXVlVmFsdWVzIiwibWlncmF0ZVRvRXhwcmVzc2lvbnMiLCJtaWdyYXRlIiwibWlncmF0ZWQiLCJjb21wb3NpdGUiLCJzdHlsZUlEcyIsInNvdXJjZUlEcyIsImNvbXBvc2l0ZWRTb3VyY2VMYXllcnMiLCJjb21wb3NpdGVJRCIsInJlZlByb3BlcnRpZXMiLCJkZXJlZiIsImRlcmVmTGF5ZXJzIiwiZGVlcEVxdWFsIiwib3BlcmF0aW9ucyIsInJlbW92ZUxheWVyIiwic2V0UGFpbnRQcm9wZXJ0eSIsInNldExheW91dFByb3BlcnR5Iiwic2V0RmlsdGVyIiwiYWRkU291cmNlIiwicmVtb3ZlU291cmNlIiwic2V0R2VvSlNPTlNvdXJjZURhdGEiLCJzZXRMYXllclpvb21SYW5nZSIsInNldExheWVyUHJvcGVydHkiLCJzZXRCZWFyaW5nIiwic2V0UGl0Y2giLCJzZXRTcHJpdGUiLCJzZXRHbHlwaHMiLCJzZXRUcmFuc2l0aW9uIiwic2V0TGlnaHQiLCJzZXRUZXJyYWluIiwic2V0Rm9nIiwic2V0UHJvamVjdGlvbiIsImFmdGVyIiwiY29tbWFuZHMiLCJjb21tYW5kIiwic291cmNlc1JlbW92ZWQiLCJ1cGRhdGVTb3VyY2UiLCJjYW5VcGRhdGVHZW9KU09OIiwiYmVmb3JlIiwiZGlmZlNvdXJjZXMiLCJkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMiLCJrbGFzcyIsInBsdWNrSWQiLCJpbmRleEJ5SWQiLCJkaWZmTGF5ZXJzIiwiYmVmb3JlT3JkZXIiLCJhZnRlck9yZGVyIiwiYmVmb3JlSW5kZXgiLCJyZWR1Y2UiLCJhZnRlckluZGV4IiwidHJhY2tlciIsImNsZWFuIiwiYmVmb3JlTGF5ZXIiLCJhZnRlckxheWVyIiwiaW5zZXJ0QmVmb3JlTGF5ZXJJZCIsImRpZmZTdHlsZXMiLCJyZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzIiwiYmVmb3JlTGF5ZXJzIiwiYmVmb3JlVGVycmFpbiIsIlZhbGlkYXRpb25FcnJvciIsImlkZW50aWZpZXIiLCJfX2xpbmVfXyIsIlBhcnNpbmdFcnJvciQxIiwidmFsaWRhdGVDb25zdGFudHMiLCJ2YWxpZGF0ZU9iamVjdCIsImVsZW1lbnRTcGVjcyIsInZhbHVlU3BlYyIsImVsZW1lbnRWYWxpZGF0b3JzIiwib2JqZWN0RWxlbWVudFZhbGlkYXRvcnMiLCJzdHlsZVNwZWMiLCJvYmplY3RLZXkiLCJlbGVtZW50U3BlY0tleSIsImVsZW1lbnRTcGVjIiwidmFsaWRhdGVFbGVtZW50IiwidmFsaWRhdGUiLCJ2YWxpZGF0ZUFycmF5IiwiYXJyYXlTcGVjIiwidmFsaWRhdGVBcnJheUVsZW1lbnQiLCJhcnJheUVsZW1lbnRWYWxpZGF0b3IiLCJhcnJheUVsZW1lbnRTcGVjIiwiZnVuY3Rpb24iLCJhcnJheUluZGV4IiwidmFsaWRhdGVOdW1iZXIiLCJzcGVjTWluIiwic3BlY01heCIsInZhbGlkYXRlRnVuY3Rpb24iLCJmdW5jdGlvblZhbHVlU3BlYyIsInN0b3BLZXlUeXBlIiwic3RvcERvbWFpblZhbHVlcyIsInByZXZpb3VzU3RvcERvbWFpblZhbHVlIiwicHJldmlvdXNTdG9wRG9tYWluWm9vbSIsImlzWm9vbUZ1bmN0aW9uIiwiaXNQcm9wZXJ0eUZ1bmN0aW9uIiwiaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbiIsInZhbGlkYXRlRnVuY3Rpb25TdG9wcyIsInZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0IiwidmFsaWRhdGVGdW5jdGlvblN0b3AiLCJ2YWxpZGF0ZVN0b3BEb21haW5WYWx1ZSIsInJlcG9ydFZhbHVlIiwidmFsaWRhdGVFeHByZXNzaW9uIiwiZXhwcmVzc2lvbkNvbnRleHQiLCJleHByZXNzaW9uT2JqIiwicHJvcGVydHlLZXkiLCJkaXNhbGxvd2VkRmlsdGVyUGFyYW1ldGVycyIsImRpc2FsbG93ZWRQYXJhbWV0ZXJzIiwiZGVsZXRlIiwidmFsaWRhdGVCb29sZWFuIiwidmFsaWRhdGVDb2xvciIsInZhbGlkYXRlRW51bSIsInZhbGlkYXRlRmlsdGVyIiwidmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyIiwidmFsaWRhdGVQcm9wZXJ0eSIsImxheWVyU3BlYyIsInRyYW5zaXRpb25NYXRjaCIsInRva2VuTWF0Y2giLCJ2YWxpZGF0ZVBhaW50UHJvcGVydHkiLCJ2YWxpZGF0ZUxheW91dFByb3BlcnR5IiwidmFsaWRhdGVMYXllciIsIm90aGVyTGF5ZXIiLCJzb3VyY2VUeXBlIiwidmFsaWRhdGVTdHJpbmciLCJ2YWxpZGF0ZVByb21vdGVJZCIsInZhbGlkYXRlU291cmNlIiwibWFwRXhwciIsInJlZHVjZUV4cHIiLCJ2YWxpZGF0ZUxpZ2h0IiwibGlnaHRTcGVjIiwicm9vdFR5cGUiLCJ2YWxpZGF0ZVRlcnJhaW4iLCJ0ZXJyYWluU3BlYyIsInZhbGlkYXRlRm9nIiwiZm9nU3BlYyIsInZhbGlkYXRlRm9ybWF0dGVkIiwidmFsaWRhdGVJbWFnZSIsInZhbGlkYXRlUHJvamVjdGlvbiIsInByb2plY3Rpb25TcGVjIiwiVkFMSURBVE9SUyIsInZhbGlkIiwidmFsaWRhdGVHbHlwaHNVUkwiLCJ2YWxpZGF0ZVN0eWxlTWluIiwic29ydEVycm9ycyIsIndyYXBDbGVhbkVycm9ycyIsInBhaW50UHJvcGVydHkiLCJsYXlvdXRQcm9wZXJ0eSIsImpzb25saW50IiwibyIsIiRWMCIsIiRWMSIsIiRWMiIsIiRWMyIsIiRWNCIsIiRWNSIsIiRWNiIsIiRWNyIsIiRWOCIsIiRWOSIsInRyYWNlIiwieXkiLCJzeW1ib2xzXyIsInRlcm1pbmFsc18iLCJwcm9kdWN0aW9uc18iLCJwZXJmb3JtQWN0aW9uIiwiYW5vbnltb3VzIiwieXl0ZXh0IiwieXlsZW5nIiwieXlsaW5lbm8iLCJ5eXN0YXRlIiwiJCQiLCJfJCIsIiQwIiwiJCIsImZpcnN0X2xpbmUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ0YWJsZSIsImRlZmF1bHRBY3Rpb25zIiwicGFyc2VFcnJvciIsInJlY292ZXJhYmxlIiwic3RhY2siLCJ2c3RhY2siLCJsc3RhY2siLCJURVJST1IiLCJFT0YiLCJhcmd1bWVudHMiLCJsZXhlciIsInNoYXJlZFN0YXRlIiwic2V0SW5wdXQiLCJ5eWxsb2MiLCJ5eWxvYyIsInJhbmdlcyIsImdldFByb3RvdHlwZU9mIiwibGV4IiwidG9rZW4iLCJzdGF0ZSIsImFjdGlvbiIsInl5dmFsIiwibmV3U3RhdGUiLCJlcnJTdHIiLCJzaG93UG9zaXRpb24iLCJsb2MiLCJsYXN0X2xpbmUiLCJmaXJzdF9jb2x1bW4iLCJsYXN0X2NvbHVtbiIsIl9pbnB1dCIsIl9tb3JlIiwiX2JhY2t0cmFjayIsImRvbmUiLCJtYXRjaGVkIiwiY29uZGl0aW9uU3RhY2siLCJvZmZzZXQiLCJjaCIsImxpbmVzIiwidW5wdXQiLCJvbGRMaW5lcyIsIm1vcmUiLCJiYWNrdHJhY2tfbGV4ZXIiLCJsZXNzIiwicGFzdElucHV0IiwicGFzdCIsInVwY29taW5nSW5wdXQiLCJuZXh0IiwicHJlIiwidGVzdF9tYXRjaCIsImluZGV4ZWRfcnVsZSIsImJhY2t1cCIsIm1hdGNoZXMiLCJ0ZW1wTWF0Y2giLCJydWxlcyIsIl9jdXJyZW50UnVsZXMiLCJmbGV4IiwiYmVnaW4iLCJjb25kaXRpb24iLCJwb3BTdGF0ZSIsInRvcFN0YXRlIiwicHVzaFN0YXRlIiwic3RhdGVTdGFja1NpemUiLCJ5eV8iLCIkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zIiwiWVlfU1RBUlQiLCJQYXJzZXIiLCJyZWFkU3R5bGUiLCJCdWZmZXIiLCJ2YWxpZGF0ZVN0eWxlIiwiU1VQUE9SVEVEX1NQRUNfVkVSU0lPTiIsIk1BWF9TT1VSQ0VTX0lOX1NUWUxFIiwiaXNWYWxpZCIsInJlZ2V4IiwiZ2V0U291cmNlQ291bnQiLCJnZXRBbGxvd2VkS2V5RXJyb3JzIiwiYWxsb3dlZCIsImFjY2VwdGVkU291cmNlVHlwZXMiLCJnZXRTb3VyY2VFcnJvcnMiLCJzb3VyY2VLZXlzIiwic291cmNlVXJsUGF0dGVybiIsImdldFNvdXJjZXNFcnJvcnMiLCJjb3VudCIsInNvdXJjZUVycm9ycyIsImdldFJvb3RFcnJvcnMiLCJzcGVjS2V5cyIsIm9wdGlvbmFsUm9vdFByb3BlcnRpZXMiLCJhbGxvd2VkS2V5RXJyb3JzIiwiZ2x5cGhVcmxQYXR0ZXJuIiwic3ByaXRlVXJsUGF0dGVybiIsInZpc2liaWxpdHlQYXR0ZXJuIiwicHJvdGVjdGVkIiwidmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQiLCJleHByZXNzaW9uJDEiLCJzdHlsZUZ1bmN0aW9uIiwidmlzaXQiLCJsYXRlc3QiLCJkaWZmIiwiZmVhdHVyZUZpbHRlciIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwiY29kZSIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImFyciIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJlbmNvZGVDaHVuayIsInVpbnQ4IiwiZXh0cmFCeXRlcyIsIm1heENodW5rTGVuZ3RoIiwiYmFzZTY0IiwicmVxdWlyZSIsImllZWU3NTQiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJrTWF4TGVuZ3RoIiwiZm9vIiwic3ViYXJyYXkiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwicG9vbFNpemUiLCJfYXVnbWVudCIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25maWd1cmFibGUiLCJhc3NlcnRTaXplIiwiYWxsb2MiLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsIndyaXRlIiwiZnJvbUFycmF5TGlrZSIsImJ5dGVPZmZzZXQiLCJpc0J1ZmZlciIsImNvcHkiLCJpc25hbiIsIl9pc0J1ZmZlciIsImxpc3QiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsInJldCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsImZvbnRXZWlnaHRzIiwidGhpbiIsImhhaXJsaW5lIiwiYm9vayIsInJlZ3VsYXIiLCJub3JtYWwiLCJwbGFpbiIsInJvbWFuIiwic3RhbmRhcmQiLCJtZWRpdW0iLCJib2xkIiwiaGVhdnkiLCJmYXQiLCJwb3N0ZXIiLCJzcCIsIml0YWxpY1JFIiwiZm9udENhY2hlIiwibGluZUhlaWdodCIsImNzc0RhdGEiLCJ3ZWlnaHQiLCJmb250RmFtaWxpZXMiLCJoYXZlV2VpZ2h0IiwiaGF2ZVN0eWxlIiwibWF5YmVXZWlnaHQiLCJmb250RmFtaWx5IiwiQXNzZXJ0aW9uRXJyb3IiLCJWRVJTSU9OIiwiRGlzcG9zYWJsZSIsImRpc3Bvc2VkXyIsImRpc3Bvc2UiLCJkaXNwb3NlSW50ZXJuYWwiLCJVTkRFRklORUQiLCJJbWFnZVRpbGUiLCJ0aWxlQ29vcmQiLCJ0aWxlTG9hZEZ1bmN0aW9uIiwib3B0X29wdGlvbnMiLCJUaWxlIiwiY3Jvc3NPcmlnaW5fIiwic3JjXyIsImltYWdlXyIsIkltYWdlIiwiaW1hZ2VMaXN0ZW5lcktleXNfIiwidGlsZUxvYWRGdW5jdGlvbl8iLCJUaWxlU3RhdGUiLCJMT0FESU5HIiwidW5saXN0ZW5JbWFnZV8iLCJnZXRCbGFua0ltYWdlIiwiaW50ZXJpbVRpbGUiLCJBQk9SVCIsImNoYW5nZWQiLCJnZXRLZXkiLCJoYW5kbGVJbWFnZUVycm9yXyIsIkVSUk9SIiwiaGFuZGxlSW1hZ2VMb2FkXyIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJMT0FERUQiLCJFTVBUWSIsImxvYWQiLCJJRExFIiwiRXZlbnRUeXBlIiwiTE9BRCIsInVubGlzdGVuQnlLZXkiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNhbnZhcyIsImdldENoYW5nZUV2ZW50VHlwZSIsIk9iamVjdEV2ZW50Iiwib2xkVmFsdWUiLCJFdmVudCIsIkJhc2VPYmplY3QiLCJvcHRfdmFsdWVzIiwiT2JzZXJ2YWJsZSIsInZhbHVlc18iLCJzZXRQcm9wZXJ0aWVzIiwiY2hhbmdlRXZlbnRUeXBlQ2FjaGUiLCJnZXRLZXlzIiwiZ2V0UHJvcGVydGllcyIsIm5vdGlmeSIsImV2ZW50VHlwZSIsImRpc3BhdGNoRXZlbnQiLCJPYmplY3RFdmVudFR5cGUiLCJQUk9QRVJUWUNIQU5HRSIsIm9wdF9zaWxlbnQiLCJ1bnNldCIsInVuQnlLZXkiLCJFdmVudFRhcmdldCIsInJldmlzaW9uXyIsIkNIQU5HRSIsImdldFJldmlzaW9uIiwibGlzdGVuZXIiLCJ1biIsInRyYW5zaXRpb25fIiwidHJhbnNpdGlvblN0YXJ0c18iLCJnZXRJbnRlcmltVGlsZSIsInJlZnJlc2hJbnRlcmltQ2hhaW4iLCJwcmV2Iiwic2V0U3RhdGUiLCJnZXRBbHBoYSIsInRpbWUiLCJpblRyYW5zaXRpb24iLCJlbmRUcmFuc2l0aW9uIiwiVGlsZUNhY2hlIiwib3B0X2hpZ2hXYXRlck1hcmsiLCJMUlVDYWNoZSIsImV4cGlyZUNhY2hlIiwidXNlZFRpbGVzIiwiY2FuRXhwaXJlQ2FjaGUiLCJwZWVrTGFzdCIsInpLZXkiLCJjb250YWlucyIsInBydW5lRXhjZXB0TmV3ZXN0WiIsImdldENvdW50IiwicGVla0ZpcnN0S2V5IiwicmVtb3ZlIiwiY3JlYXRlT3JVcGRhdGUiLCJUaWxlUmFuZ2UiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwidGlsZVJhbmdlIiwiY29udGFpbnNYWSIsImNvbnRhaW5zVGlsZVJhbmdlIiwiZ2V0SGVpZ2h0IiwiZ2V0V2lkdGgiLCJpbnRlcnNlY3RzIiwibnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbiIsImxpbmVhckZpbmROZWFyZXN0IiwicmV2ZXJzZVN1YkFycmF5IiwiZmluZCIsInN0YWJsZVNvcnQiLCJmaW5kSW5kZXgiLCJpc1NvcnRlZCIsIm9wdF9jb21wYXJhdG9yIiwibWlkIiwiY21wIiwiY29tcGFyYXRvciIsImxvdyIsImhpZ2giLCJkaXJlY3Rpb24iLCJmdW5jIiwiYXJyMSIsImFycjIiLCJsZW4xIiwiY29tcGFyZUZuYyIsImVsIiwib3B0X2Z1bmMiLCJvcHRfc3RyaWN0IiwiY3VycmVudFZhbCIsImFzc2VydCIsImFzc2VydGlvbiIsImVycm9yQ29kZSIsImNyZWF0ZUNhbnZhc0NvbnRleHQyRCIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsInJlcGxhY2VOb2RlIiwicmVtb3ZlTm9kZSIsInJlbW92ZUNoaWxkcmVuIiwib3B0X3dpZHRoIiwib3B0X2hlaWdodCIsImdldENvbnRleHQiLCJvZmZzZXRXaWR0aCIsImdldENvbXB1dGVkU3R5bGUiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJvZmZzZXRIZWlnaHQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJuZXdOb2RlIiwib2xkTm9kZSIsInBhcmVudE5vZGUiLCJyZXBsYWNlQ2hpbGQiLCJub2RlIiwicmVtb3ZlQ2hpbGQiLCJsYXN0Q2hpbGQiLCJlYXNlSW4iLCJlYXNlT3V0IiwiaW5BbmRPdXQiLCJ1cEFuZERvd24iLCJiaW5kTGlzdGVuZXIiLCJmaW5kTGlzdGVuZXIiLCJnZXRMaXN0ZW5lcnMiLCJsaXN0ZW4iLCJsaXN0ZW5PbmNlIiwidW5saXN0ZW4iLCJ1bmxpc3RlbkFsbCIsImxpc3RlbmVyT2JqIiwiYm91bmRMaXN0ZW5lciIsImV2dCIsImJpbmRUbyIsImNhbGxPbmNlIiwibGlzdGVuZXJzIiwib3B0X3RoaXMiLCJvcHRfc2V0RGVsZXRlSW5kZXgiLCJkZWxldGVJbmRleCIsImxpc3RlbmVyTWFwIiwib2xfbG0iLCJnZXRMaXN0ZW5lck1hcCIsInJlbW92ZUxpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvcHRfb25jZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInByb3BhZ2F0aW9uU3RvcHBlZCIsInBlbmRpbmdSZW1vdmFsc18iLCJkaXNwYXRjaGluZ18iLCJsaXN0ZW5lcnNfIiwiZXZlbnQiLCJwcm9wYWdhdGUiLCJwZW5kaW5nUmVtb3ZhbHMiLCJoYXNMaXN0ZW5lciIsIm9wdF90eXBlIiwiQ0xFQVIiLCJDT05URVhUTUVOVSIsIkNMSUNLIiwiREJMQ0xJQ0siLCJEUkFHRU5URVIiLCJEUkFHT1ZFUiIsIkRST1AiLCJLRVlET1dOIiwiS0VZUFJFU1MiLCJNT1VTRURPV04iLCJNT1VTRU1PVkUiLCJNT1VTRU9VVCIsIk1PVVNFVVAiLCJNT1VTRVdIRUVMIiwiTVNQT0lOVEVSRE9XTiIsIlJFU0laRSIsIlRPVUNIU1RBUlQiLCJUT1VDSE1PVkUiLCJUT1VDSEVORCIsIldIRUVMIiwiYm91bmRpbmdFeHRlbnQiLCJjbG9uZSIsImNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSIsImNvbnRhaW5zQ29vcmRpbmF0ZSIsImNvbnRhaW5zRXh0ZW50IiwiY29vcmRpbmF0ZVJlbGF0aW9uc2hpcCIsImNyZWF0ZUVtcHR5IiwiY3JlYXRlT3JVcGRhdGVFbXB0eSIsImNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUiLCJjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyIsImNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyIsImNyZWF0ZU9yVXBkYXRlRnJvbVJpbmdzIiwiZXh0ZW5kQ29vcmRpbmF0ZSIsImV4dGVuZENvb3JkaW5hdGVzIiwiZXh0ZW5kRmxhdENvb3JkaW5hdGVzIiwiZXh0ZW5kUmluZ3MiLCJleHRlbmRYWSIsImZvckVhY2hDb3JuZXIiLCJnZXRBcmVhIiwiZ2V0Qm90dG9tTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiZ2V0Q29ybmVyIiwiZ2V0RW5sYXJnZWRBcmVhIiwiZ2V0Rm9yVmlld0FuZFNpemUiLCJnZXRJbnRlcnNlY3Rpb25BcmVhIiwiZ2V0SW50ZXJzZWN0aW9uIiwiZ2V0TWFyZ2luIiwiZ2V0VG9wTGVmdCIsImdldFRvcFJpZ2h0IiwiaXNFbXB0eSIsInJldHVybk9yVXBkYXRlIiwic2NhbGVGcm9tQ2VudGVyIiwiaW50ZXJzZWN0c1NlZ21lbnQiLCJhcHBseVRyYW5zZm9ybSIsImV4dGVudCIsIl9ib3VuZGluZ0V4dGVudFhZcyIsInhzIiwieXMiLCJvcHRfZXh0ZW50IiwiZHgiLCJkeSIsImNvb3JkaW5hdGUiLCJleHRlbnQxIiwiZXh0ZW50MiIsInJlbGF0aW9uc2hpcCIsIlJlbGF0aW9uc2hpcCIsIlVOS05PV04iLCJMRUZUIiwiUklHSFQiLCJCRUxPVyIsIkFCT1ZFIiwiSU5URVJTRUNUSU5HIiwiZmxhdENvb3JkaW5hdGVzIiwic3RyaWRlIiwiYXJlYSIsImNvcm5lciIsIkNvcm5lciIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NX1JJR0hUIiwiVE9QX0xFRlQiLCJUT1BfUklHSFQiLCJyZXNvbHV0aW9uIiwicm90YXRpb24iLCJjb3NSb3RhdGlvbiIsInNpblJvdGF0aW9uIiwieENvcyIsInhTaW4iLCJ5Q29zIiwieVNpbiIsIngwIiwieTAiLCJpbnRlcnNlY3Rpb24iLCJkZWx0YVgiLCJkZWx0YVkiLCJzdGFydFJlbCIsImVuZFJlbCIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwic2xvcGUiLCJ0cmFuc2Zvcm1GbiIsIlRSVUUiLCJGQUxTRSIsIlBPSU5UIiwiTElORV9TVFJJTkciLCJMSU5FQVJfUklORyIsIlBPTFlHT04iLCJNVUxUSV9QT0lOVCIsIk1VTFRJX0xJTkVfU1RSSU5HIiwiTVVMVElfUE9MWUdPTiIsIkdFT01FVFJZX0NPTExFQ1RJT04iLCJDSVJDTEUiLCJpbmhlcml0cyIsImdldFVpZCIsIkRFQlVHX1dFQkdMIiwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRSIsIldFQkdMX0VYVEVOU0lPTlMiLCJIQVNfV0VCR0wiLCJnbCIsImZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfVEVYVFVSRV9TSVpFIiwiZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucyIsImNoaWxkQ3RvciIsInBhcmVudEN0b3IiLCJjb25zdHJ1Y3RvciIsInVpZENvdW50ZXJfIiwib2xfdWlkIiwiY2xhbXAiLCJyb3VuZFVwVG9Qb3dlck9mVHdvIiwic3F1YXJlZFNlZ21lbnREaXN0YW5jZSIsInNxdWFyZWREaXN0YW5jZSIsInNvbHZlTGluZWFyU3lzdGVtIiwidG9EZWdyZWVzIiwidG9SYWRpYW5zIiwibW9kdWxvIiwibGVycCIsImNvc2giLCJleHAiLCJtYXQiLCJtYXhSb3ciLCJtYXhFbCIsImFic1ZhbHVlIiwiY29lZiIsImFuZ2xlSW5SYWRpYW5zIiwiYW5nbGVJbkRlZ3JlZXMiLCJjbGVhciIsImdldFZhbHVlcyIsImFzc2lnbiIsInZhcl9zb3VyY2VzIiwiY2xvbmVUcmFuc2Zvcm0iLCJpZGVudGl0eVRyYW5zZm9ybSIsImFkZFByb2plY3Rpb24iLCJhZGRQcm9qZWN0aW9ucyIsImdldFBvaW50UmVzb2x1dGlvbiIsImFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyIsImFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zIiwiY2xlYXJBbGxQcm9qZWN0aW9ucyIsImNyZWF0ZVByb2plY3Rpb24iLCJjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybSIsImFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zIiwiZnJvbUxvbkxhdCIsInRvTG9uTGF0IiwiZXF1aXZhbGVudCIsImdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyIsImdldFRyYW5zZm9ybSIsInRyYW5zZm9ybSIsInRyYW5zZm9ybUV4dGVudCIsInRyYW5zZm9ybVdpdGhQcm9qZWN0aW9ucyIsImFkZENvbW1vbiIsInByb2plY3Rpb25zIiwiTUVURVJTX1BFUl9VTklUIiwib3B0X291dHB1dCIsIm9wdF9kaW1lbnNpb24iLCJhZGQiLCJnZXRDb2RlIiwicHJvamVjdGlvbkxpa2UiLCJQcm9qZWN0aW9uIiwib3B0X3VuaXRzIiwicG9pbnRSZXNvbHV0aW9uIiwiZ2V0dGVyIiwiZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYyIsImdldFVuaXRzIiwiVW5pdHMiLCJERUdSRUVTIiwidG9FUFNHNDMyNiIsInZlcnRpY2VzIiwibWV0ZXJzUGVyVW5pdCIsImdldE1ldGVyc1BlclVuaXQiLCJkZXN0aW5hdGlvbiIsInByb2plY3Rpb25zMSIsInByb2plY3Rpb25zMiIsImZvcndhcmRUcmFuc2Zvcm0iLCJpbnZlcnNlVHJhbnNmb3JtIiwicHJvamVjdGlvbjEiLCJwcm9qZWN0aW9uMiIsImRlZmF1bHRDb2RlIiwiY29vcmRUcmFuc2Zvcm0iLCJkaW1lbnNpb24iLCJpbnZlcnNlIiwic291cmNlUHJvaiIsImRlc3RQcm9qIiwib3B0X3Byb2plY3Rpb24iLCJsb25MYXQiLCJsb24iLCJlcXVhbFVuaXRzIiwidHJhbnNmb3JtRnVuYyIsInNvdXJjZVByb2plY3Rpb24iLCJkZXN0aW5hdGlvblByb2plY3Rpb24iLCJzb3VyY2VDb2RlIiwiZGVzdGluYXRpb25Db2RlIiwiRVBTRzM4NTdfUFJPSkVDVElPTlMiLCJFUFNHNDMyNl9QUk9KRUNUSU9OUyIsImZyb21FUFNHNDMyNiIsImNvZGVfIiwidW5pdHNfIiwiZXh0ZW50XyIsIndvcmxkRXh0ZW50XyIsIndvcmxkRXh0ZW50IiwiYXhpc09yaWVudGF0aW9uXyIsImF4aXNPcmllbnRhdGlvbiIsImdsb2JhbF8iLCJjYW5XcmFwWF8iLCJnZXRQb2ludFJlc29sdXRpb25GdW5jXyIsImRlZmF1bHRUaWxlR3JpZF8iLCJtZXRlcnNQZXJVbml0XyIsImNhbldyYXBYIiwiZ2V0V29ybGRFeHRlbnQiLCJnZXRBeGlzT3JpZW50YXRpb24iLCJpc0dsb2JhbCIsInNldEdsb2JhbCIsImdldERlZmF1bHRUaWxlR3JpZCIsInNldERlZmF1bHRUaWxlR3JpZCIsInNldEV4dGVudCIsInNldFdvcmxkRXh0ZW50Iiwic2V0R2V0UG9pbnRSZXNvbHV0aW9uIiwiRkVFVCIsIk1FVEVSUyIsIlBJWEVMUyIsIlRJTEVfUElYRUxTIiwiVVNGRUVUIiwiUkFESVVTIiwiSEFMRl9TSVpFIiwiV09STERfRVhURU5UIiwiRVBTRzM4NTdQcm9qZWN0aW9uIiwiUFJPSkVDVElPTlMiLCJoYWxmU2l6ZSIsIkVQU0c0MzI2UHJvamVjdGlvbiIsIm9wdF9heGlzT3JpZW50YXRpb24iLCJjYWNoZSIsInRyYW5zZm9ybXMiLCJjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uIiwicmVuZGVyIiwidGFyZ2V0UHJvaiIsInRhcmdldENlbnRlciIsInRhcmdldFJlc29sdXRpb24iLCJzb3VyY2VDZW50ZXIiLCJzb3VyY2VSZXNvbHV0aW9uIiwidGFyZ2V0TWV0ZXJzUGVyVW5pdCIsInNvdXJjZU1ldGVyc1BlclVuaXQiLCJzb3VyY2VFeHRlbnQiLCJjb21wZW5zYXRpb25GYWN0b3IiLCJlbmxhcmdlQ2xpcFBvaW50IiwiY2VudHJvaWRYIiwiY2VudHJvaWRZIiwicGl4ZWxSYXRpbyIsInRhcmdldEV4dGVudCIsInRyaWFuZ3VsYXRpb24iLCJndXR0ZXIiLCJvcHRfcmVuZGVyRWRnZXMiLCJzb3VyY2VEYXRhRXh0ZW50IiwiY2FudmFzV2lkdGhJblVuaXRzIiwiY2FudmFzSGVpZ2h0SW5Vbml0cyIsInN0aXRjaENvbnRleHQiLCJzdGl0Y2hTY2FsZSIsInhQb3MiLCJ5UG9zIiwic3JjV2lkdGgiLCJzcmNIZWlnaHQiLCJkcmF3SW1hZ2UiLCJ0YXJnZXRUb3BMZWZ0IiwiZ2V0VHJpYW5nbGVzIiwidHJpYW5nbGUiLCJ1MCIsInYwIiwidTEiLCJ1MiIsInNvdXJjZU51bWVyaWNhbFNoaWZ0WCIsInNvdXJjZU51bWVyaWNhbFNoaWZ0WSIsImF1Z21lbnRlZE1hdHJpeCIsImFmZmluZUNvZWZzIiwic2F2ZSIsImJlZ2luUGF0aCIsInAwIiwibW92ZVRvIiwibGluZVRvIiwiY2xpcCIsInRyYW5zbGF0ZSIsInJlc3RvcmUiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImNsb3NlUGF0aCIsInN0cm9rZSIsIlJlcHJvalRpbGUiLCJzb3VyY2VUaWxlR3JpZCIsInRhcmdldFRpbGVHcmlkIiwid3JhcHBlZFRpbGVDb29yZCIsImdldFRpbGVGdW5jdGlvbiIsIm9wdF9lcnJvclRocmVzaG9sZCIsInJlbmRlckVkZ2VzXyIsInBpeGVsUmF0aW9fIiwiZ3V0dGVyXyIsImNhbnZhc18iLCJzb3VyY2VUaWxlR3JpZF8iLCJ0YXJnZXRUaWxlR3JpZF8iLCJ3cmFwcGVkVGlsZUNvb3JkXyIsInNvdXJjZVRpbGVzXyIsInNvdXJjZXNMaXN0ZW5lcktleXNfIiwic291cmNlWl8iLCJtYXhUYXJnZXRFeHRlbnQiLCJtYXhTb3VyY2VFeHRlbnQiLCJsaW1pdGVkVGFyZ2V0RXh0ZW50Iiwic291cmNlUHJvakV4dGVudCIsImVycm9yVGhyZXNob2xkSW5QaXhlbHMiLCJFUlJPUl9USFJFU0hPTEQiLCJ0cmlhbmd1bGF0aW9uXyIsIlRyaWFuZ3VsYXRpb24iLCJnZXRaRm9yUmVzb2x1dGlvbiIsImNhbGN1bGF0ZVNvdXJjZUV4dGVudCIsInNvdXJjZVJhbmdlIiwiZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWiIsInNyY1giLCJzcmNZIiwidW5saXN0ZW5Tb3VyY2VzXyIsInJlcHJvamVjdF8iLCJnZXRUaWxlU2l6ZSIsImxlZnRUb0xvYWQiLCJzb3VyY2VMaXN0ZW5LZXkiLCJNQVhfU1VCRElWSVNJT04iLCJNQVhfVFJJQU5HTEVfV0lEVEgiLCJlcnJvclRocmVzaG9sZCIsInNvdXJjZVByb2pfIiwidGFyZ2V0UHJval8iLCJ0cmFuc2Zvcm1JbnZDYWNoZSIsInRyYW5zZm9ybUludiIsInRyYW5zZm9ybUludl8iLCJtYXhTb3VyY2VFeHRlbnRfIiwiZXJyb3JUaHJlc2hvbGRTcXVhcmVkXyIsInRyaWFuZ2xlc18iLCJ3cmFwc1hJblNvdXJjZV8iLCJjYW5XcmFwWEluU291cmNlXyIsInNvdXJjZVdvcmxkV2lkdGhfIiwidGFyZ2V0V29ybGRXaWR0aF8iLCJkZXN0aW5hdGlvblRvcExlZnQiLCJkZXN0aW5hdGlvblRvcFJpZ2h0IiwiZGVzdGluYXRpb25Cb3R0b21SaWdodCIsImRlc3RpbmF0aW9uQm90dG9tTGVmdCIsInNvdXJjZVRvcExlZnQiLCJzb3VyY2VUb3BSaWdodCIsInNvdXJjZUJvdHRvbVJpZ2h0Iiwic291cmNlQm90dG9tTGVmdCIsImFkZFF1YWRfIiwibGVmdEJvdW5kIiwibmV3VHJpYW5nbGUiLCJhZGRUcmlhbmdsZV8iLCJhU3JjIiwiYlNyYyIsImNTcmMiLCJkU3JjIiwibWF4U3ViZGl2aXNpb24iLCJzb3VyY2VRdWFkRXh0ZW50Iiwic291cmNlQ292ZXJhZ2VYIiwic291cmNlV29ybGRXaWR0aCIsIndyYXBzWCIsIm5lZWRzU3ViZGl2aXNpb24iLCJ0YXJnZXRRdWFkRXh0ZW50IiwidGFyZ2V0Q292ZXJhZ2VYIiwiY2VudGVyU3JjIiwiY2VudGVyU3JjRXN0aW1YIiwiY2VudGVyU3JjRXJyb3JTcXVhcmVkIiwiYmMiLCJiY1NyYyIsImRhIiwiZGFTcmMiLCJhYiIsImFiU3JjIiwiY2QiLCJjZFNyYyIsIkVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OIiwiaGFzQXJlYSIsInRvU2l6ZSIsIm9wdF9zaXplIiwicmF0aW8iLCJTb3VyY2UiLCJwcm9qZWN0aW9uXyIsImF0dHJpYnV0aW9uc18iLCJhZGFwdEF0dHJpYnV0aW9uc18iLCJzdGF0ZV8iLCJTb3VyY2VTdGF0ZSIsIlJFQURZIiwid3JhcFhfIiwid3JhcFgiLCJhdHRyaWJ1dGlvbkxpa2UiLCJmcmFtZVN0YXRlIiwiZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUiLCJnZXRSZXNvbHV0aW9ucyIsImdldFdyYXBYIiwicmVmcmVzaCIsInNldEF0dHJpYnV0aW9ucyIsIlRpbGVTb3VyY2UiLCJvcGFxdWVfIiwib3BhcXVlIiwidGlsZVBpeGVsUmF0aW9fIiwidGlsZVBpeGVsUmF0aW8iLCJ0aWxlQ2FjaGUiLCJjYWNoZVNpemUiLCJ0bXBTaXplIiwia2V5XyIsInRpbGVPcHRpb25zIiwiZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbiIsImZvckVhY2hMb2FkZWRUaWxlIiwiY292ZXJlZCIsInRpbGVDb29yZEtleSIsImxvYWRlZCIsImNvbnRhaW5zS2V5IiwiZ2V0R3V0dGVyIiwic2V0S2V5IiwiZ2V0T3BhcXVlIiwiZ2V0VGlsZSIsImdldFRpbGVHcmlkRm9yUHJvamVjdGlvbiIsInRoaXNQcm9qIiwiZ2V0VGlsZVBpeGVsUmF0aW8iLCJnZXRUaWxlUGl4ZWxTaXplIiwiZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uIiwidXNlVGlsZSIsIlRpbGVTb3VyY2VFdmVudCIsIlRJTEVMT0FEU1RBUlQiLCJUSUxFTE9BREVORCIsIlRJTEVMT0FERVJST1IiLCJUaWxlSW1hZ2UiLCJVcmxUaWxlIiwiZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24iLCJ0aWxlVXJsRnVuY3Rpb24iLCJ0aWxlQ2xhc3MiLCJ0aWxlQ2FjaGVGb3JQcm9qZWN0aW9uIiwidGlsZUdyaWRGb3JQcm9qZWN0aW9uIiwicmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfIiwicmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQiLCJyZW5kZXJSZXByb2plY3Rpb25FZGdlc18iLCJ1c2VkVGlsZUNhY2hlIiwiZ2V0R3V0dGVySW50ZXJuYWwiLCJwcm9qS2V5IiwiaGlnaFdhdGVyTWFyayIsImNyZWF0ZVRpbGVfIiwidXJsVGlsZUNvb3JkIiwidGlsZVVybCIsImhhbmRsZVRpbGVDaGFuZ2UiLCJnZXRUaWxlSW50ZXJuYWwiLCJuZXdUaWxlIiwic2V0UmVuZGVyUmVwcm9qZWN0aW9uRWRnZXMiLCJzZXRUaWxlR3JpZEZvclByb2plY3Rpb24iLCJ0aWxlZ3JpZCIsInByb2oiLCJpbWFnZVRpbGUiLCJmaXhlZFRpbGVVcmxGdW5jdGlvbiIsIm51bGxUaWxlVXJsRnVuY3Rpb24iLCJzZXRVcmxzIiwic2V0VXJsIiwic2V0VGlsZVVybEZ1bmN0aW9uIiwidGlsZUxvYWRpbmdLZXlzXyIsImdldFRpbGVMb2FkRnVuY3Rpb24iLCJnZXRUaWxlVXJsRnVuY3Rpb24iLCJnZXRVcmxzIiwidWlkIiwidGlsZVN0YXRlIiwiVGlsZUV2ZW50VHlwZSIsIm9wdF9rZXkiLCJnZXREaXN0YW5jZSIsImdldExlbmd0aCIsIkRFRkFVTFRfUkFESVVTIiwiYzEiLCJjMiIsIm9wdF9yYWRpdXMiLCJyYWRpdXMiLCJsYXQxIiwibGF0MiIsImRlbHRhTGF0QnkyIiwiZGVsdGFMb25CeTIiLCJnZXRMZW5ndGhJbnRlcm5hbCIsIkdlb21ldHJ5VHlwZSIsImNvb3JkcyIsImpqIiwiZ2V0Q29vcmRpbmF0ZXMiLCJnZXRHZW9tZXRyaWVzIiwiZ2V0QXJlYUludGVybmFsIiwibG9uMSIsImRCeVIiLCJjb3VudF8iLCJlbnRyaWVzXyIsIm9sZGVzdF8iLCJuZXdlc3RfIiwiZW50cnkiLCJ2YWx1ZV8iLCJuZXdlciIsIm9sZGVyIiwicGVla0xhc3RLZXkiLCJzZXRTaXplIiwicHJ1bmUiLCJnZXRLZXlaWFkiLCJmcm9tS2V5IiwicXVhZEtleSIsIndpdGhpbkV4dGVudEFuZFoiLCJvcHRfdGlsZUNvb3JkIiwiZGlnaXRzIiwibWFzayIsImNoYXJDb2RlIiwiZ2V0RnVsbFRpbGVSYW5nZSIsImdldEZvclByb2plY3Rpb24iLCJjcmVhdGVGb3JFeHRlbnQiLCJjcmVhdGVYWVoiLCJjcmVhdGVGb3JQcm9qZWN0aW9uIiwiZXh0ZW50RnJvbVByb2plY3Rpb24iLCJnZXRUaWxlQ29vcmRDZW50ZXIiLCJwcm9qZWN0aW9uRXh0ZW50Iiwid29ybGRXaWR0aCIsIndvcmxkc0F3YXkiLCJnZXRUaWxlQ29vcmRGb3JDb29yZEFuZFoiLCJvcHRfbWF4Wm9vbSIsIm9wdF90aWxlU2l6ZSIsIm9wdF9jb3JuZXIiLCJyZXNvbHV0aW9uc0Zyb21FeHRlbnQiLCJUaWxlR3JpZCIsIm9yaWdpbiIsIkRFRkFVTFRfTUFYX1pPT00iLCJERUZBVUxUX1RJTEVfU0laRSIsImhhbGYiLCJyZXNvbHV0aW9uc18iLCJ6b29tRmFjdG9yIiwib3JpZ2lucyIsInpvb21GYWN0b3JfIiwib3JpZ2luXyIsIm9yaWdpbnNfIiwidGlsZVNpemVzXyIsInRpbGVTaXplcyIsInRpbGVTaXplXyIsImZ1bGxUaWxlUmFuZ2VzXyIsInRtcFNpemVfIiwic2l6ZXMiLCJjYWxjdWxhdGVUaWxlUmFuZ2VzXyIsInRtcFRpbGVDb29yZCIsImZvckVhY2hUaWxlQ29vcmQiLCJmb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlIiwib3B0X3RpbGVSYW5nZSIsInRpbGVDb29yZEV4dGVudCIsImdldE9yaWdpbiIsImdldFRpbGVDb29yZENoaWxkVGlsZVJhbmdlIiwiZ2V0VGlsZVJhbmdlRXh0ZW50IiwiZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyIsImdldFRpbGVDb29yZEZvckNvb3JkQW5kUmVzb2x1dGlvbiIsImdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8iLCJyZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IiwiYWRqdXN0WCIsImFkanVzdFkiLCJ4RnJvbU9yaWdpbiIsInlGcm9tT3JpZ2luIiwidGlsZUNvb3JkWCIsInRpbGVDb29yZFkiLCJnZXRUaWxlQ29vcmRSZXNvbHV0aW9uIiwib3B0X2RpcmVjdGlvbiIsImZ1bGxUaWxlUmFuZ2VzIiwiY3JlYXRlRnJvbVRlbXBsYXRlIiwiY3JlYXRlRnJvbVRlbXBsYXRlcyIsImNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zIiwiZXhwYW5kVXJsIiwidGVtcGxhdGUiLCJ6UmVnRXgiLCJ4UmVnRXgiLCJ5UmVnRXgiLCJkYXNoWVJlZ0V4IiwidGVtcGxhdGVzIiwidGlsZVVybEZ1bmN0aW9ucyIsInN0YXJ0Q2hhckNvZGUiLCJzdG9wQ2hhckNvZGUiLCJPTkUiLCJTUkNfQUxQSEEiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsIkNPTE9SX0JVRkZFUl9CSVQiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9TVFJJUCIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJBUlJBWV9CVUZGRVIiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIlNUUkVBTV9EUkFXIiwiU1RBVElDX0RSQVciLCJEWU5BTUlDX0RSQVciLCJDVUxMX0ZBQ0UiLCJCTEVORCIsIlNURU5DSUxfVEVTVCIsIkRFUFRIX1RFU1QiLCJTQ0lTU09SX1RFU1QiLCJVTlNJR05FRF9CWVRFIiwiVU5TSUdORURfU0hPUlQiLCJVTlNJR05FRF9JTlQiLCJGTE9BVCIsIlJHQkEiLCJGUkFHTUVOVF9TSEFERVIiLCJWRVJURVhfU0hBREVSIiwiTElOS19TVEFUVVMiLCJMSU5FQVIiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIlRFWFRVUkVfV1JBUF9UIiwiVEVYVFVSRV8yRCIsIlRFWFRVUkUwIiwiQ0xBTVBfVE9fRURHRSIsIkNPTVBJTEVfU1RBVFVTIiwiRlJBTUVCVUZGRVIiLCJDT05URVhUX0lEUyIsIm9wdF9hdHRyaWJ1dGVzIiwiaWNvbiIsInRpdGxlIiwibGluayIsImdldExpbmsiLCJub3JtYWxpemVOYW1lIiwiRnVuY3Rpb24iLCJvbG1zIiwic3R5bGVmdW5jdGlvbiIsImdldFZhbHVlIiwib2xMYXllciIsInNwcml0ZUltYWdlIiwic3ByaXRlSW1nU2l6ZSIsImltZyIsIm9ubG9hZCIsIm1lYXN1cmVDYWNoZSIsIndyYXBDaGluZXNlVGV4dCIsIm1heFdpZHRoIiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJ0ZW1wIiwic3BsaXRUZXh0Iiwic2luZ2xlVGV4dCIsInRlbXBUZXh0Iiwid3JhcFRleHQiLCJlbSIsIndyYXBwZWRUZXh0Iiwib25lRW0iLCJ3b3JkcyIsIndvcmQiLCJhbGxMYXllcnMiLCJsYXllcnNCeVNvdXJjZUxheWVyIiwibWFwYm94TGF5ZXJzIiwibWFwYm94U291cmNlIiwic291cmNlTGF5ZXIiLCJmdW5jdGlvbkNhY2hlIiwiZmlsdGVyQ2FjaGUiLCJpY29uSW1hZ2VDYWNoZSIsInN0eWxlcyIsInBhdHRlcm5DYWNoZSIsInN0eWxlSWRzIiwiZ2V0R2VvbWV0cnkiLCJzdHlsZXNMZW5ndGgiLCJsYXllckRhdGEiLCJlbXB0eU9iaiIsImljb25JbWciLCJldmFsdWF0ZUZpbHRlciIsInN0cm9rZUNvbG9yIiwiaWNvbkltYWdlIiwiZnJvbVRlbXBsYXRlIiwiZ2V0RmlsbCIsImdldFN0cm9rZSIsImdldFRleHQiLCJTdHlsZSIsIkZpbGwiLCJzZXRaSW5kZXgiLCJpY29uX2NhY2hlX2tleSIsInBhdHRlcm4iLCJzcHJpdGVJbWFnZURhdGEiLCJnbG9iYWxBbHBoYSIsImNyZWF0ZVBhdHRlcm4iLCJzZXRDb2xvciIsImNvbG9yV2l0aE9wYWNpdHkiLCJTdHJva2UiLCJzZXRXaWR0aCIsInNldExpbmVDYXAiLCJzZXRMaW5lSm9pbiIsInNldE1pdGVyTGltaXQiLCJzZXRMaW5lRGFzaCIsImhhc0ltYWdlIiwic2tpcExhYmVsIiwic3R5bGVHZW9tIiwiZ2VvbSIsImdldEZsYXRNaWRwb2ludCIsInNldEdlb21ldHJ5IiwiaWNvblNpemUiLCJpY29uQ29sb3IiLCJpY29uVHJhbnNsYXRlIiwiaWNvblRyYW5zbGF0ZUFuY2hvciIsImljb25BbmNob3JWYWx1ZSIsImljb25PZmZzZXQiLCJjb3ZlcnRJY29uQW5jaG9yIiwiYW5jaG9yT2Zmc2V0IiwiaWNvbkFuY2hvciIsImdldEltYWdlRGF0YSIsImNjIiwicHV0SW1hZ2VEYXRhIiwidHJhbnNsYXRlT2Zmc2V0IiwiSWNvbiIsImFuY2hvck9yaWdpbiIsImltZ1NpemUiLCJyb3RhdGVWYWx1ZSIsInNldFJvdGF0aW9uIiwic2V0T3BhY2l0eSIsInNldEltYWdlIiwic2V0VGV4dCIsImNpcmNsZVJhZGl1cyIsImNpcmNsZVN0cm9rZUNvbG9yIiwiY2lyY2xlQ29sb3IiLCJjaXJjbGVPcGFjaXR5IiwiY2lyY2xlU3Ryb2tlV2lkdGgiLCJjaXJjbGVTdHJva2VPcGFjaXR5IiwiY2FjaGVfa2V5IiwiQ2lyY2xlIiwidGV4dEZpZWxkIiwiVGV4dCIsInRleHRTaXplIiwidGV4dExpbmVIZWlnaHQiLCJjaG9vc2VGb250IiwidGV4dFRyYW5zZm9ybSIsIndyYXBwZWRMYWJlbCIsInNldEZvbnQiLCJ0ZXh0QW5jaG9yIiwicGxhY2VtZW50Iiwic2V0UGxhY2VtZW50IiwidGV4dEhhbG9XaWR0aCIsInRleHRPZmZzZXQiLCJ0ZXh0VHJhbnNsYXRlIiwidk9mZnNldCIsImhPZmZzZXQiLCJ0ZXh0QWxpZ24iLCJzZXRUZXh0QWxpZ24iLCJzZXRNYXhBbmdsZSIsInRleHRCYXNlbGluZSIsInNldFRleHRCYXNlbGluZSIsInNldE9mZnNldFgiLCJzZXRPZmZzZXRZIiwic2V0RmlsbCIsImhhbG9Db2xvciIsInRleHRIYWxvIiwic2V0U3Ryb2tlIiwiZXhwcmVzc2lvbkRhdGEiLCJyYXdFeHByZXNzaW9uIiwiY29tcGlsZWRFeHByZXNzaW9uIiwiem9vbU9iaiIsImxheW91dE9yUGFpbnQiLCJmdW5jdGlvbnMiLCJpc0V4cHIiLCJmb250TWFwIiwidGVtcGxhdGVSZWdFeCIsImdldFpvb21Gb3JSZXNvbHV0aW9uIiwiZGVncmVlcyIsImNhbmRpZGF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4UUNsRkE7Ozs7OztRQTJHZ0JBLFUsR0FBQUEsVTtRQTBHQUMsZSxHQUFBQSxlO1FBcVBBQyxLLEdBQUFBLEs7UUFvREFDLFEsR0FBQUEsUTtRQWVBQyxTLEdBQUFBLFM7O0FBdmdCaEI7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUlDLGNBQUo7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQkMsS0FBbEIsRUFBeUI7QUFDdkIsTUFBSUMsQ0FBSixFQUFPQyxFQUFQO0FBQ0EsTUFBSSxDQUFDQyxNQUFNQyxPQUFOLENBQWNKLEtBQWQsQ0FBTCxFQUEyQjtBQUN6QixRQUFJSyxRQUFRTCxNQUFNSyxLQUFsQjtBQUNBLFFBQUlBLEtBQUosRUFBVztBQUNULFdBQUtKLElBQUksQ0FBSixFQUFPQyxLQUFLRyxNQUFNQyxNQUF2QixFQUErQkwsSUFBSUMsRUFBbkMsRUFBdUMsRUFBRUQsQ0FBekMsRUFBNEM7QUFDMUNGLGlCQUFTTSxNQUFNSixDQUFOLEVBQVMsQ0FBVCxDQUFUO0FBQ0Q7QUFDRjtBQUNEO0FBQ0Q7QUFDRCxNQUFJTSxpQkFBaUJDLGlCQUFZQyxRQUFaLEVBQXJCO0FBQ0EsTUFBSUMsV0FBV1YsTUFBTVcsR0FBTixDQUFVLFVBQVNDLElBQVQsRUFBZTtBQUN0QyxXQUFPLCtCQUFPQSxJQUFQLEVBQWEsQ0FBYixFQUFnQkMsS0FBaEIsQ0FBc0IsT0FBdEIsRUFBK0IsQ0FBL0IsRUFBa0NDLE9BQWxDLENBQTBDLElBQTFDLEVBQWdELEVBQWhELENBQVA7QUFDRCxHQUZjLENBQWY7QUFHQSxPQUFLYixJQUFJLENBQUosRUFBT0MsS0FBS1EsU0FBU0osTUFBMUIsRUFBa0NMLElBQUlDLEVBQXRDLEVBQTBDLEVBQUVELENBQTVDLEVBQStDO0FBQzdDLFFBQUljLFNBQVNMLFNBQVNULENBQVQsQ0FBYjtBQUNBLFFBQUlXLE9BQU9aLE1BQU1DLENBQU4sQ0FBWDtBQUNBLFFBQUlNLGVBQWVTLE9BQWYsQ0FBdUJELE1BQXZCLE1BQW1DLENBQUMsQ0FBeEMsRUFBMkM7QUFDekMsVUFBSSxDQUFDakIsY0FBTCxFQUFxQjtBQUNuQkEseUJBQWlCLEVBQWpCO0FBQ0Q7QUFDRCxVQUFJQSxlQUFla0IsT0FBZixDQUF1QkosSUFBdkIsS0FBZ0MsQ0FBQyxDQUFyQyxFQUF3QztBQUN0Q2QsdUJBQWVtQixJQUFmLENBQW9CTCxJQUFwQjtBQUNBLFlBQUlNLFVBQVUsNkNBQTZDSCxPQUFPRCxPQUFQLENBQWUsSUFBZixFQUFxQixHQUFyQixDQUEzRDtBQUNBLFlBQUksQ0FBQ0ssU0FBU0MsYUFBVCxDQUF1QixnQkFBZ0JGLE9BQWhCLEdBQTBCLElBQWpELENBQUwsRUFBNkQ7QUFDM0QsY0FBSUcsU0FBU0YsU0FBU0csYUFBVCxDQUF1QixNQUF2QixDQUFiO0FBQ0FELGlCQUFPRSxJQUFQLEdBQWNMLE9BQWQ7QUFDQUcsaUJBQU9HLEdBQVAsR0FBYSxZQUFiO0FBQ0FMLG1CQUFTTSxvQkFBVCxDQUE4QixNQUE5QixFQUFzQyxDQUF0QyxFQUF5Q0MsV0FBekMsQ0FBcURMLE1BQXJEO0FBQ0Q7QUFDRjtBQUNEO0FBQ0Q7QUFDRjtBQUNGOztBQUVELElBQUlNLGNBQWMsQ0FBQyxtQkFBRCxFQUFzQixlQUF0QixDQUFsQjs7QUFFQSxTQUFTQyxVQUFULENBQW9CQyxLQUFwQixFQUEyQjtBQUN6QixNQUFJLFlBQVlBLEtBQVosSUFBcUIsZ0JBQWdCQSxNQUFNQyxNQUEvQyxFQUF1RDtBQUNyRC9CLGFBQVM4QixNQUFNQyxNQUFOLENBQWEsV0FBYixLQUE2QkgsV0FBdEM7QUFDRDtBQUNGOztBQUVELElBQUlJLGNBQWMsY0FBbEI7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUJDLElBQXZCLEVBQTZCO0FBQzNCLE1BQUlBLFFBQVFELElBQUlqQixPQUFKLENBQVksTUFBWixLQUF1QixDQUFuQyxFQUFzQztBQUNwQ2lCLFVBQU1DLE9BQU9ELEdBQWI7QUFDRDtBQUNELFNBQU9BLEdBQVA7QUFDRDs7QUFFRCxTQUFTRSxXQUFULENBQXFCRixHQUFyQixFQUEwQkMsSUFBMUIsRUFBZ0NFLFNBQWhDLEVBQTJDO0FBQ3pDSCxRQUFNRCxTQUFTQyxHQUFULEVBQWNDLElBQWQsQ0FBTjtBQUNBLE1BQUlHLFFBQVFKLElBQUlLLEtBQUosQ0FBVVAsV0FBVixDQUFaO0FBQ0EsU0FBT00sUUFDTEEsTUFBTSxDQUFOLElBQVdELFNBQVgsSUFBd0JDLE1BQU0vQixNQUFOLEdBQWUsQ0FBZixHQUFtQitCLE1BQU0sQ0FBTixDQUFuQixHQUE4QixFQUF0RCxDQURLLEdBRUxKLE1BQU1HLFNBRlI7QUFHRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CTyxTQUFTM0MsVUFBVCxDQUFvQm9DLEtBQXBCLEVBQTJCVSxPQUEzQixFQUFvQ0MsTUFBcEMsRUFBNENOLElBQTVDLEVBQWtETyxXQUFsRCxFQUErRDtBQUNwRSxTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFTQyxPQUFULEVBQWtCQyxNQUFsQixFQUEwQjs7QUFFM0MsUUFBSSxRQUFPTCxPQUFQLHlDQUFPQSxPQUFQLE1BQWtCLFFBQXRCLEVBQWdDO0FBQzlCQSxnQkFBVU0sS0FBS0MsS0FBTCxDQUFXUCxPQUFYLENBQVY7QUFDRDtBQUNELFFBQUlBLFFBQVFRLE9BQVIsSUFBbUIsQ0FBdkIsRUFBMEI7QUFDeEJILGFBQU8sSUFBSUksS0FBSixDQUFVLDZCQUFWLENBQVA7QUFDRDtBQUNELFFBQUlDLFdBQUosRUFBaUJDLFVBQWpCLEVBQTZCQyxjQUE3QjtBQUNBLFFBQUlaLFFBQVFhLE1BQVosRUFBb0I7QUFDbEJILG9CQUFjSSxPQUFPQyxnQkFBUCxJQUEyQixHQUEzQixHQUFpQyxHQUFqQyxHQUF1QyxDQUFyRDtBQUNBLFVBQUlDLGFBQWFOLGVBQWUsR0FBZixHQUFxQixLQUFyQixHQUE2QixFQUE5QztBQUNBLFVBQUlPLFlBQVlyQixZQUFZSSxRQUFRYSxNQUFwQixFQUE0QmxCLElBQTVCLEVBQWtDcUIsYUFBYSxPQUEvQyxDQUFoQjs7QUFFQUUsWUFBTUQsU0FBTixFQUFpQixFQUFDRSxhQUFhLGFBQWQsRUFBakIsRUFDR0MsSUFESCxDQUNRLFVBQVNDLFFBQVQsRUFBbUI7QUFDdkI7QUFDQSxZQUFJQSxTQUFTQyxNQUFULEtBQW9CLEdBQXhCLEVBQTZCO0FBQzNCLGlCQUFPRCxTQUFTRSxJQUFULEVBQVA7QUFDRCxTQUZELE1BRU8sSUFBSVAsZUFBZSxFQUFuQixFQUF1QjtBQUM1QjtBQUNBQSx1QkFBYSxFQUFiO0FBQ0FDLHNCQUFZckIsWUFBWUksUUFBUWEsTUFBcEIsRUFBNEJsQixJQUE1QixFQUFrQyxPQUFsQyxDQUFaO0FBQ0EsaUJBQU91QixNQUFNRCxTQUFOLEVBQWlCLEVBQUNFLGFBQWEsYUFBZCxFQUFqQixFQUErQ0MsSUFBL0MsQ0FBb0Q7QUFBQSxtQkFBS0ksRUFBRUQsSUFBRixFQUFMO0FBQUEsV0FBcEQsQ0FBUDtBQUNEO0FBQ0YsT0FYSCxFQVlHSCxJQVpILENBWVEsVUFBU0ssV0FBVCxFQUFzQjtBQUMxQixZQUFJQSxnQkFBZ0JDLFNBQXBCLEVBQStCO0FBQzdCLGdCQUFNLG1CQUFOO0FBQ0Q7QUFDRGYscUJBQWFjLFdBQWI7QUFDQWIseUJBQWlCaEIsWUFBWUksUUFBUWEsTUFBcEIsRUFBNEJsQixJQUE1QixFQUFrQ3FCLGFBQWEsTUFBL0MsQ0FBakI7QUFDQVc7QUFDRCxPQW5CSCxFQW9CR0MsS0FwQkgsQ0FvQlMsVUFBU0MsR0FBVCxFQUFjO0FBQ25CQyxnQkFBUUMsS0FBUixDQUFjRixHQUFkO0FBQ0F4QixlQUFPLElBQUlJLEtBQUosQ0FBVSxtQ0FBbUNRLFNBQTdDLENBQVA7QUFDRCxPQXZCSDtBQXdCRDs7QUFFRCxRQUFJZSxLQUFKO0FBQ0EsYUFBU0wsUUFBVCxHQUFvQjtBQUNsQixVQUFJLENBQUNLLEtBQUQsS0FBVyxDQUFDaEMsUUFBUWEsTUFBVCxJQUFtQkYsVUFBOUIsTUFBOEMsQ0FBQ3BELGNBQUQsSUFBbUJBLGVBQWVRLE1BQWYsR0FBd0IsQ0FBekYsQ0FBSixFQUFpRztBQUMvRmlFLGdCQUFRLDZCQUFtQjFDLEtBQW5CLEVBQTBCVSxPQUExQixFQUFtQ0MsTUFBbkMsRUFBMkNDLFdBQTNDLEVBQXdEUyxVQUF4RCxFQUFvRUMsY0FBcEUsRUFBb0ZyRCxjQUFwRixDQUFSO0FBQ0E2QztBQUNELE9BSEQsTUFHTyxJQUFJNEIsS0FBSixFQUFXO0FBQ2hCMUMsY0FBTTJDLFFBQU4sQ0FBZUQsS0FBZjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSTFDLGlCQUFpQjRDLG9CQUFqQixJQUFvQzVDLGlCQUFpQjZDLGdCQUF6RCxFQUFzRTtBQUNwRSxVQUFJO0FBQ0YsWUFBSUMsU0FBU3BDLFFBQVFvQyxNQUFyQjtBQUNBLGFBQUssSUFBSTFFLElBQUksQ0FBUixFQUFXQyxLQUFLeUUsT0FBT3JFLE1BQTVCLEVBQW9DTCxJQUFJQyxFQUF4QyxFQUE0QyxFQUFFRCxDQUE5QyxFQUFpRDtBQUMvQyxjQUFJLE9BQU91QyxNQUFQLElBQWlCLFFBQWpCLElBQTZCbUMsT0FBTzFFLENBQVAsRUFBVXVDLE1BQVYsSUFBb0JBLE1BQWpELElBQTJEQSxPQUFPeEIsT0FBUCxDQUFlMkQsT0FBTzFFLENBQVAsRUFBVTJFLEVBQXpCLEtBQWdDLENBQS9GLEVBQWtHO0FBQ2hHaEQsdUJBQVcrQyxPQUFPMUUsQ0FBUCxDQUFYO0FBQ0Q7QUFDRjtBQUNEaUU7QUFDRCxPQVJELENBUUUsT0FBT1csQ0FBUCxFQUFVO0FBQ1ZDLG1CQUFXLFlBQVc7QUFDcEJsQyxpQkFBT2lDLENBQVA7QUFDRCxTQUZELEVBRUcsQ0FGSDtBQUdEO0FBQ0Y7QUFDRixHQWpFTSxDQUFQO0FBa0VEOztBQUVELFNBQVNFLGFBQVQsQ0FBdUJwRSxHQUF2QixFQUE0QmtCLEtBQTVCLEVBQW1DO0FBQ2pDLE1BQU1tRCxhQUFhO0FBQ2pCQyxVQUFNcEQsTUFBTW9EO0FBREssR0FBbkI7QUFHQSxXQUFTQyxXQUFULEdBQXVCO0FBQ3JCLFFBQUlDLFVBQVV4RSxJQUFJeUUsZ0JBQUosRUFBZDtBQUNBLFFBQUksQ0FBQ0QsT0FBTCxFQUFjO0FBQ1o7QUFDRDtBQUNELFFBQUlyRCxTQUFTRCxNQUFNQyxNQUFOLElBQWdCLEVBQTdCO0FBQ0EsUUFBSXVELFFBQVF4RCxNQUFNd0QsS0FBTixJQUFlLEVBQTNCO0FBQ0FMLGVBQVcsT0FBWCxJQUFzQkssS0FBdEI7QUFDQUwsZUFBV0osRUFBWCxHQUFnQixhQUFhUyxNQUFNLG9CQUFOLENBQWIsR0FBMkNBLE1BQU0sa0JBQU4sQ0FBM0Q7QUFDQSxRQUFJQyxPQUFPM0UsSUFBSTRFLE9BQUosR0FBY0MsT0FBZCxFQUFYO0FBQ0EsUUFBSUgsTUFBTSxrQkFBTixNQUE4QnBCLFNBQWxDLEVBQTZDO0FBQzNDLFVBQU13QixLQUFLLDZCQUFTVCxVQUFULEVBQXFCLE9BQXJCLEVBQThCLGtCQUE5QixFQUFrRE0sSUFBbEQsRUFBd0QsRUFBeEQsQ0FBWDtBQUNBSCxjQUFRWixLQUFSLENBQWNTLFVBQWQsR0FBMkJVLHlCQUFNNUMsS0FBTixDQUFZMkMsRUFBWixFQUFnQkUsUUFBaEIsRUFBM0I7QUFDRDtBQUNELFFBQUlOLE1BQU0sb0JBQU4sTUFBZ0NwQixTQUFwQyxFQUErQztBQUM3Q2tCLGNBQVFaLEtBQVIsQ0FBY3FCLE9BQWQsR0FBd0IsNkJBQVNaLFVBQVQsRUFBcUIsT0FBckIsRUFBOEIsb0JBQTlCLEVBQW9ETSxJQUFwRCxFQUEwRCxFQUExRCxDQUF4QjtBQUNEO0FBQ0QsUUFBSXhELE9BQU8rRCxVQUFQLElBQXFCLE1BQXpCLEVBQWlDO0FBQy9CVixjQUFRWixLQUFSLENBQWN1QixlQUFkLEdBQWdDLEVBQWhDO0FBQ0FYLGNBQVFaLEtBQVIsQ0FBY3FCLE9BQWQsR0FBd0IsRUFBeEI7QUFDRDtBQUNGO0FBQ0QsTUFBSWpGLElBQUl5RSxnQkFBSixFQUFKLEVBQTRCO0FBQzFCRjtBQUNEO0FBQ0R2RSxNQUFJb0YsRUFBSixDQUFPLENBQUMsbUJBQUQsRUFBc0IsZUFBdEIsQ0FBUCxFQUErQ2IsV0FBL0M7QUFDRDs7QUFFRDs7Ozs7QUFLTyxTQUFTeEYsZUFBVCxDQUF5QmlCLEdBQXpCLEVBQThCNEIsT0FBOUIsRUFBdUM7QUFDNUNBLFVBQVFvQyxNQUFSLENBQWVxQixJQUFmLENBQW9CLFVBQVNDLENBQVQsRUFBWTtBQUM5QixRQUFJQSxFQUFFaEIsSUFBRixJQUFVLFlBQWQsRUFBNEI7QUFDMUJGLG9CQUFjcEUsR0FBZCxFQUFtQnNGLENBQW5CO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7QUFDRixHQUxEO0FBTUQ7O0FBRUQsU0FBU0MsZ0JBQVQsQ0FBMEJ2QixNQUExQixFQUFrQ3dCLEdBQWxDLEVBQXVDO0FBQ3JDLE1BQUlDLFFBQUo7QUFDQXpCLFNBQU9xQixJQUFQLENBQVksVUFBU25FLEtBQVQsRUFBZ0I7QUFDMUIsUUFBSUEsTUFBTStDLEVBQU4sSUFBWXVCLEdBQWhCLEVBQXFCO0FBQ25CQyxpQkFBV3ZFLE1BQU1XLE1BQWpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7QUFDRixHQUxEO0FBTUEsU0FBTzRELFFBQVA7QUFDRDs7QUFFRCxTQUFTQyxZQUFULENBQXNCOUQsT0FBdEIsRUFBK0I1QixHQUEvQixFQUFvQzJGLE9BQXBDLEVBQTZDQyxJQUE3QyxFQUFtRHJFLElBQW5ELEVBQXlEc0UsV0FBekQsRUFBc0U7QUFDcEUsTUFBSUMsT0FBTzlGLElBQUk0RSxPQUFKLEVBQVg7QUFDQSxNQUFJLFlBQVloRCxPQUFaLElBQXVCLENBQUNrRSxLQUFLQyxTQUFMLEVBQTVCLEVBQThDO0FBQzVDRCxTQUFLRSxTQUFMLENBQWUsc0JBQVdwRSxRQUFRcUUsTUFBbkIsQ0FBZjtBQUNEO0FBQ0QsTUFBSSxVQUFVckUsT0FBVixJQUFxQmtFLEtBQUtqQixPQUFMLE9BQW1CdkIsU0FBNUMsRUFBdUQ7QUFDckR3QyxTQUFLSSxPQUFMLENBQWF0RSxRQUFRK0MsSUFBckI7QUFDRDtBQUNELE1BQUksQ0FBQ21CLEtBQUtDLFNBQUwsRUFBRCxJQUFxQkQsS0FBS2pCLE9BQUwsT0FBbUJ2QixTQUE1QyxFQUF1RDtBQUNyRHdDLFNBQUtLLEdBQUwsQ0FBU0wsS0FBS00sYUFBTCxHQUFxQkMsU0FBckIsRUFBVCxFQUEyQztBQUN6Q0MsZUFBUyxJQURnQztBQUV6Q0MsWUFBTXZHLElBQUl3RyxPQUFKO0FBRm1DLEtBQTNDO0FBSUQ7QUFDRCxNQUFJNUUsUUFBUWEsTUFBWixFQUFvQjtBQUNsQixRQUFJYixRQUFRYSxNQUFSLENBQWVwQyxPQUFmLENBQXVCLFdBQXZCLEtBQXVDLENBQTNDLEVBQThDO0FBQzVDdUIsY0FBUWEsTUFBUixHQUFpQmtELFVBQVUsU0FBVixHQUFzQkUsV0FBdkM7QUFDRCxLQUZELE1BRU8sSUFBSWpFLFFBQVFhLE1BQVIsQ0FBZXBDLE9BQWYsQ0FBdUIsTUFBdkIsS0FBa0MsQ0FBdEMsRUFBeUM7QUFDOUN1QixjQUFRYSxNQUFSLEdBQWlCLENBQUNtRCxPQUFRQSxPQUFPckUsSUFBZixHQUF1QixFQUF4QixJQUE4QkssUUFBUWEsTUFBdEMsR0FBK0NvRCxXQUFoRTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSVksV0FBVzdFLFFBQVFvQyxNQUF2QjtBQUNBLE1BQUkwQyxnQkFBZ0IsSUFBSUMsaUJBQUosRUFBcEI7QUFDQSxNQUFJQyxXQUFXLEVBQWY7O0FBRUEsV0FBU0MsYUFBVCxDQUF1QjNGLEtBQXZCLEVBQThCO0FBQzVCLFFBQUkwRixTQUFTakgsTUFBVCxHQUFrQixDQUF0QixFQUF5QjtBQUN2QkssVUFBSThHLFFBQUosQ0FBYTVGLEtBQWI7QUFDQSxVQUFJMkMsV0FBVyxTQUFYQSxRQUFXLEdBQVc7QUFDeEIvRSxtQkFBV29DLEtBQVgsRUFBa0JVLE9BQWxCLEVBQTJCZ0YsUUFBM0IsRUFBcUNyRixJQUFyQyxFQUEyQ3lCLElBQTNDLENBQWdELFlBQVc7QUFDekQ5QixnQkFBTTZGLFVBQU4sQ0FBaUIsSUFBakI7QUFDRCxTQUZELEVBRUcsVUFBUzdDLENBQVQsRUFBWTtBQUNiO0FBQ0FSLGtCQUFRQyxLQUFSLENBQWNPLENBQWQ7QUFDRCxTQUxEO0FBTUQsT0FQRDtBQVFBLFVBQUloRCxNQUFNaEMsU0FBTixFQUFKLEVBQXVCO0FBQ3JCMkU7QUFDRCxPQUZELE1BRU87QUFDTDNDLGNBQU04RixJQUFOLENBQVcsZUFBWCxFQUE0Qm5ELFFBQTVCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELE1BQUlvRCxPQUFKLEVBQWFDLFFBQWIsRUFBdUJDLFVBQXZCLEVBQW1DbEQsRUFBbkMsRUFBdUMvQyxLQUF2QyxFQUE4Q2tHLEtBQTlDLEVBQXFEOUYsR0FBckQ7QUFDQSxPQUFLLElBQUloQyxJQUFJLENBQVIsRUFBV0MsS0FBS2tILFNBQVM5RyxNQUE5QixFQUFzQ0wsSUFBSUMsRUFBMUMsRUFBOEMsRUFBRUQsQ0FBaEQsRUFBbUQ7QUFDakQySCxjQUFVUixTQUFTbkgsQ0FBVCxDQUFWO0FBQ0EsUUFBSTJILFFBQVEzQyxJQUFSLElBQWdCLFlBQXBCLEVBQWtDO0FBQ2hDRixvQkFBY3BFLEdBQWQsRUFBbUJpSCxPQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMaEQsV0FBS2dELFFBQVFwRixNQUFSLElBQWtCMEQsaUJBQWlCa0IsUUFBakIsRUFBMkJRLFFBQVF6QixHQUFuQyxDQUF2QjtBQUNBLFVBQUl2QixNQUFNa0QsVUFBVixFQUFzQjtBQUNwQk4sc0JBQWMzRixLQUFkO0FBQ0EwRixtQkFBVyxFQUFYO0FBQ0FNLG1CQUFXdEYsUUFBUXlGLE9BQVIsQ0FBZ0JwRCxFQUFoQixDQUFYO0FBQ0EzQyxjQUFNNEYsU0FBUzVGLEdBQWY7QUFDQSxZQUFJZ0csUUFBUUosU0FBU0ksS0FBckI7QUFDQSxZQUFJaEcsR0FBSixFQUFTO0FBQ1AsY0FBSUEsSUFBSWpCLE9BQUosQ0FBWSxXQUFaLEtBQTRCLENBQWhDLEVBQW1DO0FBQ2pDK0csb0JBQVE5RixJQUFJbkIsT0FBSixDQUFZLFdBQVosRUFBeUIsRUFBekIsQ0FBUjtBQUNBbUgsb0JBQVEsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUJ0SCxHQUFyQixDQUF5QixVQUFTNEYsSUFBVCxFQUFlO0FBQzlDLHFCQUFPLGFBQWFBLElBQWIsR0FBb0IsdUJBQXBCLEdBQThDd0IsS0FBOUMsR0FDSCxlQURHLElBRUZGLFNBQVM1QyxJQUFULElBQWlCLFFBQWpCLEdBQTRCLFlBQTVCLEdBQTJDLEtBRnpDLElBR0h1QixXQUhKO0FBSUQsYUFMTyxDQUFSO0FBTUQ7QUFDRjs7QUFFRCxZQUFJcUIsU0FBUzVDLElBQVQsSUFBaUIsUUFBckIsRUFBK0I7QUFDN0JwRCxrQkFBUW9HLFFBQVMsWUFBVztBQUMxQixnQkFBSUMsV0FBVyx5QkFBVTtBQUN2QkMsd0JBQVUsR0FEYTtBQUV2QkMsdUJBQVMsYUFBYVAsUUFBYixHQUF3QkEsU0FBU1EsT0FBakMsR0FBMkMsRUFGN0I7QUFHdkJDLHVCQUFTVCxTQUFTVTtBQUhLLGFBQVYsQ0FBZjtBQUtBLG1CQUFPLElBQUk5RCxvQkFBSixDQUFvQjtBQUN6QitELHlCQUFXLElBRGM7QUFFekJDLDZCQUFlUCxTQUFTUSxVQUFULEtBQXdCLENBQXhCLEdBQ2JSLFNBQVNTLGFBQVQsQ0FBdUJULFNBQVNRLFVBQVQsRUFBdkIsQ0FEYSxHQUNtQ3pFLFNBSHpCO0FBSXpCekIsc0JBQVEsSUFBSW9HLG9CQUFKLENBQXFCO0FBQzNCQyw4QkFBY2hCLFNBQVNpQixXQURJO0FBRTNCQyx3QkFBUSxJQUFJQyxhQUFKLEVBRm1CO0FBRzNCZCwwQkFBVUEsUUFIaUI7QUFJM0JlLHNCQUFNaEI7QUFKcUIsZUFBckIsQ0FKaUI7QUFVekJpQix1QkFBUyxLQVZnQjtBQVd6QkMsc0JBQVFsSjtBQVhpQixhQUFwQixDQUFQO0FBYUQsV0FuQmUsRUFBUixHQW1CQSxZQUFXO0FBQ2pCLGdCQUFJNEIsUUFBUSxJQUFJNEMsb0JBQUosQ0FBb0I7QUFDOUIrRCx5QkFBVyxJQURtQjtBQUU5QlUsdUJBQVMsS0FGcUI7QUFHOUJDLHNCQUFRbEo7QUFIc0IsYUFBcEIsQ0FBWjtBQUtBLGdCQUFJbUosV0FBVyxJQUFJQyxrQkFBSixDQUFhO0FBQzFCcEgsbUJBQUtBO0FBRHFCLGFBQWIsQ0FBZjtBQUdBLGdCQUFJcUgsTUFBTUYsU0FBU3JELEVBQVQsQ0FBWSxRQUFaLEVBQXNCLFlBQVc7QUFDekMsa0JBQUlxRCxTQUFTRyxRQUFULE1BQXVCLE9BQTNCLEVBQW9DO0FBQ2xDLG9CQUFJQyxjQUFjSixTQUFTSyxXQUFULEVBQWxCO0FBQ0Esb0JBQUl4QixRQUFROUgsTUFBTUMsT0FBTixDQUFjb0osWUFBWXZCLEtBQTFCLElBQW1DdUIsWUFBWXZCLEtBQS9DLEdBQXVELENBQUN1QixZQUFZdkIsS0FBYixDQUFuRTtBQUNBLHFCQUFLLElBQUloSSxJQUFJLENBQVIsRUFBV0MsS0FBSytILE1BQU0zSCxNQUEzQixFQUFtQ0wsSUFBSUMsRUFBdkMsRUFBMkMsRUFBRUQsQ0FBN0MsRUFBZ0Q7QUFDOUMsc0JBQUl5SixPQUFPekIsTUFBTWhJLENBQU4sQ0FBWDtBQUNBLHNCQUFJeUosS0FBSzFJLE9BQUwsQ0FBYSxNQUFiLEtBQXdCLENBQTVCLEVBQStCO0FBQzdCaUgsMEJBQU1oSSxDQUFOLElBQVc0SCxTQUFTNUYsR0FBVCxHQUFleUgsSUFBMUI7QUFDRDtBQUNGO0FBQ0Qsb0JBQUl4QixXQUFXa0IsU0FBU08sV0FBVCxFQUFmO0FBQ0E5SCxzQkFBTStILFNBQU4sQ0FBZ0IsSUFBSWhCLG9CQUFKLENBQXFCO0FBQ25DQyxnQ0FBY08sU0FBU1MsZUFBVCxNQUE4QkwsWUFBWVYsV0FEckI7QUFFbkNDLDBCQUFRLElBQUlDLGFBQUosRUFGMkI7QUFHbkNkLDRCQUFVLHlCQUFVO0FBQ2xCSSw2QkFBU0osU0FBU1EsVUFBVCxFQURTO0FBRWxCTiw2QkFBU0YsU0FBUzRCLFVBQVQsRUFGUztBQUdsQjNCLDhCQUFVO0FBSFEsbUJBQVYsQ0FIeUI7QUFRbkNjLHdCQUFNaEI7QUFSNkIsaUJBQXJCLENBQWhCO0FBVUEsb0JBQUlDLFNBQVNRLFVBQVQsS0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0I3Ryx3QkFBTWtJLGdCQUFOLENBQ0U3QixTQUFTUyxhQUFULENBQXVCVCxTQUFTUSxVQUFULEVBQXZCLENBREY7QUFFRDtBQUNELHlDQUFRWSxHQUFSO0FBQ0Q7QUFDRixhQTNCUyxDQUFWO0FBNEJBLG1CQUFPekgsS0FBUDtBQUNELFdBdENNLEVBbkJQO0FBMERELFNBM0RELE1BMkRPLElBQUlnRyxTQUFTNUMsSUFBVCxJQUFpQixRQUFyQixFQUErQjtBQUNwQyxjQUFJekMsTUFBSjtBQUNBLGNBQUksQ0FBQ3FGLFNBQVNJLEtBQWQsRUFBcUI7QUFDbkJ6RixxQkFBVSxZQUFXO0FBQ25CLHFCQUFPLElBQUk2RyxrQkFBSixDQUFhO0FBQ2xCcEgscUJBQUtBLEdBRGE7QUFFbEIrSCw2QkFBYTtBQUZLLGVBQWIsQ0FBUDtBQUlELGFBTFEsRUFBVDtBQU1ELFdBUEQsTUFPTztBQUNMeEgscUJBQVMsSUFBSXlILGFBQUosQ0FBUTtBQUNmcEIsNEJBQWNoQixTQUFTaUIsV0FEUjtBQUVmUix1QkFBU1QsU0FBU1UsT0FGSDtBQUdmSCx1QkFBUyxhQUFhUCxRQUFiLEdBQXdCQSxTQUFTUSxPQUFqQyxHQUEyQyxFQUhyQztBQUlmRix3QkFBVU4sU0FBU00sUUFBVCxJQUFxQixHQUpoQjtBQUtmbEcsbUJBQUtBLEdBTFU7QUFNZmdILG9CQUFNcEIsU0FBU0ksS0FOQTtBQU9mK0IsMkJBQWE7QUFQRSxhQUFSLENBQVQ7QUFTRDtBQUNEeEgsaUJBQU8wSCxtQkFBUCxDQUEyQixVQUFTUixJQUFULEVBQWVTLEdBQWYsRUFBb0I7QUFDN0MsZ0JBQUlBLElBQUluSixPQUFKLENBQVksa0JBQVosS0FBbUMsQ0FBQyxDQUF4QyxFQUEyQztBQUN6QyxrQkFBSW9KLE9BQU81SCxPQUFPbUgsV0FBUCxHQUFxQlUsa0JBQXJCLENBQXdDWCxLQUFLWSxZQUFMLEVBQXhDLENBQVg7QUFDQUgsb0JBQU1BLElBQUlySixPQUFKLENBQVksa0JBQVosRUFBZ0NzSixLQUFLekUsUUFBTCxFQUFoQyxDQUFOO0FBQ0Q7QUFDRCtELGlCQUFLYSxRQUFMLEdBQWdCSixHQUFoQixHQUFzQkEsR0FBdEI7QUFDRCxXQU5EO0FBT0F0SSxrQkFBUSxJQUFJMkksY0FBSixDQUFjO0FBQ3BCaEksb0JBQVFBLE1BRFk7QUFFcEIwRyxxQkFBU3RCLFFBQVE5RixNQUFSLEdBQWlCOEYsUUFBUTlGLE1BQVIsQ0FBZStELFVBQWYsS0FBOEIsTUFBL0MsR0FBd0Q7QUFGN0MsV0FBZCxDQUFSO0FBSUQsU0EvQk0sTUErQkEsSUFBSWdDLFNBQVM1QyxJQUFULElBQWlCLFNBQXJCLEVBQWdDO0FBQ3JDLGNBQUl3RixPQUFPNUMsU0FBUzRDLElBQXBCO0FBQ0EsY0FBSUMsUUFBSixFQUFjQyxVQUFkO0FBQ0EsY0FBSSxPQUFPRixJQUFQLElBQWUsUUFBbkIsRUFBNkI7QUFDM0JFLHlCQUFhM0ksU0FBU3lJLElBQVQsRUFBZXZJLElBQWYsQ0FBYjtBQUNELFdBRkQsTUFFTztBQUNMd0ksdUJBQVdyRCxjQUFjdUQsWUFBZCxDQUEyQkgsSUFBM0IsRUFBaUMsRUFBQ0ksbUJBQW1CLFdBQXBCLEVBQWpDLENBQVg7QUFDRDtBQUNEaEosa0JBQVEsSUFBSTZDLGdCQUFKLENBQWdCO0FBQ3RCbEMsb0JBQVEsSUFBSXNJLGdCQUFKLENBQWlCO0FBQ3ZCakMsNEJBQWNoQixTQUFTaUIsV0FEQTtBQUV2QjRCLHdCQUFVQSxRQUZhO0FBR3ZCM0Isc0JBQVExQixhQUhlO0FBSXZCcEYsbUJBQUswSTtBQUprQixhQUFqQixDQURjO0FBT3RCekIscUJBQVMsS0FQYTtBQVF0QkMsb0JBQVFsSjtBQVJjLFdBQWhCLENBQVI7QUFVRDtBQUNENkgscUJBQWFsRCxFQUFiO0FBQ0Q7QUFDRDJDLGVBQVN0RyxJQUFULENBQWMyRyxRQUFRaEQsRUFBdEI7QUFDRDtBQUNGO0FBQ0Q0QyxnQkFBYzNGLEtBQWQ7QUFDQWxCLE1BQUlvSyxHQUFKLENBQVEsY0FBUixFQUF3QnhJLE9BQXhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ08sU0FBUzVDLEtBQVQsQ0FBZWdCLEdBQWYsRUFBb0I0RCxLQUFwQixFQUEyQjs7QUFFaEMsTUFBSWlDLFdBQUosRUFBaUJGLE9BQWpCLEVBQTBCQyxJQUExQixFQUFnQ3JFLElBQWhDO0FBQ0FzRSxnQkFBY0YsVUFBVUMsT0FBT3JFLE9BQU8sRUFBdEM7O0FBRUEsTUFBSSxFQUFFdkIsZUFBZXFLLGFBQWpCLENBQUosRUFBMkI7QUFDekJySyxVQUFNLElBQUlxSyxhQUFKLENBQVE7QUFDWkMsY0FBUXRLO0FBREksS0FBUixDQUFOO0FBR0Q7O0FBRUQsTUFBSSxPQUFPNEQsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixRQUFJbEMsUUFBUWtDLE1BQU1qQyxLQUFOLENBQVlQLFdBQVosQ0FBWjtBQUNBLFFBQUlNLEtBQUosRUFBVztBQUNUaUUsZ0JBQVVqRSxNQUFNLENBQU4sQ0FBVjtBQUNBbUUsb0JBQWNuRSxNQUFNL0IsTUFBTixHQUFlLENBQWYsR0FBbUIrQixNQUFNLENBQU4sQ0FBbkIsR0FBOEIsRUFBNUM7QUFDRDs7QUFFRG9CLFVBQU1jLEtBQU4sRUFBYTtBQUNYYixtQkFBYTtBQURGLEtBQWIsRUFHR0MsSUFISCxDQUdRLFVBQVNDLFFBQVQsRUFBbUI7QUFDdkIsYUFBT0EsU0FBU0UsSUFBVCxFQUFQO0FBQ0QsS0FMSCxFQU1HSCxJQU5ILENBTVEsVUFBU3BCLE9BQVQsRUFBa0I7QUFDdEIsVUFBSTJJLElBQUkvSixTQUFTRyxhQUFULENBQXVCLEdBQXZCLENBQVI7QUFDQTRKLFFBQUUzSixJQUFGLEdBQVNnRCxLQUFUO0FBQ0FyQyxhQUFPZ0osRUFBRUMsUUFBRixDQUFXdEssS0FBWCxDQUFpQixHQUFqQixFQUFzQnVLLEtBQXRCLENBQTRCLENBQTVCLEVBQStCLENBQUMsQ0FBaEMsRUFBbUNDLElBQW5DLENBQXdDLEdBQXhDLElBQStDLEdBQXREO0FBQ0E5RSxhQUFPaEMsTUFBTStHLE1BQU4sQ0FBYSxDQUFiLEVBQWdCL0csTUFBTXZELE9BQU4sQ0FBY2tCLElBQWQsQ0FBaEIsQ0FBUDs7QUFFQW1FLG1CQUFhOUQsT0FBYixFQUFzQjVCLEdBQXRCLEVBQTJCMkYsT0FBM0IsRUFBb0NDLElBQXBDLEVBQTBDckUsSUFBMUMsRUFBZ0RzRSxXQUFoRDtBQUNELEtBYkgsRUFjR3JDLEtBZEgsQ0FjUyxVQUFTQyxHQUFULEVBQWM7QUFDbkJDLGNBQVFDLEtBQVIsQ0FBY0YsR0FBZDtBQUNBLFlBQU0sSUFBSXBCLEtBQUosQ0FBVSxvQkFBb0J1QixLQUE5QixDQUFOO0FBQ0QsS0FqQkg7QUFrQkQsR0F6QkQsTUF5Qk87QUFDTE8sZUFBVyxZQUFXO0FBQ3BCdUIsbUJBQWE5QixLQUFiLEVBQW9CNUQsR0FBcEI7QUFDRCxLQUZELEVBRUcsQ0FGSDtBQUdEO0FBQ0QsU0FBT0EsR0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNmLFFBQVQsQ0FBa0JlLEdBQWxCLEVBQXVCNEssT0FBdkIsRUFBZ0M7QUFDckMsTUFBTTVHLFNBQVNoRSxJQUFJNkssU0FBSixHQUFnQkMsUUFBaEIsRUFBZjtBQUNBLE9BQUssSUFBSXhMLElBQUksQ0FBUixFQUFXQyxLQUFLeUUsT0FBT3JFLE1BQTVCLEVBQW9DTCxJQUFJQyxFQUF4QyxFQUE0QyxFQUFFRCxDQUE5QyxFQUFpRDtBQUMvQyxRQUFJMEUsT0FBTzFFLENBQVAsRUFBVXlMLEdBQVYsQ0FBYyxlQUFkLEVBQStCMUssT0FBL0IsQ0FBdUN1SyxPQUF2QyxNQUFvRCxDQUFDLENBQXpELEVBQTREO0FBQzFELGFBQU81RyxPQUFPMUUsQ0FBUCxDQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7QUFNTyxTQUFTSixTQUFULENBQW1CYyxHQUFuQixFQUF3QnlGLFFBQXhCLEVBQWtDO0FBQ3ZDLE1BQU16QixTQUFTaEUsSUFBSTZLLFNBQUosR0FBZ0JDLFFBQWhCLEVBQWY7QUFDQSxPQUFLLElBQUl4TCxJQUFJLENBQVIsRUFBV0MsS0FBS3lFLE9BQU9yRSxNQUE1QixFQUFvQ0wsSUFBSUMsRUFBeEMsRUFBNEMsRUFBRUQsQ0FBOUMsRUFBaUQ7QUFDL0MsUUFBTXVDLFNBQVNtQyxPQUFPMUUsQ0FBUCxFQUFVSixTQUFWLEVBQWY7QUFDQSxRQUFJOEUsT0FBTzFFLENBQVAsRUFBVXlMLEdBQVYsQ0FBYyxlQUFkLEVBQStCMUssT0FBL0IsQ0FBdUNvRixRQUF2QyxNQUFxRCxDQUFDLENBQTFELEVBQTZEO0FBQzNELGFBQU81RCxNQUFQO0FBQ0Q7QUFDRjtBQUNGLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyaEJELElBQUltSixXQUFXLENBQWY7QUFDQSxJQUFJQyxRQUFRO0FBQ1g3SSxhQUFTO0FBQ1I4SSxrQkFBVSxJQURGO0FBRVI1RyxjQUFNLE1BRkU7QUFHUjZHLGdCQUFRLENBQ1AsQ0FETyxDQUhBO0FBTVJDLGFBQUssZ0RBTkc7QUFPUkMsaUJBQVM7QUFQRCxLQURFO0FBVVhDLFVBQU07QUFDTGhILGNBQU0sUUFERDtBQUVMOEcsYUFBSyxzQ0FGQTtBQUdMQyxpQkFBUztBQUhKLEtBVks7QUFlWEUsY0FBVTtBQUNUakgsY0FBTSxHQURHO0FBRVQ4RyxhQUFLO0FBRkksS0FmQztBQW1CWG5GLFlBQVE7QUFDUDNCLGNBQU0sT0FEQztBQUVQa0gsZUFBTyxRQUZBO0FBR1BKLGFBQUssNktBSEU7QUFJUEMsaUJBQVMsQ0FDUixDQUFDLE9BRE8sRUFFUixPQUZRO0FBSkYsS0FuQkc7QUE0QlgxRyxVQUFNO0FBQ0xMLGNBQU0sUUFERDtBQUVMOEcsYUFBSyxpSkFGQTtBQUdMQyxpQkFBUztBQUhKLEtBNUJLO0FBaUNYSSxhQUFTO0FBQ1JuSCxjQUFNLFFBREU7QUFFUixtQkFBVyxDQUZIO0FBR1JvSCxnQkFBUSxHQUhBO0FBSVJDLGVBQU8sU0FKQztBQUtSUCxhQUFLLDRRQUxHO0FBTVJDLGlCQUFTO0FBTkQsS0FqQ0U7QUF5Q1hPLFdBQU87QUFDTnRILGNBQU0sUUFEQTtBQUVOLG1CQUFXLENBRkw7QUFHTnFILGVBQU8sU0FIRDtBQUlOUCxhQUFLLGtTQUpDO0FBS05DLGlCQUFTO0FBTEgsS0F6Q0k7QUFnRFhRLFdBQU87QUFDTnZILGNBQU0sT0FEQTtBQUVOOEcsYUFBSywwQkFGQztBQUdOQyxpQkFBUztBQUNSUyxvQkFBUSxVQURBO0FBRVJDLG1CQUFPLE9BRkM7QUFHUkMsdUJBQVc7QUFISDtBQUhILEtBaERJO0FBeURYQyxhQUFTO0FBQ1IzSCxjQUFNLFNBREU7QUFFUjhHLGFBQUs7QUFGRyxLQXpERTtBQTZEWGMsU0FBSztBQUNKNUgsY0FBTSxLQURGO0FBRUo4RyxhQUFLO0FBRkQsS0E3RE07QUFpRVgvRCxhQUFTO0FBQ1I2RCxrQkFBVSxJQURGO0FBRVI1RyxjQUFNLFNBRkU7QUFHUjhHLGFBQUssNkJBSEc7QUFJUkMsaUJBQVM7QUFDUiw4QkFBa0I7QUFDakIvRyxzQkFBTSxRQURXO0FBRWpCaEQscUJBQUs7QUFGWTtBQURWO0FBSkQsS0FqRUU7QUE0RVhtQixZQUFRO0FBQ1A2QixjQUFNLFFBREM7QUFFUDhHLGFBQUssNGFBRkU7QUFHUEMsaUJBQVM7QUFIRixLQTVFRztBQWlGWGMsWUFBUTtBQUNQN0gsY0FBTSxRQURDO0FBRVA4RyxhQUFLLCtVQUZFO0FBR1BDLGlCQUFTO0FBSEYsS0FqRkc7QUFzRlhlLGdCQUFZO0FBQ1g5SCxjQUFNLFlBREs7QUFFWDhHLGFBQUsscVJBRk07QUFHWEMsaUJBQVM7QUFDUmdCLHNCQUFVLEdBREY7QUFFUkMsbUJBQU87QUFGQztBQUhFLEtBdEZEO0FBOEZYQyxnQkFBWTtBQUNYakksY0FBTSxZQURLO0FBRVg4RyxhQUFLLDZSQUZNO0FBR1hDLGlCQUFTO0FBQ1JDLGtCQUFNLFFBREU7QUFFUnJGLG9CQUFRLENBQ1AsQ0FBQyxHQURNLEVBRVAsRUFGTyxDQUZBO0FBTVJ1Ryx1QkFBVyxDQUNWLEVBRFUsRUFFVixFQUZVO0FBTkg7QUFIRSxLQTlGRDtBQTZHWHhJLFlBQVE7QUFDUGtILGtCQUFVLElBREg7QUFFUDVHLGNBQU0sT0FGQztBQUdQa0gsZUFBTyxPQUhBO0FBSVBKLGFBQUssa0RBSkU7QUFLUEMsaUJBQVMsQ0FDUjtBQUNDcEgsZ0JBQUksT0FETDtBQUVDcEMsb0JBQVEsZ0JBRlQ7QUFHQyw0QkFBZ0IsT0FIakI7QUFJQ3lDLGtCQUFNLE1BSlA7QUFLQ0ksbUJBQU87QUFDTiw4QkFBYztBQURSO0FBTFIsU0FEUTtBQUxGO0FBN0dHLENBQVo7QUErSEEsSUFBSTJDLFVBQVU7QUFDYixTQUFLO0FBQ0ovQyxjQUFNLFFBREY7QUFFSjhHLGFBQUs7QUFGRDtBQURRLENBQWQ7QUFNQSxJQUFJdkosU0FBUyxDQUNaLGVBRFksRUFFWixlQUZZLEVBR1osbUJBSFksRUFJWixnQkFKWSxFQUtaLGNBTFksRUFNWixjQU5ZLENBQWI7QUFRQSxJQUFJNEssZ0JBQWdCO0FBQ25CbkksVUFBTTtBQUNMNEcsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxNQUZEO0FBR0w2RyxnQkFBUTtBQUNQdUIsb0JBQVE7QUFDUHRCLHFCQUFLO0FBREU7QUFERCxTQUhIO0FBUUxBLGFBQUs7QUFSQSxLQURhO0FBV25COUosU0FBSztBQUNKZ0QsY0FBTSxRQURGO0FBRUo4RyxhQUFLO0FBRkQsS0FYYztBQWVuQjlELFdBQU87QUFDTmhELGNBQU0sT0FEQTtBQUVOa0gsZUFBTyxRQUZEO0FBR05KLGFBQUs7QUFIQyxLQWZZO0FBb0JuQnVCLFlBQVE7QUFDUHJJLGNBQU0sT0FEQztBQUVQa0gsZUFBTyxRQUZBO0FBR1A3TCxnQkFBUSxDQUhEO0FBSVAsbUJBQVcsQ0FDVixDQUFDLEdBRFMsRUFFVixDQUFDLFNBRlMsRUFHVixHQUhVLEVBSVYsU0FKVSxDQUpKO0FBVVB5TCxhQUFLO0FBVkUsS0FwQlc7QUFnQ25Cd0IsWUFBUTtBQUNQdEksY0FBTSxNQURDO0FBRVA2RyxnQkFBUTtBQUNQMEIsaUJBQUs7QUFDSnpCLHFCQUFLO0FBREQsYUFERTtBQUlQMEIsaUJBQUs7QUFDSjFCLHFCQUFLO0FBREQ7QUFKRSxTQUZEO0FBVVAsbUJBQVcsS0FWSjtBQVdQQSxhQUFLO0FBWEUsS0FoQ1c7QUE2Q25CeEQsYUFBUztBQUNSdEQsY0FBTSxRQURFO0FBRVIsbUJBQVcsQ0FGSDtBQUdSOEcsYUFBSztBQUhHLEtBN0NVO0FBa0RuQjFELGFBQVM7QUFDUnBELGNBQU0sUUFERTtBQUVSLG1CQUFXLEVBRkg7QUFHUjhHLGFBQUs7QUFIRyxLQWxEVTtBQXVEbkJqRCxpQkFBYTtBQUNaN0QsY0FBTSxRQURNO0FBRVo4RyxhQUFLO0FBRk8sS0F2RE07QUEyRG5CMkIsZUFBVztBQUNWekksY0FBTSxXQURJO0FBRVY4RyxhQUFLO0FBRkssS0EzRFE7QUErRG5CNEIsY0FBVTtBQUNUMUksY0FBTSxTQURHO0FBRVQsbUJBQVcsS0FGRjtBQUdUOEcsYUFBSyxxRUFISTtBQUlULHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCNkIseUJBQVMsT0FEYTtBQUV0QkMscUJBQUs7QUFGaUI7QUFEVDtBQUpOLEtBL0RTO0FBMEVuQixTQUFLO0FBQ0o1SSxjQUFNLEdBREY7QUFFSjhHLGFBQUs7QUFGRDtBQTFFYyxDQUFwQjtBQStFQSxJQUFJK0IsZ0JBQWdCO0FBQ25CN0ksVUFBTTtBQUNMNEcsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxNQUZEO0FBR0w2RyxnQkFBUTtBQUNQaUMsb0JBQVE7QUFDUGhDLHFCQUFLO0FBREU7QUFERCxTQUhIO0FBUUxBLGFBQUs7QUFSQSxLQURhO0FBV25COUosU0FBSztBQUNKZ0QsY0FBTSxRQURGO0FBRUo4RyxhQUFLO0FBRkQsS0FYYztBQWVuQjlELFdBQU87QUFDTmhELGNBQU0sT0FEQTtBQUVOa0gsZUFBTyxRQUZEO0FBR05KLGFBQUs7QUFIQyxLQWZZO0FBb0JuQnVCLFlBQVE7QUFDUHJJLGNBQU0sT0FEQztBQUVQa0gsZUFBTyxRQUZBO0FBR1A3TCxnQkFBUSxDQUhEO0FBSVAsbUJBQVcsQ0FDVixDQUFDLEdBRFMsRUFFVixDQUFDLFNBRlMsRUFHVixHQUhVLEVBSVYsU0FKVSxDQUpKO0FBVVB5TCxhQUFLO0FBVkUsS0FwQlc7QUFnQ25CeEQsYUFBUztBQUNSdEQsY0FBTSxRQURFO0FBRVIsbUJBQVcsQ0FGSDtBQUdSOEcsYUFBSztBQUhHLEtBaENVO0FBcUNuQjFELGFBQVM7QUFDUnBELGNBQU0sUUFERTtBQUVSLG1CQUFXLEVBRkg7QUFHUjhHLGFBQUs7QUFIRyxLQXJDVTtBQTBDbkI1RCxjQUFVO0FBQ1RsRCxjQUFNLFFBREc7QUFFVCxtQkFBVyxHQUZGO0FBR1RxSCxlQUFPLFFBSEU7QUFJVFAsYUFBSztBQUpJLEtBMUNTO0FBZ0RuQndCLFlBQVE7QUFDUHRJLGNBQU0sTUFEQztBQUVQNkcsZ0JBQVE7QUFDUDBCLGlCQUFLO0FBQ0p6QixxQkFBSztBQURELGFBREU7QUFJUDBCLGlCQUFLO0FBQ0oxQixxQkFBSztBQUREO0FBSkUsU0FGRDtBQVVQLG1CQUFXLEtBVko7QUFXUEEsYUFBSztBQVhFLEtBaERXO0FBNkRuQmpELGlCQUFhO0FBQ1o3RCxjQUFNLFFBRE07QUFFWjhHLGFBQUs7QUFGTyxLQTdETTtBQWlFbkI0QixjQUFVO0FBQ1QxSSxjQUFNLFNBREc7QUFFVCxtQkFBVyxLQUZGO0FBR1Q4RyxhQUFLLHFFQUhJO0FBSVQsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEI2Qix5QkFBUyxPQURhO0FBRXRCQyxxQkFBSztBQUZpQjtBQURUO0FBSk4sS0FqRVM7QUE0RW5CLFNBQUs7QUFDSjVJLGNBQU0sR0FERjtBQUVKOEcsYUFBSztBQUZEO0FBNUVjLENBQXBCO0FBaUZBLElBQUlpQyxvQkFBb0I7QUFDdkIvSSxVQUFNO0FBQ0w0RyxrQkFBVSxJQURMO0FBRUw1RyxjQUFNLE1BRkQ7QUFHTDZHLGdCQUFRO0FBQ1AsMEJBQWM7QUFDYkMscUJBQUs7QUFEUTtBQURQLFNBSEg7QUFRTEEsYUFBSztBQVJBLEtBRGlCO0FBV3ZCOUosU0FBSztBQUNKZ0QsY0FBTSxRQURGO0FBRUo4RyxhQUFLO0FBRkQsS0FYa0I7QUFldkI5RCxXQUFPO0FBQ05oRCxjQUFNLE9BREE7QUFFTmtILGVBQU8sUUFGRDtBQUdOSixhQUFLO0FBSEMsS0FmZ0I7QUFvQnZCdUIsWUFBUTtBQUNQckksY0FBTSxPQURDO0FBRVBrSCxlQUFPLFFBRkE7QUFHUDdMLGdCQUFRLENBSEQ7QUFJUCxtQkFBVyxDQUNWLENBQUMsR0FEUyxFQUVWLENBQUMsU0FGUyxFQUdWLEdBSFUsRUFJVixTQUpVLENBSko7QUFVUHlMLGFBQUs7QUFWRSxLQXBCZTtBQWdDdkJ4RCxhQUFTO0FBQ1J0RCxjQUFNLFFBREU7QUFFUixtQkFBVyxDQUZIO0FBR1I4RyxhQUFLO0FBSEcsS0FoQ2M7QUFxQ3ZCMUQsYUFBUztBQUNScEQsY0FBTSxRQURFO0FBRVIsbUJBQVcsRUFGSDtBQUdSOEcsYUFBSztBQUhHLEtBckNjO0FBMEN2QjVELGNBQVU7QUFDVGxELGNBQU0sUUFERztBQUVULG1CQUFXLEdBRkY7QUFHVHFILGVBQU8sUUFIRTtBQUlUUCxhQUFLO0FBSkksS0ExQ2E7QUFnRHZCakQsaUJBQWE7QUFDWjdELGNBQU0sUUFETTtBQUVaOEcsYUFBSztBQUZPLEtBaERVO0FBb0R2QmtDLGNBQVU7QUFDVGhKLGNBQU0sTUFERztBQUVUNkcsZ0JBQVE7QUFDUG9DLHVCQUFXO0FBQ1ZuQyxxQkFBSztBQURLLGFBREo7QUFJUG9DLG9CQUFRO0FBQ1BwQyxxQkFBSztBQURFO0FBSkQsU0FGQztBQVVULG1CQUFXLFFBVkY7QUFXVEEsYUFBSztBQVhJLEtBcERhO0FBaUV2QjRCLGNBQVU7QUFDVDFJLGNBQU0sU0FERztBQUVULG1CQUFXLEtBRkY7QUFHVDhHLGFBQUsscUVBSEk7QUFJVCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QjZCLHlCQUFTLE9BRGE7QUFFdEJDLHFCQUFLO0FBRmlCO0FBRFQ7QUFKTixLQWpFYTtBQTRFdkIsU0FBSztBQUNKNUksY0FBTSxHQURGO0FBRUo4RyxhQUFLO0FBRkQ7QUE1RWtCLENBQXhCO0FBaUZBLElBQUlxQyxpQkFBaUI7QUFDcEJuSixVQUFNO0FBQ0w0RyxrQkFBVSxJQURMO0FBRUw1RyxjQUFNLE1BRkQ7QUFHTDZHLGdCQUFRO0FBQ1B1QyxxQkFBUztBQUNSdEMscUJBQUs7QUFERztBQURGLFNBSEg7QUFRTEEsYUFBSztBQVJBLEtBRGM7QUFXcEJ0QixVQUFNO0FBQ0x4RixjQUFNLEdBREQ7QUFFTDhHLGFBQUs7QUFGQSxLQVhjO0FBZXBCMUQsYUFBUztBQUNScEQsY0FBTSxRQURFO0FBRVIsbUJBQVcsRUFGSDtBQUdSOEcsYUFBSztBQUhHLEtBZlc7QUFvQnBCakQsaUJBQWE7QUFDWjdELGNBQU0sUUFETTtBQUVaOEcsYUFBSztBQUZPLEtBcEJPO0FBd0JwQnVDLFlBQVE7QUFDUHJKLGNBQU0sUUFEQztBQUVQLG1CQUFXLEdBRko7QUFHUHNKLGlCQUFTLEdBSEY7QUFJUEMsaUJBQVMsQ0FKRjtBQUtQekMsYUFBSztBQUxFLEtBeEJZO0FBK0JwQjBDLFlBQVE7QUFDUHhKLGNBQU0sR0FEQztBQUVQOEcsYUFBSztBQUZFLEtBL0JZO0FBbUNwQjJDLGVBQVc7QUFDVnpKLGNBQU0sUUFESTtBQUVWLG1CQUFXLEtBRkQ7QUFHVjhHLGFBQUs7QUFISyxLQW5DUztBQXdDcEI0QyxhQUFTO0FBQ1IxSixjQUFNLFNBREU7QUFFUixtQkFBVyxLQUZIO0FBR1I4RyxhQUFLO0FBSEcsS0F4Q1c7QUE2Q3BCNkMsbUJBQWU7QUFDZDNKLGNBQU0sUUFEUTtBQUVkLG1CQUFXLEVBRkc7QUFHZHVKLGlCQUFTLENBSEs7QUFJZHpDLGFBQUs7QUFKUyxLQTdDSztBQW1EcEI4QyxvQkFBZ0I7QUFDZjVKLGNBQU0sUUFEUztBQUVmOEcsYUFBSztBQUZVLEtBbkRJO0FBdURwQitDLHNCQUFrQjtBQUNqQjdKLGNBQU0sUUFEVztBQUVqQjhHLGFBQUs7QUFGWSxLQXZERTtBQTJEcEJnRCx1QkFBbUI7QUFDbEI5SixjQUFNLEdBRFk7QUFFbEI4RyxhQUFLO0FBRmEsS0EzREM7QUErRHBCaUQsaUJBQWE7QUFDWi9KLGNBQU0sU0FETTtBQUVaLG1CQUFXLEtBRkM7QUFHWjhHLGFBQUs7QUFITyxLQS9ETztBQW9FcEJrRCxnQkFBWTtBQUNYaEssY0FBTSxTQURLO0FBRVgsbUJBQVcsS0FGQTtBQUdYOEcsYUFBSztBQUhNLEtBcEVRO0FBeUVwQjJCLGVBQVc7QUFDVnpJLGNBQU0sV0FESTtBQUVWOEcsYUFBSztBQUZLO0FBekVTLENBQXJCO0FBOEVBLElBQUltRCxlQUFlO0FBQ2xCakssVUFBTTtBQUNMNEcsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxNQUZEO0FBR0w2RyxnQkFBUTtBQUNQcUQsbUJBQU87QUFDTnBELHFCQUFLO0FBREM7QUFEQSxTQUhIO0FBUUxBLGFBQUs7QUFSQSxLQURZO0FBV2xCOUMsVUFBTTtBQUNMNEMsa0JBQVUsSUFETDtBQUVMNUcsY0FBTSxPQUZEO0FBR0xrSCxlQUFPLFFBSEY7QUFJTEosYUFBSztBQUpBLEtBWFk7QUFpQmxCcUQsaUJBQWE7QUFDWnZELGtCQUFVLElBREU7QUFFWkUsYUFBSywwREFGTztBQUdaOUcsY0FBTSxPQUhNO0FBSVozRSxnQkFBUSxDQUpJO0FBS1o2TCxlQUFPO0FBQ05sSCxrQkFBTSxPQURBO0FBRU4zRSxvQkFBUSxDQUZGO0FBR042TCxtQkFBTyxRQUhEO0FBSU5KLGlCQUFLO0FBSkM7QUFMSztBQWpCSyxDQUFuQjtBQThCQSxJQUFJc0QsZUFBZTtBQUNsQnBLLFVBQU07QUFDTDRHLGtCQUFVLElBREw7QUFFTDVHLGNBQU0sTUFGRDtBQUdMNkcsZ0JBQVE7QUFDUHdELG1CQUFPO0FBQ052RCxxQkFBSztBQURDO0FBREEsU0FISDtBQVFMQSxhQUFLO0FBUkEsS0FEWTtBQVdsQjlKLFNBQUs7QUFDSjRKLGtCQUFVLElBRE47QUFFSjVHLGNBQU0sUUFGRjtBQUdKOEcsYUFBSztBQUhELEtBWGE7QUFnQmxCcUQsaUJBQWE7QUFDWnZELGtCQUFVLElBREU7QUFFWkUsYUFBSywwREFGTztBQUdaOUcsY0FBTSxPQUhNO0FBSVozRSxnQkFBUSxDQUpJO0FBS1o2TCxlQUFPO0FBQ05sSCxrQkFBTSxPQURBO0FBRU4zRSxvQkFBUSxDQUZGO0FBR042TCxtQkFBTyxRQUhEO0FBSU5KLGlCQUFLO0FBSkM7QUFMSztBQWhCSyxDQUFuQjtBQTZCQSxJQUFJbEssUUFBUTtBQUNYK0MsUUFBSTtBQUNISyxjQUFNLFFBREg7QUFFSDhHLGFBQUssb0JBRkY7QUFHSEYsa0JBQVU7QUFIUCxLQURPO0FBTVg1RyxVQUFNO0FBQ0xBLGNBQU0sTUFERDtBQUVMNkcsZ0JBQVE7QUFDUHlELGtCQUFNO0FBQ0x4RCxxQkFBSyxtREFEQTtBQUVMLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCeUQsNEJBQUksUUFEa0I7QUFFdEI1QixpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QjRCLCtCQUFPO0FBSmU7QUFEVDtBQUZWLGFBREM7QUFZUEMsa0JBQU07QUFDTDNELHFCQUFLLGlCQURBO0FBRUwsK0JBQWU7QUFDZCwyQ0FBdUI7QUFDdEJ5RCw0QkFBSSxRQURrQjtBQUV0QjVCLGlDQUFTLE9BRmE7QUFHdEJDLDZCQUFLLE9BSGlCO0FBSXRCNEIsK0JBQU87QUFKZTtBQURUO0FBRlYsYUFaQztBQXVCUEUsb0JBQVE7QUFDUDVELHFCQUFLLDBCQURFO0FBRVAsK0JBQWU7QUFDZCwyQ0FBdUI7QUFDdEJ5RCw0QkFBSSxRQURrQjtBQUV0QjVCLGlDQUFTLE9BRmE7QUFHdEJDLDZCQUFLLE9BSGlCO0FBSXRCNEIsK0JBQU87QUFKZTtBQURUO0FBRlIsYUF2QkQ7QUFrQ1BHLG9CQUFRO0FBQ1A3RCxxQkFBSyxrQkFERTtBQUVQLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCeUQsNEJBQUksUUFEa0I7QUFFdEI1QixpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QjRCLCtCQUFPO0FBSmU7QUFEVDtBQUZSLGFBbENEO0FBNkNQSSxxQkFBUztBQUNSOUQscUJBQUssWUFERztBQUVSLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCeUQsNEJBQUksUUFEa0I7QUFFdEI1QixpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QjRCLCtCQUFPO0FBSmU7QUFEVDtBQUZQLGFBN0NGO0FBd0RQLDhCQUFrQjtBQUNqQjFELHFCQUFLLDJCQURZO0FBRWpCLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCeUQsNEJBQUksUUFEa0I7QUFFdEI1QixpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QjRCLCtCQUFPO0FBSmU7QUFEVDtBQUZFLGFBeERYO0FBbUVQMUIsb0JBQVE7QUFDUGhDLHFCQUFLLGdEQURFO0FBRVAsK0JBQWU7QUFDZCwyQ0FBdUI7QUFDdEJ5RCw0QkFBSSxRQURrQjtBQUV0QjVCLGlDQUFTLE9BRmE7QUFHdEJDLDZCQUFLLE9BSGlCO0FBSXRCNEIsK0JBQU87QUFKZTtBQURUO0FBRlIsYUFuRUQ7QUE4RVBLLHVCQUFXO0FBQ1YvRCxxQkFBSyxxSkFESztBQUVWLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCeUQsNEJBQUksUUFEa0I7QUFFdEI1QixpQ0FBUyxPQUZhO0FBR3RCQyw2QkFBSyxPQUhpQjtBQUl0QjRCLCtCQUFPO0FBSmU7QUFEVDtBQUZMLGFBOUVKO0FBeUZQekssd0JBQVk7QUFDWCtHLHFCQUFLLDZDQURNO0FBRVgsK0JBQWU7QUFDZCwyQ0FBdUI7QUFDdEJ5RCw0QkFBSSxRQURrQjtBQUV0QjVCLGlDQUFTLE9BRmE7QUFHdEJDLDZCQUFLLE9BSGlCO0FBSXRCNEIsK0JBQU87QUFKZTtBQURUO0FBRkosYUF6Rkw7QUFvR1BNLGlCQUFLO0FBQ0poRSxxQkFBSyxrRkFERDtBQUVKLCtCQUFlO0FBQ2QsMkNBQXVCO0FBQ3RCeUQsNEJBQUksT0FEa0I7QUFFdEIzQiw2QkFBSyxRQUZpQjtBQUd0QkQsaUNBQVM7QUFIYTtBQURUO0FBRlg7QUFwR0UsU0FGSDtBQWlITDdCLGFBQUssK0JBakhBO0FBa0hMRixrQkFBVTtBQWxITCxLQU5LO0FBMEhYSyxjQUFVO0FBQ1RqSCxjQUFNLEdBREc7QUFFVDhHLGFBQUs7QUFGSSxLQTFIQztBQThIWHZKLFlBQVE7QUFDUHlDLGNBQU0sUUFEQztBQUVQOEcsYUFBSztBQUZFLEtBOUhHO0FBa0lYLG9CQUFnQjtBQUNmOUcsY0FBTSxRQURTO0FBRWY4RyxhQUFLO0FBRlUsS0FsSUw7QUFzSVh4RCxhQUFTO0FBQ1J0RCxjQUFNLFFBREU7QUFFUnVKLGlCQUFTLENBRkQ7QUFHUkQsaUJBQVMsRUFIRDtBQUlSeEMsYUFBSztBQUpHLEtBdElFO0FBNElYMUQsYUFBUztBQUNScEQsY0FBTSxRQURFO0FBRVJ1SixpQkFBUyxDQUZEO0FBR1JELGlCQUFTLEVBSEQ7QUFJUnhDLGFBQUs7QUFKRyxLQTVJRTtBQWtKWDBDLFlBQVE7QUFDUHhKLGNBQU0sUUFEQztBQUVQOEcsYUFBSztBQUZFLEtBbEpHO0FBc0pYakssWUFBUTtBQUNQbUQsY0FBTSxRQURDO0FBRVA4RyxhQUFLO0FBRkUsS0F0Skc7QUEwSlgxRyxXQUFPO0FBQ05KLGNBQU0sT0FEQTtBQUVOOEcsYUFBSztBQUZDO0FBMUpJLENBQVo7QUErSkEsSUFBSWpLLFNBQVMsQ0FDWixhQURZLEVBRVosYUFGWSxFQUdaLGVBSFksRUFJWixnQkFKWSxFQUtaLHVCQUxZLEVBTVosZUFOWSxFQU9aLGVBUFksRUFRWixrQkFSWSxFQVNaLG1CQVRZLEVBVVosWUFWWSxDQUFiO0FBWUEsSUFBSWtPLG9CQUFvQjtBQUN2Qm5LLGdCQUFZO0FBQ1haLGNBQU0sTUFESztBQUVYNkcsZ0JBQVE7QUFDUDVDLHFCQUFTO0FBQ1I2QyxxQkFBSztBQURHLGFBREY7QUFJUGtFLGtCQUFNO0FBQ0xsRSxxQkFBSztBQURBO0FBSkMsU0FGRztBQVVYLG1CQUFXLFNBVkE7QUFXWEEsYUFBSyxrQ0FYTTtBQVlYLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQURXLENBQXhCO0FBd0JBLElBQUlTLGFBQWE7QUFDaEJySyxnQkFBWTtBQUNYWixjQUFNLE1BREs7QUFFWDZHLGdCQUFRO0FBQ1A1QyxxQkFBUztBQUNSNkMscUJBQUs7QUFERyxhQURGO0FBSVBrRSxrQkFBTTtBQUNMbEUscUJBQUs7QUFEQTtBQUpDLFNBRkc7QUFVWCxtQkFBVyxTQVZBO0FBV1hBLGFBQUssa0NBWE07QUFZWCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLE9BRGtCO0FBRXRCM0IscUJBQUssUUFGaUI7QUFHdEJELHlCQUFTO0FBSGE7QUFEVCxTQVpKO0FBbUJYLHlCQUFpQjtBQW5CTjtBQURJLENBQWpCO0FBdUJBLElBQUl1QyxjQUFjO0FBQ2pCLHFCQUFpQjtBQUNoQmxMLGNBQU0sUUFEVTtBQUVoQjhHLGFBQUssMElBRlc7QUFHaEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxPQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxPQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBSEM7QUFpQmhCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWpCSTtBQXdCaEIseUJBQWlCO0FBeEJELEtBREE7QUEyQmpCekssZ0JBQVk7QUFDWFosY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNUMscUJBQVM7QUFDUjZDLHFCQUFLO0FBREcsYUFERjtBQUlQa0Usa0JBQU07QUFDTGxFLHFCQUFLO0FBREE7QUFKQyxTQUZHO0FBVVgsbUJBQVcsU0FWQTtBQVdYQSxhQUFLLGtDQVhNO0FBWVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBWko7QUFvQlgseUJBQWlCO0FBcEJOO0FBM0JLLENBQWxCO0FBa0RBLElBQUljLGdCQUFnQjtBQUNuQix1QkFBbUI7QUFDbEJ0TCxjQUFNLFFBRFk7QUFFbEI4RyxhQUFLLDBJQUZhO0FBR2xCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksT0FEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksT0FEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQUhHO0FBaUJsQlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0FqQk07QUF3QmxCLHlCQUFpQjtBQXhCQyxLQURBO0FBMkJuQnpLLGdCQUFZO0FBQ1haLGNBQU0sTUFESztBQUVYNkcsZ0JBQVE7QUFDUDVDLHFCQUFTO0FBQ1I2QyxxQkFBSztBQURHLGFBREY7QUFJUGtFLGtCQUFNO0FBQ0xsRSxxQkFBSztBQURBO0FBSkMsU0FGRztBQVVYLG1CQUFXLFNBVkE7QUFXWEEsYUFBSyxrQ0FYTTtBQVlYLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQTNCTyxDQUFwQjtBQWtEQSxJQUFJZSxpQkFBaUI7QUFDcEIzSyxnQkFBWTtBQUNYWixjQUFNLE1BREs7QUFFWDZHLGdCQUFRO0FBQ1A1QyxxQkFBUztBQUNSNkMscUJBQUs7QUFERyxhQURGO0FBSVBrRSxrQkFBTTtBQUNMbEUscUJBQUs7QUFEQTtBQUpDLFNBRkc7QUFVWCxtQkFBVyxTQVZBO0FBV1hBLGFBQUssa0NBWE07QUFZWCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FaSjtBQW9CWCx5QkFBaUI7QUFwQk47QUFEUSxDQUFyQjtBQXdCQSxJQUFJZ0IsY0FBYztBQUNqQixnQkFBWTtBQUNYeEwsY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNEUsa0JBQU07QUFDTDNFLHFCQUFLO0FBREEsYUFEQztBQUlQNEUsbUJBQU87QUFDTjVFLHFCQUFLO0FBREMsYUFKQTtBQU9QNkUsb0JBQVE7QUFDUDdFLHFCQUFLO0FBREU7QUFQRCxTQUZHO0FBYVgsbUJBQVcsTUFiQTtBQWNYQSxhQUFLLDhCQWRNO0FBZVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSTtBQURrQjtBQVBULFNBZko7QUEwQlhZLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBMUJEO0FBaUNYLHlCQUFpQjtBQWpDTixLQURLO0FBb0NqQixpQkFBYTtBQUNackwsY0FBTSxNQURNO0FBRVo2RyxnQkFBUTtBQUNQK0UsbUJBQU87QUFDTjlFLHFCQUFLO0FBREMsYUFEQTtBQUlQNEUsbUJBQU87QUFDTjVFLHFCQUFLO0FBREMsYUFKQTtBQU9QK0UsbUJBQU87QUFDTi9FLHFCQUFLO0FBREM7QUFQQSxTQUZJO0FBYVosbUJBQVcsT0FiQztBQWNaQSxhQUFLLG9DQWRPO0FBZVosdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBZkg7QUE2QlpXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBN0JBO0FBb0NaLHlCQUFpQjtBQXBDTCxLQXBDSTtBQTBFakIsd0JBQW9CO0FBQ25CckwsY0FBTSxRQURhO0FBRW5CLG1CQUFXLENBRlE7QUFHbkI4RyxhQUFLLDRFQUhjO0FBSW5CZ0Ysa0JBQVUsQ0FDVDtBQUNDLHlCQUFhO0FBRGQsU0FEUyxDQUpTO0FBU25CLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVRJO0FBaUJuQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWpCTztBQXVCbkIseUJBQWlCO0FBdkJFLEtBMUVIO0FBbUdqQix3QkFBb0I7QUFDbkJyTCxjQUFNLFFBRGE7QUFFbkIsbUJBQVcsSUFGUTtBQUduQjhHLGFBQUssOEVBSGM7QUFJbkJnRixrQkFBVSxDQUNUO0FBQ0MseUJBQWE7QUFEZCxTQURTLENBSlM7QUFTbkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBVEk7QUFpQm5CVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBakJPO0FBdUJuQix5QkFBaUI7QUF2QkUsS0FuR0g7QUE0SGpCLHFCQUFpQjtBQUNoQnJMLGNBQU0sUUFEVTtBQUVoQjhHLGFBQUssMElBRlc7QUFHaEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxPQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxPQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBSEM7QUFpQmhCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWpCSTtBQXdCaEIseUJBQWlCO0FBeEJELEtBNUhBO0FBc0pqQnpLLGdCQUFZO0FBQ1haLGNBQU0sTUFESztBQUVYNkcsZ0JBQVE7QUFDUDVDLHFCQUFTO0FBQ1I2QyxxQkFBSztBQURHLGFBREY7QUFJUGtFLGtCQUFNO0FBQ0xsRSxxQkFBSztBQURBO0FBSkMsU0FGRztBQVVYLG1CQUFXLFNBVkE7QUFXWEEsYUFBSyxrQ0FYTTtBQVlYLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQXRKSyxDQUFsQjtBQTZLQSxJQUFJdUIsZ0JBQWdCO0FBQ25CLHdCQUFvQjtBQUNuQi9MLGNBQU0sTUFEYTtBQUVuQjZHLGdCQUFRO0FBQ1BtRixtQkFBTztBQUNObEYscUJBQUs7QUFEQyxhQURBO0FBSVAyRCxrQkFBTTtBQUNMM0QscUJBQUs7QUFEQSxhQUpDO0FBT1AsMkJBQWU7QUFDZEEscUJBQUs7QUFEUztBQVBSLFNBRlc7QUFhbkIsbUJBQVcsT0FiUTtBQWNuQkEsYUFBSywyQ0FkYztBQWVuQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FmSTtBQTZCbkJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0E3Qk87QUFtQ25CLHlCQUFpQjtBQW5DRSxLQUREO0FBc0NuQixzQkFBa0I7QUFDakJyTCxjQUFNLFFBRFc7QUFFakIsbUJBQVcsR0FGTTtBQUdqQnVKLGlCQUFTLENBSFE7QUFJakJsQyxlQUFPLFFBSlU7QUFLakJQLGFBQUssc0NBTFk7QUFNakJnRixrQkFBVSxDQUNUO0FBQ0MsZ0NBQW9CO0FBRHJCLFNBRFMsQ0FOTztBQVdqQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FYRTtBQW1CakJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FuQks7QUF5QmpCLHlCQUFpQjtBQXpCQSxLQXRDQztBQWlFbkIsMEJBQXNCO0FBQ3JCckwsY0FBTSxTQURlO0FBRXJCLG1CQUFXLEtBRlU7QUFHckI4RyxhQUFLLDRhQUhnQjtBQUlyQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FKTTtBQVlyQlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQVpTO0FBa0JyQix5QkFBaUI7QUFsQkksS0FqRUg7QUFxRm5CLHVCQUFtQjtBQUNsQnJMLGNBQU0sUUFEWTtBQUVsQjhHLGFBQUssMllBRmE7QUFHbEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLFFBSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLFFBSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBSEc7QUFpQmxCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWpCTTtBQXdCbEIseUJBQWlCO0FBeEJDLEtBckZBO0FBK0duQixzQkFBa0I7QUFDakJyTCxjQUFNLE1BRFc7QUFFakI2RyxnQkFBUTtBQUNQb0Ysa0JBQU07QUFDTG5GLHFCQUFLO0FBREEsYUFEQztBQUlQLDBCQUFjO0FBQ2JBLHFCQUFLO0FBRFEsYUFKUDtBQU9Qdkosb0JBQVE7QUFDUHVKLHFCQUFLO0FBREU7QUFQRCxTQUZTO0FBYWpCLG1CQUFXLE1BYk07QUFjakJBLGFBQUssOFBBZFk7QUFlakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBZkU7QUF1QmpCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdkJLO0FBNkJqQix5QkFBaUI7QUE3QkEsS0EvR0M7QUE4SW5CLDBCQUFzQjtBQUNyQnJMLGNBQU0sU0FEZTtBQUVyQixtQkFBVyxLQUZVO0FBR3JCOEcsYUFBSyw0RkFIZ0I7QUFJckJnRixrQkFBVSxDQUNULFlBRFMsQ0FKVztBQU9yQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FQTTtBQWVyQlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZTO0FBcUJyQix5QkFBaUI7QUFyQkksS0E5SUg7QUFxS25CLDZCQUF5QjtBQUN4QnJMLGNBQU0sU0FEa0I7QUFFeEIsbUJBQVcsS0FGYTtBQUd4QjhHLGFBQUssMkVBSG1CO0FBSXhCZ0Ysa0JBQVUsQ0FDVCxZQURTLENBSmM7QUFPeEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUFM7QUFleEJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmWTtBQXFCeEIseUJBQWlCO0FBckJPLEtBcktOO0FBNExuQixxQkFBaUI7QUFDaEJyTCxjQUFNLFNBRFU7QUFFaEIsbUJBQVcsS0FGSztBQUdoQjhHLGFBQUssK0hBSFc7QUFJaEJnRixrQkFBVSxDQUNULFlBRFMsRUFFVCxZQUZTLENBSk07QUFRaEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUkM7QUFnQmhCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBaEJJO0FBc0JoQix5QkFBaUI7QUF0QkQsS0E1TEU7QUFvTm5CLCtCQUEyQjtBQUMxQnJMLGNBQU0sTUFEb0I7QUFFMUI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREksYUFKSDtBQU9QbUYsa0JBQU07QUFDTG5GLHFCQUFLO0FBREE7QUFQQyxTQUZrQjtBQWExQixtQkFBVyxNQWJlO0FBYzFCQSxhQUFLLG9GQWRxQjtBQWUxQmdGLGtCQUFVLENBQ1QsWUFEUyxDQWZnQjtBQWtCMUIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsNEJBQWdCO0FBQ2ZELG9CQUFJLFFBRFc7QUFFZjVCLHlCQUFTLE9BRk07QUFHZkMscUJBQUssT0FIVTtBQUlmNEIsdUJBQU87QUFKUTtBQVBGLFNBbEJXO0FBZ0MxQlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWhDYztBQXNDMUIseUJBQWlCO0FBdENTLEtBcE5SO0FBNFBuQixpQkFBYTtBQUNackwsY0FBTSxRQURNO0FBRVosbUJBQVcsQ0FGQztBQUdadUosaUJBQVMsQ0FIRztBQUlabEMsZUFBTyxrQ0FKSztBQUtaUCxhQUFLLGtOQUxPO0FBTVpnRixrQkFBVSxDQUNULFlBRFMsQ0FORTtBQVNaLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVRIO0FBdUJaVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXZCQTtBQThCWix5QkFBaUI7QUE5QkwsS0E1UE07QUE0Um5CLHFCQUFpQjtBQUNoQnJMLGNBQU0sTUFEVTtBQUVoQjZHLGdCQUFRO0FBQ1BtRSxrQkFBTTtBQUNMbEUscUJBQUs7QUFEQSxhQURDO0FBSVBxRixtQkFBTztBQUNOckYscUJBQUs7QUFEQyxhQUpBO0FBT1BzRixvQkFBUTtBQUNQdEYscUJBQUs7QUFERSxhQVBEO0FBVVB1RixrQkFBTTtBQUNMdkYscUJBQUs7QUFEQTtBQVZDLFNBRlE7QUFnQmhCLG1CQUFXLE1BaEJLO0FBaUJoQkEsYUFBSyxvREFqQlc7QUFrQmhCZ0Ysa0JBQVUsQ0FDVCxZQURTLEVBRVQsWUFGUyxDQWxCTTtBQXNCaEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsaUNBQXFCO0FBQ3BCRCxvQkFBSSxPQURnQjtBQUVwQjVCLHlCQUFTLE9BRlc7QUFHcEJDLHFCQUFLLE9BSGU7QUFJcEI0Qix1QkFBTztBQUphO0FBUFAsU0F0QkM7QUFvQ2hCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBcENJO0FBMENoQix5QkFBaUI7QUExQ0QsS0E1UkU7QUF3VW5CLDZCQUF5QjtBQUN4QnJMLGNBQU0sT0FEa0I7QUFFeEJrSCxlQUFPLFFBRmlCO0FBR3hCN0wsZ0JBQVEsQ0FIZ0I7QUFJeEIsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxFQUdWLENBSFUsRUFJVixDQUpVLENBSmE7QUFVeEJnTSxlQUFPLFFBVmlCO0FBV3hCUCxhQUFLLDhIQVhtQjtBQVl4QmdGLGtCQUFVLENBQ1QsWUFEUyxFQUVULFlBRlMsRUFHVDtBQUNDLDZCQUFpQixDQUNoQixNQURnQixFQUVoQixPQUZnQixFQUdoQixRQUhnQjtBQURsQixTQUhTLENBWmM7QUF1QnhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQXZCUztBQStCeEJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0EvQlk7QUFxQ3hCLHlCQUFpQjtBQXJDTyxLQXhVTjtBQStXbkIsa0JBQWM7QUFDYnJMLGNBQU0sZUFETztBQUViOEcsYUFBSyxpRUFGUTtBQUdid0YsZ0JBQVEsSUFISztBQUliLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCL0Isb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQUpGO0FBa0JiVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWxCQztBQXlCYix5QkFBaUI7QUF6QkosS0EvV0s7QUEwWW5CLG1CQUFlO0FBQ2RyTCxjQUFNLFFBRFE7QUFFZCxtQkFBVyxDQUZHO0FBR2RvSCxnQkFBUSxHQUhNO0FBSWRDLGVBQU8sU0FKTztBQUtkUCxhQUFLLDZCQUxTO0FBTWRnRixrQkFBVSxDQUNULFlBRFMsQ0FOSTtBQVNkLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVREO0FBdUJkVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXZCRTtBQThCZCx5QkFBaUI7QUE5QkgsS0ExWUk7QUEwYW5CLG9CQUFnQjtBQUNmckwsY0FBTSxRQURTO0FBRWYsbUJBQVcsQ0FGSTtBQUdmdUosaUJBQVMsQ0FITTtBQUlmbEMsZUFBTyxRQUpRO0FBS2ZQLGFBQUssZ0dBTFU7QUFNZmdGLGtCQUFVLENBQ1QsWUFEUyxDQU5LO0FBU2YsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBVEE7QUFpQmZXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FqQkc7QUF1QmYseUJBQWlCO0FBdkJGLEtBMWFHO0FBbWNuQix5QkFBcUI7QUFDcEJyTCxjQUFNLFNBRGM7QUFFcEIsbUJBQVcsS0FGUztBQUdwQjhHLGFBQUssaUZBSGU7QUFJcEJnRixrQkFBVSxDQUNULFlBRFMsRUFFVDtBQUNDLHVDQUEyQjtBQUQ1QixTQUZTLEVBS1Q7QUFDQyxnQ0FBb0IsQ0FDbkIsTUFEbUIsRUFFbkIsYUFGbUI7QUFEckIsU0FMUyxDQUpVO0FBZ0JwQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FoQks7QUF3QnBCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBeEJRO0FBOEJwQix5QkFBaUI7QUE5QkcsS0FuY0Y7QUFtZW5CLG1CQUFlO0FBQ2RyTCxjQUFNLE9BRFE7QUFFZGtILGVBQU8sUUFGTztBQUdkN0wsZ0JBQVEsQ0FITTtBQUlkLG1CQUFXLENBQ1YsQ0FEVSxFQUVWLENBRlUsQ0FKRztBQVFkeUwsYUFBSyxzVEFSUztBQVNkZ0Ysa0JBQVUsQ0FDVCxZQURTLENBVEk7QUFZZCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FaRDtBQTBCZFcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0ExQkU7QUFpQ2QseUJBQWlCO0FBakNILEtBbmVJO0FBc2dCbkIsbUJBQWU7QUFDZHJMLGNBQU0sTUFEUTtBQUVkNkcsZ0JBQVE7QUFDUGxGLG9CQUFRO0FBQ1BtRixxQkFBSztBQURFLGFBREQ7QUFJUHlGLGtCQUFNO0FBQ0x6RixxQkFBSztBQURBLGFBSkM7QUFPUDBGLG1CQUFPO0FBQ04xRixxQkFBSztBQURDLGFBUEE7QUFVUDJGLGlCQUFLO0FBQ0ozRixxQkFBSztBQURELGFBVkU7QUFhUDRGLG9CQUFRO0FBQ1A1RixxQkFBSztBQURFLGFBYkQ7QUFnQlAsd0JBQVk7QUFDWEEscUJBQUs7QUFETSxhQWhCTDtBQW1CUCx5QkFBYTtBQUNaQSxxQkFBSztBQURPLGFBbkJOO0FBc0JQLDJCQUFlO0FBQ2RBLHFCQUFLO0FBRFMsYUF0QlI7QUF5QlAsNEJBQWdCO0FBQ2ZBLHFCQUFLO0FBRFU7QUF6QlQsU0FGTTtBQStCZCxtQkFBVyxRQS9CRztBQWdDZEEsYUFBSyxnREFoQ1M7QUFpQ2RnRixrQkFBVSxDQUNULFlBRFMsQ0FqQ0k7QUFvQ2QsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBcENEO0FBa0RkVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWxERTtBQXlEZCx5QkFBaUI7QUF6REgsS0F0Z0JJO0FBaWtCbkIsNEJBQXdCO0FBQ3ZCckwsY0FBTSxNQURpQjtBQUV2QjZHLGdCQUFRO0FBQ1BuTCxpQkFBSztBQUNKb0wscUJBQUs7QUFERCxhQURFO0FBSVBvRixzQkFBVTtBQUNUcEYscUJBQUs7QUFESSxhQUpIO0FBT1BtRixrQkFBTTtBQUNMbkYscUJBQUs7QUFEQTtBQVBDLFNBRmU7QUFhdkIsbUJBQVcsTUFiWTtBQWN2QkEsYUFBSywwQ0Fka0I7QUFldkJnRixrQkFBVSxDQUNULFlBRFMsQ0FmYTtBQWtCdkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBbEJRO0FBMEJ2Qlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQTFCVztBQWdDdkIseUJBQWlCO0FBaENNLEtBamtCTDtBQW1tQm5CLDRCQUF3QjtBQUN2QnJMLGNBQU0sTUFEaUI7QUFFdkI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREksYUFKSDtBQU9QbUYsa0JBQU07QUFDTG5GLHFCQUFLO0FBREE7QUFQQyxTQUZlO0FBYXZCLG1CQUFXLE1BYlk7QUFjdkJBLGFBQUssMENBZGtCO0FBZXZCZ0Ysa0JBQVUsQ0FDVCxZQURTLENBZmE7QUFrQnZCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLDRCQUFnQjtBQUNmRCxvQkFBSSxRQURXO0FBRWY1Qix5QkFBUyxPQUZNO0FBR2ZDLHFCQUFLLE9BSFU7QUFJZjRCLHVCQUFPO0FBSlE7QUFQRixTQWxCUTtBQWdDdkJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FoQ1c7QUFzQ3ZCLHlCQUFpQjtBQXRDTSxLQW5tQkw7QUEyb0JuQiwrQkFBMkI7QUFDMUJyTCxjQUFNLE1BRG9CO0FBRTFCNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUG9GLHNCQUFVO0FBQ1RwRixxQkFBSztBQURJLGFBSkg7QUFPUG1GLGtCQUFNO0FBQ0xuRixxQkFBSztBQURBO0FBUEMsU0FGa0I7QUFhMUIsbUJBQVcsTUFiZTtBQWMxQkEsYUFBSyxxSEFkcUI7QUFlMUJnRixrQkFBVSxDQUNULFlBRFMsQ0FmZ0I7QUFrQjFCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLDRCQUFnQjtBQUNmRCxvQkFBSSxRQURXO0FBRWY1Qix5QkFBUyxPQUZNO0FBR2ZDLHFCQUFLLE9BSFU7QUFJZjRCLHVCQUFPO0FBSlE7QUFQRixTQWxCVztBQWdDMUJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FoQ2M7QUFzQzFCLHlCQUFpQjtBQXRDUyxLQTNvQlI7QUFtckJuQixrQkFBYztBQUNickwsY0FBTSxXQURPO0FBRWIsbUJBQVcsRUFGRTtBQUdic00sZ0JBQVEsSUFISztBQUlieEYsYUFBSyxvTkFKUTtBQUtiLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQUxGO0FBbUJiVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQW5CQztBQTBCYix5QkFBaUI7QUExQkosS0FuckJLO0FBK3NCbkIsaUJBQWE7QUFDWnJMLGNBQU0sT0FETTtBQUVaa0gsZUFBTyxRQUZLO0FBR1osbUJBQVcsQ0FDVixtQkFEVSxFQUVWLDBCQUZVLENBSEM7QUFPWkosYUFBSyx3Q0FQTztBQVFaZ0Ysa0JBQVUsQ0FDVCxZQURTLENBUkU7QUFXWix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FYSDtBQXlCWlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0F6QkE7QUFnQ1oseUJBQWlCO0FBaENMLEtBL3NCTTtBQWl2Qm5CLGlCQUFhO0FBQ1pyTCxjQUFNLFFBRE07QUFFWixtQkFBVyxFQUZDO0FBR1p1SixpQkFBUyxDQUhHO0FBSVpsQyxlQUFPLFFBSks7QUFLWlAsYUFBSyxZQUxPO0FBTVpnRixrQkFBVSxDQUNULFlBRFMsQ0FORTtBQVNaLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVRIO0FBdUJaVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXZCQTtBQThCWix5QkFBaUI7QUE5QkwsS0FqdkJNO0FBaXhCbkIsc0JBQWtCO0FBQ2pCckwsY0FBTSxRQURXO0FBRWpCLG1CQUFXLEVBRk07QUFHakJ1SixpQkFBUyxDQUhRO0FBSWpCbEMsZUFBTyxLQUpVO0FBS2pCUCxhQUFLLDJDQUxZO0FBTWpCZ0Ysa0JBQVUsQ0FDVCxZQURTLEVBRVQ7QUFDQyxnQ0FBb0IsQ0FDbkIsT0FEbUI7QUFEckIsU0FGUyxDQU5PO0FBY2pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQWRFO0FBNEJqQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0E1Qks7QUFtQ2pCLHlCQUFpQjtBQW5DQSxLQWp4QkM7QUFzekJuQix3QkFBb0I7QUFDbkJyTCxjQUFNLFFBRGE7QUFFbkIsbUJBQVcsR0FGUTtBQUduQnFILGVBQU8sS0FIWTtBQUluQlAsYUFBSyx5Q0FKYztBQUtuQmdGLGtCQUFVLENBQ1QsWUFEUyxDQUxTO0FBUW5CLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUk7QUFEa0I7QUFQVCxTQVJJO0FBbUJuQlksb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0FuQk87QUEwQm5CLHlCQUFpQjtBQTFCRSxLQXR6QkQ7QUFrMUJuQiwyQkFBdUI7QUFDdEJyTCxjQUFNLFFBRGdCO0FBRXRCLG1CQUFXLENBRlc7QUFHdEJxSCxlQUFPLEtBSGU7QUFJdEJQLGFBQUssdUJBSmlCO0FBS3RCZ0Ysa0JBQVUsQ0FDVCxZQURTLENBTFk7QUFRdEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUk87QUFzQnRCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXRCVTtBQTZCdEIseUJBQWlCO0FBN0JLLEtBbDFCSjtBQWkzQm5CLG9CQUFnQjtBQUNmckwsY0FBTSxNQURTO0FBRWY2RyxnQkFBUTtBQUNQb0Ysa0JBQU07QUFDTG5GLHFCQUFLO0FBREEsYUFEQztBQUlQeUYsa0JBQU07QUFDTHpGLHFCQUFLO0FBREEsYUFKQztBQU9QbkYsb0JBQVE7QUFDUG1GLHFCQUFLO0FBREUsYUFQRDtBQVVQMEYsbUJBQU87QUFDTjFGLHFCQUFLO0FBREM7QUFWQSxTQUZPO0FBZ0JmLG1CQUFXLFFBaEJJO0FBaUJmQSxhQUFLLDZCQWpCVTtBQWtCZmdGLGtCQUFVLENBQ1QsWUFEUyxDQWxCSztBQXFCZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBUFQ7QUFhZHlCLGtCQUFNO0FBQ0wxQixvQkFBSSxRQURDO0FBRUw1Qix5QkFBUyxPQUZKO0FBR0xDLHFCQUFLLFFBSEE7QUFJTDRCLHVCQUFPO0FBSkY7QUFiUSxTQXJCQTtBQXlDZlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0F6Q0c7QUFnRGYseUJBQWlCO0FBaERGLEtBajNCRztBQW02Qm5CLDBCQUFzQjtBQUNyQnJMLGNBQU0sUUFEZTtBQUVyQnFILGVBQU8sS0FGYztBQUdyQixtQkFBVyxDQUhVO0FBSXJCUCxhQUFLLDBMQUpnQjtBQUtyQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssUUFIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssUUFIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FMTTtBQW1CckJzQixrQkFBVSxDQUNULFlBRFMsQ0FuQlc7QUFzQnJCLHlCQUFpQixhQXRCSTtBQXVCckJYLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZEO0FBdkJTLEtBbjZCSDtBQWs4Qm5CLDRCQUF3QjtBQUN2QnJMLGNBQU0sT0FEaUI7QUFFdkJrSCxlQUFPLE1BRmdCO0FBR3ZCTCxnQkFBUTtBQUNQbEYsb0JBQVE7QUFDUG1GLHFCQUFLO0FBREUsYUFERDtBQUlQeUYsa0JBQU07QUFDTHpGLHFCQUFLO0FBREEsYUFKQztBQU9QMEYsbUJBQU87QUFDTjFGLHFCQUFLO0FBREMsYUFQQTtBQVVQMkYsaUJBQUs7QUFDSjNGLHFCQUFLO0FBREQsYUFWRTtBQWFQNEYsb0JBQVE7QUFDUDVGLHFCQUFLO0FBREUsYUFiRDtBQWdCUCx3QkFBWTtBQUNYQSxxQkFBSztBQURNLGFBaEJMO0FBbUJQLHlCQUFhO0FBQ1pBLHFCQUFLO0FBRE8sYUFuQk47QUFzQlAsMkJBQWU7QUFDZEEscUJBQUs7QUFEUyxhQXRCUjtBQXlCUCw0QkFBZ0I7QUFDZkEscUJBQUs7QUFEVTtBQXpCVCxTQUhlO0FBZ0N2QmdGLGtCQUFVLENBQ1QsWUFEUyxFQUVUO0FBQ0MsZ0NBQW9CLENBQ25CLE9BRG1CO0FBRHJCLFNBRlMsQ0FoQ2E7QUF3Q3ZCaEYsYUFBSyx1WUF4Q2tCO0FBeUN2Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssUUFIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0F6Q1E7QUFpRHZCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBakRXO0FBdUR2Qix5QkFBaUI7QUF2RE0sS0FsOEJMO0FBMi9CbkIsbUJBQWU7QUFDZHJMLGNBQU0sTUFEUTtBQUVkNkcsZ0JBQVE7QUFDUGxGLG9CQUFRO0FBQ1BtRixxQkFBSztBQURFLGFBREQ7QUFJUHlGLGtCQUFNO0FBQ0x6RixxQkFBSztBQURBLGFBSkM7QUFPUDBGLG1CQUFPO0FBQ04xRixxQkFBSztBQURDLGFBUEE7QUFVUDJGLGlCQUFLO0FBQ0ozRixxQkFBSztBQURELGFBVkU7QUFhUDRGLG9CQUFRO0FBQ1A1RixxQkFBSztBQURFLGFBYkQ7QUFnQlAsd0JBQVk7QUFDWEEscUJBQUs7QUFETSxhQWhCTDtBQW1CUCx5QkFBYTtBQUNaQSxxQkFBSztBQURPLGFBbkJOO0FBc0JQLDJCQUFlO0FBQ2RBLHFCQUFLO0FBRFMsYUF0QlI7QUF5QlAsNEJBQWdCO0FBQ2ZBLHFCQUFLO0FBRFU7QUF6QlQsU0FGTTtBQStCZCxtQkFBVyxRQS9CRztBQWdDZEEsYUFBSyxnREFoQ1M7QUFpQ2RnRixrQkFBVSxDQUNULFlBRFMsRUFFVDtBQUNDLGlCQUFLO0FBRE4sU0FGUyxDQWpDSTtBQXVDZCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0F2Q0Q7QUFxRGRXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBckRFO0FBNERkLHlCQUFpQjtBQTVESCxLQTMvQkk7QUF5akNuQixzQkFBa0I7QUFDakJyTCxjQUFNLFFBRFc7QUFFakIsbUJBQVcsRUFGTTtBQUdqQnFILGVBQU8sU0FIVTtBQUlqQlAsYUFBSyxtREFKWTtBQUtqQmdGLGtCQUFVLENBQ1QsWUFEUyxFQUVUO0FBQ0MsZ0NBQW9CLENBQ25CLE1BRG1CLEVBRW5CLGFBRm1CO0FBRHJCLFNBRlMsQ0FMTztBQWNqQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FkRTtBQXNCakJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F0Qks7QUE0QmpCLHlCQUFpQjtBQTVCQSxLQXpqQ0M7QUF1bENuQix5QkFBcUI7QUFDcEJyTCxjQUFNLE9BRGM7QUFFcEJrSCxlQUFPLE1BRmE7QUFHcEJMLGdCQUFRO0FBQ1A4Rix3QkFBWTtBQUNYN0YscUJBQUs7QUFETSxhQURMO0FBSVA4RixzQkFBVTtBQUNUOUYscUJBQUs7QUFESTtBQUpILFNBSFk7QUFXcEJBLGFBQUssb29CQVhlO0FBWXBCZ0Ysa0JBQVUsQ0FDVCxZQURTLENBWlU7QUFlcEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxPQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBZks7QUF1QnBCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdkJRO0FBNkJwQix5QkFBaUI7QUE3QkcsS0F2bENGO0FBc25DbkIsbUJBQWU7QUFDZHJMLGNBQU0sUUFEUTtBQUVkLG1CQUFXLENBRkc7QUFHZG9ILGdCQUFRLEdBSE07QUFJZEMsZUFBTyxTQUpPO0FBS2RQLGFBQUssNkJBTFM7QUFNZGdGLGtCQUFVLENBQ1QsWUFEUyxDQU5JO0FBU2QsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBVEQ7QUF1QmRXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBdkJFO0FBOEJkLHlCQUFpQjtBQTlCSCxLQXRuQ0k7QUFzcENuQixvQkFBZ0I7QUFDZnJMLGNBQU0sUUFEUztBQUVmLG1CQUFXLENBRkk7QUFHZnVKLGlCQUFTLENBSE07QUFJZmxDLGVBQU8sUUFKUTtBQUtmUCxhQUFLLGdHQUxVO0FBTWZnRixrQkFBVSxDQUNULFlBRFMsQ0FOSztBQVNmLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVRBO0FBaUJmVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBakJHO0FBdUJmLHlCQUFpQjtBQXZCRixLQXRwQ0c7QUErcUNuQix5QkFBcUI7QUFDcEJyTCxjQUFNLFNBRGM7QUFFcEIsbUJBQVcsSUFGUztBQUdwQjhHLGFBQUssNEZBSGU7QUFJcEJnRixrQkFBVSxDQUNULFlBRFMsRUFFVDtBQUNDLHVDQUEyQjtBQUQ1QixTQUZTLEVBS1Q7QUFDQyxnQ0FBb0IsQ0FDbkIsTUFEbUIsRUFFbkIsYUFGbUI7QUFEckIsU0FMUyxDQUpVO0FBZ0JwQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FoQks7QUF3QnBCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBeEJRO0FBOEJwQix5QkFBaUI7QUE5QkcsS0EvcUNGO0FBK3NDbkIsc0JBQWtCO0FBQ2pCckwsY0FBTSxNQURXO0FBRWpCNkcsZ0JBQVE7QUFDUG1FLGtCQUFNO0FBQ0xsRSxxQkFBSztBQURBLGFBREM7QUFJUCtGLHVCQUFXO0FBQ1YvRixxQkFBSztBQURLLGFBSko7QUFPUGdHLHVCQUFXO0FBQ1ZoRyxxQkFBSztBQURLO0FBUEosU0FGUztBQWFqQixtQkFBVyxNQWJNO0FBY2pCQSxhQUFLLGlGQWRZO0FBZWpCZ0Ysa0JBQVUsQ0FDVCxZQURTLENBZk87QUFrQmpCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQWxCRTtBQWdDakJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBaENLO0FBdUNqQix5QkFBaUI7QUF2Q0EsS0Evc0NDO0FBd3ZDbkIsbUJBQWU7QUFDZHJMLGNBQU0sT0FEUTtBQUVkOEcsYUFBSyw2U0FGUztBQUdkSSxlQUFPLFFBSE87QUFJZEcsZUFBTyxLQUpPO0FBS2RoTSxnQkFBUSxDQUxNO0FBTWQsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQU5HO0FBVWR5USxrQkFBVSxDQUNULFlBRFMsRUFFVDtBQUNDLGlCQUFLO0FBRE4sU0FGUyxDQVZJO0FBZ0JkLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQWhCRDtBQThCZFcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQsU0E5QkU7QUFxQ2QseUJBQWlCO0FBckNILEtBeHZDSTtBQSt4Q25CLDBCQUFzQjtBQUNyQnJMLGNBQU0sU0FEZTtBQUVyQixtQkFBVyxLQUZVO0FBR3JCOEcsYUFBSyw0RkFIZ0I7QUFJckJnRixrQkFBVSxDQUNULFlBRFMsQ0FKVztBQU9yQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FQTTtBQWVyQlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZTO0FBcUJyQix5QkFBaUI7QUFyQkksS0EveENIO0FBc3pDbkIsNkJBQXlCO0FBQ3hCckwsY0FBTSxTQURrQjtBQUV4QixtQkFBVyxLQUZhO0FBR3hCOEcsYUFBSywyRUFIbUI7QUFJeEJnRixrQkFBVSxDQUNULFlBRFMsQ0FKYztBQU94Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FQUztBQWV4Qlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZZO0FBcUJ4Qix5QkFBaUI7QUFyQk8sS0F0ekNOO0FBNjBDbkIscUJBQWlCO0FBQ2hCckwsY0FBTSxTQURVO0FBRWhCLG1CQUFXLEtBRks7QUFHaEI4RyxhQUFLLCtIQUhXO0FBSWhCZ0Ysa0JBQVUsQ0FDVCxZQURTLEVBRVQsWUFGUyxDQUpNO0FBUWhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVJDO0FBZ0JoQlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWhCSTtBQXNCaEIseUJBQWlCO0FBdEJELEtBNzBDRTtBQXEyQ25CekssZ0JBQVk7QUFDWFosY0FBTSxNQURLO0FBRVg2RyxnQkFBUTtBQUNQNUMscUJBQVM7QUFDUjZDLHFCQUFLO0FBREcsYUFERjtBQUlQa0Usa0JBQU07QUFDTGxFLHFCQUFLO0FBREE7QUFKQyxTQUZHO0FBVVgsbUJBQVcsU0FWQTtBQVdYQSxhQUFLLGtDQVhNO0FBWVgsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBWko7QUFvQlgseUJBQWlCO0FBcEJOO0FBcjJDTyxDQUFwQjtBQTQzQ0EsSUFBSXVDLGdCQUFnQjtBQUNuQm5NLGdCQUFZO0FBQ1haLGNBQU0sTUFESztBQUVYNkcsZ0JBQVE7QUFDUDVDLHFCQUFTO0FBQ1I2QyxxQkFBSztBQURHLGFBREY7QUFJUGtFLGtCQUFNO0FBQ0xsRSxxQkFBSztBQURBO0FBSkMsU0FGRztBQVVYLG1CQUFXLFNBVkE7QUFXWEEsYUFBSyxrQ0FYTTtBQVlYLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVpKO0FBb0JYLHlCQUFpQjtBQXBCTjtBQURPLENBQXBCO0FBd0JBLElBQUl3QyxtQkFBbUI7QUFDdEJwTSxnQkFBWTtBQUNYWixjQUFNLE1BREs7QUFFWDZHLGdCQUFRO0FBQ1A1QyxxQkFBUztBQUNSNkMscUJBQUs7QUFERyxhQURGO0FBSVBrRSxrQkFBTTtBQUNMbEUscUJBQUs7QUFEQTtBQUpDLFNBRkc7QUFVWCxtQkFBVyxTQVZBO0FBV1hBLGFBQUssa0NBWE07QUFZWCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FaSjtBQW9CWCx5QkFBaUI7QUFwQk47QUFEVSxDQUF2QjtBQXdCQSxJQUFJaEIsU0FBUztBQUNaeEosVUFBTSxPQURNO0FBRVprSCxXQUFPLEdBRks7QUFHWkosU0FBSztBQUhPLENBQWI7QUFLQSxJQUFJbUcsZ0JBQWdCO0FBQ25Cak4sVUFBTSxTQURhO0FBRW5COEcsU0FBSywrT0FGYztBQUduQixlQUFXLEtBSFE7QUFJbkJnQixnQkFBWSxLQUpPO0FBS25CLHFCQUFpQixhQUxFO0FBTW5CcUQsZ0JBQVk7QUFDWEMsc0JBQWMsS0FESDtBQUVYQyxvQkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsT0FIVyxFQUlYLHNCQUpXO0FBRkQ7QUFOTyxDQUFwQjtBQWdCQSxJQUFJNkIsY0FBYztBQUNqQmxOLFVBQU0sU0FEVztBQUVqQjhHLFNBQUssZ1FBRlk7QUFHakIsZUFBVyxLQUhNO0FBSWpCZ0IsZ0JBQVksS0FKSztBQUtqQixxQkFBaUIsYUFMQTtBQU1qQnFELGdCQUFZO0FBQ1hDLHNCQUFjLEtBREg7QUFFWEMsb0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZEO0FBTkssQ0FBbEI7QUFjQSxJQUFJOEIsY0FBYztBQUNqQm5OLFVBQU0sU0FEVztBQUVqQjhHLFNBQUssOFFBRlk7QUFHakIsZUFBVyxLQUhNO0FBSWpCZ0IsZ0JBQVksS0FKSztBQUtqQixxQkFBaUIsYUFMQTtBQU1qQnFELGdCQUFZO0FBQ1hDLHNCQUFjLEtBREg7QUFFWEMsb0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZEO0FBTkssQ0FBbEI7QUFjQSxJQUFJK0IsZ0JBQWdCO0FBQ25CcE4sVUFBTSxTQURhO0FBRW5COEcsU0FBSyxpUUFGYztBQUduQixlQUFXLEtBSFE7QUFJbkJnQixnQkFBWSxLQUpPO0FBS25CLHFCQUFpQixhQUxFO0FBTW5CcUQsZ0JBQVk7QUFDWEMsc0JBQWMsS0FESDtBQUVYQyxvQkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXO0FBRkQ7QUFOTyxDQUFwQjtBQWNBLElBQUlnQyxpQkFBaUI7QUFDcEJyTixVQUFNLFNBRGM7QUFFcEI4RyxTQUFLLDBRQUZlO0FBR3BCLGVBQVcsS0FIUztBQUlwQmdCLGdCQUFZLEtBSlE7QUFLcEIscUJBQWlCLGFBTEc7QUFNcEJxRCxnQkFBWTtBQUNYQyxzQkFBYyxLQURIO0FBRVhDLG9CQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRDtBQU5RLENBQXJCO0FBY0EsSUFBSWlDLGtCQUFrQjtBQUNyQnROLFVBQU0sTUFEZTtBQUVyQjZHLFlBQVE7QUFDUCxjQUFNO0FBQ0xDLGlCQUFLO0FBREEsU0FEQztBQUlQLGNBQU07QUFDTEEsaUJBQUs7QUFEQSxTQUpDO0FBT1AsYUFBSztBQUNKQSxpQkFBSztBQURELFNBUEU7QUFVUCxjQUFNO0FBQ0xBLGlCQUFLO0FBREEsU0FWQztBQWFQLGFBQUs7QUFDSkEsaUJBQUs7QUFERCxTQWJFO0FBZ0JQLGNBQU07QUFDTEEsaUJBQUs7QUFEQSxTQWhCQztBQW1CUCxjQUFNO0FBQ0xBLGlCQUFLO0FBREEsU0FuQkM7QUFzQlAsZUFBTztBQUNOQSxpQkFBSztBQURDLFNBdEJBO0FBeUJQeUcsYUFBSztBQUNKekcsaUJBQUs7QUFERCxTQXpCRTtBQTRCUDBHLGFBQUs7QUFDSjFHLGlCQUFLO0FBREQsU0E1QkU7QUErQlBrRSxjQUFNO0FBQ0xsRSxpQkFBSztBQURBLFNBL0JDO0FBa0NQMkcsYUFBSztBQUNKM0csaUJBQUs7QUFERCxTQWxDRTtBQXFDUCxnQkFBUTtBQUNQQSxpQkFBSztBQURFLFNBckNEO0FBd0NQNEcsZ0JBQVE7QUFDUDVHLGlCQUFLO0FBREU7QUF4Q0QsS0FGYTtBQThDckJBLFNBQUs7QUE5Q2dCLENBQXRCO0FBZ0RBLElBQUk2RyxnQkFBZ0I7QUFDbkIzTixVQUFNLE1BRGE7QUFFbkI2RyxZQUFRO0FBQ1ArRyxlQUFPO0FBQ045RyxpQkFBSztBQURDLFNBREE7QUFJUCtHLG9CQUFZO0FBQ1gvRyxpQkFBSztBQURNLFNBSkw7QUFPUGdILGlCQUFTO0FBQ1JoSCxpQkFBSztBQURHO0FBUEYsS0FGVztBQWFuQkEsU0FBSztBQWJjLENBQXBCO0FBZUEsSUFBSWlILGdCQUFnQjtBQUNuQi9OLFVBQU0sT0FEYTtBQUVuQnVKLGFBQVMsQ0FGVTtBQUduQkQsYUFBUyxFQUhVO0FBSW5CcEMsV0FBTyxDQUNOLFFBRE0sRUFFTixPQUZNLENBSlk7QUFRbkI3TCxZQUFRLENBUlc7QUFTbkJ5TCxTQUFLO0FBVGMsQ0FBcEI7QUFXQSxJQUFJcUUsYUFBYTtBQUNoQm5MLFVBQU0sT0FEVTtBQUVoQmtILFdBQU8sR0FGUztBQUdoQnFDLGFBQVMsQ0FITztBQUloQnpDLFNBQUs7QUFKVyxDQUFqQjtBQU1BLElBQUlrSCxrQkFBa0I7QUFDckJsSCxTQUFLLEVBRGdCO0FBRXJCOUcsVUFBTSxNQUZlO0FBR3JCNkcsWUFBUTtBQUNQLGVBQU87QUFDTkMsaUJBQUssaUlBREM7QUFFTm1ILG1CQUFPLGtCQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFQsU0FEQTtBQWFQLGVBQU87QUFDTjFELGlCQUFLLDBDQURDO0FBRU5tSCxtQkFBTyxrQkFGRDtBQUdOLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhULFNBYkE7QUF5QlAwRCxpQkFBUztBQUNScEgsaUJBQUssMkNBREc7QUFFUm1ILG1CQUFPLE9BRkM7QUFHUiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIUCxTQXpCRjtBQXFDUDJELGVBQU87QUFDTnJILGlCQUFLLHVPQURDO0FBRU5tSCxtQkFBTyxPQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFQsU0FyQ0E7QUFpRFA0RCxZQUFJO0FBQ0h0SCxpQkFBSyxrQ0FERjtBQUVIbUgsbUJBQU8sUUFGSjtBQUdILDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhaLFNBakRHO0FBNkRQLGNBQU07QUFDTDFELGlCQUFLLGtUQURBO0FBRUxtSCxtQkFBTyxRQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxPQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0E3REM7QUF5RVAsb0JBQVk7QUFDWDFELGlCQUFLLCtNQURNO0FBRVhtSCxtQkFBTyxRQUZJO0FBR1gsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSTtBQURrQjtBQURUO0FBSEosU0F6RUw7QUFrRlBwRSxlQUFPO0FBQ05XLGlCQUFLLHVOQURDO0FBRU5tSCxtQkFBTyxRQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSTtBQURrQjtBQURUO0FBSFQsU0FsRkE7QUEyRlAsZ0JBQVE7QUFDUHpELGlCQUFLLGlIQURFO0FBRVBtSCxtQkFBTyxVQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFIsU0EzRkQ7QUF1R1BuTixlQUFPO0FBQ055SixpQkFBSyxnbkJBREM7QUFFTm1ILG1CQUFPLFVBRkQ7QUFHTiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIVCxTQXZHQTtBQW1IUDZELGtCQUFVO0FBQ1R2SCxpQkFBSyx5UEFESTtBQUVUbUgsbUJBQU8sVUFGRTtBQUdULDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhOLFNBbkhIO0FBK0hQOEQsY0FBTTtBQUNMeEgsaUJBQUssdVpBREE7QUFFTG1ILG1CQUFPLHVCQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0EvSEM7QUEySVArRCxxQkFBYTtBQUNaekgsaUJBQUssdTNCQURPO0FBRVptSCxtQkFBTyx1QkFGSztBQUdaLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhILFNBM0lOO0FBdUpQLDJCQUFtQjtBQUNsQjFELGlCQUFLLHVQQURhO0FBRWxCbUgsbUJBQU8sdUJBRlc7QUFHbEIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSTtBQURrQjtBQURUO0FBSEcsU0F2Slo7QUFnS1AsMkJBQW1CO0FBQ2xCekQsaUJBQUsseU9BRGE7QUFFbEJtSCxtQkFBTyx1QkFGVztBQUdsQiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJO0FBRGtCO0FBRFQ7QUFIRyxTQWhLWjtBQXlLUGlFLGFBQUs7QUFDSjFILGlCQUFLLHNDQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0F6S0U7QUFxTFBpRSxZQUFJO0FBQ0gzSCxpQkFBSyx1Q0FERjtBQUVIbUgsbUJBQU8sTUFGSjtBQUdILDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhaLFNBckxHO0FBaU1QNUssV0FBRztBQUNGa0gsaUJBQUssc0NBREg7QUFFRm1ILG1CQUFPLE1BRkw7QUFHRiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIYixTQWpNSTtBQTZNUCxrQkFBVTtBQUNUMUQsaUJBQUssMERBREk7QUFFVG1ILG1CQUFPLE9BRkU7QUFHVCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFITixTQTdNSDtBQXlOUGtFLGdCQUFRO0FBQ1A1SCxpQkFBSyxzTUFERTtBQUVQbUgsbUJBQU8sT0FGQTtBQUdQLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBek5EO0FBcU9QbUUsZ0JBQVE7QUFDUDdILGlCQUFLLHNNQURFO0FBRVBtSCxtQkFBTyxPQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFIsU0FyT0Q7QUFpUFBvRSxpQkFBUztBQUNSOUgsaUJBQUsseU1BREc7QUFFUm1ILG1CQUFPLE9BRkM7QUFHUiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIUCxTQWpQRjtBQTZQUHFFLGdCQUFRO0FBQ1AvSCxpQkFBSyx3TUFERTtBQUVQbUgsbUJBQU8sT0FGQTtBQUdQLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBN1BEO0FBeVFQc0Usa0JBQVU7QUFDVGhJLGlCQUFLLDRiQURJO0FBRVRtSCxtQkFBTyxPQUZFO0FBR1QsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSE4sU0F6UUg7QUFxUlAxRyxnQkFBUTtBQUNQZ0QsaUJBQUssMmlCQURFO0FBRVBtSCxtQkFBTyxPQUZBO0FBR1AsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZSxpQkFEVDtBQU9kLDZCQUFhO0FBQ1pELHdCQUFJLFFBRFE7QUFFWjVCLDZCQUFTLE9BRkc7QUFHWkMseUJBQUssT0FITztBQUlaNEIsMkJBQU87QUFKSyxpQkFQQztBQWFkLDhCQUFjO0FBQ2JELHdCQUFJLFFBRFM7QUFFYjVCLDZCQUFTLE9BRkk7QUFHYkMseUJBQUssT0FIUTtBQUliNEIsMkJBQU87QUFKTSxpQkFiQTtBQW1CZCw4QkFBYztBQUNiRCx3QkFBSSxPQURTO0FBRWI1Qiw2QkFBUyxPQUZJO0FBR2JDLHlCQUFLLFFBSFE7QUFJYjRCLDJCQUFPO0FBSk0saUJBbkJBO0FBeUJkSCx1QkFBTztBQUNORSx3QkFBSSxPQURFO0FBRU41Qiw2QkFBUyxPQUZIO0FBR05DLHlCQUFLLE9BSEM7QUFJTjRCLDJCQUFPO0FBSkQ7QUF6Qk87QUFIUixTQXJSRDtBQXlUUEgsZUFBTztBQUNOdkQsaUJBQUssbWhCQURDO0FBRU5tSCxtQkFBTyxPQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxPQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFQsU0F6VEE7QUFxVVAseUJBQWlCO0FBQ2hCMUQsaUJBQUssa2FBRFc7QUFFaEJtSCxtQkFBTyxPQUZTO0FBR2hCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhDLFNBclVWO0FBaVZQLHFCQUFhO0FBQ1oxRCxpQkFBSyx5MkJBRE87QUFFWm1ILG1CQUFPLE9BRks7QUFHWiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFISCxTQWpWTjtBQTZWUCxxQkFBYTtBQUNaMUQsaUJBQUsseWpCQURPO0FBRVptSCxtQkFBTyxPQUZLO0FBR1osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSEgsU0E3Vk47QUF5V1Asc0JBQWM7QUFDYjFELGlCQUFLLHdKQURRO0FBRWJtSCxtQkFBTyxPQUZNO0FBR2IsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSEYsU0F6V1A7QUFxWFAsbUJBQVc7QUFDVjFELGlCQUFLLGtIQURLO0FBRVZtSCxtQkFBTyxPQUZHO0FBR1YsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSEwsU0FyWEo7QUFpWVAsb0JBQVk7QUFDWDFELGlCQUFLLDZOQURNO0FBRVhtSCxtQkFBTyxPQUZJO0FBR1gsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSEosU0FqWUw7QUE2WVB1RSxhQUFLO0FBQ0pqSSxpQkFBSyw0TEFERDtBQUVKbUgsbUJBQU8sT0FGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBN1lFO0FBeVpQd0UsY0FBTTtBQUNMbEksaUJBQUssb05BREE7QUFFTG1ILG1CQUFPLE9BRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIVixTQXpaQztBQXFhUC9ELGFBQUs7QUFDSkssaUJBQUssaUxBREQ7QUFFSm1ILG1CQUFPLFFBRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIWCxTQXJhRTtBQWliUGlELGFBQUs7QUFDSjNHLGlCQUFLLDJJQUREO0FBRUptSCxtQkFBTyxRQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0FqYkU7QUE2YlBuUCxnQkFBUTtBQUNQeUwsaUJBQUssMkNBREU7QUFFUG1ILG1CQUFPLFFBRkE7QUFHUCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIUixTQTdiRDtBQXljUHlFLG9CQUFZO0FBQ1huSSxpQkFBSywySUFETTtBQUVYbUgsbUJBQU8sY0FGSTtBQUdYLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhKLFNBemNMO0FBcWRQLHlCQUFpQjtBQUNoQjFELGlCQUFLLCtkQURXO0FBRWhCbUgsbUJBQU8sY0FGUztBQUdoQiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJO0FBRGtCO0FBRFQ7QUFIQyxTQXJkVjtBQThkUCx5QkFBaUI7QUFDaEJ6RCxpQkFBSyxxUEFEVztBQUVoQm1ILG1CQUFPLGNBRlM7QUFHaEIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSEMsU0E5ZFY7QUEwZVA3SyxZQUFJO0FBQ0htSCxpQkFBSywwQ0FERjtBQUVIbUgsbUJBQU8sY0FGSjtBQUdILDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhaLFNBMWVHO0FBc2ZQbkssY0FBTTtBQUNMeUcsaUJBQUssaUxBREE7QUFFTG1ILG1CQUFPLFFBRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIVixTQXRmQztBQWtnQlBsRCxlQUFPO0FBQ05SLGlCQUFLLHVIQURDO0FBRU5tSCxtQkFBTyxRQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSTtBQURrQjtBQURUO0FBSFQsU0FsZ0JBO0FBMmdCUCxnQ0FBd0I7QUFDdkJ6RCxpQkFBSywyaEJBRGtCO0FBRXZCbUgsbUJBQU8sUUFGZ0I7QUFHdkIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSTtBQURrQjtBQURUO0FBSFEsU0EzZ0JqQjtBQW9oQlAsMkJBQW1CO0FBQ2xCekQsaUJBQUssbU5BRGE7QUFFbEJtSCxtQkFBTyxTQUZXO0FBR2xCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhHLFNBcGhCWjtBQWdpQlAseUJBQWlCO0FBQ2hCMUQsaUJBQUssK0ZBRFc7QUFFaEJtSCxtQkFBTyxjQUZTO0FBR2hCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhDLFNBaGlCVjtBQTRpQlAsK0JBQXVCO0FBQ3RCMUQsaUJBQUsscU1BRGlCO0FBRXRCbUgsbUJBQU8sS0FGZTtBQUd0QiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLE9BRGtCO0FBRXRCM0IseUJBQUssUUFGaUI7QUFHdEJELDZCQUFTO0FBSGE7QUFEVDtBQUhPLFNBNWlCaEI7QUF1akJQdUcscUJBQWE7QUFDWnBJLGlCQUFLLCtJQURPO0FBRVptSCxtQkFBTyxjQUZLO0FBR1osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSEgsU0F2akJOO0FBbWtCUCxhQUFLO0FBQ0oxRCxpQkFBSyxnQ0FERDtBQUVKbUgsbUJBQU8sTUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBbmtCRTtBQStrQlAsYUFBSztBQUNKMUQsaUJBQUssb0NBREQ7QUFFSm1ILG1CQUFPLE1BRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIWCxTQS9rQkU7QUEybEJQLGFBQUs7QUFDSjFELGlCQUFLLHFKQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0EzbEJFO0FBdW1CUCxhQUFLO0FBQ0oxRCxpQkFBSyxpRkFERDtBQUVKbUgsbUJBQU8sTUFGSDtBQUdKLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhYLFNBdm1CRTtBQW1uQlAsYUFBSztBQUNKMUQsaUJBQUssZ0ZBREQ7QUFFSm1ILG1CQUFPLE1BRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIWCxTQW5uQkU7QUErbkJQLGFBQUs7QUFDSjFELGlCQUFLLHFGQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0EvbkJFO0FBMm9CUDJFLGNBQU07QUFDTHJJLGlCQUFLLHVDQURBO0FBRUxtSCxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0Ezb0JDO0FBdXBCUDRFLGVBQU87QUFDTnRJLGlCQUFLLDhDQURDO0FBRU5tSCxtQkFBTyxNQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFQsU0F2cEJBO0FBbXFCUDZFLFlBQUk7QUFDSHZJLGlCQUFLLDZDQURGO0FBRUhtSCxtQkFBTyxNQUZKO0FBR0gsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFosU0FucUJHO0FBK3FCUDhFLGNBQU07QUFDTHhJLGlCQUFLLDhDQURBO0FBRUxtSCxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0EvcUJDO0FBMnJCUCtFLGFBQUs7QUFDSnpJLGlCQUFLLGdDQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0EzckJFO0FBdXNCUGdGLGFBQUs7QUFDSjFJLGlCQUFLLGtDQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0F2c0JFO0FBbXRCUGlGLGFBQUs7QUFDSjNJLGlCQUFLLG1DQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0FudEJFO0FBK3RCUGtGLGNBQU07QUFDTDVJLGlCQUFLLG1DQURBO0FBRUxtSCxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0EvdEJDO0FBMnVCUG1GLGNBQU07QUFDTDdJLGlCQUFLLHFDQURBO0FBRUxtSCxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0EzdUJDO0FBdXZCUG9GLGNBQU07QUFDTDlJLGlCQUFLLHNDQURBO0FBRUxtSCxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0F2dkJDO0FBbXdCUHFGLGFBQUs7QUFDSi9JLGlCQUFLLDBDQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0Fud0JFO0FBK3dCUHNGLGFBQUs7QUFDSmhKLGlCQUFLLDBDQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0Evd0JFO0FBMnhCUGtCLGVBQU87QUFDTjVFLGlCQUFLLHVJQURDO0FBRU5tSCxtQkFBTyxNQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFQsU0EzeEJBO0FBdXlCUHVGLGFBQUs7QUFDSmpKLGlCQUFLLDBDQUREO0FBRUptSCxtQkFBTyxNQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0F2eUJFO0FBbXpCUHdGLGNBQU07QUFDTGxKLGlCQUFLLDBFQURBO0FBRUxtSCxtQkFBTyxNQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFYsU0FuekJDO0FBK3pCUHlGLGVBQU87QUFDTm5KLGlCQUFLLHNFQURDO0FBRU5tSCxtQkFBTyxNQUZEO0FBR04sMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFQsU0EvekJBO0FBMjBCUDBGLGtCQUFVO0FBQ1RwSixpQkFBSyx3WUFESTtBQUVUbUgsbUJBQU8sTUFGRTtBQUdULDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCdEYsNkJBQVMsT0FEYTtBQUV0QkMseUJBQUssT0FGaUI7QUFHdEI0QiwyQkFBTztBQUhlO0FBRFQ7QUFITixTQTMwQkg7QUFzMUJQLGNBQU07QUFDTDFELGlCQUFLLGtYQURBO0FBRUxtSCxtQkFBTyxVQUZGO0FBR0wsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZSxpQkFEVDtBQU9kc0UsMEJBQVU7QUFDVHZFLHdCQUFJLFFBREs7QUFFVDVCLDZCQUFTLE9BRkE7QUFHVEMseUJBQUssT0FISTtBQUlUNEIsMkJBQU87QUFKRTtBQVBJO0FBSFYsU0F0MUJDO0FBdzJCUCxjQUFNO0FBQ0wxRCxpQkFBSyxzWEFEQTtBQUVMbUgsbUJBQU8sVUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmUsaUJBRFQ7QUFPZHNFLDBCQUFVO0FBQ1R2RSx3QkFBSSxRQURLO0FBRVQ1Qiw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVDRCLDJCQUFPO0FBSkU7QUFQSTtBQUhWLFNBeDJCQztBQTAzQlAsYUFBSztBQUNKMUQsaUJBQUssNGJBREQ7QUFFSm1ILG1CQUFPLFVBRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplLGlCQURUO0FBT2RzRSwwQkFBVTtBQUNUdkUsd0JBQUksUUFESztBQUVUNUIsNkJBQVMsT0FGQTtBQUdUQyx5QkFBSyxPQUhJO0FBSVQ0QiwyQkFBTztBQUpFO0FBUEk7QUFIWCxTQTEzQkU7QUE0NEJQLGFBQUs7QUFDSjFELGlCQUFLLHliQUREO0FBRUptSCxtQkFBTyxVQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZSxpQkFEVDtBQU9kc0UsMEJBQVU7QUFDVHZFLHdCQUFJLFFBREs7QUFFVDVCLDZCQUFTLE9BRkE7QUFHVEMseUJBQUssT0FISTtBQUlUNEIsMkJBQU87QUFKRTtBQVBJO0FBSFgsU0E1NEJFO0FBODVCUCxjQUFNO0FBQ0wxRCxpQkFBSywrYkFEQTtBQUVMbUgsbUJBQU8sVUFGRjtBQUdMLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmUsaUJBRFQ7QUFPZHNFLDBCQUFVO0FBQ1R2RSx3QkFBSSxRQURLO0FBRVQ1Qiw2QkFBUyxPQUZBO0FBR1RDLHlCQUFLLE9BSEk7QUFJVDRCLDJCQUFPO0FBSkU7QUFQSTtBQUhWLFNBOTVCQztBQWc3QlAsY0FBTTtBQUNMMUQsaUJBQUssNGJBREE7QUFFTG1ILG1CQUFPLFVBRkY7QUFHTCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplLGlCQURUO0FBT2RzRSwwQkFBVTtBQUNUdkUsd0JBQUksUUFESztBQUVUNUIsNkJBQVMsT0FGQTtBQUdUQyx5QkFBSyxPQUhJO0FBSVQ0QiwyQkFBTztBQUpFO0FBUEk7QUFIVixTQWg3QkM7QUFrOEJQK0MsYUFBSztBQUNKekcsaUJBQUssNlBBREQ7QUFFSm1ILG1CQUFPLFVBRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIWCxTQWw4QkU7QUE4OEJQZ0QsYUFBSztBQUNKMUcsaUJBQUssOFBBREQ7QUFFSm1ILG1CQUFPLFVBRkg7QUFHSiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIWCxTQTk4QkU7QUEwOUJQLGFBQUs7QUFDSjFELGlCQUFLLCtGQUREO0FBRUptSCxtQkFBTyxVQUZIO0FBR0osMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSFgsU0ExOUJFO0FBcytCUGtELGdCQUFRO0FBQ1A1RyxpQkFBSywrZkFERTtBQUVQbUgsbUJBQU8sVUFGQTtBQUdQLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksT0FEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBdCtCRDtBQWsvQlAsK0JBQXVCO0FBQ3RCMUQsaUJBQUssMFVBRGlCO0FBRXRCbUgsbUJBQU8sUUFGZTtBQUd0QiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVM7QUFGYTtBQURUO0FBSE8sU0FsL0JoQjtBQTQvQlB3SCxnQkFBUTtBQUNQckosaUJBQUssb0xBREU7QUFFUG1ILG1CQUFPLFFBRkE7QUFHUCwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QjFELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQ7QUFIUixTQTUvQkQ7QUF3Z0NQNEYsa0JBQVU7QUFDVHRKLGlCQUFLLG9MQURJO0FBRVRtSCxtQkFBTyxRQUZFO0FBR1QsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEIxRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURUO0FBSE4sU0F4Z0NIO0FBb2hDUDZGLGdCQUFRO0FBQ1B2SixpQkFBSyw2SEFERTtBQUVQbUgsbUJBQU8sUUFGQTtBQUdQLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhSLFNBcGhDRDtBQWdpQ1AsMkJBQW1CO0FBQ2xCMUQsaUJBQUssNE1BRGE7QUFFbEJtSCxtQkFBTyxRQUZXO0FBR2xCLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCMUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVDtBQUhHO0FBaGlDWjtBQUhhLENBQXRCO0FBaWpDQSxJQUFJNUMsTUFBTTtBQUNUMEksV0FBTztBQUNOdFEsY0FBTSxPQURBO0FBRU4sbUJBQVcsQ0FDVixHQURVLEVBRVYsRUFGVSxDQUZMO0FBTU51SixpQkFBUyxDQUFDLEVBTko7QUFPTkQsaUJBQVMsRUFQSDtBQVFOak8sZ0JBQVEsQ0FSRjtBQVNONkwsZUFBTyxRQVREO0FBVU4seUJBQWlCLGVBVlg7QUFXTlksb0JBQVksSUFYTjtBQVlOcUQsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQVpOO0FBa0JOdkUsYUFBSyxrUUFsQkM7QUFtQk5DLGlCQUFTLENBQ1IsR0FEUSxFQUVSLEVBRlEsQ0FuQkg7QUF1Qk4sdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ3RCxvQkFBSTtBQURrQjtBQURUO0FBdkJULEtBREU7QUE4QlQ5QyxXQUFPO0FBQ056SCxjQUFNLE9BREE7QUFFTix5QkFBaUIsZUFGWDtBQUdOLG1CQUFXLFNBSEw7QUFJTm1MLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FKTjtBQVVOdkQsb0JBQVksSUFWTjtBQVdOaEIsYUFBSywwS0FYQztBQVlOLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUk7QUFEa0I7QUFEVDtBQVpULEtBOUJFO0FBZ0RULHFCQUFpQjtBQUNoQnZLLGNBQU0sUUFEVTtBQUVoQix5QkFBaUIsZUFGRDtBQUdoQixtQkFBVyxHQUhLO0FBSWhCdUosaUJBQVMsQ0FKTztBQUtoQkQsaUJBQVMsQ0FMTztBQU1oQjZCLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FOSTtBQVloQnZELG9CQUFZLElBWkk7QUFhaEJoQixhQUFLLDBPQWJXO0FBY2hCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUk7QUFEa0I7QUFEVDtBQWRDO0FBaERSLENBQVY7QUFxRUEsSUFBSWhELFFBQVE7QUFDWEMsWUFBUTtBQUNQeEgsY0FBTSxNQURDO0FBRVAsbUJBQVcsVUFGSjtBQUdQNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUG9GLHNCQUFVO0FBQ1RwRixxQkFBSztBQURJO0FBSkgsU0FIRDtBQVdQLHlCQUFpQixlQVhWO0FBWVBnQixvQkFBWSxLQVpMO0FBYVBxRCxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBYkw7QUFtQlB2RSxhQUFLLHNFQW5CRTtBQW9CUEMsaUJBQVMsS0FwQkY7QUFxQlAsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ3RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURUO0FBckJSLEtBREc7QUErQlgrRixjQUFVO0FBQ1R2USxjQUFNLE9BREc7QUFFVCxtQkFBVyxDQUNWLElBRFUsRUFFVixHQUZVLEVBR1YsRUFIVSxDQUZGO0FBT1QzRSxnQkFBUSxDQVBDO0FBUVQ2TCxlQUFPLFFBUkU7QUFTVCx5QkFBaUIsZUFUUjtBQVVUWSxvQkFBWSxJQVZIO0FBV1RxRCxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBWEg7QUFpQlR2RSxhQUFLLGdpQkFqQkk7QUFrQlRDLGlCQUFTLENBQ1IsR0FEUSxFQUVSLEVBRlEsRUFHUixFQUhRLENBbEJBO0FBdUJULHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCd0Qsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVDtBQXZCTixLQS9CQztBQStEWC9DLFdBQU87QUFDTnpILGNBQU0sT0FEQTtBQUVOLHlCQUFpQixlQUZYO0FBR04sbUJBQVcsU0FITDtBQUlObUwsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQUpOO0FBVU52RCxvQkFBWSxJQVZOO0FBV05oQixhQUFLLDhDQVhDO0FBWU4sdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURUO0FBWlQsS0EvREk7QUFvRlg5QyxlQUFXO0FBQ1YxSCxjQUFNLFFBREk7QUFFVix5QkFBaUIsZUFGUDtBQUdWLG1CQUFXLEdBSEQ7QUFJVnVKLGlCQUFTLENBSkM7QUFLVkQsaUJBQVMsQ0FMQztBQU1WNkIsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQU5GO0FBWVZ2RCxvQkFBWSxJQVpGO0FBYVZoQixhQUFLLHVHQWJLO0FBY1YsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURUO0FBZEw7QUFwRkEsQ0FBWjtBQTRHQSxJQUFJdkMsYUFBYTtBQUNoQmpCLFVBQU07QUFDTGhILGNBQU0sTUFERDtBQUVMNkcsZ0JBQVE7QUFDUDJKLG9CQUFRO0FBQ1AxSixxQkFBSztBQURFLGFBREQ7QUFJUDJKLHdCQUFZO0FBQ1gzSixxQkFBSztBQURNLGFBSkw7QUFPUDRKLDZCQUFpQjtBQUNoQjVKLHFCQUFLO0FBRFcsYUFQVjtBQVVQNkosbUNBQXVCO0FBQ3RCN0oscUJBQUs7QUFEaUIsYUFWaEI7QUFhUDhKLHNCQUFVO0FBQ1Q5SixxQkFBSztBQURJLGFBYkg7QUFnQlArSiwwQkFBYztBQUNiL0oscUJBQUs7QUFEUSxhQWhCUDtBQW1CUGdLLDBCQUFjO0FBQ2JoSyxxQkFBSztBQURRO0FBbkJQLFNBRkg7QUF5QkwsbUJBQVcsVUF6Qk47QUEwQkxBLGFBQUssOERBMUJBO0FBMkJMRixrQkFBVSxJQTNCTDtBQTRCTCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QjJELG9CQUFJO0FBRGtCO0FBRFQ7QUE1QlYsS0FEVTtBQW1DaEI1SSxZQUFRO0FBQ1AzQixjQUFNLE9BREM7QUFFUDNFLGdCQUFRLENBRkQ7QUFHUDZMLGVBQU8sUUFIQTtBQUlQLHlCQUFpQixlQUpWO0FBS1BZLG9CQUFZLEtBTEw7QUFNUGhCLGFBQUssNk9BTkU7QUFPUEMsaUJBQVMsQ0FDUixDQUFDLEVBRE8sRUFFUixJQUZRLENBUEY7QUFXUCtFLGtCQUFVLENBQ1Q7QUFDQzlFLGtCQUFNLENBQ0wsUUFESyxFQUVMLHVCQUZLO0FBRFAsU0FEUyxDQVhIO0FBbUJQLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdUQsb0JBQUk7QUFEa0I7QUFEVDtBQW5CUixLQW5DUTtBQTREaEJyQyxlQUFXO0FBQ1ZsSSxjQUFNLE9BREk7QUFFVjNFLGdCQUFRLENBRkU7QUFHVjZMLGVBQU8sUUFIRztBQUlWLHlCQUFpQixlQUpQO0FBS1ZZLG9CQUFZLEtBTEY7QUFNVmhCLGFBQUssbVBBTks7QUFPVkMsaUJBQVMsQ0FDUixJQURRLEVBRVIsSUFGUSxDQVBDO0FBV1YrRSxrQkFBVSxDQUNUO0FBQ0M5RSxrQkFBTSxDQUNMLFFBREssRUFFTCx1QkFGSztBQURQLFNBRFMsQ0FYQTtBQW1CVix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnVELG9CQUFJO0FBRGtCO0FBRFQ7QUFuQkw7QUE1REssQ0FBakI7QUFzRkEsSUFBSTVDLFVBQVU7QUFDYnBLLFlBQVE7QUFDUHlDLGNBQU0sUUFEQztBQUVQOEcsYUFBSyx5RUFGRTtBQUdQRixrQkFBVSxJQUhIO0FBSVAsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEIyRCxvQkFBSSxPQURrQjtBQUV0QjNCLHFCQUFLLFFBRmlCO0FBR3RCRCx5QkFBUztBQUhhO0FBRFQ7QUFKUixLQURLO0FBYWJvSSxrQkFBYztBQUNiL1EsY0FBTSxRQURPO0FBRWIseUJBQWlCLGVBRko7QUFHYixtQkFBVyxDQUhFO0FBSWJ1SixpQkFBUyxDQUpJO0FBS2JELGlCQUFTLElBTEk7QUFNYjZCLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FOQztBQVlidkQsb0JBQVksSUFaQztBQWFiaEIsYUFBSyxnR0FiUTtBQWNiLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksT0FEa0I7QUFFdEIzQixxQkFBSyxRQUZpQjtBQUd0QkQseUJBQVM7QUFIYTtBQURUO0FBZEY7QUFiRCxDQUFkO0FBb0NBLElBQUl2SSxRQUFRLENBQ1gsWUFEVyxFQUVYLFlBRlcsRUFHWCxjQUhXLEVBSVgsZUFKVyxFQUtYLHNCQUxXLEVBTVgsY0FOVyxFQU9YLGNBUFcsRUFRWCxpQkFSVyxFQVNYLGtCQVRXLEVBVVgsV0FWVyxDQUFaO0FBWUEsSUFBSTRRLGFBQWE7QUFDaEIsc0JBQWtCO0FBQ2pCaFIsY0FBTSxTQURXO0FBRWpCLG1CQUFXLElBRk07QUFHakI4RyxhQUFLLGdEQUhZO0FBSWpCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQUpFO0FBWWpCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBWks7QUFrQmpCLHlCQUFpQjtBQWxCQSxLQURGO0FBcUJoQixvQkFBZ0I7QUFDZnJMLGNBQU0sUUFEUztBQUVmLG1CQUFXLENBRkk7QUFHZnVKLGlCQUFTLENBSE07QUFJZkQsaUJBQVMsQ0FKTTtBQUtmeEMsYUFBSywySkFMVTtBQU1mZ0Isb0JBQVksSUFORztBQU9mLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVBBO0FBcUJmVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQkc7QUE2QmYseUJBQWlCO0FBN0JGLEtBckJBO0FBb0RoQixrQkFBYztBQUNickwsY0FBTSxPQURPO0FBRWIsbUJBQVcsU0FGRTtBQUdiOEcsYUFBSyxpTUFIUTtBQUliZ0Isb0JBQVksSUFKQztBQUtiZ0Usa0JBQVUsQ0FDVDtBQUNDLGlCQUFLO0FBRE4sU0FEUyxDQUxHO0FBVWIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBVkY7QUF3QmJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXhCQztBQWdDYix5QkFBaUI7QUFoQ0osS0FwREU7QUFzRmhCLDBCQUFzQjtBQUNyQnJMLGNBQU0sT0FEZTtBQUVyQjhHLGFBQUssa0ZBRmdCO0FBR3JCZ0Isb0JBQVksSUFIUztBQUlyQmdFLGtCQUFVLENBQ1Q7QUFDQyxpQkFBSztBQUROLFNBRFMsRUFJVDtBQUNDLDhCQUFrQjtBQURuQixTQUpTLENBSlc7QUFZckIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBWk07QUEwQnJCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0ExQlM7QUFrQ3JCLHlCQUFpQjtBQWxDSSxLQXRGTjtBQTBIaEIsc0JBQWtCO0FBQ2pCckwsY0FBTSxPQURXO0FBRWpCa0gsZUFBTyxRQUZVO0FBR2pCN0wsZ0JBQVEsQ0FIUztBQUlqQixtQkFBVyxDQUNWLENBRFUsRUFFVixDQUZVLENBSk07QUFRakJ5TSxvQkFBWSxJQVJLO0FBU2pCVCxlQUFPLFFBVFU7QUFVakJQLGFBQUssOEZBVlk7QUFXakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBWEU7QUFtQmpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBbkJLO0FBeUJqQix5QkFBaUI7QUF6QkEsS0ExSEY7QUFxSmhCLDZCQUF5QjtBQUN4QnJMLGNBQU0sTUFEa0I7QUFFeEI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREk7QUFKSCxTQUZnQjtBQVV4QkEsYUFBSyx1REFWbUI7QUFXeEIsbUJBQVcsS0FYYTtBQVl4QmdGLGtCQUFVLENBQ1QsZ0JBRFMsQ0FaYztBQWV4Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnZCLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FmUztBQXVCeEJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F2Qlk7QUE2QnhCLHlCQUFpQjtBQTdCTyxLQXJKVDtBQW9MaEIsb0JBQWdCO0FBQ2ZyTCxjQUFNLGVBRFM7QUFFZjhILG9CQUFZLElBRkc7QUFHZmhCLGFBQUssd09BSFU7QUFJZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QjZCLHVCQUFPLFFBSGU7QUFJdEI1QixxQkFBSztBQUppQjtBQVBULFNBSkE7QUFrQmZ1QyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQWxCRztBQXlCZix5QkFBaUI7QUF6QkY7QUFwTEEsQ0FBakI7QUFnTkEsSUFBSTRGLGFBQWE7QUFDaEIsb0JBQWdCO0FBQ2ZqUixjQUFNLFFBRFM7QUFFZjhHLGFBQUssOENBRlU7QUFHZixtQkFBVyxDQUhJO0FBSWZ5QyxpQkFBUyxDQUpNO0FBS2ZELGlCQUFTLENBTE07QUFNZnhCLG9CQUFZLElBTkc7QUFPZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlDLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FQQTtBQXFCZlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBckJHO0FBNkJmLHlCQUFpQjtBQTdCRixLQURBO0FBZ0NoQixrQkFBYztBQUNickwsY0FBTSxPQURPO0FBRWI4RyxhQUFLLDhDQUZRO0FBR2IsbUJBQVcsU0FIRTtBQUliZ0Isb0JBQVksSUFKQztBQUtiZ0Usa0JBQVUsQ0FDVDtBQUNDLGlCQUFLO0FBRE4sU0FEUyxDQUxHO0FBVWIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBVkY7QUF3QmJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXhCQztBQWdDYix5QkFBaUI7QUFoQ0osS0FoQ0U7QUFrRWhCLHNCQUFrQjtBQUNqQnJMLGNBQU0sT0FEVztBQUVqQmtILGVBQU8sUUFGVTtBQUdqQjdMLGdCQUFRLENBSFM7QUFJakIsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQUpNO0FBUWpCeU0sb0JBQVksSUFSSztBQVNqQlQsZUFBTyxRQVRVO0FBVWpCUCxhQUFLLDhGQVZZO0FBV2pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVhFO0FBbUJqQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQW5CSztBQXlCakIseUJBQWlCO0FBekJBLEtBbEVGO0FBNkZoQiw2QkFBeUI7QUFDeEJyTCxjQUFNLE1BRGtCO0FBRXhCNkcsZ0JBQVE7QUFDUG5MLGlCQUFLO0FBQ0pvTCxxQkFBSztBQURELGFBREU7QUFJUG9GLHNCQUFVO0FBQ1RwRixxQkFBSztBQURJO0FBSkgsU0FGZ0I7QUFVeEJBLGFBQUssdURBVm1CO0FBV3hCLG1CQUFXLEtBWGE7QUFZeEJnRixrQkFBVSxDQUNULGdCQURTLENBWmM7QUFleEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBZlM7QUF1QnhCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdkJZO0FBNkJ4Qix5QkFBaUI7QUE3Qk8sS0E3RlQ7QUE0SGhCLGtCQUFjO0FBQ2JyTCxjQUFNLFFBRE87QUFFYixtQkFBVyxDQUZFO0FBR2J1SixpQkFBUyxDQUhJO0FBSWJ6QixvQkFBWSxJQUpDO0FBS2JULGVBQU8sUUFMTTtBQU1iUCxhQUFLLG1CQU5RO0FBT2IsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUEY7QUFxQmJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXJCQztBQTZCYix5QkFBaUI7QUE3QkosS0E1SEU7QUEySmhCLHNCQUFrQjtBQUNqQnJMLGNBQU0sUUFEVztBQUVqQixtQkFBVyxDQUZNO0FBR2pCdUosaUJBQVMsQ0FIUTtBQUlqQnpDLGFBQUssa0dBSlk7QUFLakJnQixvQkFBWSxJQUxLO0FBTWpCVCxlQUFPLFFBTlU7QUFPakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJrRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUEU7QUFxQmpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQks7QUE2QmpCLHlCQUFpQjtBQTdCQSxLQTNKRjtBQTBMaEIsbUJBQWU7QUFDZHJMLGNBQU0sUUFEUTtBQUVkLG1CQUFXLENBRkc7QUFHZDhHLGFBQUsseVFBSFM7QUFJZGdCLG9CQUFZLElBSkU7QUFLZFQsZUFBTyxRQUxPO0FBTWQsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJrRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBTkQ7QUFvQmRXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXBCRTtBQTRCZCx5QkFBaUI7QUE1QkgsS0ExTEM7QUF3TmhCLGlCQUFhO0FBQ1pyTCxjQUFNLFFBRE07QUFFWixtQkFBVyxDQUZDO0FBR1p1SixpQkFBUyxDQUhHO0FBSVp6QixvQkFBWSxJQUpBO0FBS1pULGVBQU8sUUFMSztBQU1aUCxhQUFLLHNDQU5PO0FBT1osdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUEg7QUFxQlpXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXJCQTtBQTZCWix5QkFBaUI7QUE3QkwsS0F4Tkc7QUF1UGhCLHNCQUFrQjtBQUNqQnJMLGNBQU0sT0FEVztBQUVqQmtILGVBQU8sUUFGVTtBQUdqQkosYUFBSyxnYUFIWTtBQUlqQnlDLGlCQUFTLENBSlE7QUFLakJ6QixvQkFBWSxJQUxLO0FBTWpCVCxlQUFPLGFBTlU7QUFPakJ5RSxrQkFBVSxDQUNUO0FBQ0MsaUJBQUs7QUFETixTQURTLENBUE87QUFZakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSTtBQURrQjtBQVBULFNBWkU7QUF1QmpCWSxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlc7QUFGRCxTQXZCSztBQThCakIseUJBQWlCO0FBOUJBLEtBdlBGO0FBdVJoQixvQkFBZ0I7QUFDZnJMLGNBQU0sZUFEUztBQUVmOEgsb0JBQVksSUFGRztBQUdmaEIsYUFBSyw2TkFIVTtBQUlmLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCNkIsdUJBQU8sUUFIZTtBQUl0QjVCLHFCQUFLO0FBSmlCO0FBUFQsU0FKQTtBQWtCZnVDLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELFNBbEJHO0FBeUJmLHlCQUFpQjtBQXpCRixLQXZSQTtBQWtUaEIscUJBQWlCO0FBQ2hCckwsY0FBTSxPQURVO0FBRWhCOEcsYUFBSyxvSUFGVztBQUdoQmdCLG9CQUFZLEtBSEk7QUFJaEJnRSxrQkFBVSxDQUNUO0FBQ0MsaUJBQUs7QUFETixTQURTLEVBSVQ7QUFDQ3ZPLG9CQUFRLFNBRFQ7QUFFQ2tRLGlCQUFLO0FBQ0oxRCw2QkFBYTtBQURUO0FBRk4sU0FKUyxDQUpNO0FBZWhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCUSxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBUFQsU0FmQztBQXlCaEJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxlQURXO0FBRkQsU0F6Qkk7QUErQmhCLHlCQUFpQjtBQS9CRDtBQWxURCxDQUFqQjtBQW9WQSxJQUFJNkYsZUFBZTtBQUNsQixxQkFBaUI7QUFDaEJsUixjQUFNLFFBRFU7QUFFaEIsbUJBQVcsQ0FGSztBQUdoQnVKLGlCQUFTLENBSE87QUFJaEJ6QixvQkFBWSxJQUpJO0FBS2hCVCxlQUFPLFFBTFM7QUFNaEJQLGFBQUssZ0JBTlc7QUFPaEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUEM7QUFxQmhCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQkk7QUE2QmhCLHlCQUFpQjtBQTdCRCxLQURDO0FBZ0NsQixvQkFBZ0I7QUFDZnJMLGNBQU0sT0FEUztBQUVmLG1CQUFXLFNBRkk7QUFHZjhHLGFBQUssK0JBSFU7QUFJZmdCLG9CQUFZLElBSkc7QUFLZix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlDLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FMQTtBQW1CZlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBbkJHO0FBMkJmLHlCQUFpQjtBQTNCRixLQWhDRTtBQTZEbEIsbUJBQWU7QUFDZHJMLGNBQU0sUUFEUTtBQUVkLG1CQUFXLENBRkc7QUFHZDhHLGFBQUssK0ZBSFM7QUFJZGdCLG9CQUFZLElBSkU7QUFLZCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlDLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FMRDtBQW1CZFcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBbkJFO0FBMkJkLHlCQUFpQjtBQTNCSCxLQTdERztBQTBGbEIsc0JBQWtCO0FBQ2pCckwsY0FBTSxRQURXO0FBRWpCOEcsYUFBSyxnREFGWTtBQUdqQixtQkFBVyxDQUhNO0FBSWpCeUMsaUJBQVMsQ0FKUTtBQUtqQkQsaUJBQVMsQ0FMUTtBQU1qQnhCLG9CQUFZLElBTks7QUFPakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUEU7QUFxQmpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQks7QUE2QmpCLHlCQUFpQjtBQTdCQSxLQTFGQTtBQXlIbEIsd0JBQW9CO0FBQ25CckwsY0FBTSxPQURhO0FBRW5Ca0gsZUFBTyxRQUZZO0FBR25CN0wsZ0JBQVEsQ0FIVztBQUluQixtQkFBVyxDQUNWLENBRFUsRUFFVixDQUZVLENBSlE7QUFRbkJ5TSxvQkFBWSxJQVJPO0FBU25CVCxlQUFPLFFBVFk7QUFVbkJQLGFBQUssOEZBVmM7QUFXbkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBWEk7QUFtQm5CVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBbkJPO0FBeUJuQix5QkFBaUI7QUF6QkUsS0F6SEY7QUFvSmxCLCtCQUEyQjtBQUMxQnJMLGNBQU0sTUFEb0I7QUFFMUI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREk7QUFKSCxTQUZrQjtBQVUxQkEsYUFBSyx5REFWcUI7QUFXMUIsbUJBQVcsS0FYZTtBQVkxQmdGLGtCQUFVLENBQ1Qsa0JBRFMsQ0FaZ0I7QUFlMUIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBZlc7QUF1QjFCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdkJjO0FBNkIxQix5QkFBaUI7QUE3QlMsS0FwSlQ7QUFtTGxCLDBCQUFzQjtBQUNyQnJMLGNBQU0sTUFEZTtBQUVyQjZHLGdCQUFRO0FBQ1BuTCxpQkFBSztBQUNKb0wscUJBQUs7QUFERCxhQURFO0FBSVBvRixzQkFBVTtBQUNUcEYscUJBQUs7QUFESTtBQUpILFNBRmE7QUFVckIsbUJBQVcsS0FWVTtBQVdyQkEsYUFBSyxzRUFYZ0I7QUFZckIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBWk07QUFvQnJCVyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBcEJTO0FBMEJyQix5QkFBaUI7QUExQkksS0FuTEo7QUErTWxCLDhCQUEwQjtBQUN6QnJMLGNBQU0sTUFEbUI7QUFFekI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREk7QUFKSCxTQUZpQjtBQVV6QixtQkFBVyxVQVZjO0FBV3pCQSxhQUFLLDRDQVhvQjtBQVl6Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FaVTtBQW9CekJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FwQmE7QUEwQnpCLHlCQUFpQjtBQTFCUSxLQS9NUjtBQTJPbEIsMkJBQXVCO0FBQ3RCckwsY0FBTSxRQURnQjtBQUV0QixtQkFBVyxDQUZXO0FBR3RCdUosaUJBQVMsQ0FIYTtBQUl0QnpCLG9CQUFZLElBSlU7QUFLdEJULGVBQU8sUUFMZTtBQU10QlAsYUFBSyxzRkFOaUI7QUFPdEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUE87QUFxQnRCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQlU7QUE2QnRCLHlCQUFpQjtBQTdCSyxLQTNPTDtBQTBRbEIsMkJBQXVCO0FBQ3RCckwsY0FBTSxPQURnQjtBQUV0QixtQkFBVyxTQUZXO0FBR3RCOEcsYUFBSyxpQ0FIaUI7QUFJdEJnQixvQkFBWSxJQUpVO0FBS3RCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQUxPO0FBbUJ0Qlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBbkJVO0FBMkJ0Qix5QkFBaUI7QUEzQkssS0ExUUw7QUF1U2xCLDZCQUF5QjtBQUN4QnJMLGNBQU0sUUFEa0I7QUFFeEI4RyxhQUFLLHFDQUZtQjtBQUd4QixtQkFBVyxDQUhhO0FBSXhCeUMsaUJBQVMsQ0FKZTtBQUt4QkQsaUJBQVMsQ0FMZTtBQU14QnhCLG9CQUFZLElBTlk7QUFPeEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBUFM7QUFxQnhCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0FyQlk7QUE2QnhCLHlCQUFpQjtBQTdCTztBQXZTUCxDQUFuQjtBQXVVQSxJQUFJOEYsZ0JBQWdCO0FBQ25CLHNCQUFrQjtBQUNqQm5SLGNBQU0sUUFEVztBQUVqQixtQkFBVyxFQUZNO0FBR2pCdUosaUJBQVMsQ0FIUTtBQUlqQnpCLG9CQUFZLElBSks7QUFLakJULGVBQU8sUUFMVTtBQU1qQlAsYUFBSywwTUFOWTtBQU9qQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplLGFBRFQ7QUFPZCxtQ0FBdUI7QUFDdEJELG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBUFQsU0FQRTtBQXFCakJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXJCSztBQTZCakIseUJBQWlCO0FBN0JBLEtBREM7QUFnQ25CLHNCQUFrQjtBQUNqQnJMLGNBQU0sUUFEVztBQUVqQixtQkFBVyxDQUZNO0FBR2pCdUosaUJBQVMsQ0FIUTtBQUlqQnpCLG9CQUFZLEtBSks7QUFLakJoQixhQUFLLDRNQUxZO0FBTWpCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQU5FO0FBb0JqQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBcEJLO0FBNEJqQix5QkFBaUI7QUE1QkEsS0FoQ0M7QUE4RG5CLHlCQUFxQjtBQUNwQnJMLGNBQU0sUUFEYztBQUVwQixtQkFBVyxDQUZTO0FBR3BCdUosaUJBQVMsQ0FIVztBQUlwQnpCLG9CQUFZLElBSlE7QUFLcEJoQixhQUFLLCtJQUxlO0FBTXBCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQU5LO0FBY3BCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZFE7QUFvQnBCLHlCQUFpQjtBQXBCRyxLQTlERjtBQW9GbkIscUJBQWlCO0FBQ2hCckwsY0FBTSxPQURVO0FBRWhCLG1CQUFXLENBQ1YsYUFEVSxFQUVWLENBQ0MsUUFERCxDQUZVLEVBS1YsQ0FDQyxpQkFERCxDQUxVLEVBUVYsQ0FSVSxFQVNWLG9CQVRVLEVBVVYsR0FWVSxFQVdWLFdBWFUsRUFZVixHQVpVLEVBYVYsTUFiVSxFQWNWLEdBZFUsRUFlVixNQWZVLEVBZ0JWLEdBaEJVLEVBaUJWLFFBakJVLEVBa0JWLENBbEJVLEVBbUJWLEtBbkJVLENBRks7QUF1QmhCOEcsYUFBSywrSUF2Qlc7QUF3QmhCZ0Isb0JBQVksS0F4Qkk7QUF5QmhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQVBULFNBekJDO0FBbUNoQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLGlCQURXO0FBRkQsU0FuQ0k7QUF5Q2hCLHlCQUFpQjtBQXpDRCxLQXBGRTtBQStIbkIsdUJBQW1CO0FBQ2xCckwsY0FBTSxRQURZO0FBRWxCOEcsYUFBSyw4REFGYTtBQUdsQixtQkFBVyxDQUhPO0FBSWxCeUMsaUJBQVMsQ0FKUztBQUtsQkQsaUJBQVMsQ0FMUztBQU1sQnhCLG9CQUFZLElBTk07QUFPbEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUEc7QUFlbEJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmTTtBQXFCbEIseUJBQWlCO0FBckJDO0FBL0hBLENBQXBCO0FBdUpBLElBQUkrRixlQUFlO0FBQ2xCLG9CQUFnQjtBQUNmdEssYUFBSyw4Q0FEVTtBQUVmOUcsY0FBTSxRQUZTO0FBR2YsbUJBQVcsQ0FISTtBQUlmdUosaUJBQVMsQ0FKTTtBQUtmRCxpQkFBUyxDQUxNO0FBTWZ4QixvQkFBWSxJQU5HO0FBT2ZnRSxrQkFBVSxDQUNULFlBRFMsQ0FQSztBQVVmLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVZBO0FBd0JmVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0F4Qkc7QUFnQ2YseUJBQWlCO0FBaENGLEtBREU7QUFtQ2xCLGtCQUFjO0FBQ2JyTCxjQUFNLE9BRE87QUFFYixtQkFBVyxTQUZFO0FBR2I4SCxvQkFBWSxJQUhDO0FBSWJoQixhQUFLLGdJQUpRO0FBS2JnRixrQkFBVSxDQUNULFlBRFMsQ0FMRztBQVFiLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVJGO0FBc0JiVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0F0QkM7QUE4QmIseUJBQWlCO0FBOUJKLEtBbkNJO0FBbUVsQix1QkFBbUI7QUFDbEJyTCxjQUFNLE9BRFk7QUFFbEIsbUJBQVcsa0JBRk87QUFHbEI4SCxvQkFBWSxJQUhNO0FBSWxCaEIsYUFBSyw2SUFKYTtBQUtsQmdGLGtCQUFVLENBQ1QsWUFEUyxDQUxRO0FBUWxCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVJHO0FBc0JsQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBdEJNO0FBOEJsQix5QkFBaUI7QUE5QkMsS0FuRUQ7QUFtR2xCLHVCQUFtQjtBQUNsQnJMLGNBQU0sUUFEWTtBQUVsQixtQkFBVyxDQUZPO0FBR2xCdUosaUJBQVMsQ0FIUztBQUlsQnpCLG9CQUFZLElBSk07QUFLbEJULGVBQU8sUUFMVztBQU1sQlAsYUFBSyx1Q0FOYTtBQU9sQmdGLGtCQUFVLENBQ1QsWUFEUyxDQVBRO0FBVWxCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVZHO0FBd0JsQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBeEJNO0FBZ0NsQix5QkFBaUI7QUFoQ0MsS0FuR0Q7QUFxSWxCLHNCQUFrQjtBQUNqQnJMLGNBQU0sUUFEVztBQUVqQixtQkFBVyxDQUZNO0FBR2pCdUosaUJBQVMsQ0FIUTtBQUlqQnpCLG9CQUFZLElBSks7QUFLakJULGVBQU8sUUFMVTtBQU1qQlAsYUFBSyx3Q0FOWTtBQU9qQmdGLGtCQUFVLENBQ1QsWUFEUyxDQVBPO0FBVWpCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVZFO0FBd0JqQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBeEJLO0FBZ0NqQix5QkFBaUI7QUFoQ0EsS0FySUE7QUF1S2xCLHNCQUFrQjtBQUNqQnJMLGNBQU0sT0FEVztBQUVqQmtILGVBQU8sUUFGVTtBQUdqQjdMLGdCQUFRLENBSFM7QUFJakIsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQUpNO0FBUWpCeU0sb0JBQVksSUFSSztBQVNqQlQsZUFBTyxRQVRVO0FBVWpCUCxhQUFLLDRKQVZZO0FBV2pCZ0Ysa0JBQVUsQ0FDVCxZQURTLENBWE87QUFjakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBZEU7QUFzQmpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdEJLO0FBNEJqQix5QkFBaUI7QUE1QkEsS0F2S0E7QUFxTWxCLDZCQUF5QjtBQUN4QnJMLGNBQU0sTUFEa0I7QUFFeEI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREk7QUFKSCxTQUZnQjtBQVV4QkEsYUFBSyx1REFWbUI7QUFXeEIsbUJBQVcsS0FYYTtBQVl4QmdGLGtCQUFVLENBQ1QsWUFEUyxFQUVULGdCQUZTLENBWmM7QUFnQnhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQWhCUztBQXdCeEJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F4Qlk7QUE4QnhCLHlCQUFpQjtBQTlCTyxLQXJNUDtBQXFPbEIsb0JBQWdCO0FBQ2ZyTCxjQUFNLFFBRFM7QUFFZjhHLGFBQUssOENBRlU7QUFHZixtQkFBVyxDQUhJO0FBSWZ5QyxpQkFBUyxDQUpNO0FBS2ZELGlCQUFTLENBTE07QUFNZnhCLG9CQUFZLElBTkc7QUFPZmdFLGtCQUFVLENBQ1QsWUFEUyxDQVBLO0FBVWYsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZSxhQURUO0FBT2QsbUNBQXVCO0FBQ3RCRCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQVBULFNBVkE7QUF3QmZXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVyxFQUdYLGVBSFc7QUFGRCxTQXhCRztBQWdDZix5QkFBaUI7QUFoQ0YsS0FyT0U7QUF1UWxCLGtCQUFjO0FBQ2JyTCxjQUFNLE9BRE87QUFFYjhHLGFBQUssOENBRlE7QUFHYixtQkFBVyxTQUhFO0FBSWJnQixvQkFBWSxJQUpDO0FBS2J1SixxQkFBYSxJQUxBO0FBTWJ2RixrQkFBVSxDQUNULFlBRFMsQ0FORztBQVNiLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVRGO0FBdUJiVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsU0F2QkM7QUErQmIseUJBQWlCO0FBL0JKLEtBdlFJO0FBd1NsQix1QkFBbUI7QUFDbEJyTCxjQUFNLE9BRFk7QUFFbEIsbUJBQVcsa0JBRk87QUFHbEI4SCxvQkFBWSxJQUhNO0FBSWxCaEIsYUFBSywwRUFKYTtBQUtsQmdGLGtCQUFVLENBQ1QsWUFEUyxDQUxRO0FBUWxCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVJHO0FBc0JsQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBdEJNO0FBOEJsQix5QkFBaUI7QUE5QkMsS0F4U0Q7QUF3VWxCLHVCQUFtQjtBQUNsQnJMLGNBQU0sUUFEWTtBQUVsQixtQkFBVyxDQUZPO0FBR2xCdUosaUJBQVMsQ0FIUztBQUlsQnpCLG9CQUFZLElBSk07QUFLbEJULGVBQU8sUUFMVztBQU1sQlAsYUFBSyxvRkFOYTtBQU9sQmdGLGtCQUFVLENBQ1QsWUFEUyxDQVBRO0FBVWxCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVZHO0FBd0JsQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBeEJNO0FBZ0NsQix5QkFBaUI7QUFoQ0MsS0F4VUQ7QUEwV2xCLHNCQUFrQjtBQUNqQnJMLGNBQU0sUUFEVztBQUVqQixtQkFBVyxDQUZNO0FBR2pCdUosaUJBQVMsQ0FIUTtBQUlqQnpCLG9CQUFZLElBSks7QUFLakJULGVBQU8sUUFMVTtBQU1qQlAsYUFBSyxrREFOWTtBQU9qQmdGLGtCQUFVLENBQ1QsWUFEUyxDQVBPO0FBVWpCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQUN0QkQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFQVCxTQVZFO0FBd0JqQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELFNBeEJLO0FBZ0NqQix5QkFBaUI7QUFoQ0EsS0ExV0E7QUE0WWxCLHNCQUFrQjtBQUNqQnJMLGNBQU0sT0FEVztBQUVqQmtILGVBQU8sUUFGVTtBQUdqQjdMLGdCQUFRLENBSFM7QUFJakIsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQUpNO0FBUWpCeU0sb0JBQVksSUFSSztBQVNqQlQsZUFBTyxRQVRVO0FBVWpCUCxhQUFLLDRKQVZZO0FBV2pCZ0Ysa0JBQVUsQ0FDVCxZQURTLENBWE87QUFjakIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBZEU7QUFzQmpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBdEJLO0FBNEJqQix5QkFBaUI7QUE1QkEsS0E1WUE7QUEwYWxCLDZCQUF5QjtBQUN4QnJMLGNBQU0sTUFEa0I7QUFFeEI2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREk7QUFKSCxTQUZnQjtBQVV4QkEsYUFBSyx1REFWbUI7QUFXeEIsbUJBQVcsS0FYYTtBQVl4QmdGLGtCQUFVLENBQ1QsWUFEUyxFQUVULGdCQUZTLENBWmM7QUFnQnhCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQWhCUztBQXdCeEJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0F4Qlk7QUE4QnhCLHlCQUFpQjtBQTlCTztBQTFhUCxDQUFuQjtBQTJjQSxJQUFJaUcsZUFBZTtBQUNsQixzQkFBa0I7QUFDakJ0UixjQUFNLFFBRFc7QUFFakI4RyxhQUFLLCtDQUZZO0FBR2pCLG1CQUFXLENBSE07QUFJakJ5QyxpQkFBUyxDQUpRO0FBS2pCRCxpQkFBUyxDQUxRO0FBTWpCeEIsb0JBQVksSUFOSztBQU9qQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlDLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FQRTtBQWVqQlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZLO0FBcUJqQix5QkFBaUI7QUFyQkEsS0FEQTtBQXdCbEIseUJBQXFCO0FBQ3BCckwsY0FBTSxRQURjO0FBRXBCLG1CQUFXLENBRlM7QUFHcEJvSCxnQkFBUSxHQUhZO0FBSXBCVSxvQkFBWSxJQUpRO0FBS3BCVCxlQUFPLFNBTGE7QUFNcEJQLGFBQUssc0NBTmU7QUFPcEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUEs7QUFlcEJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmUTtBQXFCcEIseUJBQWlCO0FBckJHLEtBeEJIO0FBK0NsQiw2QkFBeUI7QUFDeEJyTCxjQUFNLFFBRGtCO0FBRXhCOEcsYUFBSyxzRkFGbUI7QUFHeEIsbUJBQVcsQ0FIYTtBQUl4QnlDLGlCQUFTLENBSmU7QUFLeEJELGlCQUFTLENBTGU7QUFNeEJ4QixvQkFBWSxJQU5ZO0FBT3hCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVBTO0FBZXhCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZlk7QUFxQnhCLHlCQUFpQjtBQXJCTyxLQS9DUDtBQXNFbEIsNkJBQXlCO0FBQ3hCckwsY0FBTSxRQURrQjtBQUV4QjhHLGFBQUssc0ZBRm1CO0FBR3hCLG1CQUFXLENBSGE7QUFJeEJ5QyxpQkFBUyxDQUplO0FBS3hCRCxpQkFBUyxDQUxlO0FBTXhCeEIsb0JBQVksSUFOWTtBQU94Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlDLG9CQUFJLFFBRGtCO0FBRXRCNUIseUJBQVMsT0FGYTtBQUd0QkMscUJBQUssT0FIaUI7QUFJdEI0Qix1QkFBTztBQUplO0FBRFQsU0FQUztBQWV4Qlcsb0JBQVk7QUFDWEMsMEJBQWMsSUFESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQWZZO0FBcUJ4Qix5QkFBaUI7QUFyQk8sS0F0RVA7QUE2RmxCLHlCQUFxQjtBQUNwQnJMLGNBQU0sUUFEYztBQUVwQjhHLGFBQUssaURBRmU7QUFHcEIsbUJBQVcsQ0FIUztBQUlwQnlDLGlCQUFTLENBQUMsQ0FKVTtBQUtwQkQsaUJBQVMsQ0FMVztBQU1wQnhCLG9CQUFZLElBTlE7QUFPcEIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUEs7QUFlcEJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmUTtBQXFCcEIseUJBQWlCO0FBckJHLEtBN0ZIO0FBb0hsQix1QkFBbUI7QUFDbEJyTCxjQUFNLFFBRFk7QUFFbEI4RyxhQUFLLCtDQUZhO0FBR2xCLG1CQUFXLENBSE87QUFJbEJ5QyxpQkFBUyxDQUFDLENBSlE7QUFLbEJELGlCQUFTLENBTFM7QUFNbEJ4QixvQkFBWSxJQU5NO0FBT2xCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVBHO0FBZWxCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZk07QUFxQmxCLHlCQUFpQjtBQXJCQyxLQXBIRDtBQTJJbEIseUJBQXFCO0FBQ3BCckwsY0FBTSxNQURjO0FBRXBCOEcsYUFBSyx3R0FGZTtBQUdwQkQsZ0JBQVE7QUFDUDBLLG9CQUFRO0FBQ1B6SyxxQkFBSztBQURFLGFBREQ7QUFJUDlFLHFCQUFTO0FBQ1I4RSxxQkFBSztBQURHO0FBSkYsU0FIWTtBQVdwQixtQkFBVyxRQVhTO0FBWXBCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVpLO0FBb0JwQlcsb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQXBCUTtBQTBCcEIseUJBQWlCO0FBMUJHLEtBM0lIO0FBdUtsQiw0QkFBd0I7QUFDdkJyTCxjQUFNLFFBRGlCO0FBRXZCLG1CQUFXLEdBRlk7QUFHdkJ1SixpQkFBUyxDQUhjO0FBSXZCekIsb0JBQVksS0FKVztBQUt2QlQsZUFBTyxjQUxnQjtBQU12QlAsYUFBSyx5Q0FOa0I7QUFPdkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUFE7QUFldkJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmVztBQXFCdkIseUJBQWlCO0FBckJNO0FBdktOLENBQW5CO0FBK0xBLElBQUltRyxrQkFBa0I7QUFDckIsd0NBQW9DO0FBQ25DeFIsY0FBTSxRQUQ2QjtBQUVuQyxtQkFBVyxHQUZ3QjtBQUduQ3VKLGlCQUFTLENBSDBCO0FBSW5DRCxpQkFBUyxHQUowQjtBQUtuQ3hDLGFBQUssZ09BTDhCO0FBTW5DZ0Isb0JBQVksS0FOdUI7QUFPbkMsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUG9CO0FBZW5DVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZnVCO0FBcUJuQyx5QkFBaUI7QUFyQmtCLEtBRGY7QUF3QnJCLHFDQUFpQztBQUNoQ3JMLGNBQU0sTUFEMEI7QUFFaEM2RyxnQkFBUTtBQUNQbkwsaUJBQUs7QUFDSm9MLHFCQUFLO0FBREQsYUFERTtBQUlQb0Ysc0JBQVU7QUFDVHBGLHFCQUFLO0FBREk7QUFKSCxTQUZ3QjtBQVVoQyxtQkFBVyxVQVZxQjtBQVdoQ0EsYUFBSyxnREFYMkI7QUFZaEMsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5RCxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBWmlCO0FBb0JoQ1csb0JBQVk7QUFDWEMsMEJBQWMsS0FESDtBQUVYQyx3QkFBWSxDQUNYLE1BRFc7QUFGRCxTQXBCb0I7QUEwQmhDLHlCQUFpQjtBQTFCZSxLQXhCWjtBQW9EckIsOEJBQTBCO0FBQ3pCckwsY0FBTSxRQURtQjtBQUV6QjhHLGFBQUssNEJBRm9CO0FBR3pCLG1CQUFXLEdBSGM7QUFJekJ5QyxpQkFBUyxDQUpnQjtBQUt6QkQsaUJBQVMsQ0FMZ0I7QUFNekJ4QixvQkFBWSxJQU5hO0FBT3pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQVBVO0FBZXpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZmE7QUFxQnpCLHlCQUFpQjtBQXJCUSxLQXBETDtBQTJFckIsOEJBQTBCO0FBQ3pCckwsY0FBTSxPQURtQjtBQUV6QixtQkFBVyxTQUZjO0FBR3pCOEcsYUFBSyxrRUFIb0I7QUFJekJnQixvQkFBWSxJQUphO0FBS3pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQUxVO0FBYXpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBYmE7QUFtQnpCLHlCQUFpQjtBQW5CUSxLQTNFTDtBQWdHckIsaUNBQTZCO0FBQzVCckwsY0FBTSxPQURzQjtBQUU1QixtQkFBVyxTQUZpQjtBQUc1QjhHLGFBQUssaUVBSHVCO0FBSTVCZ0Isb0JBQVksSUFKZ0I7QUFLNUIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBTGE7QUFhNUJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FiZ0I7QUFtQjVCLHlCQUFpQjtBQW5CVyxLQWhHUjtBQXFIckIsOEJBQTBCO0FBQ3pCckwsY0FBTSxPQURtQjtBQUV6QixtQkFBVyxTQUZjO0FBR3pCOEcsYUFBSyxtRkFIb0I7QUFJekJnQixvQkFBWSxJQUphO0FBS3pCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUMsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmU7QUFEVCxTQUxVO0FBYXpCVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBYmE7QUFtQnpCLHlCQUFpQjtBQW5CUTtBQXJITCxDQUF0QjtBQTJJQSxJQUFJb0csbUJBQW1CO0FBQ3RCLHdCQUFvQjtBQUNuQnpSLGNBQU0sT0FEYTtBQUVuQixtQkFBVyxTQUZRO0FBR25COEcsYUFBSyxvREFIYztBQUluQmdCLG9CQUFZLElBSk87QUFLbkJnRSxrQkFBVSxDQUNUO0FBQ0MsaUJBQUs7QUFETixTQURTLENBTFM7QUFVbkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBVkk7QUFrQm5CVyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBbEJPO0FBd0JuQix5QkFBaUI7QUF4QkUsS0FERTtBQTJCdEIsMEJBQXNCO0FBQ3JCckwsY0FBTSxlQURlO0FBRXJCOEgsb0JBQVksSUFGUztBQUdyQmhCLGFBQUssZ1BBSGdCO0FBSXJCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksUUFEa0I7QUFFdEI1Qix5QkFBUyxPQUZhO0FBR3RCQyxxQkFBSyxPQUhpQjtBQUl0QjRCLHVCQUFPO0FBSmUsYUFEVDtBQU9kLG1DQUF1QjtBQVBULFNBSk07QUFjckJXLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FkUztBQW9CckIseUJBQWlCO0FBcEJJLEtBM0JBO0FBaUR0QiwwQkFBc0I7QUFDckJyTCxjQUFNLFFBRGU7QUFFckIsbUJBQVcsQ0FGVTtBQUdyQnVKLGlCQUFTLENBSFk7QUFJckJELGlCQUFTLENBSlk7QUFLckJ4QyxhQUFLLG9EQUxnQjtBQU1yQmdCLG9CQUFZLElBTlM7QUFPckIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ5QyxvQkFBSSxRQURrQjtBQUV0QjVCLHlCQUFTLE9BRmE7QUFHdEJDLHFCQUFLLE9BSGlCO0FBSXRCNEIsdUJBQU87QUFKZTtBQURULFNBUE07QUFlckJXLG9CQUFZO0FBQ1hDLDBCQUFjLElBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FmUztBQXFCckIseUJBQWlCO0FBckJJO0FBakRBLENBQXZCO0FBeUVBLElBQUlxRyxZQUFZO0FBQ2YsZ0JBQVk7QUFDWDFSLGNBQU0sTUFESztBQUVYNkcsZ0JBQVE7QUFDUDhLLHNCQUFVO0FBQ1Q3SyxxQkFBSztBQURJLGFBREg7QUFJUDhLLHdCQUFZO0FBQ1g5SyxxQkFBSztBQURNO0FBSkwsU0FGRztBQVVYLG1CQUFXLFlBVkE7QUFXWEEsYUFBSyxxQkFYTTtBQVlYLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksT0FEa0I7QUFFdEIzQixxQkFBSyxRQUZpQjtBQUd0QkQseUJBQVM7QUFIYTtBQURULFNBWko7QUFtQlh3QyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBbkJEO0FBeUJYLHlCQUFpQjtBQXpCTixLQURHO0FBNEJmLDBCQUFzQjtBQUNyQnJMLGNBQU0sT0FEZTtBQUVyQmtILGVBQU8sUUFGYztBQUdyQjdMLGdCQUFRLENBSGE7QUFJckJnTSxlQUFPLFNBSmM7QUFLckJrQyxpQkFBUyxDQUNSLENBRFEsRUFFUixDQUZRLENBTFk7QUFTckJELGlCQUFTLENBQ1IsR0FEUSxFQUVSLEdBRlEsQ0FUWTtBQWFyQnhCLG9CQUFZLEtBYlM7QUFjckJoQixhQUFLLDJYQWRnQjtBQWVyQix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLE9BRGtCO0FBRXRCM0IscUJBQUssUUFGaUI7QUFHdEJELHlCQUFTO0FBSGE7QUFEVCxTQWZNO0FBc0JyQm1ELGtCQUFVLENBQ1Q7QUFDQyx3QkFBWTtBQURiLFNBRFMsQ0F0Qlc7QUEyQnJCWCxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBM0JTO0FBaUNyQix5QkFBaUI7QUFqQ0ksS0E1QlA7QUErRGYsb0NBQWdDO0FBQy9CckwsY0FBTSxRQUR5QjtBQUUvQjhMLGtCQUFVLENBQ1Q7QUFDQyx3QkFBWTtBQURiLFNBRFMsQ0FGcUI7QUFPL0IsbUJBQVcsRUFQb0I7QUFRL0J2QyxpQkFBUyxDQVJzQjtBQVMvQkQsaUJBQVMsR0FUc0I7QUFVL0J4QixvQkFBWSxLQVZtQjtBQVcvQmhCLGFBQUssd0lBWDBCO0FBWS9CLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCeUQsb0JBQUksT0FEa0I7QUFFdEIzQixxQkFBSyxRQUZpQjtBQUd0QkQseUJBQVM7QUFIYTtBQURULFNBWmdCO0FBbUIvQix5QkFBaUI7QUFuQmMsS0EvRGpCO0FBb0ZmLDJCQUF1QjtBQUN0QjNJLGNBQU0sT0FEZ0I7QUFFdEI4TCxrQkFBVSxDQUNUO0FBQ0Msd0JBQVk7QUFEYixTQURTLENBRlk7QUFPdEI1RSxlQUFPLFFBUGU7QUFRdEIsbUJBQVcsQ0FDVixDQURVLEVBRVYsQ0FGVSxDQVJXO0FBWXRCN0wsZ0JBQVEsQ0FaYztBQWF0QmdNLGVBQU8sU0FiZTtBQWN0QmtDLGlCQUFTLENBQ1IsQ0FEUSxFQUVSLENBRlEsQ0FkYTtBQWtCdEJELGlCQUFTLENBQ1IsR0FEUSxFQUVSLEdBRlEsQ0FsQmE7QUFzQnRCeEIsb0JBQVksS0F0QlU7QUF1QnRCaEIsYUFBSywwVEF2QmlCO0FBd0J0Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLE9BRGtCO0FBRXRCM0IscUJBQUssUUFGaUI7QUFHdEJELHlCQUFTO0FBSGE7QUFEVCxTQXhCTztBQStCdEJ3QyxvQkFBWTtBQUNYQywwQkFBYyxLQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBL0JVO0FBcUN0Qix5QkFBaUI7QUFyQ0ssS0FwRlI7QUEySGYsMkJBQXVCO0FBQ3RCckwsY0FBTSxRQURnQjtBQUV0QjhMLGtCQUFVLENBQ1Q7QUFDQyx3QkFBWTtBQURiLFNBRFMsQ0FGWTtBQU90QixtQkFBVyxFQVBXO0FBUXRCdkMsaUJBQVMsQ0FSYTtBQVN0QkQsaUJBQVMsR0FUYTtBQVV0QnhCLG9CQUFZLEtBVlU7QUFXdEJoQixhQUFLLGlOQVhpQjtBQVl0Qix1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlELG9CQUFJLE9BRGtCO0FBRXRCM0IscUJBQUssUUFGaUI7QUFHdEJELHlCQUFTO0FBSGE7QUFEVCxTQVpPO0FBbUJ0QndDLG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXO0FBRkQsU0FuQlU7QUF5QnRCLHlCQUFpQjtBQXpCSyxLQTNIUjtBQXNKZixvQkFBZ0I7QUFDZnJMLGNBQU0sT0FEUztBQUVmLG1CQUFXLENBQ1YsYUFEVSxFQUVWLENBQ0MsUUFERCxDQUZVLEVBS1YsQ0FDQyxxQkFERCxDQUxVLEVBUVYsR0FSVSxFQVNWLFNBVFUsRUFVVixDQVZVLEVBV1YsT0FYVSxDQUZJO0FBZWY4RyxhQUFLLHlUQWZVO0FBZ0JmZ0Isb0JBQVksS0FoQkc7QUFpQmZnRSxrQkFBVSxDQUNUO0FBQ0Msd0JBQVk7QUFEYixTQURTLENBakJLO0FBc0JmLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksT0FEa0I7QUFFdEIzQixxQkFBSyxRQUZpQjtBQUd0QkQseUJBQVM7QUFIYSxhQURUO0FBTWQsbUNBQXVCO0FBTlQsU0F0QkE7QUErQmZ3QyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gscUJBRFc7QUFGRCxTQS9CRztBQXFDZix5QkFBaUI7QUFyQ0YsS0F0SkQ7QUE2TGYsaUNBQTZCO0FBQzVCckwsY0FBTSxPQURzQjtBQUU1QixtQkFBVyxPQUZpQjtBQUc1QjhHLGFBQUssOElBSHVCO0FBSTVCZ0Isb0JBQVksS0FKZ0I7QUFLNUJnRSxrQkFBVSxDQUNUO0FBQ0Msd0JBQVk7QUFEYixTQURTLENBTGtCO0FBVTVCLHVCQUFlO0FBQ2QsbUNBQXVCO0FBQ3RCdkIsb0JBQUksT0FEa0I7QUFFdEIzQixxQkFBSyxRQUZpQjtBQUd0QkQseUJBQVM7QUFIYTtBQURULFNBVmE7QUFpQjVCLHlCQUFpQjtBQWpCVyxLQTdMZDtBQWdOZiw0QkFBd0I7QUFDdkIzSSxjQUFNLE9BRGlCO0FBRXZCLG1CQUFXLE9BRlk7QUFHdkI4RyxhQUFLLHFXQUhrQjtBQUl2QmdCLG9CQUFZLEtBSlc7QUFLdkJnRSxrQkFBVSxDQUNUO0FBQ0Msd0JBQVk7QUFEYixTQURTLENBTGE7QUFVdkIsdUJBQWU7QUFDZCxtQ0FBdUI7QUFDdEJ2QixvQkFBSSxPQURrQjtBQUV0QjNCLHFCQUFLLFFBRmlCO0FBR3RCRCx5QkFBUztBQUhhO0FBRFQsU0FWUTtBQWlCdkIseUJBQWlCO0FBakJNLEtBaE5UO0FBbU9mLG1CQUFlO0FBQ2QzSSxjQUFNLFFBRFE7QUFFZCxtQkFBVyxDQUZHO0FBR2R1SixpQkFBUyxDQUhLO0FBSWRELGlCQUFTLENBSks7QUFLZHhDLGFBQUssc0NBTFM7QUFNZGdCLG9CQUFZLElBTkU7QUFPZCx1QkFBZTtBQUNkLG1DQUF1QjtBQUN0QnlDLG9CQUFJLE9BRGtCO0FBRXRCM0IscUJBQUssUUFGaUI7QUFHdEJELHlCQUFTO0FBSGE7QUFEVCxTQVBEO0FBY2R3QyxvQkFBWTtBQUNYQywwQkFBYyxJQURIO0FBRVhDLHdCQUFZLENBQ1gsTUFEVztBQUZELFNBZEU7QUFvQmQseUJBQWlCO0FBcEJIO0FBbk9BLENBQWhCO0FBMFBBLElBQUl2RCxhQUFhO0FBQ2hCQyxjQUFVO0FBQ1QvSCxjQUFNLFFBREc7QUFFVCxtQkFBVyxHQUZGO0FBR1R1SixpQkFBUyxDQUhBO0FBSVRsQyxlQUFPLGNBSkU7QUFLVFAsYUFBSztBQUxJLEtBRE07QUFRaEJrQixXQUFPO0FBQ05oSSxjQUFNLFFBREE7QUFFTixtQkFBVyxDQUZMO0FBR051SixpQkFBUyxDQUhIO0FBSU5sQyxlQUFPLGNBSkQ7QUFLTlAsYUFBSztBQUxDO0FBUlMsQ0FBakI7QUFnQkEsSUFBSTJCLFlBQVk7QUFDZixTQUFLO0FBQ0p6SSxjQUFNLFFBREY7QUFFSjhHLGFBQUs7QUFGRDtBQURVLENBQWhCO0FBTUEsSUFBSStLLEtBQUs7QUFDUm5MLGNBQVVBLFFBREY7QUFFUkMsV0FBT0EsS0FGQztBQUdSNUQsYUFBU0EsT0FIRDtBQUlSeEYsWUFBUUEsTUFKQTtBQUtSNEssbUJBQWVBLGFBTFA7QUFNUlUsbUJBQWVBLGFBTlA7QUFPUkUsdUJBQW1CQSxpQkFQWDtBQVFSSSxvQkFBZ0JBLGNBUlI7QUFTUmMsa0JBQWNBLFlBVE47QUFVUkcsa0JBQWNBLFlBVk47QUFXUnhOLFdBQU9BLEtBWEM7QUFZUkMsWUFBUUEsTUFaQTtBQWFSa08sdUJBQW1CQSxpQkFiWDtBQWNSRSxnQkFBWUEsVUFkSjtBQWVSQyxpQkFBYUEsV0FmTDtBQWdCUkksbUJBQWVBLGFBaEJQO0FBaUJSQyxvQkFBZ0JBLGNBakJSO0FBa0JSLDZCQUF5QjtBQUN6QjNLLG9CQUFZO0FBQ1haLGtCQUFNLE1BREs7QUFFWDZHLG9CQUFRO0FBQ1A1Qyx5QkFBUztBQUNSNkMseUJBQUs7QUFERyxpQkFERjtBQUlQa0Usc0JBQU07QUFDTGxFLHlCQUFLO0FBREE7QUFKQyxhQUZHO0FBVVgsdUJBQVcsU0FWQTtBQVdYQSxpQkFBSyxrQ0FYTTtBQVlYLDJCQUFlO0FBQ2QsdUNBQXVCO0FBQ3RCeUQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFEVCxhQVpKO0FBb0JYLDZCQUFpQjtBQXBCTjtBQURhLEtBbEJqQjtBQTBDUmdCLGlCQUFhQSxXQTFDTDtBQTJDUk8sbUJBQWVBLGFBM0NQO0FBNENSZ0IsbUJBQWVBLGFBNUNQO0FBNkNSQyxzQkFBa0JBLGdCQTdDVjtBQThDUnhELFlBQVFBLE1BOUNBO0FBK0NSeUQsbUJBQWVBLGFBL0NQO0FBZ0RSQyxpQkFBYUEsV0FoREw7QUFpRFJDLGlCQUFhQSxXQWpETDtBQWtEUkMsbUJBQWVBLGFBbERQO0FBbURSLDZCQUF5QjtBQUN6QnBOLGNBQU0sU0FEbUI7QUFFekI4RyxhQUFLLDBRQUZvQjtBQUd6QixtQkFBVyxLQUhjO0FBSXpCZ0Isb0JBQVksS0FKYTtBQUt6Qix5QkFBaUIsYUFMUTtBQU16QnFELG9CQUFZO0FBQ1hDLDBCQUFjLEtBREg7QUFFWEMsd0JBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZEO0FBTmEsS0FuRGpCO0FBaUVSZ0Msb0JBQWdCQSxjQWpFUjtBQWtFUkMscUJBQWlCQSxlQWxFVDtBQW1FUkssbUJBQWVBLGFBbkVQO0FBb0VSLGdCQUFZO0FBQ1p4QyxvQkFBWTtBQUNYbkwsa0JBQU0sWUFESztBQUVYOEcsaUJBQUs7QUFGTSxTQURBO0FBS1oxTCxlQUFPO0FBQ040RSxrQkFBTSxPQURBO0FBRU44RyxpQkFBSyxvQkFGQztBQUdOSSxtQkFBTztBQUhELFNBTEs7QUFVWjRLLGNBQU07QUFDTDlSLGtCQUFNLFFBREQ7QUFFTCx1QkFBVyxDQUZOO0FBR0x1SixxQkFBUyxDQUhKO0FBSUx6QyxpQkFBSztBQUpBLFNBVk07QUFnQlppTCxrQkFBVTtBQUNUL1Isa0JBQU0sUUFERztBQUVUOEcsaUJBQUssOERBRkk7QUFHVCx1QkFBVztBQUhGLFNBaEJFO0FBcUJaOUcsY0FBTTtBQUNMQSxrQkFBTSxNQUREO0FBRUw2RyxvQkFBUTtBQUNQbUwsMEJBQVU7QUFDVGxMLHlCQUFLO0FBREksaUJBREg7QUFJUG1MLDZCQUFhO0FBQ1puTCx5QkFBSztBQURPLGlCQUpOO0FBT1BvTCwwQkFBVTtBQUNUcEwseUJBQUs7QUFESSxpQkFQSDtBQVVQcUwsNkJBQWE7QUFDWnJMLHlCQUFLO0FBRE87QUFWTixhQUZIO0FBZ0JMQSxpQkFBSywyREFoQkE7QUFpQkwsdUJBQVc7QUFqQk4sU0FyQk07QUF3Q1pzTCxvQkFBWTtBQUNYcFMsa0JBQU0sTUFESztBQUVYNkcsb0JBQVE7QUFDUGtJLHFCQUFLO0FBQ0pqSSx5QkFBSztBQURELGlCQURFO0FBSVB1TCxxQkFBSztBQUNKdkwseUJBQUs7QUFERCxpQkFKRTtBQU9Qd0wscUJBQUs7QUFDSnhMLHlCQUFLO0FBREQ7QUFQRSxhQUZHO0FBYVhBLGlCQUFLLHNRQWJNO0FBY1gsdUJBQVc7QUFkQSxTQXhDQTtBQXdEWixtQkFBVztBQUNWOUcsa0JBQU0sR0FESTtBQUVWNEcsc0JBQVUsS0FGQTtBQUdWRSxpQkFBSztBQUhLO0FBeERDLEtBcEVKO0FBa0lSaUgsbUJBQWVBLGFBbElQO0FBbUlSNUMsZ0JBQVlBLFVBbklKO0FBb0lSNkMscUJBQWlCQSxlQXBJVDtBQXFJUnBHLFNBQUtBLEdBcklHO0FBc0lSTCxXQUFPQSxLQXRJQztBQXVJUlUsZ0JBQVlBLFVBdklKO0FBd0lSTixhQUFTQSxPQXhJRDtBQXlJUnZILFdBQU9BLEtBeklDO0FBMElSNFEsZ0JBQVlBLFVBMUlKO0FBMklSLDRCQUF3QjtBQUN4QixrQ0FBMEI7QUFDekJoUixrQkFBTSxRQURtQjtBQUV6Qix1QkFBVyxDQUZjO0FBR3pCdUoscUJBQVMsQ0FIZ0I7QUFJekJELHFCQUFTLENBSmdCO0FBS3pCeEMsaUJBQUssb0pBTG9CO0FBTXpCZ0Isd0JBQVksSUFOYTtBQU96QiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnlDLHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQsYUFQVTtBQWV6Qlcsd0JBQVk7QUFDWEMsOEJBQWMsSUFESDtBQUVYQyw0QkFBWSxDQUNYLE1BRFc7QUFGRCxhQWZhO0FBcUJ6Qiw2QkFBaUI7QUFyQlEsU0FERjtBQXdCeEIsZ0NBQXdCO0FBQ3ZCckwsa0JBQU0sT0FEaUI7QUFFdkIsdUJBQVcsU0FGWTtBQUd2QjhHLGlCQUFLLG1UQUhrQjtBQUl2QmdCLHdCQUFZLElBSlc7QUFLdkJnRSxzQkFBVSxDQUNUO0FBQ0MscUJBQUs7QUFETixhQURTLENBTGE7QUFVdkIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJ2Qix3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZSxpQkFEVDtBQU9kLHVDQUF1QjtBQUN0QkQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFQVCxhQVZRO0FBd0J2Qlcsd0JBQVk7QUFDWEMsOEJBQWMsSUFESDtBQUVYQyw0QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELGFBeEJXO0FBZ0N2Qiw2QkFBaUI7QUFoQ00sU0F4QkE7QUEwRHhCLG9DQUE0QjtBQUMzQnJMLGtCQUFNLE9BRHFCO0FBRTNCa0gsbUJBQU8sUUFGb0I7QUFHM0I3TCxvQkFBUSxDQUhtQjtBQUkzQix1QkFBVyxDQUNWLENBRFUsRUFFVixDQUZVLENBSmdCO0FBUTNCeU0sd0JBQVksSUFSZTtBQVMzQlQsbUJBQU8sUUFUb0I7QUFVM0JQLGlCQUFLLGtIQVZzQjtBQVczQiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnlELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQsYUFYWTtBQW1CM0JXLHdCQUFZO0FBQ1hDLDhCQUFjLElBREg7QUFFWEMsNEJBQVksQ0FDWCxNQURXO0FBRkQsYUFuQmU7QUF5QjNCLDZCQUFpQjtBQXpCVSxTQTFESjtBQXFGeEIsMkNBQW1DO0FBQ2xDckwsa0JBQU0sTUFENEI7QUFFbEM2RyxvQkFBUTtBQUNQbkwscUJBQUs7QUFDSm9MLHlCQUFLO0FBREQsaUJBREU7QUFJUG9GLDBCQUFVO0FBQ1RwRix5QkFBSztBQURJO0FBSkgsYUFGMEI7QUFVbENBLGlCQUFLLGlFQVY2QjtBQVdsQyx1QkFBVyxLQVh1QjtBQVlsQ2dGLHNCQUFVLENBQ1QsMEJBRFMsQ0Fad0I7QUFlbEMsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJ2Qix3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQURULGFBZm1CO0FBdUJsQ1csd0JBQVk7QUFDWEMsOEJBQWMsS0FESDtBQUVYQyw0QkFBWSxDQUNYLE1BRFc7QUFGRCxhQXZCc0I7QUE2QmxDLDZCQUFpQjtBQTdCaUIsU0FyRlg7QUFvSHhCLGtDQUEwQjtBQUN6QnJMLGtCQUFNLGVBRG1CO0FBRXpCOEgsd0JBQVksSUFGYTtBQUd6QmhCLGlCQUFLLHFQQUhvQjtBQUl6QiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnlELHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplLGlCQURUO0FBT2QsdUNBQXVCO0FBQ3RCRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEI2QiwyQkFBTyxRQUhlO0FBSXRCNUIseUJBQUs7QUFKaUI7QUFQVCxhQUpVO0FBa0J6QnVDLHdCQUFZO0FBQ1hDLDhCQUFjLEtBREg7QUFFWEMsNEJBQVksQ0FDWCxNQURXLEVBRVgsU0FGVztBQUZELGFBbEJhO0FBeUJ6Qiw2QkFBaUI7QUF6QlEsU0FwSEY7QUErSXhCLGlDQUF5QjtBQUN4QnJMLGtCQUFNLFFBRGtCO0FBRXhCLHVCQUFXLENBRmE7QUFHeEJ1SixxQkFBUyxDQUhlO0FBSXhCbEMsbUJBQU8sUUFKaUI7QUFLeEJQLGlCQUFLLDhDQUxtQjtBQU14QmdCLHdCQUFZLElBTlk7QUFPeEIsMkJBQWU7QUFDZCx1Q0FBdUI7QUFDdEJ5Qyx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZSxpQkFEVDtBQU9kLHVDQUF1QjtBQUN0QkQsd0JBQUksUUFEa0I7QUFFdEI1Qiw2QkFBUyxPQUZhO0FBR3RCQyx5QkFBSyxPQUhpQjtBQUl0QjRCLDJCQUFPO0FBSmU7QUFQVCxhQVBTO0FBcUJ4Qlcsd0JBQVk7QUFDWEMsOEJBQWMsSUFESDtBQUVYQyw0QkFBWSxDQUNYLE1BRFcsRUFFWCxTQUZXLEVBR1gsZUFIVztBQUZELGFBckJZO0FBNkJ4Qiw2QkFBaUI7QUE3Qk8sU0EvSUQ7QUE4S3hCLCtCQUF1QjtBQUN0QnJMLGtCQUFNLFFBRGdCO0FBRXRCLHVCQUFXLENBRlc7QUFHdEJ1SixxQkFBUyxDQUhhO0FBSXRCbEMsbUJBQU8sUUFKZTtBQUt0QlAsaUJBQUssaUhBTGlCO0FBTXRCZ0Isd0JBQVksSUFOVTtBQU90QmdFLHNCQUFVLENBQ1QsdUJBRFMsQ0FQWTtBQVV0QiwyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnZCLHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplLGlCQURUO0FBT2QsdUNBQXVCO0FBQ3RCRCx3QkFBSSxRQURrQjtBQUV0QjVCLDZCQUFTLE9BRmE7QUFHdEJDLHlCQUFLLE9BSGlCO0FBSXRCNEIsMkJBQU87QUFKZTtBQVBULGFBVk87QUF3QnRCVyx3QkFBWTtBQUNYQyw4QkFBYyxJQURIO0FBRVhDLDRCQUFZLENBQ1gsTUFEVyxFQUVYLFNBRlcsRUFHWCxlQUhXO0FBRkQsYUF4QlU7QUFnQ3RCLDZCQUFpQjtBQWhDSyxTQTlLQztBQWdOeEIsNENBQW9DO0FBQ25Dckwsa0JBQU0sU0FENkI7QUFFbkMsdUJBQVcsSUFGd0I7QUFHbkM4RyxpQkFBSywwSUFIOEI7QUFJbkNnQix3QkFBWSxLQUp1QjtBQUtuQywyQkFBZTtBQUNkLHVDQUF1QjtBQUN0QnlDLHdCQUFJLFFBRGtCO0FBRXRCNUIsNkJBQVMsT0FGYTtBQUd0QkMseUJBQUssT0FIaUI7QUFJdEI0QiwyQkFBTztBQUplO0FBRFQsYUFMb0I7QUFhbkNXLHdCQUFZO0FBQ1hDLDhCQUFjLEtBREg7QUFFWEMsNEJBQVksQ0FDWCxNQURXO0FBRkQsYUFidUI7QUFtQm5DLDZCQUFpQjtBQW5Ca0I7QUFoTlosS0EzSWhCO0FBaVhSNEYsZ0JBQVlBLFVBalhKO0FBa1hSQyxrQkFBY0EsWUFsWE47QUFtWFJDLG1CQUFlQSxhQW5YUDtBQW9YUkMsa0JBQWNBLFlBcFhOO0FBcVhSRSxrQkFBY0EsWUFyWE47QUFzWFJFLHFCQUFpQkEsZUF0WFQ7QUF1WFJDLHNCQUFrQkEsZ0JBdlhWO0FBd1hSQyxlQUFXQSxTQXhYSDtBQXlYUjVKLGdCQUFZQSxVQXpYSjtBQTBYUixxQkFBaUI7QUFDakIsdUJBQWU7QUFDZDlILGtCQUFNLGVBRFE7QUFFZDhHLGlCQUFLO0FBRlMsU0FERTtBQUtqQix1QkFBZTtBQUNkOUcsa0JBQU0sZUFEUTtBQUVkOEcsaUJBQUs7QUFGUyxTQUxFO0FBU2pCLG1DQUEyQjtBQUMxQjlHLGtCQUFNLGVBRG9CO0FBRTFCOEcsaUJBQUs7QUFGcUIsU0FUVjtBQWFqQixzQkFBYztBQUNiOUcsa0JBQU0sZUFETztBQUViOEcsaUJBQUs7QUFGUSxTQWJHO0FBaUJqQix5QkFBaUI7QUFDaEI5RyxrQkFBTSxlQURVO0FBRWhCOEcsaUJBQUs7QUFGVyxTQWpCQTtBQXFCakJ5TCxrQkFBVTtBQUNUdlMsa0JBQU0sZUFERztBQUVUOEcsaUJBQUs7QUFGSTtBQXJCTyxLQTFYVDtBQW9aUjJCLGVBQVdBO0FBcFpILENBQVQ7O0FBdVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSStKLGVBQWUsMkJBQW5COztBQUVBLElBQUlDLDZCQUE2QixTQUFTQyxTQUFULENBQW1CQyxTQUFuQixFQUE4QkMsT0FBOUIsRUFBdUM7QUFDdEUsUUFBSUMsTUFBSixFQUFZQyxTQUFaLEVBQXVCQyxRQUF2Qjs7QUFFQUgsY0FBVUEsV0FBVyxFQUFyQjtBQUNBQyxhQUFTalYsS0FBSzhVLFNBQUwsQ0FDUCxDQUFDLENBQUQsQ0FETyxFQUVQMVQsU0FGTyxFQUdQNFQsUUFBUUMsTUFBUixLQUFtQjdULFNBQW5CLEdBQStCLENBQS9CLEdBQW1DNFQsUUFBUUMsTUFIcEMsRUFJUDFNLEtBSk8sQ0FJRCxDQUpDLEVBSUUsQ0FBQyxDQUpILENBQVQ7QUFLQTJNLGdCQUNFRCxXQUFXLEVBQVgsR0FDSUcsUUFESixHQUVJSixRQUFRRSxTQUFSLEtBQXNCOVQsU0FBdEIsR0FDQSxFQURBLEdBRUE0VCxRQUFRRSxTQUxkO0FBTUFDLGVBQVdILFFBQVFHLFFBQW5COztBQUVBLFdBQVEsU0FBU0UsVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUJDLGFBQXpCLEVBQXdDQyxRQUF4QyxFQUFrRDtBQUN4RDtBQUNBLFlBQUlDLEdBQUosRUFBU0MsS0FBVCxFQUFnQkMsS0FBaEIsRUFBdUJsUCxHQUF2QixFQUE0Qm1QLE9BQTVCLEVBQXFDQyxJQUFyQyxFQUEyQ3BZLE1BQTNDLEVBQW1EcVksVUFBbkQsRUFBK0RDLFVBQS9ELEVBQTJFQyxLQUEzRSxFQUFrRmxGLE1BQWxGLEVBQTBGeEgsS0FBMUY7O0FBRUEsWUFBSWdNLE9BQU8sT0FBT0EsSUFBSVcsTUFBWCxLQUFzQixVQUFqQyxFQUE2QztBQUMzQ1gsa0JBQU1BLElBQUlXLE1BQUosRUFBTjtBQUNEOztBQUVEbkYsaUJBQVM5USxLQUFLOFUsU0FBTCxDQUFlUSxHQUFmLEVBQW9CSCxRQUFwQixDQUFUOztBQUVBLFlBQUlyRSxXQUFXMVAsU0FBZixFQUEwQjtBQUN4QixtQkFBTzBQLE1BQVA7QUFDRDs7QUFFRHJULGlCQUFTeVgsWUFBWUssY0FBYzlYLE1BQTFCLEdBQW1DK1gsUUFBNUM7O0FBRUEsWUFBSTFFLE9BQU9yVCxNQUFQLElBQWlCQSxNQUFyQixFQUE2QjtBQUMzQnNZLHlCQUFhakYsT0FBTzdTLE9BQVAsQ0FBZTJXLFlBQWYsRUFBNkIsVUFBU25WLEtBQVQsRUFBZ0J5VyxhQUFoQixFQUErQjtBQUN2RSx1QkFBT0EsaUJBQWlCelcsUUFBUSxHQUFoQztBQUNELGFBRlksQ0FBYjtBQUdBLGdCQUFJc1csV0FBV3RZLE1BQVgsSUFBcUJBLE1BQXpCLEVBQWlDO0FBQy9CLHVCQUFPc1ksVUFBUDtBQUNEO0FBQ0Y7O0FBRUQsWUFBSVosWUFBWSxJQUFoQixFQUFzQjtBQUNwQkcsa0JBQU10VixLQUFLQyxLQUFMLENBQVc2USxNQUFYLENBQU47QUFDQXFFLHVCQUFXL1QsU0FBWDtBQUNEOztBQUVELFlBQUksUUFBT2tVLEdBQVAseUNBQU9BLEdBQVAsT0FBZSxRQUFmLElBQTJCQSxRQUFRLElBQXZDLEVBQTZDO0FBQzNDUSx5QkFBYVAsZ0JBQWdCTixNQUE3QjtBQUNBVSxvQkFBUSxFQUFSO0FBQ0FELG9CQUFRLENBQVI7O0FBRUEsZ0JBQUlwWSxNQUFNQyxPQUFOLENBQWMrWCxHQUFkLENBQUosRUFBd0I7QUFDdEJVLHdCQUFRLEdBQVI7QUFDQVAsc0JBQU0sR0FBTjtBQUNBaFkseUJBQVM2WCxJQUFJN1gsTUFBYjtBQUNBLHVCQUFPaVksUUFBUWpZLE1BQWYsRUFBdUJpWSxPQUF2QixFQUFnQztBQUM5QkMsMEJBQU12WCxJQUFOLENBQ0VpWCxXQUFXQyxJQUFJSSxLQUFKLENBQVgsRUFBdUJJLFVBQXZCLEVBQW1DSixVQUFValksU0FBUyxDQUFuQixHQUF1QixDQUF2QixHQUEyQixDQUE5RCxLQUNFLE1BRko7QUFJRDtBQUNGLGFBVkQsTUFVTztBQUNMdVksd0JBQVEsR0FBUjtBQUNBUCxzQkFBTSxHQUFOO0FBQ0FJLHVCQUFPTSxPQUFPTixJQUFQLENBQVlQLEdBQVosQ0FBUDtBQUNBN1gseUJBQVNvWSxLQUFLcFksTUFBZDtBQUNBLHVCQUFPaVksUUFBUWpZLE1BQWYsRUFBdUJpWSxPQUF2QixFQUFnQztBQUM5QmpQLDBCQUFNb1AsS0FBS0gsS0FBTCxDQUFOO0FBQ0FFLDhCQUFVNVYsS0FBSzhVLFNBQUwsQ0FBZXJPLEdBQWYsSUFBc0IsSUFBaEM7QUFDQTZDLDRCQUFRK0wsV0FDTkMsSUFBSTdPLEdBQUosQ0FETSxFQUVOcVAsVUFGTSxFQUdORixRQUFRblksTUFBUixJQUFrQmlZLFVBQVVqWSxTQUFTLENBQW5CLEdBQXVCLENBQXZCLEdBQTJCLENBQTdDLENBSE0sQ0FBUjtBQUtBLHdCQUFJNkwsVUFBVWxJLFNBQWQsRUFBeUI7QUFDdkJ1VSw4QkFBTXZYLElBQU4sQ0FBV3dYLFVBQVV0TSxLQUFyQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxnQkFBSXFNLE1BQU1sWSxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsdUJBQU8sQ0FBQ3VZLEtBQUQsRUFBUWYsU0FBU1UsTUFBTW5OLElBQU4sQ0FBVyxRQUFRc04sVUFBbkIsQ0FBakIsRUFBaURMLEdBQWpELEVBQXNEak4sSUFBdEQsQ0FDTCxPQUFPK00sYUFERixDQUFQO0FBR0Q7QUFDRjs7QUFFRCxlQUFPekUsTUFBUDtBQUNELEtBeEVNLENBd0VKaUUsU0F4RUksRUF3RU8sRUF4RVAsRUF3RVcsQ0F4RVgsQ0FBUDtBQXlFRCxDQTFGRDs7QUE0RkEsU0FBU3FCLFVBQVQsQ0FBb0JkLEdBQXBCLEVBQXlCZSxTQUF6QixFQUFvQztBQUNoQyxRQUFNQyxTQUFTLEVBQWY7QUFDQSxTQUFLLElBQU03UCxHQUFYLElBQWtCNFAsU0FBbEIsRUFBNkI7QUFDekIsWUFBSWYsSUFBSTdPLEdBQUosTUFBYXJGLFNBQWpCLEVBQTRCO0FBQ3hCa1YsbUJBQU83UCxHQUFQLElBQWM2TyxJQUFJN08sR0FBSixDQUFkO0FBQ0g7QUFDSjtBQUNELFNBQUssSUFBTUEsSUFBWCxJQUFrQjZPLEdBQWxCLEVBQXVCO0FBQ25CLFlBQUlnQixPQUFPN1AsSUFBUCxNQUFnQnJGLFNBQXBCLEVBQStCO0FBQzNCa1YsbUJBQU83UCxJQUFQLElBQWM2TyxJQUFJN08sSUFBSixDQUFkO0FBQ0g7QUFDSjtBQUNELFdBQU82UCxNQUFQO0FBQ0g7QUFDRCxTQUFTcFEsTUFBVCxDQUFnQnhFLEtBQWhCLEVBQWtDO0FBQUEsUUFBWDZVLEtBQVcsdUVBQUgsQ0FBRzs7QUFDOUI3VSxZQUFRMFUsV0FBVzFVLEtBQVgsRUFBa0J1UyxHQUFHbEwsS0FBckIsQ0FBUjtBQUNBLFFBQUlySCxNQUFNSSxNQUFWLEVBQWtCO0FBQ2RKLGNBQU1JLE1BQU4sR0FBZUosTUFBTUksTUFBTixDQUFhaEUsR0FBYixDQUFpQjtBQUFBLG1CQUFTc1ksV0FBV3BYLEtBQVgsRUFBa0JpVixHQUFHalYsS0FBckIsQ0FBVDtBQUFBLFNBQWpCLENBQWY7QUFDSDtBQUNELFdBQU82ViwyQkFBMkJuVCxLQUEzQixFQUFrQyxFQUFFdVQsUUFBUXNCLEtBQVYsRUFBbEMsQ0FBUDtBQUNIOztBQUVELElBQUlDLGlCQUFpQixPQUFPQyxVQUFQLEtBQXNCLFdBQXRCLEdBQW9DQSxVQUFwQyxHQUFpRCxPQUFPalcsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsT0FBT2tXLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDLE9BQU9DLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEJBLElBQTlCLEdBQXFDLEVBQTdMOztBQUVBLFNBQVNDLG9CQUFULENBQThCQyxFQUE5QixFQUFrQztBQUNoQyxRQUFJQyxTQUFTLEVBQUVDLFNBQVMsRUFBWCxFQUFiO0FBQ0QsV0FBT0YsR0FBR0MsTUFBSCxFQUFXQSxPQUFPQyxPQUFsQixHQUE0QkQsT0FBT0MsT0FBMUM7QUFDQTs7QUFFRCxTQUFTQyxlQUFULENBQTBCNU8sTUFBMUIsRUFBa0M7QUFDakMsVUFBTSxJQUFJakksS0FBSixDQUFVLG9DQUFvQ2lJLE1BQXBDLEdBQTZDLHlJQUF2RCxDQUFOO0FBQ0E7O0FBRUQ7O0FBRUEsSUFBSTZPLFdBQVdMLHFCQUFxQixVQUFVRSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUM5RCxlQUFTRyxJQUFULEVBQWU7O0FBRWY7QUFDQSxZQUFJQyxjQUFjSixXQUNqQixDQUFDQSxRQUFRSyxRQURRLElBQ0lMLE9BRHRCO0FBRUEsWUFBSU0sYUFBYVAsVUFDaEIsQ0FBQ0EsT0FBT00sUUFEUSxJQUNJTixNQURyQjtBQUVBLFlBQUlRLGFBQWEsUUFBT2QsY0FBUCx5Q0FBT0EsY0FBUCxNQUF5QixRQUF6QixJQUFxQ0EsY0FBdEQ7QUFDQSxZQUNDYyxXQUFXWixNQUFYLEtBQXNCWSxVQUF0QixJQUNBQSxXQUFXOVcsTUFBWCxLQUFzQjhXLFVBRHRCLElBRUFBLFdBQVdYLElBQVgsS0FBb0JXLFVBSHJCLEVBSUU7QUFDREosbUJBQU9JLFVBQVA7QUFDQTs7QUFFRDs7Ozs7QUFLQSxZQUFJTCxRQUFKOzs7QUFFQTtBQUNBTSxpQkFBUyxVQUhUO0FBQUEsWUFHcUI7O0FBRXJCO0FBQ0FyRCxlQUFPLEVBTlA7QUFBQSxZQU9Bc0QsT0FBTyxDQVBQO0FBQUEsWUFRQUMsT0FBTyxFQVJQO0FBQUEsWUFTQUMsT0FBTyxFQVRQO0FBQUEsWUFVQUMsT0FBTyxHQVZQO0FBQUEsWUFXQUMsY0FBYyxFQVhkO0FBQUEsWUFZQUMsV0FBVyxHQVpYO0FBQUEsWUFZZ0I7QUFDaEJDLG9CQUFZLEdBYlo7QUFBQSxZQWFpQjs7QUFFakI7QUFDQUMsd0JBQWdCLE9BaEJoQjtBQUFBLFlBaUJBQyxnQkFBZ0IsY0FqQmhCO0FBQUEsWUFpQmdDO0FBQ2hDQywwQkFBa0IsMkJBbEJsQjtBQUFBLFlBa0IrQzs7QUFFL0M7QUFDQUMsaUJBQVM7QUFDUix3QkFBWSxpREFESjtBQUVSLHlCQUFhLGdEQUZMO0FBR1IsNkJBQWlCO0FBSFQsU0FyQlQ7OztBQTJCQTtBQUNBQyx3QkFBZ0JqRSxPQUFPc0QsSUE1QnZCO0FBQUEsWUE2QkFuRixRQUFRK0YsS0FBSy9GLEtBN0JiO0FBQUEsWUE4QkFnRyxxQkFBcUJDLE9BQU9DLFlBOUI1Qjs7O0FBZ0NBO0FBQ0E5UixXQWpDQTs7QUFtQ0E7O0FBRUE7Ozs7OztBQU1BLGlCQUFTaEYsS0FBVCxDQUFlVyxJQUFmLEVBQXFCO0FBQ3BCLGtCQUFNb1csV0FBV04sT0FBTzlWLElBQVAsQ0FBWCxDQUFOO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUUEsaUJBQVN0RSxHQUFULENBQWF5UyxLQUFiLEVBQW9Cc0csRUFBcEIsRUFBd0I7QUFDdkIsZ0JBQUlwWixTQUFTOFMsTUFBTTlTLE1BQW5CO0FBQ0EsZ0JBQUk2WSxTQUFTLEVBQWI7QUFDQSxtQkFBTzdZLFFBQVAsRUFBaUI7QUFDaEI2WSx1QkFBTzdZLE1BQVAsSUFBaUJvWixHQUFHdEcsTUFBTTlTLE1BQU4sQ0FBSCxDQUFqQjtBQUNBO0FBQ0QsbUJBQU82WSxNQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxpQkFBU21DLFNBQVQsQ0FBbUIzSCxNQUFuQixFQUEyQitGLEVBQTNCLEVBQStCO0FBQzlCLGdCQUFJclgsUUFBUXNSLE9BQU85UyxLQUFQLENBQWEsR0FBYixDQUFaO0FBQ0EsZ0JBQUlzWSxTQUFTLEVBQWI7QUFDQSxnQkFBSTlXLE1BQU0vQixNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDckI7QUFDQTtBQUNBNlkseUJBQVM5VyxNQUFNLENBQU4sSUFBVyxHQUFwQjtBQUNBc1IseUJBQVN0UixNQUFNLENBQU4sQ0FBVDtBQUNBO0FBQ0Q7QUFDQXNSLHFCQUFTQSxPQUFPN1MsT0FBUCxDQUFlZ2EsZUFBZixFQUFnQyxNQUFoQyxDQUFUO0FBQ0EsZ0JBQUlTLFNBQVM1SCxPQUFPOVMsS0FBUCxDQUFhLEdBQWIsQ0FBYjtBQUNBLGdCQUFJMmEsVUFBVTdhLElBQUk0YSxNQUFKLEVBQVk3QixFQUFaLEVBQWdCck8sSUFBaEIsQ0FBcUIsR0FBckIsQ0FBZDtBQUNBLG1CQUFPOE4sU0FBU3FDLE9BQWhCO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFhQSxpQkFBU0MsVUFBVCxDQUFvQjlILE1BQXBCLEVBQTRCO0FBQzNCLGdCQUFJK0gsU0FBUyxFQUFiO0FBQUEsZ0JBQ0lDLFVBQVUsQ0FEZDtBQUFBLGdCQUVJcmIsU0FBU3FULE9BQU9yVCxNQUZwQjtBQUFBLGdCQUdJNkwsS0FISjtBQUFBLGdCQUlJeVAsS0FKSjtBQUtBLG1CQUFPRCxVQUFVcmIsTUFBakIsRUFBeUI7QUFDeEI2TCx3QkFBUXdILE9BQU9rSSxVQUFQLENBQWtCRixTQUFsQixDQUFSO0FBQ0Esb0JBQUl4UCxTQUFTLE1BQVQsSUFBbUJBLFNBQVMsTUFBNUIsSUFBc0N3UCxVQUFVcmIsTUFBcEQsRUFBNEQ7QUFDM0Q7QUFDQXNiLDRCQUFRakksT0FBT2tJLFVBQVAsQ0FBa0JGLFNBQWxCLENBQVI7QUFDQSx3QkFBSSxDQUFDQyxRQUFRLE1BQVQsS0FBb0IsTUFBeEIsRUFBZ0M7QUFBRTtBQUNqQ0YsK0JBQU96YSxJQUFQLENBQVksQ0FBQyxDQUFDa0wsUUFBUSxLQUFULEtBQW1CLEVBQXBCLEtBQTJCeVAsUUFBUSxLQUFuQyxJQUE0QyxPQUF4RDtBQUNBLHFCQUZELE1BRU87QUFDTjtBQUNBO0FBQ0FGLCtCQUFPemEsSUFBUCxDQUFZa0wsS0FBWjtBQUNBd1A7QUFDQTtBQUNELGlCQVhELE1BV087QUFDTkQsMkJBQU96YSxJQUFQLENBQVlrTCxLQUFaO0FBQ0E7QUFDRDtBQUNELG1CQUFPdVAsTUFBUDtBQUNBOztBQUVEOzs7Ozs7OztBQVFBLGlCQUFTSSxVQUFULENBQW9CMUksS0FBcEIsRUFBMkI7QUFDMUIsbUJBQU96UyxJQUFJeVMsS0FBSixFQUFXLFVBQVNqSCxLQUFULEVBQWdCO0FBQ2pDLG9CQUFJdVAsU0FBUyxFQUFiO0FBQ0Esb0JBQUl2UCxRQUFRLE1BQVosRUFBb0I7QUFDbkJBLDZCQUFTLE9BQVQ7QUFDQXVQLDhCQUFVUixtQkFBbUIvTyxVQUFVLEVBQVYsR0FBZSxLQUFmLEdBQXVCLE1BQTFDLENBQVY7QUFDQUEsNEJBQVEsU0FBU0EsUUFBUSxLQUF6QjtBQUNBO0FBQ0R1UCwwQkFBVVIsbUJBQW1CL08sS0FBbkIsQ0FBVjtBQUNBLHVCQUFPdVAsTUFBUDtBQUNBLGFBVE0sRUFTSnJRLElBVEksQ0FTQyxFQVRELENBQVA7QUFVQTs7QUFFRDs7Ozs7Ozs7O0FBU0EsaUJBQVMwUSxZQUFULENBQXNCQyxTQUF0QixFQUFpQztBQUNoQyxnQkFBSUEsWUFBWSxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLHVCQUFPQSxZQUFZLEVBQW5CO0FBQ0E7QUFDRCxnQkFBSUEsWUFBWSxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLHVCQUFPQSxZQUFZLEVBQW5CO0FBQ0E7QUFDRCxnQkFBSUEsWUFBWSxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLHVCQUFPQSxZQUFZLEVBQW5CO0FBQ0E7QUFDRCxtQkFBT2pGLElBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxpQkFBU2tGLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCQyxJQUE3QixFQUFtQztBQUNsQztBQUNBO0FBQ0EsbUJBQU9ELFFBQVEsRUFBUixHQUFhLE1BQU1BLFFBQVEsRUFBZCxDQUFiLElBQWtDLENBQUNDLFFBQVEsQ0FBVCxLQUFlLENBQWpELENBQVA7QUFDQTs7QUFFRDs7Ozs7QUFLQSxpQkFBU0MsS0FBVCxDQUFlQyxLQUFmLEVBQXNCQyxTQUF0QixFQUFpQ0MsU0FBakMsRUFBNEM7QUFDM0MsZ0JBQUlDLElBQUksQ0FBUjtBQUNBSCxvQkFBUUUsWUFBWXJILE1BQU1tSCxRQUFRN0IsSUFBZCxDQUFaLEdBQWtDNkIsU0FBUyxDQUFuRDtBQUNBQSxxQkFBU25ILE1BQU1tSCxRQUFRQyxTQUFkLENBQVQ7QUFDQSxtQkFBSyx1QkFBeUJELFFBQVFyQixnQkFBZ0JWLElBQWhCLElBQXdCLENBQTlELEVBQWlFa0MsS0FBS3pGLElBQXRFLEVBQTRFO0FBQzNFc0Ysd0JBQVFuSCxNQUFNbUgsUUFBUXJCLGFBQWQsQ0FBUjtBQUNBO0FBQ0QsbUJBQU85RixNQUFNc0gsSUFBSSxDQUFDeEIsZ0JBQWdCLENBQWpCLElBQXNCcUIsS0FBdEIsSUFBK0JBLFFBQVE5QixJQUF2QyxDQUFWLENBQVA7QUFDQTs7QUFFRDs7Ozs7OztBQU9BLGlCQUFTa0MsTUFBVCxDQUFnQkMsS0FBaEIsRUFBdUI7QUFDdEI7QUFDQSxnQkFBSWhCLFNBQVMsRUFBYjtBQUFBLGdCQUNJaUIsY0FBY0QsTUFBTXBjLE1BRHhCO0FBQUEsZ0JBRUlzYyxHQUZKO0FBQUEsZ0JBR0kzYyxJQUFJLENBSFI7QUFBQSxnQkFJSTRjLElBQUluQyxRQUpSO0FBQUEsZ0JBS0lvQyxPQUFPckMsV0FMWDtBQUFBLGdCQU1Jc0MsS0FOSjtBQUFBLGdCQU9JQyxDQVBKO0FBQUEsZ0JBUUl6RSxLQVJKO0FBQUEsZ0JBU0kwRSxJQVRKO0FBQUEsZ0JBVUlDLENBVko7QUFBQSxnQkFXSVYsQ0FYSjtBQUFBLGdCQVlJTixLQVpKO0FBQUEsZ0JBYUlpQixDQWJKOztBQWNJO0FBQ0FDLHNCQWZKOztBQWlCQTtBQUNBO0FBQ0E7O0FBRUFMLG9CQUFRTCxNQUFNVyxXQUFOLENBQWtCMUMsU0FBbEIsQ0FBUjtBQUNBLGdCQUFJb0MsUUFBUSxDQUFaLEVBQWU7QUFDZEEsd0JBQVEsQ0FBUjtBQUNBOztBQUVELGlCQUFLQyxJQUFJLENBQVQsRUFBWUEsSUFBSUQsS0FBaEIsRUFBdUIsRUFBRUMsQ0FBekIsRUFBNEI7QUFDM0I7QUFDQSxvQkFBSU4sTUFBTWIsVUFBTixDQUFpQm1CLENBQWpCLEtBQXVCLElBQTNCLEVBQWlDO0FBQ2hDMVksMEJBQU0sV0FBTjtBQUNBO0FBQ0RvWCx1QkFBT3phLElBQVAsQ0FBWXliLE1BQU1iLFVBQU4sQ0FBaUJtQixDQUFqQixDQUFaO0FBQ0E7O0FBRUQ7QUFDQTs7QUFFQSxpQkFBS3pFLFFBQVF3RSxRQUFRLENBQVIsR0FBWUEsUUFBUSxDQUFwQixHQUF3QixDQUFyQyxFQUF3Q3hFLFFBQVFvRSxXQUFoRCxHQUE2RCx5QkFBMkI7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBS00sT0FBT2hkLENBQVAsRUFBVWlkLElBQUksQ0FBZCxFQUFpQlYsSUFBSXpGLElBQTFCLEdBQWdDLGtCQUFvQnlGLEtBQUt6RixJQUF6RCxFQUErRDs7QUFFOUQsd0JBQUl3QixTQUFTb0UsV0FBYixFQUEwQjtBQUN6QnJZLDhCQUFNLGVBQU47QUFDQTs7QUFFRDRYLDRCQUFRSCxhQUFhVyxNQUFNYixVQUFOLENBQWlCdEQsT0FBakIsQ0FBYixDQUFSOztBQUVBLHdCQUFJMkQsU0FBU25GLElBQVQsSUFBaUJtRixRQUFRaEgsTUFBTSxDQUFDa0YsU0FBU25hLENBQVYsSUFBZWlkLENBQXJCLENBQTdCLEVBQXNEO0FBQ3JENVksOEJBQU0sVUFBTjtBQUNBOztBQUVEckUseUJBQUtpYyxRQUFRZ0IsQ0FBYjtBQUNBQyx3QkFBSVgsS0FBS00sSUFBTCxHQUFZekMsSUFBWixHQUFvQm1DLEtBQUtNLE9BQU94QyxJQUFaLEdBQW1CQSxJQUFuQixHQUEwQmtDLElBQUlNLElBQXREOztBQUVBLHdCQUFJWixRQUFRaUIsQ0FBWixFQUFlO0FBQ2Q7QUFDQTs7QUFFREMsaUNBQWFyRyxPQUFPb0csQ0FBcEI7QUFDQSx3QkFBSUQsSUFBSWhJLE1BQU1rRixTQUFTZ0QsVUFBZixDQUFSLEVBQW9DO0FBQ25DOVksOEJBQU0sVUFBTjtBQUNBOztBQUVENFkseUJBQUtFLFVBQUw7QUFFQTs7QUFFRFIsc0JBQU1sQixPQUFPcGIsTUFBUCxHQUFnQixDQUF0QjtBQUNBd2MsdUJBQU9WLE1BQU1uYyxJQUFJZ2QsSUFBVixFQUFnQkwsR0FBaEIsRUFBcUJLLFFBQVEsQ0FBN0IsQ0FBUDs7QUFFQTtBQUNBO0FBQ0Esb0JBQUkvSCxNQUFNalYsSUFBSTJjLEdBQVYsSUFBaUJ4QyxTQUFTeUMsQ0FBOUIsRUFBaUM7QUFDaEN2WSwwQkFBTSxVQUFOO0FBQ0E7O0FBRUR1WSxxQkFBSzNILE1BQU1qVixJQUFJMmMsR0FBVixDQUFMO0FBQ0EzYyxxQkFBSzJjLEdBQUw7O0FBRUE7QUFDQWxCLHVCQUFPNEIsTUFBUCxDQUFjcmQsR0FBZCxFQUFtQixDQUFuQixFQUFzQjRjLENBQXRCO0FBRUE7O0FBRUQsbUJBQU9mLFdBQVdKLE1BQVgsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7O0FBT0EsaUJBQVM2QixNQUFULENBQWdCYixLQUFoQixFQUF1QjtBQUN0QixnQkFBSUcsQ0FBSjtBQUFBLGdCQUNJUixLQURKO0FBQUEsZ0JBRUltQixjQUZKO0FBQUEsZ0JBR0lDLFdBSEo7QUFBQSxnQkFJSVgsSUFKSjtBQUFBLGdCQUtJRSxDQUxKO0FBQUEsZ0JBTUlVLENBTko7QUFBQSxnQkFPSUMsQ0FQSjtBQUFBLGdCQVFJbkIsQ0FSSjtBQUFBLGdCQVNJVyxDQVRKO0FBQUEsZ0JBVUlTLFlBVko7QUFBQSxnQkFXSWxDLFNBQVMsRUFYYjs7QUFZSTtBQUNBaUIsdUJBYko7O0FBY0k7QUFDQWtCLGlDQWZKO0FBQUEsZ0JBZ0JJVCxVQWhCSjtBQUFBLGdCQWlCSVUsT0FqQko7O0FBbUJBO0FBQ0FwQixvQkFBUWpCLFdBQVdpQixLQUFYLENBQVI7O0FBRUE7QUFDQUMsMEJBQWNELE1BQU1wYyxNQUFwQjs7QUFFQTtBQUNBdWMsZ0JBQUluQyxRQUFKO0FBQ0EyQixvQkFBUSxDQUFSO0FBQ0FTLG1CQUFPckMsV0FBUDs7QUFFQTtBQUNBLGlCQUFLdUMsSUFBSSxDQUFULEVBQVlBLElBQUlMLFdBQWhCLEVBQTZCLEVBQUVLLENBQS9CLEVBQWtDO0FBQ2pDWSwrQkFBZWxCLE1BQU1NLENBQU4sQ0FBZjtBQUNBLG9CQUFJWSxlQUFlLElBQW5CLEVBQXlCO0FBQ3hCbEMsMkJBQU96YSxJQUFQLENBQVlpYSxtQkFBbUIwQyxZQUFuQixDQUFaO0FBQ0E7QUFDRDs7QUFFREosNkJBQWlCQyxjQUFjL0IsT0FBT3BiLE1BQXRDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBSW1kLFdBQUosRUFBaUI7QUFDaEIvQix1QkFBT3phLElBQVAsQ0FBWTBaLFNBQVo7QUFDQTs7QUFFRDtBQUNBLG1CQUFPNkMsaUJBQWlCYixXQUF4QixFQUFxQzs7QUFFcEM7QUFDQTtBQUNBLHFCQUFLZSxJQUFJdEQsTUFBSixFQUFZNEMsSUFBSSxDQUFyQixFQUF3QkEsSUFBSUwsV0FBNUIsRUFBeUMsRUFBRUssQ0FBM0MsRUFBOEM7QUFDN0NZLG1DQUFlbEIsTUFBTU0sQ0FBTixDQUFmO0FBQ0Esd0JBQUlZLGdCQUFnQmYsQ0FBaEIsSUFBcUJlLGVBQWVGLENBQXhDLEVBQTJDO0FBQzFDQSw0QkFBSUUsWUFBSjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBQyx3Q0FBd0JMLGlCQUFpQixDQUF6QztBQUNBLG9CQUFJRSxJQUFJYixDQUFKLEdBQVEzSCxNQUFNLENBQUNrRixTQUFTaUMsS0FBVixJQUFtQndCLHFCQUF6QixDQUFaLEVBQTZEO0FBQzVEdlosMEJBQU0sVUFBTjtBQUNBOztBQUVEK1gseUJBQVMsQ0FBQ3FCLElBQUliLENBQUwsSUFBVWdCLHFCQUFuQjtBQUNBaEIsb0JBQUlhLENBQUo7O0FBRUEscUJBQUtWLElBQUksQ0FBVCxFQUFZQSxJQUFJTCxXQUFoQixFQUE2QixFQUFFSyxDQUEvQixFQUFrQztBQUNqQ1ksbUNBQWVsQixNQUFNTSxDQUFOLENBQWY7O0FBRUEsd0JBQUlZLGVBQWVmLENBQWYsSUFBb0IsRUFBRVIsS0FBRixHQUFVakMsTUFBbEMsRUFBMEM7QUFDekM5Viw4QkFBTSxVQUFOO0FBQ0E7O0FBRUQsd0JBQUlzWixnQkFBZ0JmLENBQXBCLEVBQXVCO0FBQ3RCO0FBQ0EsNkJBQUtjLElBQUl0QixLQUFKLEVBQVdHLElBQUl6RixJQUFwQixHQUEwQixrQkFBb0J5RixLQUFLekYsSUFBbkQsRUFBeUQ7QUFDeERvRyxnQ0FBSVgsS0FBS00sSUFBTCxHQUFZekMsSUFBWixHQUFvQm1DLEtBQUtNLE9BQU94QyxJQUFaLEdBQW1CQSxJQUFuQixHQUEwQmtDLElBQUlNLElBQXREO0FBQ0EsZ0NBQUlhLElBQUlSLENBQVIsRUFBVztBQUNWO0FBQ0E7QUFDRFcsc0NBQVVILElBQUlSLENBQWQ7QUFDQUMseUNBQWFyRyxPQUFPb0csQ0FBcEI7QUFDQXpCLG1DQUFPemEsSUFBUCxDQUNDaWEsbUJBQW1CZSxhQUFha0IsSUFBSVcsVUFBVVYsVUFBM0IsRUFBdUMsQ0FBdkMsQ0FBbkIsQ0FERDtBQUdBTyxnQ0FBSXpJLE1BQU00SSxVQUFVVixVQUFoQixDQUFKO0FBQ0E7O0FBRUQxQiwrQkFBT3phLElBQVAsQ0FBWWlhLG1CQUFtQmUsYUFBYTBCLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBbkIsQ0FBWjtBQUNBYiwrQkFBT1YsTUFBTUMsS0FBTixFQUFhd0IscUJBQWIsRUFBb0NMLGtCQUFrQkMsV0FBdEQsQ0FBUDtBQUNBcEIsZ0NBQVEsQ0FBUjtBQUNBLDBCQUFFbUIsY0FBRjtBQUNBO0FBQ0Q7O0FBRUQsa0JBQUVuQixLQUFGO0FBQ0Esa0JBQUVRLENBQUY7QUFFQTtBQUNELG1CQUFPbkIsT0FBT3JRLElBQVAsQ0FBWSxFQUFaLENBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxpQkFBUzBTLFNBQVQsQ0FBbUJyQixLQUFuQixFQUEwQjtBQUN6QixtQkFBT3BCLFVBQVVvQixLQUFWLEVBQWlCLFVBQVMvSSxNQUFULEVBQWlCO0FBQ3hDLHVCQUFPaUgsY0FBY29ELElBQWQsQ0FBbUJySyxNQUFuQixJQUNKOEksT0FBTzlJLE9BQU92SSxLQUFQLENBQWEsQ0FBYixFQUFnQjZTLFdBQWhCLEVBQVAsQ0FESSxHQUVKdEssTUFGSDtBQUdBLGFBSk0sQ0FBUDtBQUtBOztBQUVEOzs7Ozs7Ozs7OztBQVdBLGlCQUFTdUssT0FBVCxDQUFpQnhCLEtBQWpCLEVBQXdCO0FBQ3ZCLG1CQUFPcEIsVUFBVW9CLEtBQVYsRUFBaUIsVUFBUy9JLE1BQVQsRUFBaUI7QUFDeEMsdUJBQU9rSCxjQUFjbUQsSUFBZCxDQUFtQnJLLE1BQW5CLElBQ0osU0FBUzRKLE9BQU81SixNQUFQLENBREwsR0FFSkEsTUFGSDtBQUdBLGFBSk0sQ0FBUDtBQUtBOztBQUVEOztBQUVBO0FBQ0FtRyxtQkFBVztBQUNWOzs7OztBQUtBLHVCQUFXLE9BTkQ7QUFPVjs7Ozs7OztBQU9BLG9CQUFRO0FBQ1AsMEJBQVUyQixVQURIO0FBRVAsMEJBQVVLO0FBRkgsYUFkRTtBQWtCVixzQkFBVVcsTUFsQkE7QUFtQlYsc0JBQVVjLE1BbkJBO0FBb0JWLHVCQUFXVyxPQXBCRDtBQXFCVix5QkFBYUg7QUFyQkgsU0FBWDs7QUF3QkE7QUFDQTtBQUNBO0FBQ0EsWUFBSS9ELGVBQWVFLFVBQW5CLEVBQStCO0FBQzlCLGdCQUFJUCxPQUFPQyxPQUFQLElBQWtCSSxXQUF0QixFQUFtQztBQUFFO0FBQ3BDRSwyQkFBV04sT0FBWCxHQUFxQkUsUUFBckI7QUFDQSxhQUZELE1BRU87QUFBRTtBQUNSLHFCQUFLeFEsR0FBTCxJQUFZd1EsUUFBWixFQUFzQjtBQUNyQkEsNkJBQVNxRSxjQUFULENBQXdCN1UsR0FBeEIsTUFBaUMwUSxZQUFZMVEsR0FBWixJQUFtQndRLFNBQVN4USxHQUFULENBQXBEO0FBQ0E7QUFDRDtBQUNELFNBUkQsTUFRTztBQUFFO0FBQ1J5USxpQkFBS0QsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQTtBQUVELEtBeGdCQSxFQXdnQkNULGNBeGdCRCxDQUFEO0FBeWdCQyxDQTFnQmMsQ0FBZjs7QUE0Z0JBLElBQUkrRSxPQUFPO0FBQ1RDLGNBQVUsa0JBQVNDLEdBQVQsRUFBYztBQUN0QixlQUFPLE9BQU9BLEdBQVAsS0FBZ0IsUUFBdkI7QUFDRCxLQUhRO0FBSVRDLGNBQVUsa0JBQVNELEdBQVQsRUFBYztBQUN0QixlQUFPLFFBQU9BLEdBQVAseUNBQU9BLEdBQVAsT0FBZ0IsUUFBaEIsSUFBNEJBLFFBQVEsSUFBM0M7QUFDRCxLQU5RO0FBT1RFLFlBQVEsZ0JBQVNGLEdBQVQsRUFBYztBQUNwQixlQUFPQSxRQUFRLElBQWY7QUFDRCxLQVRRO0FBVVRHLHVCQUFtQiwyQkFBU0gsR0FBVCxFQUFjO0FBQy9CLGVBQU9BLE9BQU8sSUFBZDtBQUNEO0FBWlEsQ0FBWDs7QUFlQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTSCxjQUFULENBQXdCaEcsR0FBeEIsRUFBNkJ1RyxJQUE3QixFQUFtQztBQUNqQyxXQUFPMUYsT0FBTzJGLFNBQVAsQ0FBaUJSLGNBQWpCLENBQWdDUyxJQUFoQyxDQUFxQ3pHLEdBQXJDLEVBQTBDdUcsSUFBMUMsQ0FBUDtBQUNEOztBQUVELElBQUlqQyxTQUFTLFNBQVRBLE1BQVMsQ0FBU29DLEVBQVQsRUFBYUMsR0FBYixFQUFrQkMsRUFBbEIsRUFBc0JsSCxPQUF0QixFQUErQjtBQUMxQ2lILFVBQU1BLE9BQU8sR0FBYjtBQUNBQyxTQUFLQSxNQUFNLEdBQVg7QUFDQSxRQUFJNUcsTUFBTSxFQUFWOztBQUVBLFFBQUksT0FBTzBHLEVBQVAsS0FBYyxRQUFkLElBQTBCQSxHQUFHdmUsTUFBSCxLQUFjLENBQTVDLEVBQStDO0FBQzdDLGVBQU82WCxHQUFQO0FBQ0Q7O0FBRUQsUUFBSTZHLFNBQVMsS0FBYjtBQUNBSCxTQUFLQSxHQUFHaGUsS0FBSCxDQUFTaWUsR0FBVCxDQUFMOztBQUVBLFFBQUlHLFVBQVUsSUFBZDtBQUNBLFFBQUlwSCxXQUFXLE9BQU9BLFFBQVFvSCxPQUFmLEtBQTJCLFFBQTFDLEVBQW9EO0FBQ2xEQSxrQkFBVXBILFFBQVFvSCxPQUFsQjtBQUNEOztBQUVELFFBQUlDLE1BQU1MLEdBQUd2ZSxNQUFiO0FBQ0E7QUFDQSxRQUFJMmUsVUFBVSxDQUFWLElBQWVDLE1BQU1ELE9BQXpCLEVBQWtDO0FBQ2hDQyxjQUFNRCxPQUFOO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJaGYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaWYsR0FBcEIsRUFBeUIsRUFBRWpmLENBQTNCLEVBQThCO0FBQzVCLFlBQUlrZixJQUFJTixHQUFHNWUsQ0FBSCxFQUFNYSxPQUFOLENBQWNrZSxNQUFkLEVBQXNCLEtBQXRCLENBQVI7QUFBQSxZQUNJSSxNQUFNRCxFQUFFbmUsT0FBRixDQUFVK2QsRUFBVixDQURWO0FBQUEsWUFFSU0sSUFGSjtBQUFBLFlBRVVDLElBRlY7QUFBQSxZQUVnQjlDLENBRmhCO0FBQUEsWUFFbUIrQyxDQUZuQjs7QUFJQSxZQUFJSCxPQUFPLENBQVgsRUFBYztBQUNaQyxtQkFBT0YsRUFBRTdULE1BQUYsQ0FBUyxDQUFULEVBQVk4VCxHQUFaLENBQVA7QUFDQUUsbUJBQU9ILEVBQUU3VCxNQUFGLENBQVM4VCxNQUFNLENBQWYsQ0FBUDtBQUNELFNBSEQsTUFHTztBQUNMQyxtQkFBT0YsQ0FBUDtBQUNBRyxtQkFBTyxFQUFQO0FBQ0Q7O0FBRUQ5QyxZQUFJZ0QsbUJBQW1CSCxJQUFuQixDQUFKO0FBQ0FFLFlBQUlDLG1CQUFtQkYsSUFBbkIsQ0FBSjs7QUFFQSxZQUFJLENBQUNuQixlQUFlaEcsR0FBZixFQUFvQnFFLENBQXBCLENBQUwsRUFBNkI7QUFDM0JyRSxnQkFBSXFFLENBQUosSUFBUytDLENBQVQ7QUFDRCxTQUZELE1BRU8sSUFBSXBmLE1BQU1DLE9BQU4sQ0FBYytYLElBQUlxRSxDQUFKLENBQWQsQ0FBSixFQUEyQjtBQUNoQ3JFLGdCQUFJcUUsQ0FBSixFQUFPdmIsSUFBUCxDQUFZc2UsQ0FBWjtBQUNELFNBRk0sTUFFQTtBQUNMcEgsZ0JBQUlxRSxDQUFKLElBQVMsQ0FBQ3JFLElBQUlxRSxDQUFKLENBQUQsRUFBUytDLENBQVQsQ0FBVDtBQUNEO0FBQ0Y7O0FBRUQsV0FBT3BILEdBQVA7QUFDRCxDQWpERDs7QUFtREE7O0FBRUEsSUFBSXNILHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQVNGLENBQVQsRUFBWTtBQUNuQyxtQkFBZUEsQ0FBZix5Q0FBZUEsQ0FBZjtBQUNFLGFBQUssUUFBTDtBQUNFLG1CQUFPQSxDQUFQOztBQUVGLGFBQUssU0FBTDtBQUNFLG1CQUFPQSxJQUFJLE1BQUosR0FBYSxPQUFwQjs7QUFFRixhQUFLLFFBQUw7QUFDRSxtQkFBT0csU0FBU0gsQ0FBVCxJQUFjQSxDQUFkLEdBQWtCLEVBQXpCOztBQUVGO0FBQ0UsbUJBQU8sRUFBUDtBQVhKO0FBYUQsQ0FkRDs7QUFnQkEsSUFBSWhDLFNBQVMsU0FBVEEsTUFBUyxDQUFTcEYsR0FBVCxFQUFjMkcsR0FBZCxFQUFtQkMsRUFBbkIsRUFBdUI5UyxJQUF2QixFQUE2QjtBQUN4QzZTLFVBQU1BLE9BQU8sR0FBYjtBQUNBQyxTQUFLQSxNQUFNLEdBQVg7QUFDQSxRQUFJNUcsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCQSxjQUFNbFUsU0FBTjtBQUNEOztBQUVELFFBQUksUUFBT2tVLEdBQVAseUNBQU9BLEdBQVAsT0FBZSxRQUFuQixFQUE2QjtBQUMzQixlQUFPYSxPQUFPTixJQUFQLENBQVlQLEdBQVosRUFBaUJ4WCxHQUFqQixDQUFxQixVQUFTNmIsQ0FBVCxFQUFZO0FBQ3RDLGdCQUFJbUQsS0FBS0MsbUJBQW1CSCxtQkFBbUJqRCxDQUFuQixDQUFuQixJQUE0Q3VDLEVBQXJEO0FBQ0EsZ0JBQUk1ZSxNQUFNQyxPQUFOLENBQWMrWCxJQUFJcUUsQ0FBSixDQUFkLENBQUosRUFBMkI7QUFDekIsdUJBQU9yRSxJQUFJcUUsQ0FBSixFQUFPN2IsR0FBUCxDQUFXLFVBQVM0ZSxDQUFULEVBQVk7QUFDNUIsMkJBQU9JLEtBQUtDLG1CQUFtQkgsbUJBQW1CRixDQUFuQixDQUFuQixDQUFaO0FBQ0QsaUJBRk0sRUFFSmxVLElBRkksQ0FFQ3lULEdBRkQsQ0FBUDtBQUdELGFBSkQsTUFJTztBQUNMLHVCQUFPYSxLQUFLQyxtQkFBbUJILG1CQUFtQnRILElBQUlxRSxDQUFKLENBQW5CLENBQW5CLENBQVo7QUFDRDtBQUNGLFNBVE0sRUFTSm5SLElBVEksQ0FTQ3lULEdBVEQsQ0FBUDtBQVdEOztBQUVELFFBQUksQ0FBQzdTLElBQUwsRUFBVyxPQUFPLEVBQVA7QUFDWCxXQUFPMlQsbUJBQW1CSCxtQkFBbUJ4VCxJQUFuQixDQUFuQixJQUErQzhTLEVBQS9DLEdBQ0FhLG1CQUFtQkgsbUJBQW1CdEgsR0FBbkIsQ0FBbkIsQ0FEUDtBQUVELENBeEJEOztBQTBCQSxJQUFJMEgsY0FBY3BHLHFCQUFxQixVQUFVRSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjs7QUFFbEVBLFlBQVE2QyxNQUFSLEdBQWlCN0MsUUFBUTlXLEtBQVIsR0FBZ0IyWixNQUFqQztBQUNBN0MsWUFBUTJELE1BQVIsR0FBaUIzRCxRQUFRakMsU0FBUixHQUFvQjRGLE1BQXJDO0FBQ0MsQ0FKaUIsQ0FBbEI7O0FBTUEsSUFBSXphLFFBQVFnZCxRQUFaO0FBQ0EsSUFBSW5kLFVBQVVvZCxVQUFkO0FBQ0EsSUFBSUMsZ0JBQWdCQyxnQkFBcEI7QUFDQSxJQUFJQyxXQUFXQyxTQUFmOztBQUVBLElBQUlDLFFBQVFDLEdBQVo7O0FBRUEsU0FBU0EsR0FBVCxHQUFlO0FBQ2IsU0FBS0MsUUFBTCxHQUFnQixJQUFoQjtBQUNBLFNBQUtDLE9BQUwsR0FBZSxJQUFmO0FBQ0EsU0FBS0MsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLamEsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLa2EsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsU0FBS0MsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLQyxNQUFMLEdBQWMsSUFBZDtBQUNBLFNBQUtDLEtBQUwsR0FBYSxJQUFiO0FBQ0EsU0FBSzFWLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxTQUFLakosSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLWCxJQUFMLEdBQVksSUFBWjtBQUNEOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxJQUFJdWYsa0JBQWtCLG1CQUF0QjtBQUFBLElBQ0lDLGNBQWMsVUFEbEI7OztBQUdJO0FBQ0FDLG9CQUFvQixvQ0FKeEI7OztBQU1JO0FBQ0E7QUFDQUMsU0FBUyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixFQUFxQixHQUFyQixFQUEwQixJQUExQixFQUFnQyxJQUFoQyxFQUFzQyxJQUF0QyxDQVJiOzs7QUFVSTtBQUNBQyxTQUFTLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLElBQWhCLEVBQXNCLEdBQXRCLEVBQTJCLEdBQTNCLEVBQWdDNUwsTUFBaEMsQ0FBdUMyTCxNQUF2QyxDQVhiOzs7QUFhSTtBQUNBRSxhQUFhLENBQUMsSUFBRCxFQUFPN0wsTUFBUCxDQUFjNEwsTUFBZCxDQWRqQjs7QUFlSTtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxlQUFlLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCOUwsTUFBMUIsQ0FBaUM2TCxVQUFqQyxDQW5CbkI7QUFBQSxJQW9CSUUsa0JBQWtCLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLENBcEJ0QjtBQUFBLElBcUJJQyxpQkFBaUIsR0FyQnJCO0FBQUEsSUFzQklDLHNCQUFzQix3QkF0QjFCO0FBQUEsSUF1QklDLG9CQUFvQiw4QkF2QnhCOztBQXdCSTtBQUNBQyxpQkFBaUI7QUFDZixrQkFBYyxJQURDO0FBRWYsbUJBQWU7QUFGQSxDQXpCckI7O0FBNkJJO0FBQ0FDLG1CQUFtQjtBQUNqQixrQkFBYyxJQURHO0FBRWpCLG1CQUFlO0FBRkUsQ0E5QnZCOztBQWtDSTtBQUNBQyxrQkFBa0I7QUFDaEIsWUFBUSxJQURRO0FBRWhCLGFBQVMsSUFGTztBQUdoQixXQUFPLElBSFM7QUFJaEIsY0FBVSxJQUpNO0FBS2hCLFlBQVEsSUFMUTtBQU1oQixhQUFTLElBTk87QUFPaEIsY0FBVSxJQVBNO0FBUWhCLFlBQVEsSUFSUTtBQVNoQixlQUFXLElBVEs7QUFVaEIsYUFBUztBQVZPLENBbkN0Qjs7QUFnREEsU0FBUzdCLFFBQVQsQ0FBa0I3ZCxHQUFsQixFQUF1QjJmLGdCQUF2QixFQUF5Q0MsaUJBQXpDLEVBQTREO0FBQzFELFFBQUk1ZixPQUFPbWMsS0FBS0csUUFBTCxDQUFjdGMsR0FBZCxDQUFQLElBQTZCQSxlQUFlb2UsR0FBaEQsRUFBcUQsT0FBT3BlLEdBQVA7O0FBRXJELFFBQUk2ZixJQUFJLElBQUl6QixHQUFKLEVBQVI7QUFDQXlCLE1BQUVoZixLQUFGLENBQVFiLEdBQVIsRUFBYTJmLGdCQUFiLEVBQStCQyxpQkFBL0I7QUFDQSxXQUFPQyxDQUFQO0FBQ0Q7O0FBRUR6QixJQUFJMUIsU0FBSixDQUFjN2IsS0FBZCxHQUFzQixVQUFTYixHQUFULEVBQWMyZixnQkFBZCxFQUFnQ0MsaUJBQWhDLEVBQW1EO0FBQ3ZFLFFBQUksQ0FBQ3pELEtBQUtDLFFBQUwsQ0FBY3BjLEdBQWQsQ0FBTCxFQUF5QjtBQUN2QixjQUFNLElBQUk4ZixTQUFKLENBQWMsbURBQWtEOWYsR0FBbEQseUNBQWtEQSxHQUFsRCxFQUFkLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUFJK2YsYUFBYS9mLElBQUlqQixPQUFKLENBQVksR0FBWixDQUFqQjtBQUFBLFFBQ0lpaEIsV0FDS0QsZUFBZSxDQUFDLENBQWhCLElBQXFCQSxhQUFhL2YsSUFBSWpCLE9BQUosQ0FBWSxHQUFaLENBQW5DLEdBQXVELEdBQXZELEdBQTZELEdBRnJFO0FBQUEsUUFHSWtoQixTQUFTamdCLElBQUlwQixLQUFKLENBQVVvaEIsUUFBVixDQUhiO0FBQUEsUUFJSUUsYUFBYSxLQUpqQjtBQUtBRCxXQUFPLENBQVAsSUFBWUEsT0FBTyxDQUFQLEVBQVVwaEIsT0FBVixDQUFrQnFoQixVQUFsQixFQUE4QixHQUE5QixDQUFaO0FBQ0FsZ0IsVUFBTWlnQixPQUFPN1csSUFBUCxDQUFZNFcsUUFBWixDQUFOOztBQUVBLFFBQUlHLE9BQU9uZ0IsR0FBWDs7QUFFQTtBQUNBO0FBQ0FtZ0IsV0FBT0EsS0FBS0MsSUFBTCxFQUFQOztBQUVBLFFBQUksQ0FBQ1IsaUJBQUQsSUFBc0I1ZixJQUFJcEIsS0FBSixDQUFVLEdBQVYsRUFBZVAsTUFBZixLQUEwQixDQUFwRCxFQUF1RDtBQUNyRDtBQUNBLFlBQUlnaUIsYUFBYXRCLGtCQUFrQnVCLElBQWxCLENBQXVCSCxJQUF2QixDQUFqQjtBQUNBLFlBQUlFLFVBQUosRUFBZ0I7QUFDZCxpQkFBS3BnQixJQUFMLEdBQVlrZ0IsSUFBWjtBQUNBLGlCQUFLN2dCLElBQUwsR0FBWTZnQixJQUFaO0FBQ0EsaUJBQUtqWCxRQUFMLEdBQWdCbVgsV0FBVyxDQUFYLENBQWhCO0FBQ0EsZ0JBQUlBLFdBQVcsQ0FBWCxDQUFKLEVBQW1CO0FBQ2pCLHFCQUFLMUIsTUFBTCxHQUFjMEIsV0FBVyxDQUFYLENBQWQ7QUFDQSxvQkFBSVYsZ0JBQUosRUFBc0I7QUFDcEIseUJBQUtmLEtBQUwsR0FBYWhCLFlBQVkvYyxLQUFaLENBQWtCLEtBQUs4ZCxNQUFMLENBQVl0VixNQUFaLENBQW1CLENBQW5CLENBQWxCLENBQWI7QUFDRCxpQkFGRCxNQUVPO0FBQ0wseUJBQUt1VixLQUFMLEdBQWEsS0FBS0QsTUFBTCxDQUFZdFYsTUFBWixDQUFtQixDQUFuQixDQUFiO0FBQ0Q7QUFDRixhQVBELE1BT08sSUFBSXNXLGdCQUFKLEVBQXNCO0FBQzNCLHFCQUFLaEIsTUFBTCxHQUFjLEVBQWQ7QUFDQSxxQkFBS0MsS0FBTCxHQUFhLEVBQWI7QUFDRDtBQUNELG1CQUFPLElBQVA7QUFDRDtBQUNGOztBQUVELFFBQUkyQixRQUFRMUIsZ0JBQWdCeUIsSUFBaEIsQ0FBcUJILElBQXJCLENBQVo7QUFDQSxRQUFJSSxLQUFKLEVBQVc7QUFDVEEsZ0JBQVFBLE1BQU0sQ0FBTixDQUFSO0FBQ0EsWUFBSUMsYUFBYUQsTUFBTXZFLFdBQU4sRUFBakI7QUFDQSxhQUFLcUMsUUFBTCxHQUFnQm1DLFVBQWhCO0FBQ0FMLGVBQU9BLEtBQUs5VyxNQUFMLENBQVlrWCxNQUFNbGlCLE1BQWxCLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUl1aEIscUJBQXFCVyxLQUFyQixJQUE4QkosS0FBSzlmLEtBQUwsQ0FBVyxzQkFBWCxDQUFsQyxFQUFzRTtBQUNwRSxZQUFJaWUsVUFBVTZCLEtBQUs5VyxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsTUFBc0IsSUFBcEM7QUFDQSxZQUFJaVYsV0FBVyxFQUFFaUMsU0FBU2QsaUJBQWlCYyxLQUFqQixDQUFYLENBQWYsRUFBb0Q7QUFDbERKLG1CQUFPQSxLQUFLOVcsTUFBTCxDQUFZLENBQVosQ0FBUDtBQUNBLGlCQUFLaVYsT0FBTCxHQUFlLElBQWY7QUFDRDtBQUNGOztBQUVELFFBQUksQ0FBQ21CLGlCQUFpQmMsS0FBakIsQ0FBRCxLQUNDakMsV0FBWWlDLFNBQVMsQ0FBQ2IsZ0JBQWdCYSxLQUFoQixDQUR2QixDQUFKLEVBQ3FEOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFJRSxVQUFVLENBQUMsQ0FBZjtBQUNBLGFBQUssSUFBSXppQixJQUFJLENBQWIsRUFBZ0JBLElBQUlvaEIsZ0JBQWdCL2dCLE1BQXBDLEVBQTRDTCxHQUE1QyxFQUFpRDtBQUMvQyxnQkFBSTBpQixNQUFNUCxLQUFLcGhCLE9BQUwsQ0FBYXFnQixnQkFBZ0JwaEIsQ0FBaEIsQ0FBYixDQUFWO0FBQ0EsZ0JBQUkwaUIsUUFBUSxDQUFDLENBQVQsS0FBZUQsWUFBWSxDQUFDLENBQWIsSUFBa0JDLE1BQU1ELE9BQXZDLENBQUosRUFDRUEsVUFBVUMsR0FBVjtBQUNIOztBQUVEO0FBQ0E7QUFDQSxZQUFJbkMsSUFBSixFQUFVb0MsTUFBVjtBQUNBLFlBQUlGLFlBQVksQ0FBQyxDQUFqQixFQUFvQjtBQUNsQjtBQUNBRSxxQkFBU1IsS0FBSy9FLFdBQUwsQ0FBaUIsR0FBakIsQ0FBVDtBQUNELFNBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQXVGLHFCQUFTUixLQUFLL0UsV0FBTCxDQUFpQixHQUFqQixFQUFzQnFGLE9BQXRCLENBQVQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsWUFBSUUsV0FBVyxDQUFDLENBQWhCLEVBQW1CO0FBQ2pCcEMsbUJBQU80QixLQUFLaFgsS0FBTCxDQUFXLENBQVgsRUFBY3dYLE1BQWQsQ0FBUDtBQUNBUixtQkFBT0EsS0FBS2hYLEtBQUwsQ0FBV3dYLFNBQVMsQ0FBcEIsQ0FBUDtBQUNBLGlCQUFLcEMsSUFBTCxHQUFZaEIsbUJBQW1CZ0IsSUFBbkIsQ0FBWjtBQUNEOztBQUVEO0FBQ0FrQyxrQkFBVSxDQUFDLENBQVg7QUFDQSxhQUFLLElBQUl6aUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbWhCLGFBQWE5Z0IsTUFBakMsRUFBeUNMLEdBQXpDLEVBQThDO0FBQzVDLGdCQUFJMGlCLE1BQU1QLEtBQUtwaEIsT0FBTCxDQUFhb2dCLGFBQWFuaEIsQ0FBYixDQUFiLENBQVY7QUFDQSxnQkFBSTBpQixRQUFRLENBQUMsQ0FBVCxLQUFlRCxZQUFZLENBQUMsQ0FBYixJQUFrQkMsTUFBTUQsT0FBdkMsQ0FBSixFQUNFQSxVQUFVQyxHQUFWO0FBQ0g7QUFDRDtBQUNBLFlBQUlELFlBQVksQ0FBQyxDQUFqQixFQUNFQSxVQUFVTixLQUFLOWhCLE1BQWY7O0FBRUYsYUFBS2lHLElBQUwsR0FBWTZiLEtBQUtoWCxLQUFMLENBQVcsQ0FBWCxFQUFjc1gsT0FBZCxDQUFaO0FBQ0FOLGVBQU9BLEtBQUtoWCxLQUFMLENBQVdzWCxPQUFYLENBQVA7O0FBRUE7QUFDQSxhQUFLRyxTQUFMOztBQUVBO0FBQ0E7QUFDQSxhQUFLbkMsUUFBTCxHQUFnQixLQUFLQSxRQUFMLElBQWlCLEVBQWpDOztBQUVBO0FBQ0E7QUFDQSxZQUFJb0MsZUFBZSxLQUFLcEMsUUFBTCxDQUFjLENBQWQsTUFBcUIsR0FBckIsSUFDZixLQUFLQSxRQUFMLENBQWMsS0FBS0EsUUFBTCxDQUFjcGdCLE1BQWQsR0FBdUIsQ0FBckMsTUFBNEMsR0FEaEQ7O0FBR0E7QUFDQSxZQUFJLENBQUN3aUIsWUFBTCxFQUFtQjtBQUNqQixnQkFBSUMsWUFBWSxLQUFLckMsUUFBTCxDQUFjN2YsS0FBZCxDQUFvQixJQUFwQixDQUFoQjtBQUNBLGlCQUFLLElBQUlaLElBQUksQ0FBUixFQUFXZ0csSUFBSThjLFVBQVV6aUIsTUFBOUIsRUFBc0NMLElBQUlnRyxDQUExQyxFQUE2Q2hHLEdBQTdDLEVBQWtEO0FBQ2hELG9CQUFJK2lCLE9BQU9ELFVBQVU5aUIsQ0FBVixDQUFYO0FBQ0Esb0JBQUksQ0FBQytpQixJQUFMLEVBQVc7QUFDWCxvQkFBSSxDQUFDQSxLQUFLMWdCLEtBQUwsQ0FBV2lmLG1CQUFYLENBQUwsRUFBc0M7QUFDcEMsd0JBQUkwQixVQUFVLEVBQWQ7QUFDQSx5QkFBSyxJQUFJakcsSUFBSSxDQUFSLEVBQVdSLElBQUl3RyxLQUFLMWlCLE1BQXpCLEVBQWlDMGMsSUFBSVIsQ0FBckMsRUFBd0NRLEdBQXhDLEVBQTZDO0FBQzNDLDRCQUFJZ0csS0FBS25ILFVBQUwsQ0FBZ0JtQixDQUFoQixJQUFxQixHQUF6QixFQUE4QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQWlHLHVDQUFXLEdBQVg7QUFDRCx5QkFMRCxNQUtPO0FBQ0xBLHVDQUFXRCxLQUFLaEcsQ0FBTCxDQUFYO0FBQ0Q7QUFDRjtBQUNEO0FBQ0Esd0JBQUksQ0FBQ2lHLFFBQVEzZ0IsS0FBUixDQUFjaWYsbUJBQWQsQ0FBTCxFQUF5QztBQUN2Qyw0QkFBSTJCLGFBQWFILFVBQVUzWCxLQUFWLENBQWdCLENBQWhCLEVBQW1CbkwsQ0FBbkIsQ0FBakI7QUFDQSw0QkFBSWtqQixVQUFVSixVQUFVM1gsS0FBVixDQUFnQm5MLElBQUksQ0FBcEIsQ0FBZDtBQUNBLDRCQUFJbWpCLE1BQU1KLEtBQUsxZ0IsS0FBTCxDQUFXa2YsaUJBQVgsQ0FBVjtBQUNBLDRCQUFJNEIsR0FBSixFQUFTO0FBQ1BGLHVDQUFXamlCLElBQVgsQ0FBZ0JtaUIsSUFBSSxDQUFKLENBQWhCO0FBQ0FELG9DQUFRRSxPQUFSLENBQWdCRCxJQUFJLENBQUosQ0FBaEI7QUFDRDtBQUNELDRCQUFJRCxRQUFRN2lCLE1BQVosRUFBb0I7QUFDbEI4aEIsbUNBQU8sTUFBTWUsUUFBUTlYLElBQVIsQ0FBYSxHQUFiLENBQU4sR0FBMEIrVyxJQUFqQztBQUNEO0FBQ0QsNkJBQUsxQixRQUFMLEdBQWdCd0MsV0FBVzdYLElBQVgsQ0FBZ0IsR0FBaEIsQ0FBaEI7QUFDQTtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFlBQUksS0FBS3FWLFFBQUwsQ0FBY3BnQixNQUFkLEdBQXVCZ2hCLGNBQTNCLEVBQTJDO0FBQ3pDLGlCQUFLWixRQUFMLEdBQWdCLEVBQWhCO0FBQ0QsU0FGRCxNQUVPO0FBQ0w7QUFDQSxpQkFBS0EsUUFBTCxHQUFnQixLQUFLQSxRQUFMLENBQWN6QyxXQUFkLEVBQWhCO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDNkUsWUFBTCxFQUFtQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFLcEMsUUFBTCxHQUFnQjVHLFNBQVNvRSxPQUFULENBQWlCLEtBQUt3QyxRQUF0QixDQUFoQjtBQUNEOztBQUVELFlBQUk0QyxJQUFJLEtBQUs3QyxJQUFMLEdBQVksTUFBTSxLQUFLQSxJQUF2QixHQUE4QixFQUF0QztBQUNBLFlBQUk4QyxJQUFJLEtBQUs3QyxRQUFMLElBQWlCLEVBQXpCO0FBQ0EsYUFBS25hLElBQUwsR0FBWWdkLElBQUlELENBQWhCO0FBQ0EsYUFBSy9oQixJQUFMLElBQWEsS0FBS2dGLElBQWxCOztBQUVBO0FBQ0E7QUFDQSxZQUFJdWMsWUFBSixFQUFrQjtBQUNoQixpQkFBS3BDLFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxDQUFjcFYsTUFBZCxDQUFxQixDQUFyQixFQUF3QixLQUFLb1YsUUFBTCxDQUFjcGdCLE1BQWQsR0FBdUIsQ0FBL0MsQ0FBaEI7QUFDQSxnQkFBSThoQixLQUFLLENBQUwsTUFBWSxHQUFoQixFQUFxQjtBQUNuQkEsdUJBQU8sTUFBTUEsSUFBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsUUFBSSxDQUFDWCxlQUFlZ0IsVUFBZixDQUFMLEVBQWlDOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxhQUFLLElBQUl4aUIsSUFBSSxDQUFSLEVBQVdnRyxJQUFJa2IsV0FBVzdnQixNQUEvQixFQUF1Q0wsSUFBSWdHLENBQTNDLEVBQThDaEcsR0FBOUMsRUFBbUQ7QUFDakQsZ0JBQUl1akIsS0FBS3JDLFdBQVdsaEIsQ0FBWCxDQUFUO0FBQ0EsZ0JBQUltaUIsS0FBS3BoQixPQUFMLENBQWF3aUIsRUFBYixNQUFxQixDQUFDLENBQTFCLEVBQ0U7QUFDRixnQkFBSUMsTUFBTTdELG1CQUFtQjRELEVBQW5CLENBQVY7QUFDQSxnQkFBSUMsUUFBUUQsRUFBWixFQUFnQjtBQUNkQyxzQkFBTUMsT0FBT0YsRUFBUCxDQUFOO0FBQ0Q7QUFDRHBCLG1CQUFPQSxLQUFLdmhCLEtBQUwsQ0FBVzJpQixFQUFYLEVBQWVuWSxJQUFmLENBQW9Cb1ksR0FBcEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBR0Q7QUFDQSxRQUFJOUMsT0FBT3lCLEtBQUtwaEIsT0FBTCxDQUFhLEdBQWIsQ0FBWDtBQUNBLFFBQUkyZixTQUFTLENBQUMsQ0FBZCxFQUFpQjtBQUNmO0FBQ0EsYUFBS0EsSUFBTCxHQUFZeUIsS0FBSzlXLE1BQUwsQ0FBWXFWLElBQVosQ0FBWjtBQUNBeUIsZUFBT0EsS0FBS2hYLEtBQUwsQ0FBVyxDQUFYLEVBQWN1VixJQUFkLENBQVA7QUFDRDtBQUNELFFBQUlnRCxLQUFLdkIsS0FBS3BoQixPQUFMLENBQWEsR0FBYixDQUFUO0FBQ0EsUUFBSTJpQixPQUFPLENBQUMsQ0FBWixFQUFlO0FBQ2IsYUFBSy9DLE1BQUwsR0FBY3dCLEtBQUs5VyxNQUFMLENBQVlxWSxFQUFaLENBQWQ7QUFDQSxhQUFLOUMsS0FBTCxHQUFhdUIsS0FBSzlXLE1BQUwsQ0FBWXFZLEtBQUssQ0FBakIsQ0FBYjtBQUNBLFlBQUkvQixnQkFBSixFQUFzQjtBQUNwQixpQkFBS2YsS0FBTCxHQUFhaEIsWUFBWS9jLEtBQVosQ0FBa0IsS0FBSytkLEtBQXZCLENBQWI7QUFDRDtBQUNEdUIsZUFBT0EsS0FBS2hYLEtBQUwsQ0FBVyxDQUFYLEVBQWN1WSxFQUFkLENBQVA7QUFDRCxLQVBELE1BT08sSUFBSS9CLGdCQUFKLEVBQXNCO0FBQzNCO0FBQ0EsYUFBS2hCLE1BQUwsR0FBYyxFQUFkO0FBQ0EsYUFBS0MsS0FBTCxHQUFhLEVBQWI7QUFDRDtBQUNELFFBQUl1QixJQUFKLEVBQVUsS0FBS2pYLFFBQUwsR0FBZ0JpWCxJQUFoQjtBQUNWLFFBQUlULGdCQUFnQmMsVUFBaEIsS0FDQSxLQUFLL0IsUUFETCxJQUNpQixDQUFDLEtBQUt2VixRQUQzQixFQUNxQztBQUNuQyxhQUFLQSxRQUFMLEdBQWdCLEdBQWhCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLEtBQUtBLFFBQUwsSUFBaUIsS0FBS3lWLE1BQTFCLEVBQWtDO0FBQ2hDLFlBQUkwQyxJQUFJLEtBQUtuWSxRQUFMLElBQWlCLEVBQXpCO0FBQ0EsWUFBSXlZLElBQUksS0FBS2hELE1BQUwsSUFBZSxFQUF2QjtBQUNBLGFBQUsxZSxJQUFMLEdBQVlvaEIsSUFBSU0sQ0FBaEI7QUFDRDs7QUFFRDtBQUNBLFNBQUtyaUIsSUFBTCxHQUFZLEtBQUt3SCxNQUFMLEVBQVo7QUFDQSxXQUFPLElBQVA7QUFDRCxDQW5RRDs7QUFxUUE7QUFDQSxTQUFTb1gsU0FBVCxDQUFtQmhJLEdBQW5CLEVBQXdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSWlHLEtBQUtDLFFBQUwsQ0FBY2xHLEdBQWQsQ0FBSixFQUF3QkEsTUFBTTJILFNBQVMzSCxHQUFULENBQU47QUFDeEIsUUFBSSxFQUFFQSxlQUFla0ksR0FBakIsQ0FBSixFQUEyQixPQUFPQSxJQUFJMUIsU0FBSixDQUFjNVYsTUFBZCxDQUFxQjZWLElBQXJCLENBQTBCekcsR0FBMUIsQ0FBUDtBQUMzQixXQUFPQSxJQUFJcFAsTUFBSixFQUFQO0FBQ0Q7O0FBRURzWCxJQUFJMUIsU0FBSixDQUFjNVYsTUFBZCxHQUF1QixZQUFXO0FBQ2hDLFFBQUl5WCxPQUFPLEtBQUtBLElBQUwsSUFBYSxFQUF4QjtBQUNBLFFBQUlBLElBQUosRUFBVTtBQUNSQSxlQUFPWixtQkFBbUJZLElBQW5CLENBQVA7QUFDQUEsZUFBT0EsS0FBSzFmLE9BQUwsQ0FBYSxNQUFiLEVBQXFCLEdBQXJCLENBQVA7QUFDQTBmLGdCQUFRLEdBQVI7QUFDRDs7QUFFRCxRQUFJRixXQUFXLEtBQUtBLFFBQUwsSUFBaUIsRUFBaEM7QUFBQSxRQUNJblYsV0FBVyxLQUFLQSxRQUFMLElBQWlCLEVBRGhDO0FBQUEsUUFFSXdWLE9BQU8sS0FBS0EsSUFBTCxJQUFhLEVBRnhCO0FBQUEsUUFHSXBhLE9BQU8sS0FIWDtBQUFBLFFBSUlzYSxRQUFRLEVBSlo7O0FBTUEsUUFBSSxLQUFLdGEsSUFBVCxFQUFlO0FBQ2JBLGVBQU9pYSxPQUFPLEtBQUtqYSxJQUFuQjtBQUNELEtBRkQsTUFFTyxJQUFJLEtBQUttYSxRQUFULEVBQW1CO0FBQ3hCbmEsZUFBT2lhLFFBQVEsS0FBS0UsUUFBTCxDQUFjMWYsT0FBZCxDQUFzQixHQUF0QixNQUErQixDQUFDLENBQWhDLEdBQ1gsS0FBSzBmLFFBRE0sR0FFWCxNQUFNLEtBQUtBLFFBQVgsR0FBc0IsR0FGbkIsQ0FBUDtBQUdBLFlBQUksS0FBS0QsSUFBVCxFQUFlO0FBQ2JsYSxvQkFBUSxNQUFNLEtBQUtrYSxJQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSSxLQUFLSSxLQUFMLElBQ0F6QyxLQUFLRyxRQUFMLENBQWMsS0FBS3NDLEtBQW5CLENBREEsSUFFQTdILE9BQU9OLElBQVAsQ0FBWSxLQUFLbUksS0FBakIsRUFBd0J2Z0IsTUFGNUIsRUFFb0M7QUFDbEN1Z0IsZ0JBQVFoQixZQUFZbEksU0FBWixDQUFzQixLQUFLa0osS0FBM0IsQ0FBUjtBQUNEOztBQUVELFFBQUlELFNBQVMsS0FBS0EsTUFBTCxJQUFnQkMsU0FBVSxNQUFNQSxLQUFoQyxJQUEyQyxFQUF4RDs7QUFFQSxRQUFJUCxZQUFZQSxTQUFTaFYsTUFBVCxDQUFnQixDQUFDLENBQWpCLE1BQXdCLEdBQXhDLEVBQTZDZ1YsWUFBWSxHQUFaOztBQUU3QztBQUNBO0FBQ0EsUUFBSSxLQUFLQyxPQUFMLElBQ0EsQ0FBQyxDQUFDRCxRQUFELElBQWFxQixnQkFBZ0JyQixRQUFoQixDQUFkLEtBQTRDL1osU0FBUyxLQUR6RCxFQUNnRTtBQUM5REEsZUFBTyxRQUFRQSxRQUFRLEVBQWhCLENBQVA7QUFDQSxZQUFJNEUsWUFBWUEsU0FBUzBZLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBdkMsRUFBNEMxWSxXQUFXLE1BQU1BLFFBQWpCO0FBQzdDLEtBSkQsTUFJTyxJQUFJLENBQUM1RSxJQUFMLEVBQVc7QUFDaEJBLGVBQU8sRUFBUDtBQUNEOztBQUVELFFBQUlvYSxRQUFRQSxLQUFLa0QsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBL0IsRUFBb0NsRCxPQUFPLE1BQU1BLElBQWI7QUFDcEMsUUFBSUMsVUFBVUEsT0FBT2lELE1BQVAsQ0FBYyxDQUFkLE1BQXFCLEdBQW5DLEVBQXdDakQsU0FBUyxNQUFNQSxNQUFmOztBQUV4Q3pWLGVBQVdBLFNBQVNySyxPQUFULENBQWlCLE9BQWpCLEVBQTBCLFVBQVN3QixLQUFULEVBQWdCO0FBQ25ELGVBQU9zZCxtQkFBbUJ0ZCxLQUFuQixDQUFQO0FBQ0QsS0FGVSxDQUFYO0FBR0FzZSxhQUFTQSxPQUFPOWYsT0FBUCxDQUFlLEdBQWYsRUFBb0IsS0FBcEIsQ0FBVDs7QUFFQSxXQUFPd2YsV0FBVy9aLElBQVgsR0FBa0I0RSxRQUFsQixHQUE2QnlWLE1BQTdCLEdBQXNDRCxJQUE3QztBQUNELENBdEREOztBQXdEQSxTQUFTWixVQUFULENBQW9CdmQsTUFBcEIsRUFBNEJzaEIsUUFBNUIsRUFBc0M7QUFDcEMsV0FBT2hFLFNBQVN0ZCxNQUFULEVBQWlCLEtBQWpCLEVBQXdCLElBQXhCLEVBQThCRyxPQUE5QixDQUFzQ21oQixRQUF0QyxDQUFQO0FBQ0Q7O0FBRUR6RCxJQUFJMUIsU0FBSixDQUFjaGMsT0FBZCxHQUF3QixVQUFTbWhCLFFBQVQsRUFBbUI7QUFDekMsV0FBTyxLQUFLOUQsYUFBTCxDQUFtQkYsU0FBU2dFLFFBQVQsRUFBbUIsS0FBbkIsRUFBMEIsSUFBMUIsQ0FBbkIsRUFBb0QvYSxNQUFwRCxFQUFQO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTa1gsZ0JBQVQsQ0FBMEJ6ZCxNQUExQixFQUFrQ3NoQixRQUFsQyxFQUE0QztBQUMxQyxRQUFJLENBQUN0aEIsTUFBTCxFQUFhLE9BQU9zaEIsUUFBUDtBQUNiLFdBQU9oRSxTQUFTdGQsTUFBVCxFQUFpQixLQUFqQixFQUF3QixJQUF4QixFQUE4QndkLGFBQTlCLENBQTRDOEQsUUFBNUMsQ0FBUDtBQUNEOztBQUVEekQsSUFBSTFCLFNBQUosQ0FBY3FCLGFBQWQsR0FBOEIsVUFBUzhELFFBQVQsRUFBbUI7QUFDL0MsUUFBSTFGLEtBQUtDLFFBQUwsQ0FBY3lGLFFBQWQsQ0FBSixFQUE2QjtBQUMzQixZQUFJdGlCLE1BQU0sSUFBSTZlLEdBQUosRUFBVjtBQUNBN2UsWUFBSXNCLEtBQUosQ0FBVWdoQixRQUFWLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCO0FBQ0FBLG1CQUFXdGlCLEdBQVg7QUFDRDs7QUFFRCxRQUFJMlgsU0FBUyxJQUFJa0gsR0FBSixFQUFiO0FBQ0EsUUFBSTBELFFBQVEvSyxPQUFPTixJQUFQLENBQVksSUFBWixDQUFaO0FBQ0EsU0FBSyxJQUFJc0wsS0FBSyxDQUFkLEVBQWlCQSxLQUFLRCxNQUFNempCLE1BQTVCLEVBQW9DMGpCLElBQXBDLEVBQTBDO0FBQ3hDLFlBQUlDLE9BQU9GLE1BQU1DLEVBQU4sQ0FBWDtBQUNBN0ssZUFBTzhLLElBQVAsSUFBZSxLQUFLQSxJQUFMLENBQWY7QUFDRDs7QUFFRDtBQUNBO0FBQ0E5SyxXQUFPd0gsSUFBUCxHQUFjbUQsU0FBU25ELElBQXZCOztBQUVBO0FBQ0EsUUFBSW1ELFNBQVN2aUIsSUFBVCxLQUFrQixFQUF0QixFQUEwQjtBQUN4QjRYLGVBQU81WCxJQUFQLEdBQWM0WCxPQUFPcFEsTUFBUCxFQUFkO0FBQ0EsZUFBT29RLE1BQVA7QUFDRDs7QUFFRDtBQUNBLFFBQUkySyxTQUFTdkQsT0FBVCxJQUFvQixDQUFDdUQsU0FBU3hELFFBQWxDLEVBQTRDO0FBQzFDO0FBQ0EsWUFBSTRELFFBQVFsTCxPQUFPTixJQUFQLENBQVlvTCxRQUFaLENBQVo7QUFDQSxhQUFLLElBQUlLLEtBQUssQ0FBZCxFQUFpQkEsS0FBS0QsTUFBTTVqQixNQUE1QixFQUFvQzZqQixJQUFwQyxFQUEwQztBQUN4QyxnQkFBSUMsT0FBT0YsTUFBTUMsRUFBTixDQUFYO0FBQ0EsZ0JBQUlDLFNBQVMsVUFBYixFQUNFakwsT0FBT2lMLElBQVAsSUFBZU4sU0FBU00sSUFBVCxDQUFmO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJekMsZ0JBQWdCeEksT0FBT21ILFFBQXZCLEtBQ0FuSCxPQUFPdUgsUUFEUCxJQUNtQixDQUFDdkgsT0FBT2hPLFFBRC9CLEVBQ3lDO0FBQ3ZDZ08sbUJBQU9qWCxJQUFQLEdBQWNpWCxPQUFPaE8sUUFBUCxHQUFrQixHQUFoQztBQUNEOztBQUVEZ08sZUFBTzVYLElBQVAsR0FBYzRYLE9BQU9wUSxNQUFQLEVBQWQ7QUFDQSxlQUFPb1EsTUFBUDtBQUNEOztBQUVELFFBQUkySyxTQUFTeEQsUUFBVCxJQUFxQndELFNBQVN4RCxRQUFULEtBQXNCbkgsT0FBT21ILFFBQXRELEVBQWdFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJLENBQUNxQixnQkFBZ0JtQyxTQUFTeEQsUUFBekIsQ0FBTCxFQUF5QztBQUN2QyxnQkFBSTVILE9BQU9NLE9BQU9OLElBQVAsQ0FBWW9MLFFBQVosQ0FBWDtBQUNBLGlCQUFLLElBQUl2RSxJQUFJLENBQWIsRUFBZ0JBLElBQUk3RyxLQUFLcFksTUFBekIsRUFBaUNpZixHQUFqQyxFQUFzQztBQUNwQyxvQkFBSS9DLElBQUk5RCxLQUFLNkcsQ0FBTCxDQUFSO0FBQ0FwRyx1QkFBT3FELENBQVAsSUFBWXNILFNBQVN0SCxDQUFULENBQVo7QUFDRDtBQUNEckQsbUJBQU81WCxJQUFQLEdBQWM0WCxPQUFPcFEsTUFBUCxFQUFkO0FBQ0EsbUJBQU9vUSxNQUFQO0FBQ0Q7O0FBRURBLGVBQU9tSCxRQUFQLEdBQWtCd0QsU0FBU3hELFFBQTNCO0FBQ0EsWUFBSSxDQUFDd0QsU0FBU3ZkLElBQVYsSUFBa0IsQ0FBQ21iLGlCQUFpQm9DLFNBQVN4RCxRQUExQixDQUF2QixFQUE0RDtBQUMxRCxnQkFBSStELFVBQVUsQ0FBQ1AsU0FBUzNZLFFBQVQsSUFBcUIsRUFBdEIsRUFBMEJ0SyxLQUExQixDQUFnQyxHQUFoQyxDQUFkO0FBQ0EsbUJBQU93akIsUUFBUS9qQixNQUFSLElBQWtCLEVBQUV3akIsU0FBU3ZkLElBQVQsR0FBZ0I4ZCxRQUFRQyxLQUFSLEVBQWxCLENBQXpCO0FBQ0EsZ0JBQUksQ0FBQ1IsU0FBU3ZkLElBQWQsRUFBb0J1ZCxTQUFTdmQsSUFBVCxHQUFnQixFQUFoQjtBQUNwQixnQkFBSSxDQUFDdWQsU0FBU3BELFFBQWQsRUFBd0JvRCxTQUFTcEQsUUFBVCxHQUFvQixFQUFwQjtBQUN4QixnQkFBSTJELFFBQVEsQ0FBUixNQUFlLEVBQW5CLEVBQXVCQSxRQUFRaEIsT0FBUixDQUFnQixFQUFoQjtBQUN2QixnQkFBSWdCLFFBQVEvakIsTUFBUixHQUFpQixDQUFyQixFQUF3QitqQixRQUFRaEIsT0FBUixDQUFnQixFQUFoQjtBQUN4QmxLLG1CQUFPaE8sUUFBUCxHQUFrQmtaLFFBQVFoWixJQUFSLENBQWEsR0FBYixDQUFsQjtBQUNELFNBUkQsTUFRTztBQUNMOE4sbUJBQU9oTyxRQUFQLEdBQWtCMlksU0FBUzNZLFFBQTNCO0FBQ0Q7QUFDRGdPLGVBQU95SCxNQUFQLEdBQWdCa0QsU0FBU2xELE1BQXpCO0FBQ0F6SCxlQUFPMEgsS0FBUCxHQUFlaUQsU0FBU2pELEtBQXhCO0FBQ0ExSCxlQUFPNVMsSUFBUCxHQUFjdWQsU0FBU3ZkLElBQVQsSUFBaUIsRUFBL0I7QUFDQTRTLGVBQU9xSCxJQUFQLEdBQWNzRCxTQUFTdEQsSUFBdkI7QUFDQXJILGVBQU91SCxRQUFQLEdBQWtCb0QsU0FBU3BELFFBQVQsSUFBcUJvRCxTQUFTdmQsSUFBaEQ7QUFDQTRTLGVBQU9zSCxJQUFQLEdBQWNxRCxTQUFTckQsSUFBdkI7QUFDQTtBQUNBLFlBQUl0SCxPQUFPaE8sUUFBUCxJQUFtQmdPLE9BQU95SCxNQUE5QixFQUFzQztBQUNwQyxnQkFBSTBDLElBQUluSyxPQUFPaE8sUUFBUCxJQUFtQixFQUEzQjtBQUNBLGdCQUFJeVksSUFBSXpLLE9BQU95SCxNQUFQLElBQWlCLEVBQXpCO0FBQ0F6SCxtQkFBT2pYLElBQVAsR0FBY29oQixJQUFJTSxDQUFsQjtBQUNEO0FBQ0R6SyxlQUFPb0gsT0FBUCxHQUFpQnBILE9BQU9vSCxPQUFQLElBQWtCdUQsU0FBU3ZELE9BQTVDO0FBQ0FwSCxlQUFPNVgsSUFBUCxHQUFjNFgsT0FBT3BRLE1BQVAsRUFBZDtBQUNBLGVBQU9vUSxNQUFQO0FBQ0Q7O0FBRUQsUUFBSW9MLGNBQWVwTCxPQUFPaE8sUUFBUCxJQUFtQmdPLE9BQU9oTyxRQUFQLENBQWdCMFksTUFBaEIsQ0FBdUIsQ0FBdkIsTUFBOEIsR0FBcEU7QUFBQSxRQUNJVyxXQUNJVixTQUFTdmQsSUFBVCxJQUNBdWQsU0FBUzNZLFFBQVQsSUFBcUIyWSxTQUFTM1ksUUFBVCxDQUFrQjBZLE1BQWxCLENBQXlCLENBQXpCLE1BQWdDLEdBSDdEO0FBQUEsUUFLSVksYUFBY0QsWUFBWUQsV0FBWixJQUNDcEwsT0FBTzVTLElBQVAsSUFBZXVkLFNBQVMzWSxRQU4zQztBQUFBLFFBT0l1WixnQkFBZ0JELFVBUHBCO0FBQUEsUUFRSUUsVUFBVXhMLE9BQU9oTyxRQUFQLElBQW1CZ08sT0FBT2hPLFFBQVAsQ0FBZ0J0SyxLQUFoQixDQUFzQixHQUF0QixDQUFuQixJQUFpRCxFQVIvRDtBQUFBLFFBU0l3akIsVUFBVVAsU0FBUzNZLFFBQVQsSUFBcUIyWSxTQUFTM1ksUUFBVCxDQUFrQnRLLEtBQWxCLENBQXdCLEdBQXhCLENBQXJCLElBQXFELEVBVG5FO0FBQUEsUUFVSStqQixZQUFZekwsT0FBT21ILFFBQVAsSUFBbUIsQ0FBQ3FCLGdCQUFnQnhJLE9BQU9tSCxRQUF2QixDQVZwQzs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSXNFLFNBQUosRUFBZTtBQUNiekwsZUFBT3VILFFBQVAsR0FBa0IsRUFBbEI7QUFDQXZILGVBQU9zSCxJQUFQLEdBQWMsSUFBZDtBQUNBLFlBQUl0SCxPQUFPNVMsSUFBWCxFQUFpQjtBQUNmLGdCQUFJb2UsUUFBUSxDQUFSLE1BQWUsRUFBbkIsRUFBdUJBLFFBQVEsQ0FBUixJQUFheEwsT0FBTzVTLElBQXBCLENBQXZCLEtBQ0tvZSxRQUFRdEIsT0FBUixDQUFnQmxLLE9BQU81UyxJQUF2QjtBQUNOO0FBQ0Q0UyxlQUFPNVMsSUFBUCxHQUFjLEVBQWQ7QUFDQSxZQUFJdWQsU0FBU3hELFFBQWIsRUFBdUI7QUFDckJ3RCxxQkFBU3BELFFBQVQsR0FBb0IsSUFBcEI7QUFDQW9ELHFCQUFTckQsSUFBVCxHQUFnQixJQUFoQjtBQUNBLGdCQUFJcUQsU0FBU3ZkLElBQWIsRUFBbUI7QUFDakIsb0JBQUk4ZCxRQUFRLENBQVIsTUFBZSxFQUFuQixFQUF1QkEsUUFBUSxDQUFSLElBQWFQLFNBQVN2ZCxJQUF0QixDQUF2QixLQUNLOGQsUUFBUWhCLE9BQVIsQ0FBZ0JTLFNBQVN2ZCxJQUF6QjtBQUNOO0FBQ0R1ZCxxQkFBU3ZkLElBQVQsR0FBZ0IsSUFBaEI7QUFDRDtBQUNEa2UscUJBQWFBLGVBQWVKLFFBQVEsQ0FBUixNQUFlLEVBQWYsSUFBcUJNLFFBQVEsQ0FBUixNQUFlLEVBQW5ELENBQWI7QUFDRDs7QUFFRCxRQUFJSCxRQUFKLEVBQWM7QUFDWjtBQUNBckwsZUFBTzVTLElBQVAsR0FBZXVkLFNBQVN2ZCxJQUFULElBQWlCdWQsU0FBU3ZkLElBQVQsS0FBa0IsRUFBcEMsR0FDQXVkLFNBQVN2ZCxJQURULEdBQ2dCNFMsT0FBTzVTLElBRHJDO0FBRUE0UyxlQUFPdUgsUUFBUCxHQUFtQm9ELFNBQVNwRCxRQUFULElBQXFCb0QsU0FBU3BELFFBQVQsS0FBc0IsRUFBNUMsR0FDQW9ELFNBQVNwRCxRQURULEdBQ29CdkgsT0FBT3VILFFBRDdDO0FBRUF2SCxlQUFPeUgsTUFBUCxHQUFnQmtELFNBQVNsRCxNQUF6QjtBQUNBekgsZUFBTzBILEtBQVAsR0FBZWlELFNBQVNqRCxLQUF4QjtBQUNBOEQsa0JBQVVOLE9BQVY7QUFDQTtBQUNELEtBVkQsTUFVTyxJQUFJQSxRQUFRL2pCLE1BQVosRUFBb0I7QUFDekI7QUFDQTtBQUNBLFlBQUksQ0FBQ3FrQixPQUFMLEVBQWNBLFVBQVUsRUFBVjtBQUNkQSxnQkFBUUUsR0FBUjtBQUNBRixrQkFBVUEsUUFBUXJQLE1BQVIsQ0FBZStPLE9BQWYsQ0FBVjtBQUNBbEwsZUFBT3lILE1BQVAsR0FBZ0JrRCxTQUFTbEQsTUFBekI7QUFDQXpILGVBQU8wSCxLQUFQLEdBQWVpRCxTQUFTakQsS0FBeEI7QUFDRCxLQVJNLE1BUUEsSUFBSSxDQUFDekMsS0FBS0ssaUJBQUwsQ0FBdUJxRixTQUFTbEQsTUFBaEMsQ0FBTCxFQUE4QztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxZQUFJZ0UsU0FBSixFQUFlO0FBQ2J6TCxtQkFBT3VILFFBQVAsR0FBa0J2SCxPQUFPNVMsSUFBUCxHQUFjb2UsUUFBUUwsS0FBUixFQUFoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFJUSxhQUFhM0wsT0FBTzVTLElBQVAsSUFBZTRTLE9BQU81UyxJQUFQLENBQVl2RixPQUFaLENBQW9CLEdBQXBCLElBQTJCLENBQTFDLEdBQ0FtWSxPQUFPNVMsSUFBUCxDQUFZMUYsS0FBWixDQUFrQixHQUFsQixDQURBLEdBQ3lCLEtBRDFDO0FBRUEsZ0JBQUlpa0IsVUFBSixFQUFnQjtBQUNkM0wsdUJBQU9xSCxJQUFQLEdBQWNzRSxXQUFXUixLQUFYLEVBQWQ7QUFDQW5MLHVCQUFPNVMsSUFBUCxHQUFjNFMsT0FBT3VILFFBQVAsR0FBa0JvRSxXQUFXUixLQUFYLEVBQWhDO0FBQ0Q7QUFDRjtBQUNEbkwsZUFBT3lILE1BQVAsR0FBZ0JrRCxTQUFTbEQsTUFBekI7QUFDQXpILGVBQU8wSCxLQUFQLEdBQWVpRCxTQUFTakQsS0FBeEI7QUFDQTtBQUNBLFlBQUksQ0FBQ3pDLEtBQUtJLE1BQUwsQ0FBWXJGLE9BQU9oTyxRQUFuQixDQUFELElBQWlDLENBQUNpVCxLQUFLSSxNQUFMLENBQVlyRixPQUFPeUgsTUFBbkIsQ0FBdEMsRUFBa0U7QUFDaEV6SCxtQkFBT2pYLElBQVAsR0FBYyxDQUFDaVgsT0FBT2hPLFFBQVAsR0FBa0JnTyxPQUFPaE8sUUFBekIsR0FBb0MsRUFBckMsS0FDQ2dPLE9BQU95SCxNQUFQLEdBQWdCekgsT0FBT3lILE1BQXZCLEdBQWdDLEVBRGpDLENBQWQ7QUFFRDtBQUNEekgsZUFBTzVYLElBQVAsR0FBYzRYLE9BQU9wUSxNQUFQLEVBQWQ7QUFDQSxlQUFPb1EsTUFBUDtBQUNEOztBQUVELFFBQUksQ0FBQ3dMLFFBQVFya0IsTUFBYixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E2WSxlQUFPaE8sUUFBUCxHQUFrQixJQUFsQjtBQUNBO0FBQ0EsWUFBSWdPLE9BQU95SCxNQUFYLEVBQW1CO0FBQ2pCekgsbUJBQU9qWCxJQUFQLEdBQWMsTUFBTWlYLE9BQU95SCxNQUEzQjtBQUNELFNBRkQsTUFFTztBQUNMekgsbUJBQU9qWCxJQUFQLEdBQWMsSUFBZDtBQUNEO0FBQ0RpWCxlQUFPNVgsSUFBUCxHQUFjNFgsT0FBT3BRLE1BQVAsRUFBZDtBQUNBLGVBQU9vUSxNQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBSTRMLE9BQU9KLFFBQVF2WixLQUFSLENBQWMsQ0FBQyxDQUFmLEVBQWtCLENBQWxCLENBQVg7QUFDQSxRQUFJNFosbUJBQ0EsQ0FBQzdMLE9BQU81UyxJQUFQLElBQWV1ZCxTQUFTdmQsSUFBeEIsSUFBZ0NvZSxRQUFRcmtCLE1BQVIsR0FBaUIsQ0FBbEQsTUFDQ3lrQixTQUFTLEdBQVQsSUFBZ0JBLFNBQVMsSUFEMUIsS0FDbUNBLFNBQVMsRUFGaEQ7O0FBSUE7QUFDQTtBQUNBLFFBQUlFLEtBQUssQ0FBVDtBQUNBLFNBQUssSUFBSWhsQixJQUFJMGtCLFFBQVFya0IsTUFBckIsRUFBNkJMLEtBQUssQ0FBbEMsRUFBcUNBLEdBQXJDLEVBQTBDO0FBQ3hDOGtCLGVBQU9KLFFBQVExa0IsQ0FBUixDQUFQO0FBQ0EsWUFBSThrQixTQUFTLEdBQWIsRUFBa0I7QUFDaEJKLG9CQUFRckgsTUFBUixDQUFlcmQsQ0FBZixFQUFrQixDQUFsQjtBQUNELFNBRkQsTUFFTyxJQUFJOGtCLFNBQVMsSUFBYixFQUFtQjtBQUN4Qkosb0JBQVFySCxNQUFSLENBQWVyZCxDQUFmLEVBQWtCLENBQWxCO0FBQ0FnbEI7QUFDRCxTQUhNLE1BR0EsSUFBSUEsRUFBSixFQUFRO0FBQ2JOLG9CQUFRckgsTUFBUixDQUFlcmQsQ0FBZixFQUFrQixDQUFsQjtBQUNBZ2xCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFFBQUksQ0FBQ1IsVUFBRCxJQUFlLENBQUNDLGFBQXBCLEVBQW1DO0FBQ2pDLGVBQU9PLElBQVAsRUFBYUEsRUFBYixFQUFpQjtBQUNmTixvQkFBUXRCLE9BQVIsQ0FBZ0IsSUFBaEI7QUFDRDtBQUNGOztBQUVELFFBQUlvQixjQUFjRSxRQUFRLENBQVIsTUFBZSxFQUE3QixLQUNDLENBQUNBLFFBQVEsQ0FBUixDQUFELElBQWVBLFFBQVEsQ0FBUixFQUFXZCxNQUFYLENBQWtCLENBQWxCLE1BQXlCLEdBRHpDLENBQUosRUFDbUQ7QUFDakRjLGdCQUFRdEIsT0FBUixDQUFnQixFQUFoQjtBQUNEOztBQUVELFFBQUkyQixvQkFBcUJMLFFBQVF0WixJQUFSLENBQWEsR0FBYixFQUFrQkMsTUFBbEIsQ0FBeUIsQ0FBQyxDQUExQixNQUFpQyxHQUExRCxFQUFnRTtBQUM5RHFaLGdCQUFRMWpCLElBQVIsQ0FBYSxFQUFiO0FBQ0Q7O0FBRUQsUUFBSWlrQixhQUFhUCxRQUFRLENBQVIsTUFBZSxFQUFmLElBQ1pBLFFBQVEsQ0FBUixLQUFjQSxRQUFRLENBQVIsRUFBV2QsTUFBWCxDQUFrQixDQUFsQixNQUF5QixHQUQ1Qzs7QUFHQTtBQUNBLFFBQUllLFNBQUosRUFBZTtBQUNiekwsZUFBT3VILFFBQVAsR0FBa0J2SCxPQUFPNVMsSUFBUCxHQUFjMmUsYUFBYSxFQUFiLEdBQ0FQLFFBQVFya0IsTUFBUixHQUFpQnFrQixRQUFRTCxLQUFSLEVBQWpCLEdBQW1DLEVBRG5FO0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSVEsYUFBYTNMLE9BQU81UyxJQUFQLElBQWU0UyxPQUFPNVMsSUFBUCxDQUFZdkYsT0FBWixDQUFvQixHQUFwQixJQUEyQixDQUExQyxHQUNBbVksT0FBTzVTLElBQVAsQ0FBWTFGLEtBQVosQ0FBa0IsR0FBbEIsQ0FEQSxHQUN5QixLQUQxQztBQUVBLFlBQUlpa0IsVUFBSixFQUFnQjtBQUNkM0wsbUJBQU9xSCxJQUFQLEdBQWNzRSxXQUFXUixLQUFYLEVBQWQ7QUFDQW5MLG1CQUFPNVMsSUFBUCxHQUFjNFMsT0FBT3VILFFBQVAsR0FBa0JvRSxXQUFXUixLQUFYLEVBQWhDO0FBQ0Q7QUFDRjs7QUFFREcsaUJBQWFBLGNBQWV0TCxPQUFPNVMsSUFBUCxJQUFlb2UsUUFBUXJrQixNQUFuRDs7QUFFQSxRQUFJbWtCLGNBQWMsQ0FBQ1MsVUFBbkIsRUFBK0I7QUFDN0JQLGdCQUFRdEIsT0FBUixDQUFnQixFQUFoQjtBQUNEOztBQUVELFFBQUksQ0FBQ3NCLFFBQVFya0IsTUFBYixFQUFxQjtBQUNuQjZZLGVBQU9oTyxRQUFQLEdBQWtCLElBQWxCO0FBQ0FnTyxlQUFPalgsSUFBUCxHQUFjLElBQWQ7QUFDRCxLQUhELE1BR087QUFDTGlYLGVBQU9oTyxRQUFQLEdBQWtCd1osUUFBUXRaLElBQVIsQ0FBYSxHQUFiLENBQWxCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLENBQUMrUyxLQUFLSSxNQUFMLENBQVlyRixPQUFPaE8sUUFBbkIsQ0FBRCxJQUFpQyxDQUFDaVQsS0FBS0ksTUFBTCxDQUFZckYsT0FBT3lILE1BQW5CLENBQXRDLEVBQWtFO0FBQ2hFekgsZUFBT2pYLElBQVAsR0FBYyxDQUFDaVgsT0FBT2hPLFFBQVAsR0FBa0JnTyxPQUFPaE8sUUFBekIsR0FBb0MsRUFBckMsS0FDQ2dPLE9BQU95SCxNQUFQLEdBQWdCekgsT0FBT3lILE1BQXZCLEdBQWdDLEVBRGpDLENBQWQ7QUFFRDtBQUNEekgsV0FBT3FILElBQVAsR0FBY3NELFNBQVN0RCxJQUFULElBQWlCckgsT0FBT3FILElBQXRDO0FBQ0FySCxXQUFPb0gsT0FBUCxHQUFpQnBILE9BQU9vSCxPQUFQLElBQWtCdUQsU0FBU3ZELE9BQTVDO0FBQ0FwSCxXQUFPNVgsSUFBUCxHQUFjNFgsT0FBT3BRLE1BQVAsRUFBZDtBQUNBLFdBQU9vUSxNQUFQO0FBQ0QsQ0E1UUQ7O0FBOFFBa0gsSUFBSTFCLFNBQUosQ0FBY2tFLFNBQWQsR0FBMEIsWUFBVztBQUNuQyxRQUFJdGMsT0FBTyxLQUFLQSxJQUFoQjtBQUNBLFFBQUlrYSxPQUFPTSxZQUFZd0IsSUFBWixDQUFpQmhjLElBQWpCLENBQVg7QUFDQSxRQUFJa2EsSUFBSixFQUFVO0FBQ1JBLGVBQU9BLEtBQUssQ0FBTCxDQUFQO0FBQ0EsWUFBSUEsU0FBUyxHQUFiLEVBQWtCO0FBQ2hCLGlCQUFLQSxJQUFMLEdBQVlBLEtBQUtuVixNQUFMLENBQVksQ0FBWixDQUFaO0FBQ0Q7QUFDRC9FLGVBQU9BLEtBQUsrRSxNQUFMLENBQVksQ0FBWixFQUFlL0UsS0FBS2pHLE1BQUwsR0FBY21nQixLQUFLbmdCLE1BQWxDLENBQVA7QUFDRDtBQUNELFFBQUlpRyxJQUFKLEVBQVUsS0FBS21hLFFBQUwsR0FBZ0JuYSxJQUFoQjtBQUNYLENBWEQ7O0FBYUEsSUFBSXRFLE1BQU07QUFDVGEsV0FBT0EsS0FERTtBQUVUSCxhQUFTQSxPQUZBO0FBR1RxZCxtQkFBZUEsYUFITjtBQUlUalgsWUFBUW1YLFFBSkM7QUFLVEcsU0FBS0Q7QUFMSSxDQUFWOztBQVFBLFNBQVMrRSxvQkFBVCxDQUE4QkMsWUFBOUIsRUFBNEM7QUFDeEMsU0FBSyxJQUFJbmxCLElBQUksQ0FBYixFQUFnQkEsSUFBSTZXLEdBQUdoVixNQUFILENBQVV4QixNQUE5QixFQUFzQ0wsR0FBdEMsRUFBMkM7QUFDdkMsYUFBSyxJQUFNcUosR0FBWCxJQUFrQndOLEdBQUdBLEdBQUdoVixNQUFILENBQVU3QixDQUFWLENBQUgsQ0FBbEIsRUFBb0M7QUFDaEMsZ0JBQUlxSixRQUFROGIsWUFBWixFQUNJLE9BQU90TyxHQUFHQSxHQUFHaFYsTUFBSCxDQUFVN0IsQ0FBVixDQUFILEVBQWlCcUosR0FBakIsQ0FBUDtBQUNQO0FBQ0o7QUFDRCxTQUFLLElBQUlySixLQUFJLENBQWIsRUFBZ0JBLEtBQUk2VyxHQUFHelIsS0FBSCxDQUFTL0UsTUFBN0IsRUFBcUNMLElBQXJDLEVBQTBDO0FBQ3RDLGFBQUssSUFBTXFKLEtBQVgsSUFBa0J3TixHQUFHQSxHQUFHelIsS0FBSCxDQUFTcEYsRUFBVCxDQUFILENBQWxCLEVBQW1DO0FBQy9CLGdCQUFJcUosVUFBUThiLFlBQVosRUFDSSxPQUFPdE8sR0FBR0EsR0FBR3pSLEtBQUgsQ0FBU3BGLEVBQVQsQ0FBSCxFQUFnQnFKLEtBQWhCLENBQVA7QUFDUDtBQUNKO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7QUFDRCxTQUFTK2IsVUFBVCxDQUFvQjlnQixLQUFwQixFQUEyQitnQixRQUEzQixFQUFxQztBQUNqQyxTQUFLLElBQU05SSxDQUFYLElBQWdCalksTUFBTXlELE9BQXRCLEVBQStCO0FBQzNCc2QsaUJBQVMvZ0IsTUFBTXlELE9BQU4sQ0FBY3dVLENBQWQsQ0FBVDtBQUNIO0FBQ0o7QUFDRCxTQUFTK0ksU0FBVCxDQUFtQmhoQixLQUFuQixFQUEwQitnQixRQUExQixFQUFvQztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNoQyw2QkFBb0IvZ0IsTUFBTUksTUFBMUIsOEhBQWtDO0FBQUEsZ0JBQXZCOUMsTUFBdUI7O0FBQzlCeWpCLHFCQUFTempCLE1BQVQ7QUFDSDtBQUgrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSW5DO0FBQ0QsU0FBUzJqQixZQUFULENBQXNCamhCLEtBQXRCLEVBQTZCc1QsT0FBN0IsRUFBc0N5TixRQUF0QyxFQUFnRDtBQUM1QyxhQUFTRyxLQUFULENBQWU1akIsS0FBZixFQUFzQjZqQixZQUF0QixFQUFvQztBQUNoQyxZQUFNeFIsYUFBYXJTLE1BQU02akIsWUFBTixDQUFuQjtBQUNBLFlBQUksQ0FBQ3hSLFVBQUwsRUFDSTtBQUNKOEUsZUFBT04sSUFBUCxDQUFZeEUsVUFBWixFQUF3QnlSLE9BQXhCLENBQWdDLGVBQU87QUFDbkNMLHFCQUFTO0FBQ0xwakIsc0JBQU0sQ0FDRkwsTUFBTStDLEVBREosRUFFRjhnQixZQUZFLEVBR0ZwYyxHQUhFLENBREQ7QUFNTEEsd0JBTks7QUFPTDZDLHVCQUFPK0gsV0FBVzVLLEdBQVgsQ0FQRjtBQVFMNFAsMkJBQVdpTSxxQkFBcUI3YixHQUFyQixDQVJOO0FBU0x5QixtQkFUSyxlQVNEb1UsQ0FUQyxFQVNFO0FBQ0hqTCwrQkFBVzVLLEdBQVgsSUFBa0I2VixDQUFsQjtBQUNIO0FBWEksYUFBVDtBQWFILFNBZEQ7QUFlSDtBQUNEb0csY0FBVWhoQixLQUFWLEVBQWlCLGlCQUFTO0FBQ3RCLFlBQUlzVCxRQUFReFMsS0FBWixFQUFtQjtBQUNmb2dCLGtCQUFNNWpCLEtBQU4sRUFBYSxPQUFiO0FBQ0g7QUFDRCxZQUFJZ1csUUFBUS9WLE1BQVosRUFBb0I7QUFDaEIyakIsa0JBQU01akIsS0FBTixFQUFhLFFBQWI7QUFDSDtBQUNKLEtBUEQ7QUFRSDs7QUFFRCxTQUFTK2pCLFVBQVQsQ0FBb0IvakIsS0FBcEIsRUFBMkJ5akIsUUFBM0IsRUFBcUM7QUFDakMsU0FBSyxJQUFNOUksQ0FBWCxJQUFnQjNhLEtBQWhCLEVBQXVCO0FBQ25CLFlBQUkyYSxFQUFFeGIsT0FBRixDQUFVLFFBQVYsTUFBd0IsQ0FBNUIsRUFBK0I7QUFDM0Jza0IscUJBQVN6akIsTUFBTTJhLENBQU4sQ0FBVCxFQUFtQkEsQ0FBbkI7QUFDSDtBQUNKO0FBQ0o7QUFDRCxTQUFTcUosU0FBVCxDQUFtQmhrQixLQUFuQixFQUEwQnlqQixRQUExQixFQUFvQztBQUNoQyxTQUFLLElBQU05SSxDQUFYLElBQWdCM2EsS0FBaEIsRUFBdUI7QUFDbkIsWUFBSTJhLEVBQUV4YixPQUFGLENBQVUsT0FBVixNQUF1QixDQUEzQixFQUE4QjtBQUMxQnNrQixxQkFBU3pqQixNQUFNMmEsQ0FBTixDQUFULEVBQW1CQSxDQUFuQjtBQUNIO0FBQ0o7QUFDSjtBQUNELFNBQVNzSixlQUFULENBQXlCdmhCLEtBQXpCLEVBQWdDNEgsS0FBaEMsRUFBdUM7QUFDbkMsUUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCQSxNQUFNLENBQU4sTUFBYSxHQUE5QyxFQUFtRDtBQUMvQyxlQUFPMlosZ0JBQWdCdmhCLEtBQWhCLEVBQXVCQSxNQUFNd2hCLFNBQU4sQ0FBZ0I1WixLQUFoQixDQUF2QixDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBT0EsS0FBUDtBQUNIO0FBQ0o7QUFDRCxTQUFTNlosVUFBVCxDQUFvQjdaLEtBQXBCLEVBQTJCO0FBQ3ZCLFdBQU9oTSxNQUFNQyxPQUFOLENBQWMrTCxNQUFNOUwsS0FBcEIsQ0FBUDtBQUNIO0FBQ0QsU0FBUzRsQixjQUFULENBQXdCOU4sR0FBeEIsRUFBNkIrTixJQUE3QixFQUFtQ0MsRUFBbkMsRUFBdUM7QUFDbkNoTyxRQUFJZ08sRUFBSixJQUFVaE8sSUFBSStOLElBQUosQ0FBVjtBQUNBLFdBQU8vTixJQUFJK04sSUFBSixDQUFQO0FBQ0g7QUFDRCxTQUFTRSxXQUFULENBQXNCN2hCLEtBQXRCLEVBQTZCO0FBQ3pCQSxVQUFNeEIsT0FBTixHQUFnQixDQUFoQjtBQUNBc2lCLGVBQVc5Z0IsS0FBWCxFQUFrQixrQkFBVTtBQUN4QixZQUFJL0IsT0FBT3lDLElBQVAsS0FBZ0IsT0FBaEIsSUFBMkJ6QyxPQUFPUCxHQUFQLEtBQWVnQyxTQUE5QyxFQUF5RDtBQUNyRGdpQiwyQkFBZXpqQixNQUFmLEVBQXVCLEtBQXZCLEVBQThCLE1BQTlCO0FBQ0g7QUFDRCxZQUFJQSxPQUFPeUMsSUFBUCxLQUFnQixPQUFwQixFQUE2QjtBQUN6QnpDLG1CQUFPNE0sV0FBUCxDQUFtQnVXLE9BQW5CLENBQTJCLGlCQUFTO0FBQ2hDLHVCQUFPVSxNQUFNQyxPQUFOLEVBQVA7QUFDSCxhQUZEO0FBR0g7QUFDSixLQVREO0FBVUFmLGNBQVVoaEIsS0FBVixFQUFpQixpQkFBUztBQUN0QnFoQixtQkFBVy9qQixLQUFYLEVBQWtCLGtCQUFVO0FBQ3hCLGdCQUFJQyxPQUFPLHFCQUFQLE1BQWtDbUMsU0FBdEMsRUFBaUQ7QUFDN0NnaUIsK0JBQWVua0IsTUFBZixFQUF1QixxQkFBdkIsRUFBOEMsZ0JBQTlDO0FBQ0g7QUFDSixTQUpEO0FBS0ErakIsa0JBQVVoa0IsS0FBVixFQUFpQixpQkFBUztBQUN0QixnQkFBSXdELE1BQU0sa0JBQU4sTUFBOEJwQixTQUFsQyxFQUE2QztBQUN6Q2dpQiwrQkFBZTVnQixLQUFmLEVBQXNCLGtCQUF0QixFQUEwQyxvQkFBMUM7QUFDSDtBQUNELGdCQUFJQSxNQUFNLFlBQU4sTUFBd0JwQixTQUE1QixFQUF1QztBQUNuQ2dpQiwrQkFBZTVnQixLQUFmLEVBQXNCLFlBQXRCLEVBQW9DLGNBQXBDO0FBQ0g7QUFDRCxnQkFBSUEsTUFBTSxZQUFOLE1BQXdCcEIsU0FBNUIsRUFBdUM7QUFDbkNnaUIsK0JBQWU1Z0IsS0FBZixFQUFzQixZQUF0QixFQUFvQyxjQUFwQztBQUNIO0FBQ0osU0FWRDtBQVdILEtBakJEO0FBa0JBbWdCLGlCQUFhamhCLEtBQWIsRUFBb0I7QUFDaEJjLGVBQU8sSUFEUztBQUVoQnZELGdCQUFRO0FBRlEsS0FBcEIsRUFHRyxvQkFBWTtBQUNYLFlBQU1xSyxRQUFRMlosZ0JBQWdCdmhCLEtBQWhCLEVBQXVCeVMsU0FBUzdLLEtBQWhDLENBQWQ7QUFDQSxZQUFJNlosV0FBVzdaLEtBQVgsQ0FBSixFQUF1QjtBQUNuQkEsa0JBQU05TCxLQUFOLENBQVlzbEIsT0FBWixDQUFvQixnQkFBUTtBQUN4QlkscUJBQUssQ0FBTCxJQUFVVCxnQkFBZ0J2aEIsS0FBaEIsRUFBdUJnaUIsS0FBSyxDQUFMLENBQXZCLENBQVY7QUFDSCxhQUZEO0FBR0g7QUFDRHZQLGlCQUFTak0sR0FBVCxDQUFhb0IsS0FBYjtBQUNILEtBWEQ7QUFZQSxXQUFPNUgsTUFBTXdoQixTQUFiO0FBQ0FSLGNBQVVoaEIsS0FBVixFQUFpQixpQkFBUztBQUN0QnFoQixtQkFBVy9qQixLQUFYLEVBQWtCLGtCQUFVO0FBQ3hCLG1CQUFPQyxPQUFPLGVBQVAsQ0FBUDtBQUNBLG1CQUFPQSxPQUFPLGVBQVAsQ0FBUDtBQUNILFNBSEQ7QUFJQStqQixrQkFBVWhrQixLQUFWLEVBQWlCLGlCQUFTO0FBQ3RCLGdCQUFJd0QsTUFBTSxXQUFOLENBQUosRUFBd0I7QUFDcEIsb0JBQUksQ0FBQ3hELE1BQU1DLE1BQVgsRUFDSUQsTUFBTUMsTUFBTixHQUFlLEVBQWY7QUFDSkQsc0JBQU1DLE1BQU4sQ0FBYSxXQUFiLElBQTRCdUQsTUFBTSxXQUFOLENBQTVCO0FBQ0EsdUJBQU9BLE1BQU0sV0FBTixDQUFQO0FBQ0g7QUFDRCxnQkFBSUEsTUFBTSxXQUFOLENBQUosRUFBd0I7QUFDcEIsb0JBQUksQ0FBQ3hELE1BQU1DLE1BQVgsRUFDSUQsTUFBTUMsTUFBTixHQUFlLEVBQWY7QUFDSkQsc0JBQU1DLE1BQU4sQ0FBYSxXQUFiLElBQTRCdUQsTUFBTSxXQUFOLENBQTVCO0FBQ0EsdUJBQU9BLE1BQU0sV0FBTixDQUFQO0FBQ0g7QUFDSixTQWJEO0FBY0gsS0FuQkQ7QUFvQkEsYUFBU21oQixtQkFBVCxDQUE2QjlKLEtBQTdCLEVBQW9DO0FBQ2hDLFlBQU0rSixjQUFjeGtCLElBQUlhLEtBQUosQ0FBVTRaLEtBQVYsQ0FBcEI7QUFDQSxZQUFNZ0sscUJBQXFCRCxZQUFZdGIsUUFBWixDQUFxQnRLLEtBQXJCLENBQTJCLEdBQTNCLENBQTNCO0FBQ0EsWUFBSTRsQixZQUFZbkcsUUFBWixLQUF5QixTQUE3QixFQUF3QztBQUNwQyxtQkFBTzVELEtBQVA7QUFDSCxTQUZELE1BRU8sSUFBSStKLFlBQVkvRixRQUFaLEtBQXlCLFdBQTdCLEVBQTBDO0FBQzdDLG1CQUFPLCtDQUFQO0FBQ0gsU0FGTSxNQUVBLElBQUkrRixZQUFZL0YsUUFBWixLQUF5QixPQUE3QixFQUFzQztBQUN6Qyx1Q0FBMEJnRyxtQkFBbUIsQ0FBbkIsQ0FBMUI7QUFDSCxTQUZNLE1BRUE7QUFDVjtBQUNELFFBQUluaUIsTUFBTXVJLE1BQVYsRUFBa0I7QUFDZHZJLGNBQU11SSxNQUFOLEdBQWUwWixvQkFBb0JqaUIsTUFBTXVJLE1BQTFCLENBQWY7QUFDSDtBQUNELGFBQVM2WixnQkFBVCxDQUEwQi9sQixJQUExQixFQUFnQztBQUM1QixpQkFBU2dtQixZQUFULENBQXNCalQsTUFBdEIsRUFBOEI7QUFDMUIsbUJBQU9BLE9BQU85UyxLQUFQLENBQWEsR0FBYixFQUFrQkYsR0FBbEIsQ0FBc0IsYUFBSztBQUM5Qix1QkFBT2lqQixFQUFFdkIsSUFBRixFQUFQO0FBQ0gsYUFGTSxDQUFQO0FBR0g7QUFDRCxZQUFJbGlCLE1BQU1DLE9BQU4sQ0FBY1EsSUFBZCxDQUFKLEVBQXlCO0FBQ3JCLG1CQUFPQSxJQUFQO0FBQ0gsU0FGRCxNQUVPLElBQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUNqQyxtQkFBT2dtQixhQUFhaG1CLElBQWIsQ0FBUDtBQUNILFNBRk0sTUFFQSxJQUFJLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBcEIsRUFBOEI7QUFDakNBLGlCQUFLUCxLQUFMLENBQVdzbEIsT0FBWCxDQUFtQixnQkFBUTtBQUN2QlkscUJBQUssQ0FBTCxJQUFVSyxhQUFhTCxLQUFLLENBQUwsQ0FBYixDQUFWO0FBQ0gsYUFGRDtBQUdBLG1CQUFPM2xCLElBQVA7QUFDSCxTQUxNLE1BS0E7QUFDSCxrQkFBTSxJQUFJb0MsS0FBSixDQUFVLHVCQUFWLENBQU47QUFDSDtBQUNKO0FBQ0R1aUIsY0FBVWhoQixLQUFWLEVBQWlCLGlCQUFTO0FBQ3RCcWhCLG1CQUFXL2pCLEtBQVgsRUFBa0Isa0JBQVU7QUFDeEIsZ0JBQUlDLE9BQU8sV0FBUCxDQUFKLEVBQXlCO0FBQ3JCQSx1QkFBTyxXQUFQLElBQXNCNmtCLGlCQUFpQjdrQixPQUFPLFdBQVAsQ0FBakIsQ0FBdEI7QUFDSDtBQUNKLFNBSkQ7QUFLSCxLQU5EO0FBT0EsUUFBSStrQixtQkFBbUIsQ0FBdkI7QUFDQSxTQUFLLElBQUk1bUIsSUFBSXNFLE1BQU1JLE1BQU4sQ0FBYXJFLE1BQWIsR0FBc0IsQ0FBbkMsRUFBc0NMLEtBQUssQ0FBM0MsRUFBOENBLEdBQTlDLEVBQW1EO0FBQy9DLFlBQU00QixVQUFRMEMsTUFBTUksTUFBTixDQUFhMUUsQ0FBYixDQUFkO0FBQ0EsWUFBSTRCLFFBQU1vRCxJQUFOLEtBQWUsUUFBbkIsRUFBNkI7QUFDekI0aEIsK0JBQW1CNW1CLElBQUksQ0FBdkI7QUFDQTtBQUNIO0FBQ0o7QUFDRCxRQUFNNm1CLGVBQWV2aUIsTUFBTUksTUFBTixDQUFhMlksTUFBYixDQUFvQnVKLGdCQUFwQixDQUFyQjtBQUNBQyxpQkFBYVIsT0FBYjtBQUNBL2hCLFVBQU1JLE1BQU4sR0FBZUosTUFBTUksTUFBTixDQUFhMlEsTUFBYixDQUFvQndSLFlBQXBCLENBQWY7QUFDQSxXQUFPdmlCLEtBQVA7QUFDSDs7QUFFRCxTQUFTd2lCLE1BQVQsQ0FBaUJyTCxNQUFqQixFQUFvQztBQUFBLHNDQUFSc0wsTUFBUTtBQUFSQSxjQUFRO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ2hDLDhCQUFvQkEsTUFBcEIsbUlBQTRCO0FBQUEsZ0JBQWpCdEssS0FBaUI7O0FBQ3hCLGlCQUFLLElBQU1GLENBQVgsSUFBZ0JFLEtBQWhCLEVBQXVCO0FBQ25CaEIsdUJBQU9jLENBQVAsSUFBWUUsTUFBTUYsQ0FBTixDQUFaO0FBQ0g7QUFDSjtBQUwrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1oQyxXQUFPZCxNQUFQO0FBQ0g7O0lBRUt1TCxZOzs7QUFDRiwwQkFBWTNkLEdBQVosRUFBaUI0ZCxPQUFqQixFQUEwQjtBQUFBOztBQUFBLGdJQUNoQkEsT0FEZ0I7O0FBRXRCLGNBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNBLGNBQUs1ZCxHQUFMLEdBQVdBLEdBQVg7QUFIc0I7QUFJekI7OztFQUxzQnRHLEs7O0lBUXJCbWtCLEs7QUFDRixtQkFBWUMsTUFBWixFQUFtQztBQUFBLFlBQWZDLFFBQWUsdUVBQUosRUFBSTs7QUFBQTs7QUFDL0IsYUFBS0QsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUYrQjtBQUFBO0FBQUE7O0FBQUE7QUFHL0Isa0NBQWlDQSxRQUFqQyxtSUFBMkM7QUFBQTs7QUFBQTs7QUFBQSxvQkFBL0JwYixJQUErQjtBQUFBLG9CQUF6Qm1FLFdBQXlCOztBQUN2QyxxQkFBS2lYLFFBQUwsQ0FBY3BiLElBQWQsSUFBc0JtRSxXQUF0QjtBQUNIO0FBTDhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNbEM7Ozs7K0JBQ01pWCxRLEVBQVU7QUFDYixtQkFBTyxJQUFJRixLQUFKLENBQVUsSUFBVixFQUFnQkUsUUFBaEIsQ0FBUDtBQUNIOzs7NEJBQ0dwYixJLEVBQU07QUFDTixnQkFBSSxLQUFLb2IsUUFBTCxDQUFjcGIsSUFBZCxDQUFKLEVBQXlCO0FBQ3JCLHVCQUFPLEtBQUtvYixRQUFMLENBQWNwYixJQUFkLENBQVA7QUFDSDtBQUNELGdCQUFJLEtBQUttYixNQUFULEVBQWlCO0FBQ2IsdUJBQU8sS0FBS0EsTUFBTCxDQUFZMWIsR0FBWixDQUFnQk8sSUFBaEIsQ0FBUDtBQUNIO0FBQ0Qsa0JBQU0sSUFBSWpKLEtBQUosQ0FBY2lKLElBQWQsMEJBQU47QUFDSDs7OzRCQUNHQSxJLEVBQU07QUFDTixnQkFBSSxLQUFLb2IsUUFBTCxDQUFjcGIsSUFBZCxDQUFKLEVBQ0ksT0FBTyxJQUFQO0FBQ0osbUJBQU8sS0FBS21iLE1BQUwsR0FBYyxLQUFLQSxNQUFMLENBQVkxVSxHQUFaLENBQWdCekcsSUFBaEIsQ0FBZCxHQUFzQyxLQUE3QztBQUNIOzs7Ozs7QUFHTCxJQUFNcWIsV0FBVyxFQUFFQyxNQUFNLE1BQVIsRUFBakI7QUFDQSxJQUFNQyxhQUFhLEVBQUVELE1BQU0sUUFBUixFQUFuQjtBQUNBLElBQU1FLGFBQWEsRUFBRUYsTUFBTSxRQUFSLEVBQW5CO0FBQ0EsSUFBTUcsY0FBYyxFQUFFSCxNQUFNLFNBQVIsRUFBcEI7QUFDQSxJQUFNSSxZQUFZLEVBQUVKLE1BQU0sT0FBUixFQUFsQjtBQUNBLElBQU1LLGFBQWEsRUFBRUwsTUFBTSxRQUFSLEVBQW5CO0FBQ0EsSUFBTU0sWUFBWSxFQUFFTixNQUFNLE9BQVIsRUFBbEI7QUFDQSxJQUFNTyxZQUFZLEVBQUVQLE1BQU0sT0FBUixFQUFsQjtBQUNBLElBQU1RLGVBQWUsRUFBRVIsTUFBTSxVQUFSLEVBQXJCO0FBQ0EsSUFBTVMsZ0JBQWdCLEVBQUVULE1BQU0sV0FBUixFQUF0QjtBQUNBLElBQU1VLG9CQUFvQixFQUFFVixNQUFNLGVBQVIsRUFBMUI7QUFDQSxTQUFTblUsS0FBVCxDQUFlOFUsUUFBZixFQUF5QkMsQ0FBekIsRUFBNEI7QUFDeEIsV0FBTztBQUNIWixjQUFNLE9BREg7QUFFSFcsMEJBRkc7QUFHSEM7QUFIRyxLQUFQO0FBS0g7QUFDRCxTQUFTeGlCLFFBQVQsQ0FBa0JWLElBQWxCLEVBQXdCO0FBQ3BCLFFBQUlBLEtBQUtzaUIsSUFBTCxLQUFjLE9BQWxCLEVBQTJCO0FBQ3ZCLFlBQU1XLFdBQVd2aUIsU0FBU1YsS0FBS2lqQixRQUFkLENBQWpCO0FBQ0EsZUFBTyxPQUFPampCLEtBQUtrakIsQ0FBWixLQUFrQixRQUFsQixjQUF1Q0QsUUFBdkMsVUFBc0RqakIsS0FBS2tqQixDQUEzRCxTQUFtRWxqQixLQUFLaWpCLFFBQUwsQ0FBY1gsSUFBZCxLQUF1QixPQUF2QixHQUFpQyxPQUFqQyxjQUFxRFcsUUFBckQsTUFBMUU7QUFDSCxLQUhELE1BR087QUFDSCxlQUFPampCLEtBQUtzaUIsSUFBWjtBQUNIO0FBQ0o7QUFDRCxJQUFNYSxtQkFBbUIsQ0FDckJkLFFBRHFCLEVBRXJCRSxVQUZxQixFQUdyQkMsVUFIcUIsRUFJckJDLFdBSnFCLEVBS3JCQyxTQUxxQixFQU1yQkssYUFOcUIsRUFPckJKLFVBUHFCLEVBUXJCeFUsTUFBTXlVLFNBQU4sQ0FScUIsRUFTckJJLGlCQVRxQixDQUF6QjtBQVdBLFNBQVNJLGFBQVQsQ0FBc0JDLFFBQXRCLEVBQWdDbkwsQ0FBaEMsRUFBbUM7QUFDL0IsUUFBSUEsRUFBRW9LLElBQUYsS0FBVyxPQUFmLEVBQXdCO0FBQ3BCLGVBQU8sSUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJZSxTQUFTZixJQUFULEtBQWtCLE9BQXRCLEVBQStCO0FBQ2xDLFlBQUlwSyxFQUFFb0ssSUFBRixLQUFXLE9BQVgsS0FBdUJwSyxFQUFFZ0wsQ0FBRixLQUFRLENBQVIsSUFBYWhMLEVBQUUrSyxRQUFGLENBQVdYLElBQVgsS0FBb0IsT0FBakMsSUFBNEMsQ0FBQ2MsY0FBYUMsU0FBU0osUUFBdEIsRUFBZ0MvSyxFQUFFK0ssUUFBbEMsQ0FBcEUsTUFBcUgsT0FBT0ksU0FBU0gsQ0FBaEIsS0FBc0IsUUFBdEIsSUFBa0NHLFNBQVNILENBQVQsS0FBZWhMLEVBQUVnTCxDQUF4SyxDQUFKLEVBQWdMO0FBQzVLLG1CQUFPLElBQVA7QUFDSDtBQUNKLEtBSk0sTUFJQSxJQUFJRyxTQUFTZixJQUFULEtBQWtCcEssRUFBRW9LLElBQXhCLEVBQThCO0FBQ2pDLGVBQU8sSUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJZSxTQUFTZixJQUFULEtBQWtCLE9BQXRCLEVBQStCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ2xDLGtDQUF5QmEsZ0JBQXpCLG1JQUEyQztBQUFBLG9CQUFoQ0csVUFBZ0M7O0FBQ3ZDLG9CQUFJLENBQUNGLGNBQWFFLFVBQWIsRUFBeUJwTCxDQUF6QixDQUFMLEVBQWtDO0FBQzlCLDJCQUFPLElBQVA7QUFDSDtBQUNKO0FBTGlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNckM7QUFDRCx5QkFBb0J4WCxTQUFTMmlCLFFBQVQsQ0FBcEIsbUJBQXNEM2lCLFNBQVN3WCxDQUFULENBQXREO0FBQ0g7QUFDRCxTQUFTcUwsV0FBVCxDQUFxQkMsUUFBckIsRUFBK0JDLFlBQS9CLEVBQTZDO0FBQ3pDLFdBQU9BLGFBQWExaUIsSUFBYixDQUFrQjtBQUFBLGVBQUttWCxFQUFFb0ssSUFBRixLQUFXa0IsU0FBU2xCLElBQXpCO0FBQUEsS0FBbEIsQ0FBUDtBQUNIO0FBQ0QsU0FBU29CLGlCQUFULENBQTJCRixRQUEzQixFQUFxQ0MsWUFBckMsRUFBbUQ7QUFDL0MsV0FBT0EsYUFBYTFpQixJQUFiLENBQWtCLGFBQUs7QUFDMUIsWUFBSW1YLE1BQU0sTUFBVixFQUFrQjtBQUNkLG1CQUFPc0wsYUFBYSxJQUFwQjtBQUNILFNBRkQsTUFFTyxJQUFJdEwsTUFBTSxPQUFWLEVBQW1CO0FBQ3RCLG1CQUFPaGQsTUFBTUMsT0FBTixDQUFjcW9CLFFBQWQsQ0FBUDtBQUNILFNBRk0sTUFFQSxJQUFJdEwsTUFBTSxRQUFWLEVBQW9CO0FBQ3ZCLG1CQUFPc0wsWUFBWSxDQUFDdG9CLE1BQU1DLE9BQU4sQ0FBY3FvQixRQUFkLENBQWIsSUFBd0MsUUFBT0EsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUFuRTtBQUNILFNBRk0sTUFFQTtBQUNILG1CQUFPdEwsY0FBYXNMLFFBQWIseUNBQWFBLFFBQWIsRUFBUDtBQUNIO0FBQ0osS0FWTSxDQUFQO0FBV0g7O0FBRUQsSUFBSUcsaUJBQWlCblAscUJBQXFCLFVBQVVFLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQUlpUCxpQkFBaUI7QUFDbkIsdUJBQWUsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUwsRUFBTyxDQUFQLENBREksRUFDTyxhQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQURwQjtBQUVuQix3QkFBZ0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBRkcsRUFFYyxRQUFRLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQUZ0QjtBQUduQixzQkFBYyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FISyxFQUdZLFNBQVMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBSHJCO0FBSW5CLGlCQUFTLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQUpVLEVBSU8sVUFBVSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FKakI7QUFLbkIsaUJBQVMsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUwsRUFBTyxDQUFQLENBTFUsRUFLQyxrQkFBa0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBTG5CO0FBTW5CLGdCQUFRLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLEVBQVMsQ0FBVCxDQU5XLEVBTUUsY0FBYyxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixFQUFZLENBQVosQ0FOaEI7QUFPbkIsaUJBQVMsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEVBQVIsRUFBVyxDQUFYLENBUFUsRUFPSyxhQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQVBsQjtBQVFuQixxQkFBYSxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixFQUFZLENBQVosQ0FSTSxFQVFVLGNBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLENBQVQsRUFBVyxDQUFYLENBUnhCO0FBU25CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULEVBQVksQ0FBWixDQVRNLEVBU1UsU0FBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxFQUFZLENBQVosQ0FUbkI7QUFVbkIsMEJBQWtCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQVZDLEVBVWdCLFlBQVksQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBVjVCO0FBV25CLG1CQUFXLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLEVBQVcsQ0FBWCxDQVhRLEVBV08sUUFBUSxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FYZjtBQVluQixvQkFBWSxDQUFDLENBQUQsRUFBRyxDQUFILEVBQUssR0FBTCxFQUFTLENBQVQsQ0FaTyxFQVlNLFlBQVksQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBWmxCO0FBYW5CLHlCQUFpQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxFQUFZLENBQVosQ0FiRSxFQWFjLFlBQVksQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBYjFCO0FBY25CLHFCQUFhLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLEVBQVMsQ0FBVCxDQWRNLEVBY08sWUFBWSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FkbkI7QUFlbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBZk0sRUFlVyxlQUFlLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQWYxQjtBQWdCbkIsMEJBQWtCLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLEVBQVcsQ0FBWCxDQWhCQyxFQWdCYyxjQUFjLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULEVBQVcsQ0FBWCxDQWhCNUI7QUFpQm5CLHNCQUFjLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLEVBQVksQ0FBWixDQWpCSyxFQWlCVyxXQUFXLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLEVBQVMsQ0FBVCxDQWpCdEI7QUFrQm5CLHNCQUFjLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWxCSyxFQWtCWSxnQkFBZ0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbEI1QjtBQW1CbkIseUJBQWlCLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQW5CRSxFQW1CYSxpQkFBaUIsQ0FBQyxFQUFELEVBQUksRUFBSixFQUFPLEVBQVAsRUFBVSxDQUFWLENBbkI5QjtBQW9CbkIseUJBQWlCLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLEVBQVUsQ0FBVixDQXBCRSxFQW9CWSxpQkFBaUIsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBcEI3QjtBQXFCbkIsc0JBQWMsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBckJLLEVBcUJVLFlBQVksQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEdBQVIsRUFBWSxDQUFaLENBckJ0QjtBQXNCbkIsdUJBQWUsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBdEJJLEVBc0JXLFdBQVcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBdEJ0QjtBQXVCbkIsbUJBQVcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBdkJRLEVBdUJTLGNBQWMsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEdBQVIsRUFBWSxDQUFaLENBdkJ2QjtBQXdCbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEVBQVIsRUFBVyxDQUFYLENBeEJNLEVBd0JTLGVBQWUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBeEJ4QjtBQXlCbkIsdUJBQWUsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEVBQVIsRUFBVyxDQUFYLENBekJJLEVBeUJXLFdBQVcsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBekJ0QjtBQTBCbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBMUJNLEVBMEJXLGNBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBMUJ6QjtBQTJCbkIsZ0JBQVEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLENBQVQsRUFBVyxDQUFYLENBM0JXLEVBMkJJLGFBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEVBQVQsRUFBWSxDQUFaLENBM0JqQjtBQTRCbkIsZ0JBQVEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBNUJXLEVBNEJNLFNBQVMsQ0FBQyxDQUFELEVBQUcsR0FBSCxFQUFPLENBQVAsRUFBUyxDQUFULENBNUJmO0FBNkJuQix1QkFBZSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxFQUFZLENBQVosQ0E3QkksRUE2QlksUUFBUSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0E3QnBCO0FBOEJuQixvQkFBWSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0E5Qk8sRUE4QlUsV0FBVyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0E5QnJCO0FBK0JuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsRUFBUixFQUFXLENBQVgsQ0EvQk0sRUErQlMsVUFBVSxDQUFDLEVBQUQsRUFBSSxDQUFKLEVBQU0sR0FBTixFQUFVLENBQVYsQ0EvQm5CO0FBZ0NuQixpQkFBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FoQ1UsRUFnQ08sU0FBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FoQ2hCO0FBaUNuQixvQkFBWSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FqQ08sRUFpQ1UsaUJBQWlCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWpDM0I7QUFrQ25CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULEVBQVcsQ0FBWCxDQWxDTSxFQWtDUyxnQkFBZ0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbEN6QjtBQW1DbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbkNNLEVBbUNXLGNBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbkN6QjtBQW9DbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBcENNLEVBb0NXLHdCQUF3QixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FwQ25DO0FBcUNuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FyQ00sRUFxQ1csY0FBYyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0FyQ3pCO0FBc0NuQixxQkFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F0Q00sRUFzQ1csYUFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F0Q3hCO0FBdUNuQix1QkFBZSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F2Q0ksRUF1Q2EsaUJBQWlCLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLEVBQVksQ0FBWixDQXZDOUI7QUF3Q25CLHdCQUFnQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F4Q0csRUF3Q2Msa0JBQWtCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXhDaEM7QUF5Q25CLDBCQUFrQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F6Q0MsRUF5Q2dCLGtCQUFrQixDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F6Q2xDO0FBMENuQix1QkFBZSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0ExQ0ksRUEwQ2EsUUFBUSxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0ExQ3JCO0FBMkNuQixxQkFBYSxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsRUFBUixFQUFXLENBQVgsQ0EzQ00sRUEyQ1MsU0FBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0EzQ2xCO0FBNENuQixtQkFBVyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxFQUFXLENBQVgsQ0E1Q1EsRUE0Q08sVUFBVSxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0E1Q2pCO0FBNkNuQiw0QkFBb0IsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBN0NELEVBNkNrQixjQUFjLENBQUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLEVBQVMsQ0FBVCxDQTdDaEM7QUE4Q25CLHdCQUFnQixDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixFQUFZLENBQVosQ0E5Q0csRUE4Q2EsZ0JBQWdCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTlDN0I7QUErQ25CLDBCQUFrQixDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixFQUFZLENBQVosQ0EvQ0MsRUErQ2UsbUJBQW1CLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQS9DbEM7QUFnRG5CLDZCQUFxQixDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxFQUFXLENBQVgsQ0FoREYsRUFnRGlCLG1CQUFtQixDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixFQUFZLENBQVosQ0FoRHBDO0FBaURuQiwyQkFBbUIsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEdBQVIsRUFBWSxDQUFaLENBakRBLEVBaURnQixnQkFBZ0IsQ0FBQyxFQUFELEVBQUksRUFBSixFQUFPLEdBQVAsRUFBVyxDQUFYLENBakRoQztBQWtEbkIscUJBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbERNLEVBa0RXLGFBQWEsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbER4QjtBQW1EbkIsb0JBQVksQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbkRPLEVBbURVLGVBQWUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBbkR6QjtBQW9EbkIsZ0JBQVEsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLEdBQUwsRUFBUyxDQUFULENBcERXLEVBb0RFLFdBQVcsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBcERiO0FBcURuQixpQkFBUyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsQ0FBVCxFQUFXLENBQVgsQ0FyRFUsRUFxREssYUFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxFQUFZLENBQVosQ0FyRGxCO0FBc0RuQixrQkFBVSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsQ0FBVCxFQUFXLENBQVgsQ0F0RFMsRUFzRE0sYUFBYSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsQ0FBUixFQUFVLENBQVYsQ0F0RG5CO0FBdURuQixrQkFBVSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0F2RFMsRUF1RFEsaUJBQWlCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXZEekI7QUF3RG5CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXhETSxFQXdEVyxpQkFBaUIsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBeEQ1QjtBQXlEbkIseUJBQWlCLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXpERSxFQXlEZSxjQUFjLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXpEN0I7QUEwRG5CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTFETSxFQTBEVyxRQUFRLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULEVBQVksQ0FBWixDQTFEbkI7QUEyRG5CLGdCQUFRLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTNEVyxFQTJETSxRQUFRLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQTNEZDtBQTREbkIsc0JBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBNURLLEVBNERZLFVBQVUsQ0FBQyxHQUFELEVBQUssQ0FBTCxFQUFPLEdBQVAsRUFBVyxDQUFYLENBNUR0QjtBQTZEbkIseUJBQWlCLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLEVBQVksQ0FBWixDQTdERTtBQThEbkIsZUFBTyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sQ0FBUCxFQUFTLENBQVQsQ0E5RFksRUE4REMsYUFBYSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxFQUFhLENBQWIsQ0E5RGQ7QUErRG5CLHFCQUFhLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLEVBQVksQ0FBWixDQS9ETSxFQStEVSxlQUFlLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLEVBQVcsQ0FBWCxDQS9EekI7QUFnRW5CLGtCQUFVLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWhFUyxFQWdFUSxjQUFjLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULEVBQVksQ0FBWixDQWhFdEI7QUFpRW5CLG9CQUFZLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLEVBQVcsQ0FBWCxDQWpFTyxFQWlFUSxZQUFZLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWpFcEI7QUFrRW5CLGtCQUFVLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLEVBQVcsQ0FBWCxDQWxFUyxFQWtFTSxVQUFVLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQWxFaEI7QUFtRW5CLG1CQUFXLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQW5FUSxFQW1FUyxhQUFhLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLEVBQVksQ0FBWixDQW5FdEI7QUFvRW5CLHFCQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXBFTSxFQW9FVyxhQUFhLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXBFeEI7QUFxRW5CLGdCQUFRLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXJFVyxFQXFFTSxlQUFlLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQXJFckI7QUFzRW5CLHFCQUFhLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLEVBQVksQ0FBWixDQXRFTSxFQXNFVSxPQUFPLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXRFakI7QUF1RW5CLGdCQUFRLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLEVBQVcsQ0FBWCxDQXZFVyxFQXVFSSxXQUFXLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULEVBQWEsQ0FBYixDQXZFZjtBQXdFbkIsa0JBQVUsQ0FBQyxHQUFELEVBQUssRUFBTCxFQUFRLEVBQVIsRUFBVyxDQUFYLENBeEVTLEVBd0VNLGFBQWEsQ0FBQyxFQUFELEVBQUksR0FBSixFQUFRLEdBQVIsRUFBWSxDQUFaLENBeEVuQjtBQXlFbkIsa0JBQVUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBekVTLEVBeUVRLFNBQVMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBekVqQjtBQTBFbkIsaUJBQVMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBMUVVLEVBMEVPLGNBQWMsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBYSxDQUFiLENBMUVyQjtBQTJFbkIsa0JBQVUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLENBQVQsRUFBVyxDQUFYLENBM0VTLEVBMkVNLGVBQWUsQ0FBQyxHQUFELEVBQUssR0FBTCxFQUFTLEVBQVQsRUFBWSxDQUFaLENBM0VyQixFQUFyQjs7QUE2RUEsYUFBU0MsY0FBVCxDQUF3QjdvQixDQUF4QixFQUEyQjtBQUFHO0FBQzVCQSxZQUFJZ2IsS0FBS3RLLEtBQUwsQ0FBVzFRLENBQVgsQ0FBSixDQUR5QixDQUNMO0FBQ3BCLGVBQU9BLElBQUksQ0FBSixHQUFRLENBQVIsR0FBWUEsSUFBSSxHQUFKLEdBQVUsR0FBVixHQUFnQkEsQ0FBbkM7QUFDRDs7QUFFRCxhQUFTOG9CLGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCO0FBQUc7QUFDN0IsZUFBT0EsSUFBSSxDQUFKLEdBQVEsQ0FBUixHQUFZQSxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVlBLENBQS9CO0FBQ0Q7O0FBRUQsYUFBU0MsYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFBRztBQUM3QixZQUFJQSxJQUFJQSxJQUFJNW9CLE1BQUosR0FBYSxDQUFqQixNQUF3QixHQUE1QixFQUNFLE9BQU93b0IsZUFBZUssV0FBV0QsR0FBWCxJQUFrQixHQUFsQixHQUF3QixHQUF2QyxDQUFQO0FBQ0YsZUFBT0osZUFBZU0sU0FBU0YsR0FBVCxDQUFmLENBQVA7QUFDRDs7QUFFRCxhQUFTRyxlQUFULENBQXlCSCxHQUF6QixFQUE4QjtBQUFHO0FBQy9CLFlBQUlBLElBQUlBLElBQUk1b0IsTUFBSixHQUFhLENBQWpCLE1BQXdCLEdBQTVCLEVBQ0UsT0FBT3lvQixnQkFBZ0JJLFdBQVdELEdBQVgsSUFBa0IsR0FBbEMsQ0FBUDtBQUNGLGVBQU9ILGdCQUFnQkksV0FBV0QsR0FBWCxDQUFoQixDQUFQO0FBQ0Q7O0FBRUQsYUFBU0ksY0FBVCxDQUF3QkMsRUFBeEIsRUFBNEJDLEVBQTVCLEVBQWdDakcsQ0FBaEMsRUFBbUM7QUFDakMsWUFBSUEsSUFBSSxDQUFSLEVBQVdBLEtBQUssQ0FBTCxDQUFYLEtBQ0ssSUFBSUEsSUFBSSxDQUFSLEVBQVdBLEtBQUssQ0FBTDs7QUFFaEIsWUFBSUEsSUFBSSxDQUFKLEdBQVEsQ0FBWixFQUFlLE9BQU9nRyxLQUFLLENBQUNDLEtBQUtELEVBQU4sSUFBWWhHLENBQVosR0FBZ0IsQ0FBNUI7QUFDZixZQUFJQSxJQUFJLENBQUosR0FBUSxDQUFaLEVBQWUsT0FBT2lHLEVBQVA7QUFDZixZQUFJakcsSUFBSSxDQUFKLEdBQVEsQ0FBWixFQUFlLE9BQU9nRyxLQUFLLENBQUNDLEtBQUtELEVBQU4sS0FBYSxJQUFFLENBQUYsR0FBTWhHLENBQW5CLElBQXdCLENBQXBDO0FBQ2YsZUFBT2dHLEVBQVA7QUFDRDs7QUFFRCxhQUFTRSxhQUFULENBQXVCQyxPQUF2QixFQUFnQztBQUM5QjtBQUNBLFlBQUlSLE1BQU1RLFFBQVE1b0IsT0FBUixDQUFnQixJQUFoQixFQUFzQixFQUF0QixFQUEwQm1kLFdBQTFCLEVBQVY7O0FBRUE7QUFDQSxZQUFJaUwsT0FBT0wsY0FBWCxFQUEyQixPQUFPQSxlQUFlSyxHQUFmLEVBQW9COWQsS0FBcEIsRUFBUCxDQUxHLENBS2tDOztBQUVoRTtBQUNBLFlBQUk4ZCxJQUFJLENBQUosTUFBVyxHQUFmLEVBQW9CO0FBQ2xCLGdCQUFJQSxJQUFJNW9CLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixvQkFBSXFwQixLQUFLUCxTQUFTRixJQUFJNWQsTUFBSixDQUFXLENBQVgsQ0FBVCxFQUF3QixFQUF4QixDQUFULENBRG9CLENBQ21CO0FBQ3ZDLG9CQUFJLEVBQUVxZSxNQUFNLENBQU4sSUFBV0EsTUFBTSxLQUFuQixDQUFKLEVBQStCLE9BQU8sSUFBUCxDQUZYLENBRXlCO0FBQzdDLHVCQUFPLENBQUUsQ0FBQ0EsS0FBSyxLQUFOLEtBQWdCLENBQWpCLEdBQXVCLENBQUNBLEtBQUssS0FBTixLQUFnQixDQUF4QyxFQUNFQSxLQUFLLElBQU4sR0FBZSxDQUFDQSxLQUFLLElBQU4sS0FBZSxDQUQvQixFQUVFQSxLQUFLLEdBQU4sR0FBYyxDQUFDQSxLQUFLLEdBQU4sS0FBYyxDQUY3QixFQUdDLENBSEQsQ0FBUDtBQUlELGFBUEQsTUFPTyxJQUFJVCxJQUFJNW9CLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUMzQixvQkFBSXFwQixLQUFLUCxTQUFTRixJQUFJNWQsTUFBSixDQUFXLENBQVgsQ0FBVCxFQUF3QixFQUF4QixDQUFULENBRDJCLENBQ1k7QUFDdkMsb0JBQUksRUFBRXFlLE1BQU0sQ0FBTixJQUFXQSxNQUFNLFFBQW5CLENBQUosRUFBa0MsT0FBTyxJQUFQLENBRlAsQ0FFcUI7QUFDaEQsdUJBQU8sQ0FBQyxDQUFDQSxLQUFLLFFBQU4sS0FBbUIsRUFBcEIsRUFDQyxDQUFDQSxLQUFLLE1BQU4sS0FBaUIsQ0FEbEIsRUFFQ0EsS0FBSyxJQUZOLEVBR0MsQ0FIRCxDQUFQO0FBSUQ7O0FBRUQsbUJBQU8sSUFBUDtBQUNEOztBQUVELFlBQUlDLEtBQUtWLElBQUlsb0IsT0FBSixDQUFZLEdBQVosQ0FBVDtBQUFBLFlBQTJCNm9CLEtBQUtYLElBQUlsb0IsT0FBSixDQUFZLEdBQVosQ0FBaEM7QUFDQSxZQUFJNG9CLE9BQU8sQ0FBQyxDQUFSLElBQWFDLEtBQUssQ0FBTCxLQUFXWCxJQUFJNW9CLE1BQWhDLEVBQXdDO0FBQ3RDLGdCQUFJd3BCLFFBQVFaLElBQUk1ZCxNQUFKLENBQVcsQ0FBWCxFQUFjc2UsRUFBZCxDQUFaO0FBQ0EsZ0JBQUlHLFNBQVNiLElBQUk1ZCxNQUFKLENBQVdzZSxLQUFHLENBQWQsRUFBaUJDLE1BQUlELEtBQUcsQ0FBUCxDQUFqQixFQUE0Qi9vQixLQUE1QixDQUFrQyxHQUFsQyxDQUFiO0FBQ0EsZ0JBQUltcEIsUUFBUSxDQUFaLENBSHNDLENBR3RCO0FBQ2hCLG9CQUFRRixLQUFSO0FBQ0UscUJBQUssTUFBTDtBQUNFLHdCQUFJQyxPQUFPenBCLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUIsT0FBTyxJQUFQO0FBQ3pCMHBCLDRCQUFRWCxnQkFBZ0JVLE9BQU9sRixHQUFQLEVBQWhCLENBQVI7QUFDQTtBQUNGLHFCQUFLLEtBQUw7QUFDRSx3QkFBSWtGLE9BQU96cEIsTUFBUCxLQUFrQixDQUF0QixFQUF5QixPQUFPLElBQVA7QUFDekIsMkJBQU8sQ0FBQzJvQixjQUFjYyxPQUFPLENBQVAsQ0FBZCxDQUFELEVBQ0NkLGNBQWNjLE9BQU8sQ0FBUCxDQUFkLENBREQsRUFFQ2QsY0FBY2MsT0FBTyxDQUFQLENBQWQsQ0FGRCxFQUdDQyxLQUhELENBQVA7QUFJRixxQkFBSyxNQUFMO0FBQ0Usd0JBQUlELE9BQU96cEIsTUFBUCxLQUFrQixDQUF0QixFQUF5QixPQUFPLElBQVA7QUFDekIwcEIsNEJBQVFYLGdCQUFnQlUsT0FBT2xGLEdBQVAsRUFBaEIsQ0FBUjtBQUNBO0FBQ0YscUJBQUssS0FBTDtBQUNFLHdCQUFJa0YsT0FBT3pwQixNQUFQLEtBQWtCLENBQXRCLEVBQXlCLE9BQU8sSUFBUDtBQUN6Qix3QkFBSWlqQixJQUFLLENBQUU0RixXQUFXWSxPQUFPLENBQVAsQ0FBWCxJQUF3QixHQUF6QixHQUFnQyxHQUFqQyxJQUF3QyxHQUF6QyxHQUFnRCxHQUF4RCxDQUZGLENBRWdFO0FBQzlEO0FBQ0E7QUFDQSx3QkFBSW5HLElBQUl5RixnQkFBZ0JVLE9BQU8sQ0FBUCxDQUFoQixDQUFSO0FBQ0Esd0JBQUk5akIsSUFBSW9qQixnQkFBZ0JVLE9BQU8sQ0FBUCxDQUFoQixDQUFSO0FBQ0Esd0JBQUlQLEtBQUt2akIsS0FBSyxHQUFMLEdBQVdBLEtBQUsyZCxJQUFJLENBQVQsQ0FBWCxHQUF5QjNkLElBQUkyZCxDQUFKLEdBQVEzZCxJQUFJMmQsQ0FBOUM7QUFDQSx3QkFBSTJGLEtBQUt0akIsSUFBSSxDQUFKLEdBQVF1akIsRUFBakI7QUFDQSwyQkFBTyxDQUFDVixlQUFlUSxlQUFlQyxFQUFmLEVBQW1CQyxFQUFuQixFQUF1QmpHLElBQUUsSUFBRSxDQUEzQixJQUFnQyxHQUEvQyxDQUFELEVBQ0N1RixlQUFlUSxlQUFlQyxFQUFmLEVBQW1CQyxFQUFuQixFQUF1QmpHLENBQXZCLElBQTRCLEdBQTNDLENBREQsRUFFQ3VGLGVBQWVRLGVBQWVDLEVBQWYsRUFBbUJDLEVBQW5CLEVBQXVCakcsSUFBRSxJQUFFLENBQTNCLElBQWdDLEdBQS9DLENBRkQsRUFHQ3lHLEtBSEQsQ0FBUDtBQUlGO0FBQ0UsMkJBQU8sSUFBUDtBQTdCSjtBQStCRDs7QUFFRCxlQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJO0FBQUVwUSxnQkFBUTZQLGFBQVIsR0FBd0JBLGFBQXhCO0FBQXdDLEtBQTlDLENBQStDLE9BQU01a0IsQ0FBTixFQUFTLENBQUc7QUFDMUQsQ0ExTW9CLENBQXJCOztJQTRNTWEsSztBQUNGLG1CQUFZM0IsQ0FBWixFQUFla21CLENBQWYsRUFBa0JDLENBQWxCLEVBQTRCO0FBQUEsWUFBUGhmLENBQU8sdUVBQUgsQ0FBRzs7QUFBQTs7QUFDeEIsYUFBS25ILENBQUwsR0FBU0EsQ0FBVDtBQUNBLGFBQUtrbUIsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsYUFBS0MsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsYUFBS2hmLENBQUwsR0FBU0EsQ0FBVDtBQUNIOzs7O21DQWlCVTtBQUFBLDJCQUNjLEtBQUtpZixPQUFMLEVBRGQ7QUFBQTtBQUFBLGdCQUNBcG1CLENBREE7QUFBQSxnQkFDR2ttQixDQURIO0FBQUEsZ0JBQ01DLENBRE47QUFBQSxnQkFDU2hmLENBRFQ7O0FBRVAsNkJBQWdCK1AsS0FBS3RLLEtBQUwsQ0FBVzVNLENBQVgsQ0FBaEIsU0FBbUNrWCxLQUFLdEssS0FBTCxDQUFXc1osQ0FBWCxDQUFuQyxTQUFzRGhQLEtBQUt0SyxLQUFMLENBQVd1WixDQUFYLENBQXRELFNBQXlFaGYsQ0FBekU7QUFDSDs7O2tDQUNTO0FBQUEsZ0JBQ0NuSCxDQURELEdBQ2UsSUFEZixDQUNDQSxDQUREO0FBQUEsZ0JBQ0lrbUIsQ0FESixHQUNlLElBRGYsQ0FDSUEsQ0FESjtBQUFBLGdCQUNPQyxDQURQLEdBQ2UsSUFEZixDQUNPQSxDQURQO0FBQUEsZ0JBQ1VoZixDQURWLEdBQ2UsSUFEZixDQUNVQSxDQURWOztBQUVOLG1CQUFPQSxNQUFNLENBQU4sR0FBVSxDQUNiLENBRGEsRUFFYixDQUZhLEVBR2IsQ0FIYSxFQUliLENBSmEsQ0FBVixHQUtILENBQ0FuSCxJQUFJLEdBQUosR0FBVW1ILENBRFYsRUFFQStlLElBQUksR0FBSixHQUFVL2UsQ0FGVixFQUdBZ2YsSUFBSSxHQUFKLEdBQVVoZixDQUhWLEVBSUFBLENBSkEsQ0FMSjtBQVdIOzs7OEJBakNZd1IsSyxFQUFPO0FBQ2hCLGdCQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNSLHVCQUFPelksU0FBUDtBQUNIO0FBQ0QsZ0JBQUl5WSxpQkFBaUJoWCxLQUFyQixFQUE0QjtBQUN4Qix1QkFBT2dYLEtBQVA7QUFDSDtBQUNELGdCQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0IsdUJBQU96WSxTQUFQO0FBQ0g7QUFDRCxnQkFBTWdRLE9BQU8yVSxlQUFlYSxhQUFmLENBQTZCL00sS0FBN0IsQ0FBYjtBQUNBLGdCQUFJLENBQUN6SSxJQUFMLEVBQVc7QUFDUCx1QkFBT2hRLFNBQVA7QUFDSDtBQUNELG1CQUFPLElBQUl5QixLQUFKLENBQVV1TyxLQUFLLENBQUwsSUFBVSxHQUFWLEdBQWdCQSxLQUFLLENBQUwsQ0FBMUIsRUFBbUNBLEtBQUssQ0FBTCxJQUFVLEdBQVYsR0FBZ0JBLEtBQUssQ0FBTCxDQUFuRCxFQUE0REEsS0FBSyxDQUFMLElBQVUsR0FBVixHQUFnQkEsS0FBSyxDQUFMLENBQTVFLEVBQXFGQSxLQUFLLENBQUwsQ0FBckYsQ0FBUDtBQUNIOzs7Ozs7QUFvQkx2TyxNQUFNMGtCLEtBQU4sR0FBYyxJQUFJMWtCLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFkO0FBQ0FBLE1BQU0ya0IsS0FBTixHQUFjLElBQUkza0IsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQWQ7QUFDQUEsTUFBTTRrQixXQUFOLEdBQW9CLElBQUk1a0IsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQXBCO0FBQ0FBLE1BQU02a0IsR0FBTixHQUFZLElBQUk3a0IsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQVo7QUFDQUEsTUFBTThrQixJQUFOLEdBQWEsSUFBSTlrQixLQUFKLENBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBYjs7SUFFTStrQixRO0FBQ0Ysc0JBQVlDLGFBQVosRUFBMkJDLGtCQUEzQixFQUErQ0MsTUFBL0MsRUFBdUQ7QUFBQTs7QUFDbkQsWUFBSUYsYUFBSixFQUNJLEtBQUtHLFdBQUwsR0FBbUJGLHFCQUFxQixTQUFyQixHQUFpQyxNQUFwRCxDQURKLEtBR0ksS0FBS0UsV0FBTCxHQUFtQkYscUJBQXFCLFFBQXJCLEdBQWdDLE1BQW5EO0FBQ0osYUFBS0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBSzdXLFFBQUwsR0FBZ0IsSUFBSStXLEtBQUtMLFFBQVQsQ0FBa0IsS0FBS0csTUFBTCxHQUFjLEtBQUtBLE1BQW5CLEdBQTRCLEVBQTlDLEVBQWtEO0FBQzlEQyx5QkFBYSxLQUFLQSxXQUQ0QztBQUU5REUsbUJBQU87QUFGdUQsU0FBbEQsQ0FBaEI7QUFJSDs7OztnQ0FDT0MsRyxFQUFLQyxHLEVBQUs7QUFDZCxtQkFBTyxLQUFLbFgsUUFBTCxDQUFjbVgsT0FBZCxDQUFzQkYsR0FBdEIsRUFBMkJDLEdBQTNCLENBQVA7QUFDSDs7O3lDQUNnQjtBQUNiLG1CQUFPLElBQUlILEtBQUtMLFFBQVQsQ0FBa0IsS0FBS0csTUFBTCxHQUFjLEtBQUtBLE1BQW5CLEdBQTRCLEVBQTlDLEVBQWtETyxlQUFsRCxHQUFvRVAsTUFBM0U7QUFDSDs7Ozs7O0lBR0NRLGdCLEdBQ0YsMEJBQVlDLElBQVosRUFBa0IvYixLQUFsQixFQUF5QmdjLEtBQXpCLEVBQWdDQyxTQUFoQyxFQUEyQ0MsU0FBM0MsRUFBc0Q7QUFBQTs7QUFDbEQsU0FBS0gsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBSy9iLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUtnYyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0gsQzs7SUFFQ0MsUztBQUNGLHVCQUFZQyxRQUFaLEVBQXNCO0FBQUE7O0FBQ2xCLGFBQUtBLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0g7Ozs7a0NBSVM7QUFDTixnQkFBSSxLQUFLQSxRQUFMLENBQWNwckIsTUFBZCxLQUF5QixDQUE3QixFQUNJLE9BQU8sSUFBUDtBQUNKLG1CQUFPLENBQUMsS0FBS29yQixRQUFMLENBQWMxbEIsSUFBZCxDQUFtQjtBQUFBLHVCQUFXMmxCLFFBQVFOLElBQVIsQ0FBYS9xQixNQUFiLEtBQXdCLENBQXhCLElBQTZCcXJCLFFBQVFyYyxLQUFSLElBQWlCcWMsUUFBUXJjLEtBQVIsQ0FBY3JELElBQWQsQ0FBbUIzTCxNQUFuQixLQUE4QixDQUF2RjtBQUFBLGFBQW5CLENBQVI7QUFDSDs7O21DQVFVO0FBQ1AsZ0JBQUksS0FBS29yQixRQUFMLENBQWNwckIsTUFBZCxLQUF5QixDQUE3QixFQUNJLE9BQU8sRUFBUDtBQUNKLG1CQUFPLEtBQUtvckIsUUFBTCxDQUFjL3FCLEdBQWQsQ0FBa0I7QUFBQSx1QkFBV2dyQixRQUFRTixJQUFuQjtBQUFBLGFBQWxCLEVBQTJDaGdCLElBQTNDLENBQWdELEVBQWhELENBQVA7QUFDSDs7O29DQUNXO0FBQ1IsZ0JBQU11Z0IsYUFBYSxDQUFDLFFBQUQsQ0FBbkI7QUFEUTtBQUFBO0FBQUE7O0FBQUE7QUFFUixzQ0FBc0IsS0FBS0YsUUFBM0IsbUlBQXFDO0FBQUEsd0JBQTFCQyxPQUEwQjs7QUFDakMsd0JBQUlBLFFBQVFyYyxLQUFaLEVBQW1CO0FBQ2ZzYyxtQ0FBVzNxQixJQUFYLENBQWdCLENBQ1osT0FEWSxFQUVaMHFCLFFBQVFyYyxLQUFSLENBQWNyRCxJQUZGLENBQWhCO0FBSUE7QUFDSDtBQUNEMmYsK0JBQVczcUIsSUFBWCxDQUFnQjBxQixRQUFRTixJQUF4QjtBQUNBLHdCQUFNeFQsVUFBVSxFQUFoQjtBQUNBLHdCQUFJOFQsUUFBUUosU0FBWixFQUF1QjtBQUNuQjFULGdDQUFRLFdBQVIsSUFBdUIsQ0FDbkIsU0FEbUIsRUFFbkI4VCxRQUFRSixTQUFSLENBQWtCMXFCLEtBQWxCLENBQXdCLEdBQXhCLENBRm1CLENBQXZCO0FBSUg7QUFDRCx3QkFBSThxQixRQUFRTCxLQUFaLEVBQW1CO0FBQ2Z6VCxnQ0FBUSxZQUFSLElBQXdCOFQsUUFBUUwsS0FBaEM7QUFDSDtBQUNELHdCQUFJSyxRQUFRSCxTQUFaLEVBQXVCO0FBQ25CM1QsZ0NBQVEsWUFBUixJQUF3QixDQUFDLE1BQUQsRUFBU3ZDLE1BQVQsQ0FBZ0JxVyxRQUFRSCxTQUFSLENBQWtCckIsT0FBbEIsRUFBaEIsQ0FBeEI7QUFDSDtBQUNEeUIsK0JBQVczcUIsSUFBWCxDQUFnQjRXLE9BQWhCO0FBQ0g7QUF6Qk87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEwQlIsbUJBQU8rVCxVQUFQO0FBQ0g7OzttQ0EvQ2lCQyxXLEVBQWE7QUFDM0IsbUJBQU8sSUFBSUosU0FBSixDQUFjLENBQUMsSUFBSUwsZ0JBQUosQ0FBcUJTLFdBQXJCLEVBQWtDLElBQWxDLEVBQXdDLElBQXhDLEVBQThDLElBQTlDLEVBQW9ELElBQXBELENBQUQsQ0FBZCxDQUFQO0FBQ0g7OztnQ0FNY1IsSSxFQUFNO0FBQ2pCLGdCQUFJQSxnQkFBZ0JJLFNBQXBCLEVBQStCO0FBQzNCLHVCQUFPSixJQUFQO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsdUJBQU9JLFVBQVVLLFVBQVYsQ0FBcUJULElBQXJCLENBQVA7QUFDSDtBQUNKOzs7Ozs7SUFvQ0NVLGE7QUFDRiwyQkFBWWxVLE9BQVosRUFBcUI7QUFBQTs7QUFDakIsYUFBSzVMLElBQUwsR0FBWTRMLFFBQVE1TCxJQUFwQjtBQUNBLGFBQUsrZixTQUFMLEdBQWlCblUsUUFBUW1VLFNBQXpCO0FBQ0g7Ozs7bUNBQ1U7QUFDUCxtQkFBTyxLQUFLL2YsSUFBWjtBQUNIOzs7b0NBU1c7QUFDUixtQkFBTyxDQUNILE9BREcsRUFFSCxLQUFLQSxJQUZGLENBQVA7QUFJSDs7O21DQWJpQkEsSSxFQUFNO0FBQ3BCLGdCQUFJLENBQUNBLElBQUwsRUFDSSxPQUFPLElBQVA7QUFDSixtQkFBTyxJQUFJOGYsYUFBSixDQUFrQjtBQUNyQjlmLDBCQURxQjtBQUVyQitmLDJCQUFXO0FBRlUsYUFBbEIsQ0FBUDtBQUlIOzs7Ozs7QUFTTCxTQUFTQyxZQUFULENBQXNCbG9CLENBQXRCLEVBQXlCa21CLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQmhmLENBQS9CLEVBQWtDO0FBQzlCLFFBQUksRUFBRSxPQUFPbkgsQ0FBUCxLQUFhLFFBQWIsSUFBeUJBLEtBQUssQ0FBOUIsSUFBbUNBLEtBQUssR0FBeEMsSUFBK0MsT0FBT2ttQixDQUFQLEtBQWEsUUFBNUQsSUFBd0VBLEtBQUssQ0FBN0UsSUFBa0ZBLEtBQUssR0FBdkYsSUFBOEYsT0FBT0MsQ0FBUCxLQUFhLFFBQTNHLElBQXVIQSxLQUFLLENBQTVILElBQWlJQSxLQUFLLEdBQXhJLENBQUosRUFBa0o7QUFDOUksWUFBTS9kLFFBQVEsT0FBT2pCLENBQVAsS0FBYSxRQUFiLEdBQXdCLENBQ2xDbkgsQ0FEa0MsRUFFbENrbUIsQ0FGa0MsRUFHbENDLENBSGtDLEVBSWxDaGYsQ0FKa0MsQ0FBeEIsR0FLVixDQUNBbkgsQ0FEQSxFQUVBa21CLENBRkEsRUFHQUMsQ0FIQSxDQUxKO0FBVUEsd0NBQStCL2QsTUFBTWQsSUFBTixDQUFXLElBQVgsQ0FBL0I7QUFDSDtBQUNELFFBQUksRUFBRSxPQUFPSCxDQUFQLEtBQWEsV0FBYixJQUE0QixPQUFPQSxDQUFQLEtBQWEsUUFBYixJQUF5QkEsS0FBSyxDQUE5QixJQUFtQ0EsS0FBSyxDQUF0RSxDQUFKLEVBQThFO0FBQzFFLHdDQUErQixDQUMzQm5ILENBRDJCLEVBRTNCa21CLENBRjJCLEVBRzNCQyxDQUgyQixFQUkzQmhmLENBSjJCLEVBSzdCRyxJQUw2QixDQUt4QixJQUx3QixDQUEvQjtBQU1IO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7QUFDRCxTQUFTNmdCLE9BQVQsQ0FBaUJDLEtBQWpCLEVBQXdCO0FBQ3BCLFFBQUlBLFVBQVUsSUFBZCxFQUFvQjtBQUNoQixlQUFPLElBQVA7QUFDSCxLQUZELE1BRU8sSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2xDLGVBQU8sSUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJLE9BQU9BLEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDbkMsZUFBTyxJQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUNsQyxlQUFPLElBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSUEsaUJBQWlCem1CLEtBQXJCLEVBQTRCO0FBQy9CLGVBQU8sSUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJeW1CLGlCQUFpQjFCLFFBQXJCLEVBQStCO0FBQ2xDLGVBQU8sSUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJMEIsaUJBQWlCVixTQUFyQixFQUFnQztBQUNuQyxlQUFPLElBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSVUsaUJBQWlCSixhQUFyQixFQUFvQztBQUN2QyxlQUFPLElBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSTVyQixNQUFNQyxPQUFOLENBQWMrckIsS0FBZCxDQUFKLEVBQTBCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQzdCLGtDQUFtQkEsS0FBbkIsbUlBQTBCO0FBQUEsb0JBQWZDLElBQWU7O0FBQ3RCLG9CQUFJLENBQUNGLFFBQVFFLElBQVIsQ0FBTCxFQUFvQjtBQUNoQiwyQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUw0QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU03QixlQUFPLElBQVA7QUFDSCxLQVBNLE1BT0EsSUFBSSxRQUFPRCxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQXJCLEVBQStCO0FBQ2xDLGFBQUssSUFBTTdpQixHQUFYLElBQWtCNmlCLEtBQWxCLEVBQXlCO0FBQ3JCLGdCQUFJLENBQUNELFFBQVFDLE1BQU03aUIsR0FBTixDQUFSLENBQUwsRUFBMEI7QUFDdEIsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxlQUFPLElBQVA7QUFDSCxLQVBNLE1BT0E7QUFDSCxlQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBUytpQixNQUFULENBQWdCbGdCLEtBQWhCLEVBQXVCO0FBQ25CLFFBQUlBLFVBQVUsSUFBZCxFQUFvQjtBQUNoQixlQUFPbWIsUUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJLE9BQU9uYixLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2xDLGVBQU9zYixVQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUksT0FBT3RiLEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDbkMsZUFBT3ViLFdBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSSxPQUFPdmIsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUNsQyxlQUFPcWIsVUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJcmIsaUJBQWlCekcsS0FBckIsRUFBNEI7QUFDL0IsZUFBT2lpQixTQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUl4YixpQkFBaUJzZSxRQUFyQixFQUErQjtBQUNsQyxlQUFPMUMsWUFBUDtBQUNILEtBRk0sTUFFQSxJQUFJNWIsaUJBQWlCc2YsU0FBckIsRUFBZ0M7QUFDbkMsZUFBT3pELGFBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSTdiLGlCQUFpQjRmLGFBQXJCLEVBQW9DO0FBQ3ZDLGVBQU85RCxpQkFBUDtBQUNILEtBRk0sTUFFQSxJQUFJOW5CLE1BQU1DLE9BQU4sQ0FBYytMLEtBQWQsQ0FBSixFQUEwQjtBQUM3QixZQUFNN0wsU0FBUzZMLE1BQU03TCxNQUFyQjtBQUNBLFlBQUk0bkIsaUJBQUo7QUFGNkI7QUFBQTtBQUFBOztBQUFBO0FBRzdCLGtDQUFtQi9iLEtBQW5CLG1JQUEwQjtBQUFBLG9CQUFmaWdCLElBQWU7O0FBQ3RCLG9CQUFNalAsSUFBSWtQLE9BQU9ELElBQVAsQ0FBVjtBQUNBLG9CQUFJLENBQUNsRSxRQUFMLEVBQWU7QUFDWEEsK0JBQVcvSyxDQUFYO0FBQ0gsaUJBRkQsTUFFTyxJQUFJK0ssYUFBYS9LLENBQWpCLEVBQW9CO0FBQ3ZCO0FBQ0gsaUJBRk0sTUFFQTtBQUNIK0ssK0JBQVdMLFNBQVg7QUFDQTtBQUNIO0FBQ0o7QUFiNEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFjN0IsZUFBT3pVLE1BQU04VSxZQUFZTCxTQUFsQixFQUE2QnZuQixNQUE3QixDQUFQO0FBQ0gsS0FmTSxNQWVBO0FBQ0gsZUFBT3NuQixVQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVMwRSxVQUFULENBQW9CbmdCLEtBQXBCLEVBQTJCO0FBQ3ZCLFFBQU1sSCxjQUFja0gsS0FBZCx5Q0FBY0EsS0FBZCxDQUFOO0FBQ0EsUUFBSUEsVUFBVSxJQUFkLEVBQW9CO0FBQ2hCLGVBQU8sRUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJbEgsU0FBUyxRQUFULElBQXFCQSxTQUFTLFFBQTlCLElBQTBDQSxTQUFTLFNBQXZELEVBQWtFO0FBQ3JFLGVBQU9rVyxPQUFPaFAsS0FBUCxDQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUlBLGlCQUFpQnpHLEtBQWpCLElBQTBCeUcsaUJBQWlCc2YsU0FBM0MsSUFBd0R0ZixpQkFBaUI0ZixhQUE3RSxFQUE0RjtBQUMvRixlQUFPNWYsTUFBTXhHLFFBQU4sRUFBUDtBQUNILEtBRk0sTUFFQTtBQUNILGVBQU85QyxLQUFLOFUsU0FBTCxDQUFleEwsS0FBZixDQUFQO0FBQ0g7QUFDSjs7SUFFS29nQixPO0FBQ0YscUJBQVl0bkIsSUFBWixFQUFrQmtILEtBQWxCLEVBQXlCO0FBQUE7O0FBQ3JCLGFBQUtsSCxJQUFMLEdBQVlBLElBQVo7QUFDQSxhQUFLa0gsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7Ozs7bUNBY1U7QUFDUCxtQkFBTyxLQUFLQSxLQUFaO0FBQ0g7OztvQ0FDVyxDQUNYOzs7d0NBQ2U7QUFDWixtQkFBTyxJQUFQO0FBQ0g7OztvQ0FDVztBQUNSLGdCQUFJLEtBQUtsSCxJQUFMLENBQVVzaUIsSUFBVixLQUFtQixPQUFuQixJQUE4QixLQUFLdGlCLElBQUwsQ0FBVXNpQixJQUFWLEtBQW1CLFFBQXJELEVBQStEO0FBQzNELHVCQUFPLENBQ0gsU0FERyxFQUVILEtBQUtwYixLQUZGLENBQVA7QUFJSCxhQUxELE1BS08sSUFBSSxLQUFLQSxLQUFMLFlBQXNCekcsS0FBMUIsRUFBaUM7QUFDcEMsdUJBQU8sQ0FBQyxNQUFELEVBQVM0UCxNQUFULENBQWdCLEtBQUtuSixLQUFMLENBQVdnZSxPQUFYLEVBQWhCLENBQVA7QUFDSCxhQUZNLE1BRUEsSUFBSSxLQUFLaGUsS0FBTCxZQUFzQnNmLFNBQTFCLEVBQXFDO0FBQ3hDLHVCQUFPLEtBQUt0ZixLQUFMLENBQVdxZ0IsU0FBWCxFQUFQO0FBQ0gsYUFGTSxNQUVBO0FBQ0gsdUJBQU8sS0FBS3JnQixLQUFaO0FBQ0g7QUFDSjs7OzhCQWxDWXNnQixJLEVBQU1DLE8sRUFBUztBQUN4QixnQkFBSUQsS0FBS25zQixNQUFMLEtBQWdCLENBQXBCLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIscUVBQWdGbW9CLEtBQUtuc0IsTUFBTCxHQUFjLENBQTlGLGdCQUFQO0FBQ0osZ0JBQUksQ0FBQzRyQixRQUFRTyxLQUFLLENBQUwsQ0FBUixDQUFMLEVBQ0ksT0FBT0MsUUFBUXBvQixLQUFSLGlCQUFQO0FBQ0osZ0JBQU02SCxRQUFRc2dCLEtBQUssQ0FBTCxDQUFkO0FBQ0EsZ0JBQUl4bkIsT0FBT29uQixPQUFPbGdCLEtBQVAsQ0FBWDtBQUNBLGdCQUFNbWMsV0FBV29FLFFBQVFDLFlBQXpCO0FBQ0EsZ0JBQUkxbkIsS0FBS3NpQixJQUFMLEtBQWMsT0FBZCxJQUF5QnRpQixLQUFLa2pCLENBQUwsS0FBVyxDQUFwQyxJQUF5Q0csUUFBekMsSUFBcURBLFNBQVNmLElBQVQsS0FBa0IsT0FBdkUsS0FBbUYsT0FBT2UsU0FBU0gsQ0FBaEIsS0FBc0IsUUFBdEIsSUFBa0NHLFNBQVNILENBQVQsS0FBZSxDQUFwSSxDQUFKLEVBQTRJO0FBQ3hJbGpCLHVCQUFPcWpCLFFBQVA7QUFDSDtBQUNELG1CQUFPLElBQUlpRSxPQUFKLENBQVl0bkIsSUFBWixFQUFrQmtILEtBQWxCLENBQVA7QUFDSDs7Ozs7O0lBeUJDeWdCLFk7QUFDRiwwQkFBWTFGLE9BQVosRUFBcUI7QUFBQTs7QUFDakIsYUFBS2piLElBQUwsR0FBWSwyQkFBWjtBQUNBLGFBQUtpYixPQUFMLEdBQWVBLE9BQWY7QUFDSDs7OztpQ0FDUTtBQUNMLG1CQUFPLEtBQUtBLE9BQVo7QUFDSDs7Ozs7O0FBR0wsSUFBTTJGLFFBQVE7QUFDVmxaLFlBQVE4VCxVQURFO0FBRVY3VCxZQUFRNFQsVUFGRTtBQUdWM1QsYUFBUzZULFdBSEM7QUFJVjVULFlBQVE4VDtBQUpFLENBQWQ7O0lBTU1rRixTO0FBQ0YsdUJBQVk3bkIsSUFBWixFQUFrQnduQixJQUFsQixFQUF3QjtBQUFBOztBQUNwQixhQUFLeG5CLElBQUwsR0FBWUEsSUFBWjtBQUNBLGFBQUt3bkIsSUFBTCxHQUFZQSxJQUFaO0FBQ0g7Ozs7aUNBdUNRTSxHLEVBQUs7QUFDVixpQkFBSyxJQUFJOXNCLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLd3NCLElBQUwsQ0FBVW5zQixNQUE5QixFQUFzQ0wsR0FBdEMsRUFBMkM7QUFDdkMsb0JBQU1rTSxRQUFRLEtBQUtzZ0IsSUFBTCxDQUFVeHNCLENBQVYsRUFBYStzQixRQUFiLENBQXNCRCxHQUF0QixDQUFkO0FBQ0Esb0JBQU16b0IsU0FBUStqQixjQUFhLEtBQUtwakIsSUFBbEIsRUFBd0JvbkIsT0FBT2xnQixLQUFQLENBQXhCLENBQWQ7QUFDQSxvQkFBSSxDQUFDN0gsTUFBTCxFQUFZO0FBQ1IsMkJBQU82SCxLQUFQO0FBQ0gsaUJBRkQsTUFFTyxJQUFJbE0sTUFBTSxLQUFLd3NCLElBQUwsQ0FBVW5zQixNQUFWLEdBQW1CLENBQTdCLEVBQWdDO0FBQ25DLDBCQUFNLElBQUlzc0IsWUFBSixtQ0FBa0RqbkIsU0FBUyxLQUFLVixJQUFkLENBQWxELG9CQUFzRlUsU0FBUzBtQixPQUFPbGdCLEtBQVAsQ0FBVCxDQUF0RixlQUFOO0FBQ0g7QUFDSjtBQUNELG1CQUFPLElBQVA7QUFDSDs7O2tDQUNTdU4sRSxFQUFJO0FBQ1YsaUJBQUsrUyxJQUFMLENBQVU5RyxPQUFWLENBQWtCak0sRUFBbEI7QUFDSDs7O3dDQUNlO0FBQ1osbUJBQU8sS0FBSytTLElBQUwsQ0FBVVEsS0FBVixDQUFnQjtBQUFBLHVCQUFPM08sSUFBSTRPLGFBQUosRUFBUDtBQUFBLGFBQWhCLENBQVA7QUFDSDs7O29DQUNXO0FBQ1IsZ0JBQU1qb0IsT0FBTyxLQUFLQSxJQUFsQjtBQUNBLGdCQUFNMm1CLGFBQWEsQ0FBQzNtQixLQUFLc2lCLElBQU4sQ0FBbkI7QUFDQSxnQkFBSXRpQixLQUFLc2lCLElBQUwsS0FBYyxPQUFsQixFQUEyQjtBQUN2QixvQkFBTVcsV0FBV2pqQixLQUFLaWpCLFFBQXRCO0FBQ0Esb0JBQUlBLFNBQVNYLElBQVQsS0FBa0IsUUFBbEIsSUFBOEJXLFNBQVNYLElBQVQsS0FBa0IsUUFBaEQsSUFBNERXLFNBQVNYLElBQVQsS0FBa0IsU0FBbEYsRUFBNkY7QUFDekZxRSwrQkFBVzNxQixJQUFYLENBQWdCaW5CLFNBQVNYLElBQXpCO0FBQ0Esd0JBQU1ZLElBQUlsakIsS0FBS2tqQixDQUFmO0FBQ0Esd0JBQUksT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFBeUIsS0FBS3NFLElBQUwsQ0FBVW5zQixNQUFWLEdBQW1CLENBQWhELEVBQW1EO0FBQy9Dc3JCLG1DQUFXM3FCLElBQVgsQ0FBZ0JrbkIsQ0FBaEI7QUFDSDtBQUNKO0FBQ0o7QUFDRCxtQkFBT3lELFdBQVd0VyxNQUFYLENBQWtCLEtBQUttWCxJQUFMLENBQVU5ckIsR0FBVixDQUFjO0FBQUEsdUJBQU8yZCxJQUFJa08sU0FBSixFQUFQO0FBQUEsYUFBZCxDQUFsQixDQUFQO0FBQ0g7Ozs4QkF0RVlDLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsR0FBYyxDQUFsQixFQUNJLE9BQU9vc0IsUUFBUXBvQixLQUFSLG1DQUFQO0FBQ0osZ0JBQUlyRSxJQUFJLENBQVI7QUFDQSxnQkFBSWdGLGFBQUo7QUFDQSxnQkFBTWdILE9BQU93Z0IsS0FBSyxDQUFMLENBQWI7QUFDQSxnQkFBSXhnQixTQUFTLE9BQWIsRUFBc0I7QUFDbEIsb0JBQUlpYyxpQkFBSjtBQUNBLG9CQUFJdUUsS0FBS25zQixNQUFMLEdBQWMsQ0FBbEIsRUFBcUI7QUFDakIsd0JBQU0yRSxRQUFPd25CLEtBQUssQ0FBTCxDQUFiO0FBQ0Esd0JBQUksT0FBT3huQixLQUFQLEtBQWdCLFFBQWhCLElBQTRCLEVBQUVBLFNBQVE0bkIsS0FBVixDQUE1QixJQUFnRDVuQixVQUFTLFFBQTdELEVBQ0ksT0FBT3luQixRQUFRcG9CLEtBQVIsQ0FBYywwRUFBZCxFQUEwRixDQUExRixDQUFQO0FBQ0o0akIsK0JBQVcyRSxNQUFNNW5CLEtBQU4sQ0FBWDtBQUNBaEY7QUFDSCxpQkFORCxNQU1PO0FBQ0hpb0IsK0JBQVdMLFNBQVg7QUFDSDtBQUNELG9CQUFJTSxVQUFKO0FBQ0Esb0JBQUlzRSxLQUFLbnNCLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNqQix3QkFBSW1zQixLQUFLLENBQUwsTUFBWSxJQUFaLEtBQXFCLE9BQU9BLEtBQUssQ0FBTCxDQUFQLEtBQW1CLFFBQW5CLElBQStCQSxLQUFLLENBQUwsSUFBVSxDQUF6QyxJQUE4Q0EsS0FBSyxDQUFMLE1BQVl4UixLQUFLL0YsS0FBTCxDQUFXdVgsS0FBSyxDQUFMLENBQVgsQ0FBL0UsQ0FBSixFQUF5RztBQUNyRywrQkFBT0MsUUFBUXBvQixLQUFSLENBQWMsbUVBQWQsRUFBbUYsQ0FBbkYsQ0FBUDtBQUNIO0FBQ0Q2akIsd0JBQUlzRSxLQUFLLENBQUwsQ0FBSjtBQUNBeHNCO0FBQ0g7QUFDRGdGLHVCQUFPbU8sTUFBTThVLFFBQU4sRUFBZ0JDLENBQWhCLENBQVA7QUFDSCxhQXBCRCxNQW9CTztBQUNIbGpCLHVCQUFPNG5CLE1BQU01Z0IsSUFBTixDQUFQO0FBQ0g7QUFDRCxnQkFBTWtoQixTQUFTLEVBQWY7QUFDQSxtQkFBT2x0QixJQUFJd3NCLEtBQUtuc0IsTUFBaEIsRUFBd0JMLEdBQXhCLEVBQTZCO0FBQ3pCLG9CQUFNeWMsUUFBUWdRLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUt4c0IsQ0FBTCxDQUFkLEVBQXVCQSxDQUF2QixFQUEwQjRuQixTQUExQixDQUFkO0FBQ0Esb0JBQUksQ0FBQ25MLEtBQUwsRUFDSSxPQUFPLElBQVA7QUFDSnlRLHVCQUFPbHNCLElBQVAsQ0FBWXliLEtBQVo7QUFDSDtBQUNELG1CQUFPLElBQUlvUSxTQUFKLENBQWM3bkIsSUFBZCxFQUFvQmtvQixNQUFwQixDQUFQO0FBQ0g7Ozs7OztJQW9DQ0MsZ0I7QUFDRiw4QkFBWTFCLFFBQVosRUFBc0I7QUFBQTs7QUFDbEIsYUFBS3ptQixJQUFMLEdBQVkraUIsYUFBWjtBQUNBLGFBQUswRCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNIOzs7O2lDQXVEUXFCLEcsRUFBSztBQUNWLGdCQUFNTSxrQkFBa0IsU0FBbEJBLGVBQWtCLFVBQVc7QUFDL0Isb0JBQU1DLG1CQUFtQjNCLFFBQVE0QixPQUFSLENBQWdCUCxRQUFoQixDQUF5QkQsR0FBekIsQ0FBekI7QUFDQSxvQkFBSVYsT0FBT2lCLGdCQUFQLE1BQTZCckYsaUJBQWpDLEVBQW9EO0FBQ2hELDJCQUFPLElBQUltRCxnQkFBSixDQUFxQixFQUFyQixFQUF5QmtDLGdCQUF6QixFQUEyQyxJQUEzQyxFQUFpRCxJQUFqRCxFQUF1RCxJQUF2RCxDQUFQO0FBQ0g7QUFDRCx1QkFBTyxJQUFJbEMsZ0JBQUosQ0FBcUJrQixXQUFXZ0IsZ0JBQVgsQ0FBckIsRUFBbUQsSUFBbkQsRUFBeUQzQixRQUFRTCxLQUFSLEdBQWdCSyxRQUFRTCxLQUFSLENBQWMwQixRQUFkLENBQXVCRCxHQUF2QixDQUFoQixHQUE4QyxJQUF2RyxFQUE2R3BCLFFBQVEvcUIsSUFBUixHQUFlK3FCLFFBQVEvcUIsSUFBUixDQUFhb3NCLFFBQWIsQ0FBc0JELEdBQXRCLEVBQTJCMWhCLElBQTNCLENBQWdDLEdBQWhDLENBQWYsR0FBc0QsSUFBbkssRUFBeUtzZ0IsUUFBUUgsU0FBUixHQUFvQkcsUUFBUUgsU0FBUixDQUFrQndCLFFBQWxCLENBQTJCRCxHQUEzQixDQUFwQixHQUFzRCxJQUEvTixDQUFQO0FBQ0gsYUFORDtBQU9BLG1CQUFPLElBQUl0QixTQUFKLENBQWMsS0FBS0MsUUFBTCxDQUFjL3FCLEdBQWQsQ0FBa0Iwc0IsZUFBbEIsQ0FBZCxDQUFQO0FBQ0g7OztrQ0FDUzNULEUsRUFBSTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNWLHNDQUFzQixLQUFLZ1MsUUFBM0IsbUlBQXFDO0FBQUEsd0JBQTFCQyxPQUEwQjs7QUFDakNqUyx1QkFBR2lTLFFBQVE0QixPQUFYO0FBQ0Esd0JBQUk1QixRQUFRTCxLQUFaLEVBQW1CO0FBQ2Y1UiwyQkFBR2lTLFFBQVFMLEtBQVg7QUFDSDtBQUNELHdCQUFJSyxRQUFRL3FCLElBQVosRUFBa0I7QUFDZDhZLDJCQUFHaVMsUUFBUS9xQixJQUFYO0FBQ0g7QUFDRCx3QkFBSStxQixRQUFRSCxTQUFaLEVBQXVCO0FBQ25COVIsMkJBQUdpUyxRQUFRSCxTQUFYO0FBQ0g7QUFDSjtBQVpTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFhYjs7O3dDQUNlO0FBQ1osbUJBQU8sS0FBUDtBQUNIOzs7b0NBQ1c7QUFDUixnQkFBTUksYUFBYSxDQUFDLFFBQUQsQ0FBbkI7QUFEUTtBQUFBO0FBQUE7O0FBQUE7QUFFUixzQ0FBc0IsS0FBS0YsUUFBM0IsbUlBQXFDO0FBQUEsd0JBQTFCQyxPQUEwQjs7QUFDakNDLCtCQUFXM3FCLElBQVgsQ0FBZ0IwcUIsUUFBUTRCLE9BQVIsQ0FBZ0JmLFNBQWhCLEVBQWhCO0FBQ0Esd0JBQU0zVSxVQUFVLEVBQWhCO0FBQ0Esd0JBQUk4VCxRQUFRTCxLQUFaLEVBQW1CO0FBQ2Z6VCxnQ0FBUSxZQUFSLElBQXdCOFQsUUFBUUwsS0FBUixDQUFja0IsU0FBZCxFQUF4QjtBQUNIO0FBQ0Qsd0JBQUliLFFBQVEvcUIsSUFBWixFQUFrQjtBQUNkaVgsZ0NBQVEsV0FBUixJQUF1QjhULFFBQVEvcUIsSUFBUixDQUFhNHJCLFNBQWIsRUFBdkI7QUFDSDtBQUNELHdCQUFJYixRQUFRSCxTQUFaLEVBQXVCO0FBQ25CM1QsZ0NBQVEsWUFBUixJQUF3QjhULFFBQVFILFNBQVIsQ0FBa0JnQixTQUFsQixFQUF4QjtBQUNIO0FBQ0RaLCtCQUFXM3FCLElBQVgsQ0FBZ0I0VyxPQUFoQjtBQUNIO0FBZk87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnQlIsbUJBQU8rVCxVQUFQO0FBQ0g7Ozs4QkFsR1lhLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNqQix1QkFBT29zQixRQUFRcG9CLEtBQVIsbUNBQVA7QUFDSDtBQUNELGdCQUFNa3BCLFdBQVdmLEtBQUssQ0FBTCxDQUFqQjtBQUNBLGdCQUFJLENBQUN0c0IsTUFBTUMsT0FBTixDQUFjb3RCLFFBQWQsQ0FBRCxJQUE0QixRQUFPQSxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXBELEVBQThEO0FBQzFELHVCQUFPZCxRQUFRcG9CLEtBQVIsb0RBQVA7QUFDSDtBQUNELGdCQUFNb25CLFdBQVcsRUFBakI7QUFDQSxnQkFBSStCLHVCQUF1QixLQUEzQjtBQUNBLGlCQUFLLElBQUl4dEIsSUFBSSxDQUFiLEVBQWdCQSxLQUFLd3NCLEtBQUtuc0IsTUFBTCxHQUFjLENBQW5DLEVBQXNDLEVBQUVMLENBQXhDLEVBQTJDO0FBQ3ZDLG9CQUFNcWUsTUFBTW1PLEtBQUt4c0IsQ0FBTCxDQUFaO0FBQ0Esb0JBQUl3dEIsd0JBQXdCLFFBQU9uUCxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBdkMsSUFBbUQsQ0FBQ25lLE1BQU1DLE9BQU4sQ0FBY2tlLEdBQWQsQ0FBeEQsRUFBNEU7QUFDeEVtUCwyQ0FBdUIsS0FBdkI7QUFDQSx3QkFBSW5DLFFBQVEsSUFBWjtBQUNBLHdCQUFJaE4sSUFBSSxZQUFKLENBQUosRUFBdUI7QUFDbkJnTixnQ0FBUW9CLFFBQVE1cEIsS0FBUixDQUFjd2IsSUFBSSxZQUFKLENBQWQsRUFBaUMsQ0FBakMsRUFBb0NrSixVQUFwQyxDQUFSO0FBQ0EsNEJBQUksQ0FBQzhELEtBQUwsRUFDSSxPQUFPLElBQVA7QUFDUDtBQUNELHdCQUFJMXFCLE9BQU8sSUFBWDtBQUNBLHdCQUFJMGQsSUFBSSxXQUFKLENBQUosRUFBc0I7QUFDbEIxZCwrQkFBTzhyQixRQUFRNXBCLEtBQVIsQ0FBY3diLElBQUksV0FBSixDQUFkLEVBQWdDLENBQWhDLEVBQW1DbEwsTUFBTXFVLFVBQU4sQ0FBbkMsQ0FBUDtBQUNBLDRCQUFJLENBQUM3bUIsSUFBTCxFQUNJLE9BQU8sSUFBUDtBQUNQO0FBQ0Qsd0JBQUk0cUIsWUFBWSxJQUFoQjtBQUNBLHdCQUFJbE4sSUFBSSxZQUFKLENBQUosRUFBdUI7QUFDbkJrTixvQ0FBWWtCLFFBQVE1cEIsS0FBUixDQUFjd2IsSUFBSSxZQUFKLENBQWQsRUFBaUMsQ0FBakMsRUFBb0NxSixTQUFwQyxDQUFaO0FBQ0EsNEJBQUksQ0FBQzZELFNBQUwsRUFDSSxPQUFPLElBQVA7QUFDUDtBQUNELHdCQUFNa0MsaUJBQWlCaEMsU0FBU0EsU0FBU3ByQixNQUFULEdBQWtCLENBQTNCLENBQXZCO0FBQ0FvdEIsbUNBQWVwQyxLQUFmLEdBQXVCQSxLQUF2QjtBQUNBb0MsbUNBQWU5c0IsSUFBZixHQUFzQkEsSUFBdEI7QUFDQThzQixtQ0FBZWxDLFNBQWYsR0FBMkJBLFNBQTNCO0FBQ0gsaUJBeEJELE1Bd0JPO0FBQ0gsd0JBQU0rQixVQUFVYixRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLeHNCLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQjRuQixTQUExQixDQUFoQjtBQUNBLHdCQUFJLENBQUMwRixPQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osd0JBQU1oRyxPQUFPZ0csUUFBUXRvQixJQUFSLENBQWFzaUIsSUFBMUI7QUFDQSx3QkFBSUEsU0FBUyxRQUFULElBQXFCQSxTQUFTLE9BQTlCLElBQXlDQSxTQUFTLE1BQWxELElBQTREQSxTQUFTLGVBQXpFLEVBQ0ksT0FBT21GLFFBQVFwb0IsS0FBUixxRUFBUDtBQUNKbXBCLDJDQUF1QixJQUF2QjtBQUNBL0IsNkJBQVN6cUIsSUFBVCxDQUFjO0FBQ1Zzc0Isd0NBRFU7QUFFVmpDLCtCQUFPLElBRkc7QUFHVjFxQiw4QkFBTSxJQUhJO0FBSVY0cUIsbUNBQVc7QUFKRCxxQkFBZDtBQU1IO0FBQ0o7QUFDRCxtQkFBTyxJQUFJNEIsZ0JBQUosQ0FBcUIxQixRQUFyQixDQUFQO0FBQ0g7Ozs7OztJQWdEQ2lDLGU7QUFDRiw2QkFBWWpSLEtBQVosRUFBbUI7QUFBQTs7QUFDZixhQUFLelgsSUFBTCxHQUFZZ2pCLGlCQUFaO0FBQ0EsYUFBS3ZMLEtBQUwsR0FBYUEsS0FBYjtBQUNIOzs7O2lDQVVRcVEsRyxFQUFLO0FBQ1YsZ0JBQU1hLHFCQUFxQixLQUFLbFIsS0FBTCxDQUFXc1EsUUFBWCxDQUFvQkQsR0FBcEIsQ0FBM0I7QUFDQSxnQkFBTTVnQixRQUFRNGYsY0FBY0QsVUFBZCxDQUF5QjhCLGtCQUF6QixDQUFkO0FBQ0EsZ0JBQUl6aEIsU0FBUzRnQixJQUFJYyxlQUFqQixFQUNJMWhCLE1BQU02ZixTQUFOLEdBQWtCZSxJQUFJYyxlQUFKLENBQW9CN3NCLE9BQXBCLENBQTRCNHNCLGtCQUE1QixJQUFrRCxDQUFDLENBQXJFO0FBQ0osbUJBQU96aEIsS0FBUDtBQUNIOzs7a0NBQ1N1TixFLEVBQUk7QUFDVkEsZUFBRyxLQUFLZ0QsS0FBUjtBQUNIOzs7d0NBQ2U7QUFDWixtQkFBTyxLQUFQO0FBQ0g7OztvQ0FDVztBQUNSLG1CQUFPLENBQ0gsT0FERyxFQUVILEtBQUtBLEtBQUwsQ0FBVzhQLFNBQVgsRUFGRyxDQUFQO0FBSUg7Ozs4QkEzQllDLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsdUJBQU9vc0IsUUFBUXBvQixLQUFSLDJCQUFQO0FBQ0g7QUFDRCxnQkFBTTJILE9BQU95Z0IsUUFBUTVwQixLQUFSLENBQWMycEIsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsRUFBMEJoRixVQUExQixDQUFiO0FBQ0EsZ0JBQUksQ0FBQ3hiLElBQUwsRUFDSSxPQUFPeWdCLFFBQVFwb0IsS0FBUiwyQkFBUDtBQUNKLG1CQUFPLElBQUlxcEIsZUFBSixDQUFvQjFoQixJQUFwQixDQUFQO0FBQ0g7Ozs7OztBQXNCTCxJQUFNNmhCLFVBQVU7QUFDWixrQkFBY3BHLFdBREY7QUFFWixnQkFBWUMsU0FGQTtBQUdaLGlCQUFhSCxVQUhEO0FBSVosaUJBQWFDO0FBSkQsQ0FBaEI7O0lBTU1zRyxRO0FBQ0Ysc0JBQVk5b0IsSUFBWixFQUFrQnduQixJQUFsQixFQUF3QjtBQUFBOztBQUNwQixhQUFLeG5CLElBQUwsR0FBWUEsSUFBWjtBQUNBLGFBQUt3bkIsSUFBTCxHQUFZQSxJQUFaO0FBQ0g7Ozs7aUNBaUJRTSxHLEVBQUs7QUFDVixnQkFBSSxLQUFLOW5CLElBQUwsQ0FBVXNpQixJQUFWLEtBQW1CLFNBQXZCLEVBQWtDO0FBQzlCLHVCQUFPeUcsUUFBUSxLQUFLdkIsSUFBTCxDQUFVLENBQVYsRUFBYU8sUUFBYixDQUFzQkQsR0FBdEIsQ0FBUixDQUFQO0FBQ0gsYUFGRCxNQUVPLElBQUksS0FBSzluQixJQUFMLENBQVVzaUIsSUFBVixLQUFtQixPQUF2QixFQUFnQztBQUNuQyxvQkFBSTdLLGNBQUo7QUFDQSxvQkFBSXBZLGdCQUFKO0FBRm1DO0FBQUE7QUFBQTs7QUFBQTtBQUduQywyQ0FBa0IsS0FBS21vQixJQUF2Qix3SUFBNkI7QUFBQSw0QkFBbEJuTyxHQUFrQjs7QUFDekI1QixnQ0FBUTRCLElBQUkwTyxRQUFKLENBQWFELEdBQWIsQ0FBUjtBQUNBem9CLGtDQUFRLElBQVI7QUFDQSw0QkFBSW9ZLGlCQUFpQmhYLEtBQXJCLEVBQTRCO0FBQ3hCLG1DQUFPZ1gsS0FBUDtBQUNILHlCQUZELE1BRU8sSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2xDLGdDQUFNdVIsSUFBSWxCLElBQUltQixVQUFKLENBQWV4UixLQUFmLENBQVY7QUFDQSxnQ0FBSXVSLENBQUosRUFDSSxPQUFPQSxDQUFQO0FBQ1AseUJBSk0sTUFJQSxJQUFJOXRCLE1BQU1DLE9BQU4sQ0FBY3NjLEtBQWQsQ0FBSixFQUEwQjtBQUM3QixnQ0FBSUEsTUFBTXBjLE1BQU4sR0FBZSxDQUFmLElBQW9Cb2MsTUFBTXBjLE1BQU4sR0FBZSxDQUF2QyxFQUEwQztBQUN0Q2dFLGtFQUErQnpCLEtBQUs4VSxTQUFMLENBQWUrRSxLQUFmLENBQS9CO0FBQ0gsNkJBRkQsTUFFTztBQUNIcFksMENBQVEybkIsYUFBYXZQLE1BQU0sQ0FBTixDQUFiLEVBQXVCQSxNQUFNLENBQU4sQ0FBdkIsRUFBaUNBLE1BQU0sQ0FBTixDQUFqQyxFQUEyQ0EsTUFBTSxDQUFOLENBQTNDLENBQVI7QUFDSDtBQUNELGdDQUFJLENBQUNwWSxPQUFMLEVBQVk7QUFDUix1Q0FBTyxJQUFJb0IsS0FBSixDQUFVZ1gsTUFBTSxDQUFOLElBQVcsR0FBckIsRUFBMEJBLE1BQU0sQ0FBTixJQUFXLEdBQXJDLEVBQTBDQSxNQUFNLENBQU4sSUFBVyxHQUFyRCxFQUEwREEsTUFBTSxDQUFOLENBQTFELENBQVA7QUFDSDtBQUNKO0FBQ0o7QUF0QmtDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBdUJuQyxzQkFBTSxJQUFJa1EsWUFBSixDQUFpQnRvQixtREFBK0MsT0FBT29ZLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQTVCLEdBQW9DdkIsT0FBT3RZLEtBQUs4VSxTQUFMLENBQWUrRSxLQUFmLENBQVAsQ0FBbkYsT0FBakIsQ0FBTjtBQUNILGFBeEJNLE1Bd0JBLElBQUksS0FBS3pYLElBQUwsQ0FBVXNpQixJQUFWLEtBQW1CLFFBQXZCLEVBQWlDO0FBQ3BDLG9CQUFJcGIsUUFBUSxJQUFaO0FBRG9DO0FBQUE7QUFBQTs7QUFBQTtBQUVwQywyQ0FBa0IsS0FBS3NnQixJQUF2Qix3SUFBNkI7QUFBQSw0QkFBbEJuTyxJQUFrQjs7QUFDekJuUyxnQ0FBUW1TLEtBQUkwTyxRQUFKLENBQWFELEdBQWIsQ0FBUjtBQUNBLDRCQUFJNWdCLFVBQVUsSUFBZCxFQUNJLE9BQU8sQ0FBUDtBQUNKLDRCQUFNZ2lCLE1BQU1DLE9BQU9qaUIsS0FBUCxDQUFaO0FBQ0EsNEJBQUlraUIsTUFBTUYsR0FBTixDQUFKLEVBQ0k7QUFDSiwrQkFBT0EsR0FBUDtBQUNIO0FBVm1DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBV3BDLHNCQUFNLElBQUl2QixZQUFKLHdCQUF1Qy9wQixLQUFLOFUsU0FBTCxDQUFleEwsS0FBZixDQUF2QyxpQkFBTjtBQUNILGFBWk0sTUFZQSxJQUFJLEtBQUtsSCxJQUFMLENBQVVzaUIsSUFBVixLQUFtQixXQUF2QixFQUFvQztBQUN2Qyx1QkFBT2tFLFVBQVVLLFVBQVYsQ0FBcUJRLFdBQVcsS0FBS0csSUFBTCxDQUFVLENBQVYsRUFBYU8sUUFBYixDQUFzQkQsR0FBdEIsQ0FBWCxDQUFyQixDQUFQO0FBQ0gsYUFGTSxNQUVBLElBQUksS0FBSzluQixJQUFMLENBQVVzaUIsSUFBVixLQUFtQixlQUF2QixFQUF3QztBQUMzQyx1QkFBT3dFLGNBQWNELFVBQWQsQ0FBeUJRLFdBQVcsS0FBS0csSUFBTCxDQUFVLENBQVYsRUFBYU8sUUFBYixDQUFzQkQsR0FBdEIsQ0FBWCxDQUF6QixDQUFQO0FBQ0gsYUFGTSxNQUVBO0FBQ0gsdUJBQU9ULFdBQVcsS0FBS0csSUFBTCxDQUFVLENBQVYsRUFBYU8sUUFBYixDQUFzQkQsR0FBdEIsQ0FBWCxDQUFQO0FBQ0g7QUFDSjs7O2tDQUNTclQsRSxFQUFJO0FBQ1YsaUJBQUsrUyxJQUFMLENBQVU5RyxPQUFWLENBQWtCak0sRUFBbEI7QUFDSDs7O3dDQUNlO0FBQ1osbUJBQU8sS0FBSytTLElBQUwsQ0FBVVEsS0FBVixDQUFnQjtBQUFBLHVCQUFPM08sSUFBSTRPLGFBQUosRUFBUDtBQUFBLGFBQWhCLENBQVA7QUFDSDs7O29DQUNXO0FBQ1IsZ0JBQUksS0FBS2pvQixJQUFMLENBQVVzaUIsSUFBVixLQUFtQixXQUF2QixFQUFvQztBQUNoQyx1QkFBTyxJQUFJNkYsZ0JBQUosQ0FBcUIsQ0FBQztBQUNyQkcsNkJBQVMsS0FBS2QsSUFBTCxDQUFVLENBQVYsQ0FEWTtBQUVyQm5CLDJCQUFPLElBRmM7QUFHckIxcUIsMEJBQU0sSUFIZTtBQUlyQjRxQiwrQkFBVztBQUpVLGlCQUFELENBQXJCLEVBS0NnQixTQUxELEVBQVA7QUFNSDtBQUNELGdCQUFJLEtBQUt2bkIsSUFBTCxDQUFVc2lCLElBQVYsS0FBbUIsZUFBdkIsRUFBd0M7QUFDcEMsdUJBQU8sSUFBSW9HLGVBQUosQ0FBb0IsS0FBS2xCLElBQUwsQ0FBVSxDQUFWLENBQXBCLEVBQWtDRCxTQUFsQyxFQUFQO0FBQ0g7QUFDRCxnQkFBTVosYUFBYSxTQUFRLEtBQUszbUIsSUFBTCxDQUFVc2lCLElBQWxCLENBQW5CO0FBQ0EsaUJBQUsrRyxTQUFMLENBQWUsaUJBQVM7QUFDcEIxQywyQkFBVzNxQixJQUFYLENBQWdCc3RCLE1BQU0vQixTQUFOLEVBQWhCO0FBQ0gsYUFGRDtBQUdBLG1CQUFPWixVQUFQO0FBQ0g7Ozs4QkF0RllhLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsR0FBYyxDQUFsQixFQUNJLE9BQU9vc0IsUUFBUXBvQixLQUFSLG1DQUFQO0FBQ0osZ0JBQU0ySCxPQUFPd2dCLEtBQUssQ0FBTCxDQUFiO0FBQ0EsZ0JBQUksQ0FBQ3hnQixTQUFTLFlBQVQsSUFBeUJBLFNBQVMsV0FBbkMsS0FBbUR3Z0IsS0FBS25zQixNQUFMLEtBQWdCLENBQXZFLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIsMEJBQVA7QUFDSixnQkFBTVcsT0FBTzZvQixRQUFRN2hCLElBQVIsQ0FBYjtBQUNBLGdCQUFNa2hCLFNBQVMsRUFBZjtBQUNBLGlCQUFLLElBQUlsdEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd3NCLEtBQUtuc0IsTUFBekIsRUFBaUNMLEdBQWpDLEVBQXNDO0FBQ2xDLG9CQUFNeWMsUUFBUWdRLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUt4c0IsQ0FBTCxDQUFkLEVBQXVCQSxDQUF2QixFQUEwQjRuQixTQUExQixDQUFkO0FBQ0Esb0JBQUksQ0FBQ25MLEtBQUwsRUFDSSxPQUFPLElBQVA7QUFDSnlRLHVCQUFPbHNCLElBQVAsQ0FBWXliLEtBQVo7QUFDSDtBQUNELG1CQUFPLElBQUlxUixRQUFKLENBQWE5b0IsSUFBYixFQUFtQmtvQixNQUFuQixDQUFQO0FBQ0g7Ozs7OztBQTBFTCxJQUFNcUIsZ0JBQWdCLENBQ2xCLFNBRGtCLEVBRWxCLE9BRmtCLEVBR2xCLFlBSGtCLEVBSWxCLFNBSmtCLENBQXRCOztJQU1NQyxpQjtBQUNGLGlDQUFjO0FBQUE7O0FBQ1YsYUFBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxhQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNBLGFBQUtDLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxhQUFLQyxnQkFBTCxHQUF3QixJQUF4QjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCLEVBQXhCO0FBQ0EsYUFBS2pCLGVBQUwsR0FBdUIsSUFBdkI7QUFDQSxhQUFLa0IsU0FBTCxHQUFpQixJQUFqQjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsYUFBS0MsbUJBQUwsR0FBMkIsSUFBM0I7QUFDSDs7Ozs2QkFDSTtBQUNELG1CQUFPLEtBQUtOLE9BQUwsSUFBZ0IsUUFBUSxLQUFLQSxPQUE3QixHQUF1QyxLQUFLQSxPQUFMLENBQWEvcEIsRUFBcEQsR0FBeUQsSUFBaEU7QUFDSDs7O3VDQUNjO0FBQ1gsbUJBQU8sS0FBSytwQixPQUFMLEdBQWUsT0FBTyxLQUFLQSxPQUFMLENBQWExcEIsSUFBcEIsS0FBNkIsUUFBN0IsR0FBd0N1cEIsY0FBYyxLQUFLRyxPQUFMLENBQWExcEIsSUFBM0IsQ0FBeEMsR0FBMkUsS0FBSzBwQixPQUFMLENBQWExcEIsSUFBdkcsR0FBOEcsSUFBckg7QUFDSDs7O21DQUNVO0FBQ1AsbUJBQU8sS0FBSzBwQixPQUFMLElBQWdCLGNBQWMsS0FBS0EsT0FBbkMsR0FBNkMsS0FBS0EsT0FBTCxDQUFhTyxRQUExRCxHQUFxRSxJQUE1RTtBQUNIOzs7c0NBQ2E7QUFDVixtQkFBTyxLQUFLSCxTQUFaO0FBQ0g7OztxQ0FDWTtBQUNULG1CQUFPLEtBQUtKLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhemEsVUFBN0IsSUFBMkMsRUFBbEQ7QUFDSDs7OzZDQUNvQjtBQUNqQixnQkFBSSxLQUFLOGEsZ0JBQUwsSUFBeUIsS0FBS0MsbUJBQWxDLEVBQXVEO0FBQ25ELG9CQUFNaEIsSUFBSSxLQUFLZ0IsbUJBQUwsQ0FBeUJyb0IsTUFBbkM7QUFDQSxvQkFBTTBrQixRQUFRLEtBQUsyRCxtQkFBTCxDQUF5QjNELEtBQXZDO0FBRm1ELHdDQUdwQyxLQUFLMEQsZ0JBSCtCO0FBQUEsb0JBRzVDN1AsQ0FINEMscUJBRzVDQSxDQUg0QztBQUFBLG9CQUd6Q2dRLENBSHlDLHFCQUd6Q0EsQ0FIeUM7O0FBSW5ELG9CQUFNQyxLQUFLalEsSUFBSW1NLEtBQUosR0FBWTJDLEVBQUUsQ0FBRixDQUF2QjtBQUNBLG9CQUFNb0IsS0FBS0YsSUFBSTdELEtBQUosR0FBWTJDLEVBQUUsQ0FBRixDQUF2QjtBQUNBLG9CQUFNcUIsS0FBSyxLQUFLTCxtQkFBTCxDQUF5QjdpQixPQUF6QixDQUFpQyxDQUFqQyxDQUFYO0FBQ0Esb0JBQU1takIsS0FBSyxLQUFLTixtQkFBTCxDQUF5QjdpQixPQUF6QixDQUFpQyxDQUFqQyxDQUFYO0FBQ0Esb0JBQU1vakIsT0FBT0YsS0FBS0YsRUFBTCxHQUFVRyxLQUFLRixFQUE1QjtBQUNBLHVCQUFPRyxJQUFQO0FBQ0g7QUFDRCxtQkFBTyxDQUFQO0FBQ0g7OzttQ0FDVTlTLEssRUFBTztBQUNkLGdCQUFJK1MsU0FBUyxLQUFLWCxnQkFBTCxDQUFzQnBTLEtBQXRCLENBQWI7QUFDQSxnQkFBSSxDQUFDK1MsTUFBTCxFQUFhO0FBQ1RBLHlCQUFTLEtBQUtYLGdCQUFMLENBQXNCcFMsS0FBdEIsSUFBK0JoWCxNQUFNNUMsS0FBTixDQUFZNFosS0FBWixDQUF4QztBQUNIO0FBQ0QsbUJBQU8rUyxNQUFQO0FBQ0g7Ozs7OztJQUdDQyxrQjtBQUNGLGdDQUFZempCLElBQVosRUFBa0JoSCxJQUFsQixFQUF3QituQixRQUF4QixFQUFrQ1AsSUFBbEMsRUFBd0M7QUFBQTs7QUFDcEMsYUFBS3hnQixJQUFMLEdBQVlBLElBQVo7QUFDQSxhQUFLaEgsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsYUFBSzBxQixTQUFMLEdBQWlCM0MsUUFBakI7QUFDQSxhQUFLUCxJQUFMLEdBQVlBLElBQVo7QUFDSDs7OztpQ0FDUU0sRyxFQUFLO0FBQ1YsbUJBQU8sS0FBSzRDLFNBQUwsQ0FBZTVDLEdBQWYsRUFBb0IsS0FBS04sSUFBekIsQ0FBUDtBQUNIOzs7a0NBQ1MvUyxFLEVBQUk7QUFDVixpQkFBSytTLElBQUwsQ0FBVTlHLE9BQVYsQ0FBa0JqTSxFQUFsQjtBQUNIOzs7d0NBQ2U7QUFDWixtQkFBTyxLQUFQO0FBQ0g7OztvQ0FDVztBQUNSLG1CQUFPLENBQUMsS0FBS3pOLElBQU4sRUFBWXFKLE1BQVosQ0FBbUIsS0FBS21YLElBQUwsQ0FBVTlyQixHQUFWLENBQWM7QUFBQSx1QkFBTzJkLElBQUlrTyxTQUFKLEVBQVA7QUFBQSxhQUFkLENBQW5CLENBQVA7QUFDSDs7OzhCQUNZQyxJLEVBQU1DLE8sRUFBUztBQUN4QixnQkFBTTlDLEtBQUs2QyxLQUFLLENBQUwsQ0FBWDtBQUNBLGdCQUFNbUQsYUFBYUYsbUJBQW1CRyxXQUFuQixDQUErQmpHLEVBQS9CLENBQW5CO0FBQ0EsZ0JBQUksQ0FBQ2dHLFVBQUwsRUFBaUI7QUFDYix1QkFBT2xELFFBQVFwb0IsS0FBUiwyQkFBc0NzbEIsRUFBdEMsbUVBQXNHLENBQXRHLENBQVA7QUFDSDtBQUNELGdCQUFNM2tCLE9BQU85RSxNQUFNQyxPQUFOLENBQWN3dkIsVUFBZCxJQUE0QkEsV0FBVyxDQUFYLENBQTVCLEdBQTRDQSxXQUFXM3FCLElBQXBFO0FBQ0EsZ0JBQU02cUIscUJBQXFCM3ZCLE1BQU1DLE9BQU4sQ0FBY3d2QixVQUFkLElBQTRCLENBQUMsQ0FDaERBLFdBQVcsQ0FBWCxDQURnRCxFQUVoREEsV0FBVyxDQUFYLENBRmdELENBQUQsQ0FBNUIsR0FHbEJBLFdBQVdHLFNBSHBCO0FBSUEsZ0JBQU1BLFlBQVlELG1CQUFtQnJoQixNQUFuQixDQUEwQjtBQUFBO0FBQUEsb0JBQUV1aEIsU0FBRjs7QUFBQSx1QkFBaUIsQ0FBQzd2QixNQUFNQyxPQUFOLENBQWM0dkIsU0FBZCxDQUFELElBQTZCQSxVQUFVMXZCLE1BQVYsS0FBcUJtc0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBakY7QUFBQSxhQUExQixDQUFsQjtBQUNBLGdCQUFJMnZCLG1CQUFtQixJQUF2QjtBQVp3QjtBQUFBO0FBQUE7O0FBQUE7QUFheEIsdUNBQWlDRixTQUFqQyx3SUFBNEM7QUFBQTs7QUFBQTs7QUFBQSx3QkFBaENoRyxNQUFnQztBQUFBLHdCQUF4QmlELFFBQXdCOztBQUN4Q2lELHVDQUFtQixJQUFJQyxjQUFKLENBQW1CeEQsUUFBUXlELFFBQTNCLEVBQXFDekQsUUFBUXhxQixJQUE3QyxFQUFtRCxJQUFuRCxFQUF5RHdxQixRQUFRMEQsS0FBakUsQ0FBbkI7QUFDQSx3QkFBTUMsYUFBYSxFQUFuQjtBQUNBLHdCQUFJQyxpQkFBaUIsS0FBckI7QUFDQSx5QkFBSyxJQUFJcndCLE1BQUksQ0FBYixFQUFnQkEsTUFBSXdzQixLQUFLbnNCLE1BQXpCLEVBQWlDTCxLQUFqQyxFQUFzQztBQUNsQyw0QkFBTXFlLE1BQU1tTyxLQUFLeHNCLEdBQUwsQ0FBWjtBQUNBLDRCQUFNMHNCLGVBQWV4c0IsTUFBTUMsT0FBTixDQUFjMnBCLE1BQWQsSUFBd0JBLE9BQU85cEIsTUFBSSxDQUFYLENBQXhCLEdBQXdDOHBCLE9BQU85a0IsSUFBcEU7QUFDQSw0QkFBTWtvQixVQUFTOEMsaUJBQWlCbnRCLEtBQWpCLENBQXVCd2IsR0FBdkIsRUFBNEIsSUFBSStSLFdBQVcvdkIsTUFBM0MsRUFBbURxc0IsWUFBbkQsQ0FBZjtBQUNBLDRCQUFJLENBQUNRLE9BQUwsRUFBYTtBQUNUbUQsNkNBQWlCLElBQWpCO0FBQ0E7QUFDSDtBQUNERCxtQ0FBV3B2QixJQUFYLENBQWdCa3NCLE9BQWhCO0FBQ0g7QUFDRCx3QkFBSW1ELGNBQUosRUFBb0I7QUFDaEI7QUFDSDtBQUNELHdCQUFJbndCLE1BQU1DLE9BQU4sQ0FBYzJwQixNQUFkLENBQUosRUFBMkI7QUFDdkIsNEJBQUlBLE9BQU96cEIsTUFBUCxLQUFrQit2QixXQUFXL3ZCLE1BQWpDLEVBQXlDO0FBQ3JDMnZCLDZDQUFpQjNyQixLQUFqQixlQUFvQ3lsQixPQUFPenBCLE1BQTNDLDhCQUE0RSt2QixXQUFXL3ZCLE1BQXZGO0FBQ0E7QUFDSDtBQUNKO0FBQ0QseUJBQUssSUFBSUwsTUFBSSxDQUFiLEVBQWdCQSxNQUFJb3dCLFdBQVcvdkIsTUFBL0IsRUFBdUNMLEtBQXZDLEVBQTRDO0FBQ3hDLDRCQUFNcW9CLFlBQVdub0IsTUFBTUMsT0FBTixDQUFjMnBCLE1BQWQsSUFBd0JBLE9BQU85cEIsR0FBUCxDQUF4QixHQUFvQzhwQixPQUFPOWtCLElBQTVEO0FBQ0EsNEJBQU1xWixRQUFNK1IsV0FBV3B3QixHQUFYLENBQVo7QUFDQWd3Qix5Q0FBaUIzYSxNQUFqQixDQUF3QnJWLE1BQUksQ0FBNUIsRUFBK0Jvb0IsWUFBL0IsQ0FBNENDLFNBQTVDLEVBQXNEaEssTUFBSXJaLElBQTFEO0FBQ0g7QUFDRCx3QkFBSWdyQixpQkFBaUJsVixNQUFqQixDQUF3QnphLE1BQXhCLEtBQW1DLENBQXZDLEVBQTBDO0FBQ3RDLCtCQUFPLElBQUlvdkIsa0JBQUosQ0FBdUI5RixFQUF2QixFQUEyQjNrQixJQUEzQixFQUFpQytuQixRQUFqQyxFQUEyQ3FELFVBQTNDLENBQVA7QUFDSDtBQUNKO0FBNUN1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQTZDeEIsZ0JBQUlOLFVBQVV6dkIsTUFBVixLQUFxQixDQUF6QixFQUE0QjtBQUFBOztBQUN4QiwyQ0FBUXlhLE1BQVIsRUFBZTlaLElBQWYsMkNBQXVCZ3ZCLGlCQUFpQmxWLE1BQXhDO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsb0JBQU11TixXQUFXeUgsVUFBVXp2QixNQUFWLEdBQW1CeXZCLFNBQW5CLEdBQStCRCxrQkFBaEQ7QUFDQSxvQkFBTVMsYUFBYWpJLFNBQVMzbkIsR0FBVCxDQUFhO0FBQUE7QUFBQSx3QkFBRW9wQixNQUFGOztBQUFBLDJCQUFjeUcsbUJBQW1CekcsTUFBbkIsQ0FBZDtBQUFBLGlCQUFiLEVBQXVEMWUsSUFBdkQsQ0FBNEQsS0FBNUQsQ0FBbkI7QUFDQSxvQkFBTW9sQixjQUFjLEVBQXBCO0FBQ0EscUJBQUssSUFBSXh3QixJQUFJLENBQWIsRUFBZ0JBLElBQUl3c0IsS0FBS25zQixNQUF6QixFQUFpQ0wsR0FBakMsRUFBc0M7QUFDbEMsd0JBQU1rdEIsU0FBU1QsUUFBUTVwQixLQUFSLENBQWMycEIsS0FBS3hzQixDQUFMLENBQWQsRUFBdUIsSUFBSXd3QixZQUFZbndCLE1BQXZDLENBQWY7QUFDQSx3QkFBSSxDQUFDNnNCLE1BQUwsRUFDSSxPQUFPLElBQVA7QUFDSnNELGdDQUFZeHZCLElBQVosQ0FBaUIwRSxTQUFTd25CLE9BQU9sb0IsSUFBaEIsQ0FBakI7QUFDSDtBQUNEeW5CLHdCQUFRcG9CLEtBQVIsaUNBQTZDaXNCLFVBQTdDLHFCQUF5RUUsWUFBWXBsQixJQUFaLENBQWlCLElBQWpCLENBQXpFO0FBQ0g7QUFDRCxtQkFBTyxJQUFQO0FBQ0g7OztpQ0FDZThrQixRLEVBQVVOLFcsRUFBYTtBQUNuQ0gsK0JBQW1CRyxXQUFuQixHQUFpQ0EsV0FBakM7QUFDQSxpQkFBSyxJQUFNNWpCLElBQVgsSUFBbUI0akIsV0FBbkIsRUFBZ0M7QUFDNUJNLHlCQUFTbGtCLElBQVQsSUFBaUJ5akIsa0JBQWpCO0FBQ0g7QUFDSjs7Ozs7O0FBRUwsU0FBU2Msa0JBQVQsQ0FBNEJSLFNBQTVCLEVBQXVDO0FBQ25DLFFBQUk3dkIsTUFBTUMsT0FBTixDQUFjNHZCLFNBQWQsQ0FBSixFQUE4QjtBQUMxQixxQkFBWUEsVUFBVXJ2QixHQUFWLENBQWNnRixRQUFkLEVBQXdCMEYsSUFBeEIsQ0FBNkIsSUFBN0IsQ0FBWjtBQUNILEtBRkQsTUFFTztBQUNILHFCQUFZMUYsU0FBU3FxQixVQUFVL3FCLElBQW5CLENBQVo7QUFDSDtBQUNKOztJQUVLeXJCLGtCO0FBQ0YsZ0NBQVloRyxhQUFaLEVBQTJCQyxrQkFBM0IsRUFBK0NDLE1BQS9DLEVBQXVEO0FBQUE7O0FBQ25ELGFBQUszbEIsSUFBTCxHQUFZOGlCLFlBQVo7QUFDQSxhQUFLNkMsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS0YsYUFBTCxHQUFxQkEsYUFBckI7QUFDQSxhQUFLQyxrQkFBTCxHQUEwQkEsa0JBQTFCO0FBQ0g7Ozs7aUNBcUJRb0MsRyxFQUFLO0FBQ1YsbUJBQU8sSUFBSXRDLFFBQUosQ0FBYSxLQUFLQyxhQUFMLENBQW1Cc0MsUUFBbkIsQ0FBNEJELEdBQTVCLENBQWIsRUFBK0MsS0FBS3BDLGtCQUFMLENBQXdCcUMsUUFBeEIsQ0FBaUNELEdBQWpDLENBQS9DLEVBQXNGLEtBQUtuQyxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZb0MsUUFBWixDQUFxQkQsR0FBckIsQ0FBZCxHQUEwQyxJQUFoSSxDQUFQO0FBQ0g7OztrQ0FDU3JULEUsRUFBSTtBQUNWQSxlQUFHLEtBQUtnUixhQUFSO0FBQ0FoUixlQUFHLEtBQUtpUixrQkFBUjtBQUNBLGdCQUFJLEtBQUtDLE1BQVQsRUFBaUI7QUFDYmxSLG1CQUFHLEtBQUtrUixNQUFSO0FBQ0g7QUFDSjs7O3dDQUNlO0FBQ1osbUJBQU8sS0FBUDtBQUNIOzs7b0NBQ1c7QUFDUixnQkFBTS9TLFVBQVUsRUFBaEI7QUFDQUEsb0JBQVEsZ0JBQVIsSUFBNEIsS0FBSzZTLGFBQUwsQ0FBbUI4QixTQUFuQixFQUE1QjtBQUNBM1Usb0JBQVEscUJBQVIsSUFBaUMsS0FBSzhTLGtCQUFMLENBQXdCNkIsU0FBeEIsRUFBakM7QUFDQSxnQkFBSSxLQUFLNUIsTUFBVCxFQUFpQjtBQUNiL1Msd0JBQVEsUUFBUixJQUFvQixLQUFLK1MsTUFBTCxDQUFZNEIsU0FBWixFQUFwQjtBQUNIO0FBQ0QsbUJBQU8sQ0FDSCxVQURHLEVBRUgzVSxPQUZHLENBQVA7QUFJSDs7OzhCQTVDWTRVLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFDSSxPQUFPb3NCLFFBQVFwb0IsS0FBUiwwQkFBUDtBQUNKLGdCQUFNdVQsVUFBVTRVLEtBQUssQ0FBTCxDQUFoQjtBQUNBLGdCQUFJLFFBQU81VSxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQStCMVgsTUFBTUMsT0FBTixDQUFjeVgsT0FBZCxDQUFuQyxFQUNJLE9BQU82VSxRQUFRcG9CLEtBQVIsZ0RBQVA7QUFDSixnQkFBTW9tQixnQkFBZ0JnQyxRQUFRNXBCLEtBQVIsQ0FBYytVLFFBQVEsZ0JBQVIsTUFBOEI1VCxTQUE5QixHQUEwQyxLQUExQyxHQUFrRDRULFFBQVEsZ0JBQVIsQ0FBaEUsRUFBMkYsQ0FBM0YsRUFBOEY2UCxXQUE5RixDQUF0QjtBQUNBLGdCQUFJLENBQUNnRCxhQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osZ0JBQU1DLHFCQUFxQitCLFFBQVE1cEIsS0FBUixDQUFjK1UsUUFBUSxxQkFBUixNQUFtQzVULFNBQW5DLEdBQStDLEtBQS9DLEdBQXVENFQsUUFBUSxxQkFBUixDQUFyRSxFQUFxRyxDQUFyRyxFQUF3RzZQLFdBQXhHLENBQTNCO0FBQ0EsZ0JBQUksQ0FBQ2lELGtCQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osZ0JBQUlDLFNBQVMsSUFBYjtBQUNBLGdCQUFJL1MsUUFBUSxRQUFSLENBQUosRUFBdUI7QUFDbkIrUyx5QkFBUzhCLFFBQVE1cEIsS0FBUixDQUFjK1UsUUFBUSxRQUFSLENBQWQsRUFBaUMsQ0FBakMsRUFBb0M0UCxVQUFwQyxDQUFUO0FBQ0Esb0JBQUksQ0FBQ21ELE1BQUwsRUFDSSxPQUFPLElBQVA7QUFDUDtBQUNELG1CQUFPLElBQUk4RixrQkFBSixDQUF1QmhHLGFBQXZCLEVBQXNDQyxrQkFBdEMsRUFBMERDLE1BQTFELENBQVA7QUFDSDs7Ozs7O0FBNEJMLElBQU0rRixTQUFTLElBQWY7QUFDQSxTQUFTQyxVQUFULENBQW9CeG1CLElBQXBCLEVBQTBCaWMsS0FBMUIsRUFBaUM7QUFDN0JqYyxTQUFLLENBQUwsSUFBVTZRLEtBQUtuRyxHQUFMLENBQVMxSyxLQUFLLENBQUwsQ0FBVCxFQUFrQmljLE1BQU0sQ0FBTixDQUFsQixDQUFWO0FBQ0FqYyxTQUFLLENBQUwsSUFBVTZRLEtBQUtuRyxHQUFMLENBQVMxSyxLQUFLLENBQUwsQ0FBVCxFQUFrQmljLE1BQU0sQ0FBTixDQUFsQixDQUFWO0FBQ0FqYyxTQUFLLENBQUwsSUFBVTZRLEtBQUtsRyxHQUFMLENBQVMzSyxLQUFLLENBQUwsQ0FBVCxFQUFrQmljLE1BQU0sQ0FBTixDQUFsQixDQUFWO0FBQ0FqYyxTQUFLLENBQUwsSUFBVTZRLEtBQUtsRyxHQUFMLENBQVMzSyxLQUFLLENBQUwsQ0FBVCxFQUFrQmljLE1BQU0sQ0FBTixDQUFsQixDQUFWO0FBQ0g7QUFDRCxTQUFTd0ssZ0JBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQzNCLFdBQU8sQ0FBQyxNQUFNQSxHQUFQLElBQWMsR0FBckI7QUFDSDtBQUNELFNBQVNDLGdCQUFULENBQTBCQyxHQUExQixFQUErQjtBQUMzQixXQUFPLENBQUMsTUFBTSxNQUFNL1YsS0FBS2dXLEVBQVgsR0FBZ0JoVyxLQUFLaVcsR0FBTCxDQUFTalcsS0FBS3ZHLEdBQUwsQ0FBU3VHLEtBQUtnVyxFQUFMLEdBQVUsQ0FBVixHQUFjRCxNQUFNL1YsS0FBS2dXLEVBQVgsR0FBZ0IsR0FBdkMsQ0FBVCxDQUF2QixJQUFnRixHQUF2RjtBQUNIO0FBQ0QsU0FBU0UsWUFBVCxDQUFzQkMsS0FBdEIsRUFBNkJDLEtBQTdCLEVBQW9DO0FBQ2hDLFFBQUlELE1BQU0sQ0FBTixLQUFZQyxNQUFNLENBQU4sQ0FBaEIsRUFDSSxPQUFPLEtBQVA7QUFDSixRQUFJRCxNQUFNLENBQU4sS0FBWUMsTUFBTSxDQUFOLENBQWhCLEVBQ0ksT0FBTyxLQUFQO0FBQ0osUUFBSUQsTUFBTSxDQUFOLEtBQVlDLE1BQU0sQ0FBTixDQUFoQixFQUNJLE9BQU8sS0FBUDtBQUNKLFFBQUlELE1BQU0sQ0FBTixLQUFZQyxNQUFNLENBQU4sQ0FBaEIsRUFDSSxPQUFPLEtBQVA7QUFDSixXQUFPLElBQVA7QUFDSDtBQUNELFNBQVNDLGtCQUFULENBQTRCaE8sQ0FBNUIsRUFBK0J5TCxTQUEvQixFQUEwQztBQUN0QyxRQUFNNVAsSUFBSTBSLGlCQUFpQnZOLEVBQUUsQ0FBRixDQUFqQixDQUFWO0FBQ0EsUUFBTTZMLElBQUk0QixpQkFBaUJ6TixFQUFFLENBQUYsQ0FBakIsQ0FBVjtBQUNBLFFBQU1pTyxjQUFjdFcsS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVl6QyxVQUFVMEMsQ0FBdEIsQ0FBcEI7QUFDQSxXQUFPLENBQ0h4VyxLQUFLdEssS0FBTCxDQUFXd08sSUFBSW9TLFdBQUosR0FBa0JaLE1BQTdCLENBREcsRUFFSDFWLEtBQUt0SyxLQUFMLENBQVd3ZSxJQUFJb0MsV0FBSixHQUFrQlosTUFBN0IsQ0FGRyxDQUFQO0FBSUg7QUFDRCxTQUFTZSxVQUFULENBQW9CcE8sQ0FBcEIsRUFBdUJxTyxFQUF2QixFQUEyQkMsRUFBM0IsRUFBK0I7QUFDM0IsUUFBTUMsS0FBS3ZPLEVBQUUsQ0FBRixJQUFPcU8sR0FBRyxDQUFILENBQWxCO0FBQ0EsUUFBTUcsS0FBS3hPLEVBQUUsQ0FBRixJQUFPcU8sR0FBRyxDQUFILENBQWxCO0FBQ0EsUUFBTUksS0FBS3pPLEVBQUUsQ0FBRixJQUFPc08sR0FBRyxDQUFILENBQWxCO0FBQ0EsUUFBTUksS0FBSzFPLEVBQUUsQ0FBRixJQUFPc08sR0FBRyxDQUFILENBQWxCO0FBQ0EsV0FBT0MsS0FBS0csRUFBTCxHQUFVRCxLQUFLRCxFQUFmLEtBQXNCLENBQXRCLElBQTJCRCxLQUFLRSxFQUFMLElBQVcsQ0FBdEMsSUFBMkNELEtBQUtFLEVBQUwsSUFBVyxDQUE3RDtBQUNIO0FBQ0QsU0FBU0MsWUFBVCxDQUFzQjNPLENBQXRCLEVBQXlCcU8sRUFBekIsRUFBNkJDLEVBQTdCLEVBQWlDO0FBQzdCLFdBQU9ELEdBQUcsQ0FBSCxJQUFRck8sRUFBRSxDQUFGLENBQVIsS0FBaUJzTyxHQUFHLENBQUgsSUFBUXRPLEVBQUUsQ0FBRixDQUF6QixJQUFpQ0EsRUFBRSxDQUFGLElBQU8sQ0FBQ3NPLEdBQUcsQ0FBSCxJQUFRRCxHQUFHLENBQUgsQ0FBVCxLQUFtQnJPLEVBQUUsQ0FBRixJQUFPcU8sR0FBRyxDQUFILENBQTFCLEtBQW9DQyxHQUFHLENBQUgsSUFBUUQsR0FBRyxDQUFILENBQTVDLElBQXFEQSxHQUFHLENBQUgsQ0FBcEc7QUFDSDtBQUNELFNBQVNPLGtCQUFULENBQTRCamhCLEtBQTVCLEVBQW1Da2hCLEtBQW5DLEVBQTBDO0FBQ3RDLFFBQUlDLFNBQVMsS0FBYjtBQUNBLFNBQUssSUFBSW55QixJQUFJLENBQVIsRUFBV2lmLE1BQU1pVCxNQUFNN3hCLE1BQTVCLEVBQW9DTCxJQUFJaWYsR0FBeEMsRUFBNkNqZixHQUE3QyxFQUFrRDtBQUM5QyxZQUFNb3lCLE9BQU9GLE1BQU1seUIsQ0FBTixDQUFiO0FBQ0EsYUFBSyxJQUFJK2MsSUFBSSxDQUFSLEVBQVdzVixPQUFPRCxLQUFLL3hCLE1BQTVCLEVBQW9DMGMsSUFBSXNWLE9BQU8sQ0FBL0MsRUFBa0R0VixHQUFsRCxFQUF1RDtBQUNuRCxnQkFBSTBVLFdBQVd6Z0IsS0FBWCxFQUFrQm9oQixLQUFLclYsQ0FBTCxDQUFsQixFQUEyQnFWLEtBQUtyVixJQUFJLENBQVQsQ0FBM0IsQ0FBSixFQUNJLE9BQU8sS0FBUDtBQUNKLGdCQUFJaVYsYUFBYWhoQixLQUFiLEVBQW9Cb2hCLEtBQUtyVixDQUFMLENBQXBCLEVBQTZCcVYsS0FBS3JWLElBQUksQ0FBVCxDQUE3QixDQUFKLEVBQ0lvVixTQUFTLENBQUNBLE1BQVY7QUFDUDtBQUNKO0FBQ0QsV0FBT0EsTUFBUDtBQUNIO0FBQ0QsU0FBU0csbUJBQVQsQ0FBNkJ0aEIsS0FBN0IsRUFBb0N1aEIsUUFBcEMsRUFBOEM7QUFDMUMsU0FBSyxJQUFJdnlCLElBQUksQ0FBYixFQUFnQkEsSUFBSXV5QixTQUFTbHlCLE1BQTdCLEVBQXFDTCxHQUFyQyxFQUEwQztBQUN0QyxZQUFJaXlCLG1CQUFtQmpoQixLQUFuQixFQUEwQnVoQixTQUFTdnlCLENBQVQsQ0FBMUIsQ0FBSixFQUNJLE9BQU8sSUFBUDtBQUNQO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTd3lCLElBQVQsQ0FBY0MsRUFBZCxFQUFrQkMsRUFBbEIsRUFBc0I7QUFDbEIsV0FBT0QsR0FBRyxDQUFILElBQVFDLEdBQUcsQ0FBSCxDQUFSLEdBQWdCRCxHQUFHLENBQUgsSUFBUUMsR0FBRyxDQUFILENBQS9CO0FBQ0g7QUFDRCxTQUFTQyxRQUFULENBQWtCakIsRUFBbEIsRUFBc0JDLEVBQXRCLEVBQTBCaUIsRUFBMUIsRUFBOEJDLEVBQTlCLEVBQWtDO0FBQzlCLFFBQU1qQixLQUFLRixHQUFHLENBQUgsSUFBUWtCLEdBQUcsQ0FBSCxDQUFuQjtBQUNBLFFBQU1mLEtBQUtILEdBQUcsQ0FBSCxJQUFRa0IsR0FBRyxDQUFILENBQW5CO0FBQ0EsUUFBTWQsS0FBS0gsR0FBRyxDQUFILElBQVFpQixHQUFHLENBQUgsQ0FBbkI7QUFDQSxRQUFNYixLQUFLSixHQUFHLENBQUgsSUFBUWlCLEdBQUcsQ0FBSCxDQUFuQjtBQUNBLFFBQU1FLEtBQUtELEdBQUcsQ0FBSCxJQUFRRCxHQUFHLENBQUgsQ0FBbkI7QUFDQSxRQUFNRyxLQUFLRixHQUFHLENBQUgsSUFBUUQsR0FBRyxDQUFILENBQW5CO0FBQ0EsUUFBTUksT0FBT3BCLEtBQUttQixFQUFMLEdBQVVELEtBQUtqQixFQUE1QjtBQUNBLFFBQU1vQixPQUFPbkIsS0FBS2lCLEVBQUwsR0FBVUQsS0FBS2YsRUFBNUI7QUFDQSxRQUFJaUIsT0FBTyxDQUFQLElBQVlDLE9BQU8sQ0FBbkIsSUFBd0JELE9BQU8sQ0FBUCxJQUFZQyxPQUFPLENBQS9DLEVBQ0ksT0FBTyxJQUFQO0FBQ0osV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTQyxpQkFBVCxDQUEyQmpvQixDQUEzQixFQUE4QmdmLENBQTlCLEVBQWlDK0QsQ0FBakMsRUFBb0NtRixDQUFwQyxFQUF1QztBQUNuQyxRQUFNQyxVQUFVLENBQ1puSixFQUFFLENBQUYsSUFBT2hmLEVBQUUsQ0FBRixDQURLLEVBRVpnZixFQUFFLENBQUYsSUFBT2hmLEVBQUUsQ0FBRixDQUZLLENBQWhCO0FBSUEsUUFBTW9vQixVQUFVLENBQ1pGLEVBQUUsQ0FBRixJQUFPbkYsRUFBRSxDQUFGLENBREssRUFFWm1GLEVBQUUsQ0FBRixJQUFPbkYsRUFBRSxDQUFGLENBRkssQ0FBaEI7QUFJQSxRQUFJd0UsS0FBS2EsT0FBTCxFQUFjRCxPQUFkLE1BQTJCLENBQS9CLEVBQ0ksT0FBTyxLQUFQO0FBQ0osUUFBSVQsU0FBUzFuQixDQUFULEVBQVlnZixDQUFaLEVBQWUrRCxDQUFmLEVBQWtCbUYsQ0FBbEIsS0FBd0JSLFNBQVMzRSxDQUFULEVBQVltRixDQUFaLEVBQWVsb0IsQ0FBZixFQUFrQmdmLENBQWxCLENBQTVCLEVBQ0ksT0FBTyxJQUFQO0FBQ0osV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTcUosb0JBQVQsQ0FBOEI1QixFQUE5QixFQUFrQ0MsRUFBbEMsRUFBc0M0QixPQUF0QyxFQUErQztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUMzQywrQkFBbUJBLE9BQW5CLHdJQUE0QjtBQUFBLGdCQUFqQm5CLElBQWlCOztBQUN4QixpQkFBSyxJQUFJclYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJcVYsS0FBSy94QixNQUFMLEdBQWMsQ0FBbEMsRUFBcUMsRUFBRTBjLENBQXZDLEVBQTBDO0FBQ3RDLG9CQUFJbVcsa0JBQWtCeEIsRUFBbEIsRUFBc0JDLEVBQXRCLEVBQTBCUyxLQUFLclYsQ0FBTCxDQUExQixFQUFtQ3FWLEtBQUtyVixJQUFJLENBQVQsQ0FBbkMsQ0FBSixFQUFxRDtBQUNqRCwyQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNKO0FBUDBDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBUTNDLFdBQU8sS0FBUDtBQUNIO0FBQ0QsU0FBU3lXLHVCQUFULENBQWlDL2pCLElBQWpDLEVBQXVDOGpCLE9BQXZDLEVBQWdEO0FBQzVDLFNBQUssSUFBSXZ6QixJQUFJLENBQWIsRUFBZ0JBLElBQUl5UCxLQUFLcFAsTUFBekIsRUFBaUMsRUFBRUwsQ0FBbkMsRUFBc0M7QUFDbEMsWUFBSSxDQUFDaXlCLG1CQUFtQnhpQixLQUFLelAsQ0FBTCxDQUFuQixFQUE0QnV6QixPQUE1QixDQUFMLEVBQTJDO0FBQ3ZDLG1CQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBSyxJQUFJdnpCLE1BQUksQ0FBYixFQUFnQkEsTUFBSXlQLEtBQUtwUCxNQUFMLEdBQWMsQ0FBbEMsRUFBcUMsRUFBRUwsR0FBdkMsRUFBMEM7QUFDdEMsWUFBSXN6QixxQkFBcUI3akIsS0FBS3pQLEdBQUwsQ0FBckIsRUFBOEJ5UCxLQUFLelAsTUFBSSxDQUFULENBQTlCLEVBQTJDdXpCLE9BQTNDLENBQUosRUFBeUQ7QUFDckQsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSDtBQUNELFNBQVNFLHdCQUFULENBQWtDaGtCLElBQWxDLEVBQXdDOGlCLFFBQXhDLEVBQWtEO0FBQzlDLFNBQUssSUFBSXZ5QixJQUFJLENBQWIsRUFBZ0JBLElBQUl1eUIsU0FBU2x5QixNQUE3QixFQUFxQ0wsR0FBckMsRUFBMEM7QUFDdEMsWUFBSXd6Qix3QkFBd0IvakIsSUFBeEIsRUFBOEI4aUIsU0FBU3Z5QixDQUFULENBQTlCLENBQUosRUFDSSxPQUFPLElBQVA7QUFDUDtBQUNELFdBQU8sS0FBUDtBQUNIO0FBQ0QsU0FBUzB6QixjQUFULENBQXdCdmtCLFdBQXhCLEVBQXFDaEYsSUFBckMsRUFBMkMya0IsU0FBM0MsRUFBc0Q7QUFDbEQsUUFBTXlFLFVBQVUsRUFBaEI7QUFDQSxTQUFLLElBQUl2ekIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbVAsWUFBWTlPLE1BQWhDLEVBQXdDTCxHQUF4QyxFQUE2QztBQUN6QyxZQUFNb3lCLE9BQU8sRUFBYjtBQUNBLGFBQUssSUFBSXJWLElBQUksQ0FBYixFQUFnQkEsSUFBSTVOLFlBQVluUCxDQUFaLEVBQWVLLE1BQW5DLEVBQTJDMGMsR0FBM0MsRUFBZ0Q7QUFDNUMsZ0JBQU1xSixRQUFRaUwsbUJBQW1CbGlCLFlBQVluUCxDQUFaLEVBQWUrYyxDQUFmLENBQW5CLEVBQXNDK1IsU0FBdEMsQ0FBZDtBQUNBNkIsdUJBQVd4bUIsSUFBWCxFQUFpQmljLEtBQWpCO0FBQ0FnTSxpQkFBS3B4QixJQUFMLENBQVVvbEIsS0FBVjtBQUNIO0FBQ0RtTixnQkFBUXZ5QixJQUFSLENBQWFveEIsSUFBYjtBQUNIO0FBQ0QsV0FBT21CLE9BQVA7QUFDSDtBQUNELFNBQVNJLGVBQVQsQ0FBeUJ4a0IsV0FBekIsRUFBc0NoRixJQUF0QyxFQUE0QzJrQixTQUE1QyxFQUF1RDtBQUNuRCxRQUFNeUQsV0FBVyxFQUFqQjtBQUNBLFNBQUssSUFBSXZ5QixJQUFJLENBQWIsRUFBZ0JBLElBQUltUCxZQUFZOU8sTUFBaEMsRUFBd0NMLEdBQXhDLEVBQTZDO0FBQ3pDLFlBQU11ekIsVUFBVUcsZUFBZXZrQixZQUFZblAsQ0FBWixDQUFmLEVBQStCbUssSUFBL0IsRUFBcUMya0IsU0FBckMsQ0FBaEI7QUFDQXlELGlCQUFTdnhCLElBQVQsQ0FBY3V5QixPQUFkO0FBQ0g7QUFDRCxXQUFPaEIsUUFBUDtBQUNIO0FBQ0QsU0FBU3FCLFdBQVQsQ0FBcUJ2USxDQUFyQixFQUF3QmxaLElBQXhCLEVBQThCMHBCLFFBQTlCLEVBQXdDQyxTQUF4QyxFQUFtRDtBQUMvQyxRQUFJelEsRUFBRSxDQUFGLElBQU93USxTQUFTLENBQVQsQ0FBUCxJQUFzQnhRLEVBQUUsQ0FBRixJQUFPd1EsU0FBUyxDQUFULENBQWpDLEVBQThDO0FBQzFDLFlBQU1FLGdCQUFnQkQsWUFBWSxHQUFsQztBQUNBLFlBQUl6UCxRQUFRaEIsRUFBRSxDQUFGLElBQU93USxTQUFTLENBQVQsQ0FBUCxHQUFxQkUsYUFBckIsR0FBcUMsQ0FBQ0QsU0FBdEMsR0FBa0RELFNBQVMsQ0FBVCxJQUFjeFEsRUFBRSxDQUFGLENBQWQsR0FBcUIwUSxhQUFyQixHQUFxQ0QsU0FBckMsR0FBaUQsQ0FBL0c7QUFDQSxZQUFJelAsVUFBVSxDQUFkLEVBQWlCO0FBQ2JBLG9CQUFRaEIsRUFBRSxDQUFGLElBQU93USxTQUFTLENBQVQsQ0FBUCxHQUFxQkUsYUFBckIsR0FBcUMsQ0FBQ0QsU0FBdEMsR0FBa0RELFNBQVMsQ0FBVCxJQUFjeFEsRUFBRSxDQUFGLENBQWQsR0FBcUIwUSxhQUFyQixHQUFxQ0QsU0FBckMsR0FBaUQsQ0FBM0c7QUFDSDtBQUNEelEsVUFBRSxDQUFGLEtBQVFnQixLQUFSO0FBQ0g7QUFDRHNNLGVBQVd4bUIsSUFBWCxFQUFpQmtaLENBQWpCO0FBQ0g7QUFDRCxTQUFTMlEsU0FBVCxDQUFtQjdwQixJQUFuQixFQUF5QjtBQUNyQkEsU0FBSyxDQUFMLElBQVVBLEtBQUssQ0FBTCxJQUFVNk4sUUFBcEI7QUFDQTdOLFNBQUssQ0FBTCxJQUFVQSxLQUFLLENBQUwsSUFBVSxDQUFDNk4sUUFBckI7QUFDSDtBQUNELFNBQVNpYyxhQUFULENBQXVCaEYsUUFBdkIsRUFBaUNpRixTQUFqQyxFQUE0Q0wsUUFBNUMsRUFBc0QvRSxTQUF0RCxFQUFpRTtBQUM3RCxRQUFNZ0YsWUFBWTlZLEtBQUt1VyxHQUFMLENBQVMsQ0FBVCxFQUFZekMsVUFBVTBDLENBQXRCLElBQTJCZCxNQUE3QztBQUNBLFFBQU15RCxTQUFTLENBQ1hyRixVQUFVNVAsQ0FBVixHQUFjd1IsTUFESCxFQUVYNUIsVUFBVUksQ0FBVixHQUFjd0IsTUFGSCxDQUFmO0FBSUEsUUFBTTBELGFBQWEsRUFBbkI7QUFONkQ7QUFBQTtBQUFBOztBQUFBO0FBTzdELCtCQUFxQm5GLFFBQXJCLHdJQUErQjtBQUFBLGdCQUFwQm9GLE1BQW9CO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQzNCLHVDQUFvQkEsTUFBcEIsd0lBQTRCO0FBQUEsd0JBQWpCcmpCLEtBQWlCOztBQUN4Qix3QkFBTXFTLElBQUksQ0FDTnJTLE1BQU1rTyxDQUFOLEdBQVVpVixPQUFPLENBQVAsQ0FESixFQUVObmpCLE1BQU1rZSxDQUFOLEdBQVVpRixPQUFPLENBQVAsQ0FGSixDQUFWO0FBSUFQLGdDQUFZdlEsQ0FBWixFQUFlNlEsU0FBZixFQUEwQkwsUUFBMUIsRUFBb0NDLFNBQXBDO0FBQ0FNLCtCQUFXcHpCLElBQVgsQ0FBZ0JxaUIsQ0FBaEI7QUFDSDtBQVIwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUzlCO0FBaEI0RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWlCN0QsV0FBTytRLFVBQVA7QUFDSDtBQUNELFNBQVNFLFlBQVQsQ0FBc0JyRixRQUF0QixFQUFnQ3NGLFFBQWhDLEVBQTBDVixRQUExQyxFQUFvRC9FLFNBQXBELEVBQStEO0FBQzNELFFBQU1nRixZQUFZOVksS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVl6QyxVQUFVMEMsQ0FBdEIsSUFBMkJkLE1BQTdDO0FBQ0EsUUFBTXlELFNBQVMsQ0FDWHJGLFVBQVU1UCxDQUFWLEdBQWN3UixNQURILEVBRVg1QixVQUFVSSxDQUFWLEdBQWN3QixNQUZILENBQWY7QUFJQSxRQUFNOEQsWUFBWSxFQUFsQjtBQU4yRDtBQUFBO0FBQUE7O0FBQUE7QUFPM0QsK0JBQW1CdkYsUUFBbkIsd0lBQTZCO0FBQUEsZ0JBQWxCeGYsSUFBa0I7O0FBQ3pCLGdCQUFNZ2xCLFdBQVcsRUFBakI7QUFEeUI7QUFBQTtBQUFBOztBQUFBO0FBRXpCLHVDQUFvQmhsQixJQUFwQix3SUFBMEI7QUFBQSx3QkFBZnVCLEtBQWU7O0FBQ3RCLHdCQUFNcVMsS0FBSSxDQUNOclMsTUFBTWtPLENBQU4sR0FBVWlWLE9BQU8sQ0FBUCxDQURKLEVBRU5uakIsTUFBTWtlLENBQU4sR0FBVWlGLE9BQU8sQ0FBUCxDQUZKLENBQVY7QUFJQXhELCtCQUFXNEQsUUFBWCxFQUFxQmxSLEVBQXJCO0FBQ0FvUiw2QkFBU3p6QixJQUFULENBQWNxaUIsRUFBZDtBQUNIO0FBVHdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVXpCbVIsc0JBQVV4ekIsSUFBVixDQUFleXpCLFFBQWY7QUFDSDtBQWxCMEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFtQjNELFFBQUlGLFNBQVMsQ0FBVCxJQUFjQSxTQUFTLENBQVQsQ0FBZCxJQUE2QlQsWUFBWSxDQUE3QyxFQUFnRDtBQUM1Q0Usa0JBQVVPLFFBQVY7QUFENEM7QUFBQTtBQUFBOztBQUFBO0FBRTVDLG1DQUFtQkMsU0FBbkIsd0lBQThCO0FBQUEsb0JBQW5CL2tCLEtBQW1CO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQzFCLDJDQUFnQkEsS0FBaEIsd0lBQXNCO0FBQUEsNEJBQVg0VCxDQUFXOztBQUNsQnVRLG9DQUFZdlEsQ0FBWixFQUFla1IsUUFBZixFQUF5QlYsUUFBekIsRUFBbUNDLFNBQW5DO0FBQ0g7QUFIeUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUk3QjtBQU4yQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTy9DO0FBQ0QsV0FBT1UsU0FBUDtBQUNIO0FBQ0QsU0FBU0Usb0JBQVQsQ0FBOEI1SCxHQUE5QixFQUFtQzZILGVBQW5DLEVBQW9EO0FBQ2hELFFBQU1ULFlBQVksQ0FDZGxjLFFBRGMsRUFFZEEsUUFGYyxFQUdkLENBQUNBLFFBSGEsRUFJZCxDQUFDQSxRQUphLENBQWxCO0FBTUEsUUFBTTZiLFdBQVcsQ0FDYjdiLFFBRGEsRUFFYkEsUUFGYSxFQUdiLENBQUNBLFFBSFksRUFJYixDQUFDQSxRQUpZLENBQWpCO0FBTUEsUUFBTThXLFlBQVloQyxJQUFJOEgsV0FBSixFQUFsQjtBQUNBLFFBQUlELGdCQUFnQjN2QixJQUFoQixLQUF5QixTQUE3QixFQUF3QztBQUNwQyxZQUFNNnZCLGNBQWNuQixlQUFlaUIsZ0JBQWdCeGxCLFdBQS9CLEVBQTRDMGtCLFFBQTVDLEVBQXNEL0UsU0FBdEQsQ0FBcEI7QUFDQSxZQUFNc0YsYUFBYUgsY0FBY25ILElBQUltQyxRQUFKLEVBQWQsRUFBOEJpRixTQUE5QixFQUF5Q0wsUUFBekMsRUFBbUQvRSxTQUFuRCxDQUFuQjtBQUNBLFlBQUksQ0FBQ29DLGFBQWFnRCxTQUFiLEVBQXdCTCxRQUF4QixDQUFMLEVBQ0ksT0FBTyxLQUFQO0FBSmdDO0FBQUE7QUFBQTs7QUFBQTtBQUtwQyxtQ0FBb0JPLFVBQXBCLHdJQUFnQztBQUFBLG9CQUFyQnBqQixLQUFxQjs7QUFDNUIsb0JBQUksQ0FBQ2loQixtQkFBbUJqaEIsS0FBbkIsRUFBMEI2akIsV0FBMUIsQ0FBTCxFQUNJLE9BQU8sS0FBUDtBQUNQO0FBUm1DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTdkM7QUFDRCxRQUFJRixnQkFBZ0IzdkIsSUFBaEIsS0FBeUIsY0FBN0IsRUFBNkM7QUFDekMsWUFBTTh2QixlQUFlbkIsZ0JBQWdCZ0IsZ0JBQWdCeGxCLFdBQWhDLEVBQTZDMGtCLFFBQTdDLEVBQXVEL0UsU0FBdkQsQ0FBckI7QUFDQSxZQUFNc0YsY0FBYUgsY0FBY25ILElBQUltQyxRQUFKLEVBQWQsRUFBOEJpRixTQUE5QixFQUF5Q0wsUUFBekMsRUFBbUQvRSxTQUFuRCxDQUFuQjtBQUNBLFlBQUksQ0FBQ29DLGFBQWFnRCxTQUFiLEVBQXdCTCxRQUF4QixDQUFMLEVBQ0ksT0FBTyxLQUFQO0FBSnFDO0FBQUE7QUFBQTs7QUFBQTtBQUt6QyxtQ0FBb0JPLFdBQXBCLHdJQUFnQztBQUFBLG9CQUFyQnBqQixNQUFxQjs7QUFDNUIsb0JBQUksQ0FBQ3NoQixvQkFBb0J0aEIsTUFBcEIsRUFBMkI4akIsWUFBM0IsQ0FBTCxFQUNJLE9BQU8sS0FBUDtBQUNQO0FBUndDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTNUM7QUFDRCxXQUFPLElBQVA7QUFDSDtBQUNELFNBQVNDLG1CQUFULENBQTZCakksR0FBN0IsRUFBa0M2SCxlQUFsQyxFQUFtRDtBQUMvQyxRQUFNSixXQUFXLENBQ2J2YyxRQURhLEVBRWJBLFFBRmEsRUFHYixDQUFDQSxRQUhZLEVBSWIsQ0FBQ0EsUUFKWSxDQUFqQjtBQU1BLFFBQU02YixXQUFXLENBQ2I3YixRQURhLEVBRWJBLFFBRmEsRUFHYixDQUFDQSxRQUhZLEVBSWIsQ0FBQ0EsUUFKWSxDQUFqQjtBQU1BLFFBQU04VyxZQUFZaEMsSUFBSThILFdBQUosRUFBbEI7QUFDQSxRQUFJRCxnQkFBZ0IzdkIsSUFBaEIsS0FBeUIsU0FBN0IsRUFBd0M7QUFDcEMsWUFBTTZ2QixjQUFjbkIsZUFBZWlCLGdCQUFnQnhsQixXQUEvQixFQUE0QzBrQixRQUE1QyxFQUFzRC9FLFNBQXRELENBQXBCO0FBQ0EsWUFBTTBGLFlBQVlGLGFBQWF4SCxJQUFJbUMsUUFBSixFQUFiLEVBQTZCc0YsUUFBN0IsRUFBdUNWLFFBQXZDLEVBQWlEL0UsU0FBakQsQ0FBbEI7QUFDQSxZQUFJLENBQUNvQyxhQUFhcUQsUUFBYixFQUF1QlYsUUFBdkIsQ0FBTCxFQUNJLE9BQU8sS0FBUDtBQUpnQztBQUFBO0FBQUE7O0FBQUE7QUFLcEMsbUNBQW1CVyxTQUFuQix3SUFBOEI7QUFBQSxvQkFBbkIva0IsSUFBbUI7O0FBQzFCLG9CQUFJLENBQUMrakIsd0JBQXdCL2pCLElBQXhCLEVBQThCb2xCLFdBQTlCLENBQUwsRUFDSSxPQUFPLEtBQVA7QUFDUDtBQVJtQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU3ZDO0FBQ0QsUUFBSUYsZ0JBQWdCM3ZCLElBQWhCLEtBQXlCLGNBQTdCLEVBQTZDO0FBQ3pDLFlBQU04dkIsZUFBZW5CLGdCQUFnQmdCLGdCQUFnQnhsQixXQUFoQyxFQUE2QzBrQixRQUE3QyxFQUF1RC9FLFNBQXZELENBQXJCO0FBQ0EsWUFBTTBGLGFBQVlGLGFBQWF4SCxJQUFJbUMsUUFBSixFQUFiLEVBQTZCc0YsUUFBN0IsRUFBdUNWLFFBQXZDLEVBQWlEL0UsU0FBakQsQ0FBbEI7QUFDQSxZQUFJLENBQUNvQyxhQUFhcUQsUUFBYixFQUF1QlYsUUFBdkIsQ0FBTCxFQUNJLE9BQU8sS0FBUDtBQUpxQztBQUFBO0FBQUE7O0FBQUE7QUFLekMsbUNBQW1CVyxVQUFuQix3SUFBOEI7QUFBQSxvQkFBbkIva0IsTUFBbUI7O0FBQzFCLG9CQUFJLENBQUNna0IseUJBQXlCaGtCLE1BQXpCLEVBQStCcWxCLFlBQS9CLENBQUwsRUFDSSxPQUFPLEtBQVA7QUFDUDtBQVJ3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUzVDO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7O0lBQ0tFLE07QUFDRixvQkFBWTVtQixPQUFaLEVBQXFCNm1CLFVBQXJCLEVBQWlDO0FBQUE7O0FBQzdCLGFBQUtqd0IsSUFBTCxHQUFZeWlCLFdBQVo7QUFDQSxhQUFLclosT0FBTCxHQUFlQSxPQUFmO0FBQ0EsYUFBSzZtQixVQUFMLEdBQWtCQSxVQUFsQjtBQUNIOzs7O2lDQXdCUW5JLEcsRUFBSztBQUNWLGdCQUFJQSxJQUFJbUMsUUFBSixNQUFrQixJQUFsQixJQUEwQm5DLElBQUk4SCxXQUFKLE1BQXFCLElBQW5ELEVBQXlEO0FBQ3JELG9CQUFJOUgsSUFBSW9JLFlBQUosT0FBdUIsT0FBM0IsRUFBb0M7QUFDaEMsMkJBQU9SLHFCQUFxQjVILEdBQXJCLEVBQTBCLEtBQUttSSxVQUEvQixDQUFQO0FBQ0gsaUJBRkQsTUFFTyxJQUFJbkksSUFBSW9JLFlBQUosT0FBdUIsWUFBM0IsRUFBeUM7QUFDNUMsMkJBQU9ILG9CQUFvQmpJLEdBQXBCLEVBQXlCLEtBQUttSSxVQUE5QixDQUFQO0FBQ0g7QUFDSjtBQUNELG1CQUFPLEtBQVA7QUFDSDs7O29DQUNXLENBQ1g7Ozt3Q0FDZTtBQUNaLG1CQUFPLElBQVA7QUFDSDs7O29DQUNXO0FBQ1IsbUJBQU8sQ0FDSCxRQURHLEVBRUgsS0FBSzdtQixPQUZGLENBQVA7QUFJSDs7OzhCQTNDWW9lLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFDSSxPQUFPb3NCLFFBQVFwb0IsS0FBUixvRUFBK0Vtb0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBN0YsZ0JBQVA7QUFDSixnQkFBSTRyQixRQUFRTyxLQUFLLENBQUwsQ0FBUixDQUFKLEVBQXNCO0FBQ2xCLG9CQUFNcGUsVUFBVW9lLEtBQUssQ0FBTCxDQUFoQjtBQUNBLG9CQUFJcGUsUUFBUXBKLElBQVIsS0FBaUIsbUJBQXJCLEVBQTBDO0FBQ3RDLHlCQUFLLElBQUloRixJQUFJLENBQWIsRUFBZ0JBLElBQUlvTyxRQUFRM0QsUUFBUixDQUFpQnBLLE1BQXJDLEVBQTZDLEVBQUVMLENBQS9DLEVBQWtEO0FBQzlDLDRCQUFNZ0YsT0FBT29KLFFBQVEzRCxRQUFSLENBQWlCekssQ0FBakIsRUFBb0JpdkIsUUFBcEIsQ0FBNkJqcUIsSUFBMUM7QUFDQSw0QkFBSUEsU0FBUyxTQUFULElBQXNCQSxTQUFTLGNBQW5DLEVBQW1EO0FBQy9DLG1DQUFPLElBQUlnd0IsTUFBSixDQUFXNW1CLE9BQVgsRUFBb0JBLFFBQVEzRCxRQUFSLENBQWlCekssQ0FBakIsRUFBb0JpdkIsUUFBeEMsQ0FBUDtBQUNIO0FBQ0o7QUFDSixpQkFQRCxNQU9PLElBQUk3Z0IsUUFBUXBKLElBQVIsS0FBaUIsU0FBckIsRUFBZ0M7QUFDbkMsd0JBQU1BLFNBQU9vSixRQUFRNmdCLFFBQVIsQ0FBaUJqcUIsSUFBOUI7QUFDQSx3QkFBSUEsV0FBUyxTQUFULElBQXNCQSxXQUFTLGNBQW5DLEVBQW1EO0FBQy9DLCtCQUFPLElBQUlnd0IsTUFBSixDQUFXNW1CLE9BQVgsRUFBb0JBLFFBQVE2Z0IsUUFBNUIsQ0FBUDtBQUNIO0FBQ0osaUJBTE0sTUFLQSxJQUFJN2dCLFFBQVFwSixJQUFSLEtBQWlCLFNBQWpCLElBQThCb0osUUFBUXBKLElBQVIsS0FBaUIsY0FBbkQsRUFBbUU7QUFDdEUsMkJBQU8sSUFBSWd3QixNQUFKLENBQVc1bUIsT0FBWCxFQUFvQkEsT0FBcEIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxtQkFBT3FlLFFBQVFwb0IsS0FBUiwwRkFBUDtBQUNIOzs7Ozs7QUF3QkwsU0FBUzh3QixpQkFBVCxDQUEyQnZ3QixDQUEzQixFQUE4QjtBQUMxQixRQUFJQSxhQUFhNnFCLGtCQUFqQixFQUFxQztBQUNqQyxZQUFJN3FCLEVBQUVvSCxJQUFGLEtBQVcsS0FBWCxJQUFvQnBILEVBQUU0bkIsSUFBRixDQUFPbnNCLE1BQVAsS0FBa0IsQ0FBMUMsRUFBNkM7QUFDekMsbUJBQU8sS0FBUDtBQUNILFNBRkQsTUFFTyxJQUFJdUUsRUFBRW9ILElBQUYsS0FBVyxlQUFmLEVBQWdDO0FBQ25DLG1CQUFPLEtBQVA7QUFDSCxTQUZNLE1BRUEsSUFBSXBILEVBQUVvSCxJQUFGLEtBQVcsS0FBWCxJQUFvQnBILEVBQUU0bkIsSUFBRixDQUFPbnNCLE1BQVAsS0FBa0IsQ0FBMUMsRUFBNkM7QUFDaEQsbUJBQU8sS0FBUDtBQUNILFNBRk0sTUFFQSxJQUFJdUUsRUFBRW9ILElBQUYsS0FBVyxZQUFYLElBQTJCcEgsRUFBRW9ILElBQUYsS0FBVyxlQUF0QyxJQUF5RHBILEVBQUVvSCxJQUFGLEtBQVcsSUFBeEUsRUFBOEU7QUFDakYsbUJBQU8sS0FBUDtBQUNILFNBRk0sTUFFQSxJQUFJLFdBQVcrUixJQUFYLENBQWdCblosRUFBRW9ILElBQWxCLENBQUosRUFBNkI7QUFDaEMsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxRQUFJcEgsYUFBYW93QixNQUFqQixFQUF5QjtBQUNyQixlQUFPLEtBQVA7QUFDSDtBQUNELFFBQUk5YixTQUFTLElBQWI7QUFDQXRVLE1BQUV5cEIsU0FBRixDQUFZLGVBQU87QUFDZixZQUFJblYsVUFBVSxDQUFDaWMsa0JBQWtCOVcsR0FBbEIsQ0FBZixFQUF1QztBQUNuQ25GLHFCQUFTLEtBQVQ7QUFDSDtBQUNKLEtBSkQ7QUFLQSxXQUFPQSxNQUFQO0FBQ0g7QUFDRCxTQUFTa2MsZUFBVCxDQUF5Qnh3QixDQUF6QixFQUE0QjtBQUN4QixRQUFJQSxhQUFhNnFCLGtCQUFqQixFQUFxQztBQUNqQyxZQUFJN3FCLEVBQUVvSCxJQUFGLEtBQVcsZUFBZixFQUFnQztBQUM1QixtQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNELFFBQUlrTixTQUFTLElBQWI7QUFDQXRVLE1BQUV5cEIsU0FBRixDQUFZLGVBQU87QUFDZixZQUFJblYsVUFBVSxDQUFDa2MsZ0JBQWdCL1csR0FBaEIsQ0FBZixFQUFxQztBQUNqQ25GLHFCQUFTLEtBQVQ7QUFDSDtBQUNKLEtBSkQ7QUFLQSxXQUFPQSxNQUFQO0FBQ0g7QUFDRCxTQUFTbWMsd0JBQVQsQ0FBa0N6d0IsQ0FBbEMsRUFBcUNxUCxVQUFyQyxFQUFpRDtBQUM3QyxRQUFJclAsYUFBYTZxQixrQkFBYixJQUFtQ3hiLFdBQVdsVCxPQUFYLENBQW1CNkQsRUFBRW9ILElBQXJCLEtBQThCLENBQXJFLEVBQXdFO0FBQ3BFLGVBQU8sS0FBUDtBQUNIO0FBQ0QsUUFBSWtOLFNBQVMsSUFBYjtBQUNBdFUsTUFBRXlwQixTQUFGLENBQVksZUFBTztBQUNmLFlBQUluVixVQUFVLENBQUNtYyx5QkFBeUJoWCxHQUF6QixFQUE4QnBLLFVBQTlCLENBQWYsRUFBMEQ7QUFDdERpRixxQkFBUyxLQUFUO0FBQ0g7QUFDSixLQUpEO0FBS0EsV0FBT0EsTUFBUDtBQUNIOztJQUVLb2MsRztBQUNGLGlCQUFZdHBCLElBQVosRUFBa0J1cEIsZUFBbEIsRUFBbUM7QUFBQTs7QUFDL0IsYUFBS3Z3QixJQUFMLEdBQVl1d0IsZ0JBQWdCdndCLElBQTVCO0FBQ0EsYUFBS2dILElBQUwsR0FBWUEsSUFBWjtBQUNBLGFBQUt1cEIsZUFBTCxHQUF1QkEsZUFBdkI7QUFDSDs7OztpQ0FVUXpJLEcsRUFBSztBQUNWLG1CQUFPLEtBQUt5SSxlQUFMLENBQXFCeEksUUFBckIsQ0FBOEJELEdBQTlCLENBQVA7QUFDSDs7O29DQUNXLENBQ1g7Ozt3Q0FDZTtBQUNaLG1CQUFPLEtBQVA7QUFDSDs7O29DQUNXO0FBQ1IsbUJBQU8sQ0FDSCxLQURHLEVBRUgsS0FBSzlnQixJQUZGLENBQVA7QUFJSDs7OzhCQXRCWXdnQixJLEVBQU1DLE8sRUFBUztBQUN4QixnQkFBSUQsS0FBS25zQixNQUFMLEtBQWdCLENBQWhCLElBQXFCLE9BQU9tc0IsS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBNUMsRUFDSSxPQUFPQyxRQUFRcG9CLEtBQVIsa0VBQVA7QUFDSixnQkFBTTJILE9BQU93Z0IsS0FBSyxDQUFMLENBQWI7QUFDQSxnQkFBSSxDQUFDQyxRQUFRMEQsS0FBUixDQUFjMWQsR0FBZCxDQUFrQnpHLElBQWxCLENBQUwsRUFBOEI7QUFDMUIsdUJBQU95Z0IsUUFBUXBvQixLQUFSLHlCQUFvQzJILElBQXBDLHdCQUEyREEsSUFBM0QsNEVBQXNJLENBQXRJLENBQVA7QUFDSDtBQUNELG1CQUFPLElBQUlzcEIsR0FBSixDQUFRdHBCLElBQVIsRUFBY3lnQixRQUFRMEQsS0FBUixDQUFjMWtCLEdBQWQsQ0FBa0JPLElBQWxCLENBQWQsQ0FBUDtBQUNIOzs7Ozs7SUFpQkNpa0IsYztBQUNGLDRCQUFZQyxRQUFaLEVBQWlGO0FBQUEsWUFBM0RqdUIsSUFBMkQsdUVBQXBELEVBQW9EO0FBQUEsWUFBaER5cUIsWUFBZ0Q7QUFBQSxZQUFsQ3lELEtBQWtDLHVFQUExQixJQUFJakosS0FBSixFQUEwQjtBQUFBLFlBQWJwTSxNQUFhLHVFQUFKLEVBQUk7O0FBQUE7O0FBQzdFLGFBQUtvVixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLGFBQUtqdUIsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsYUFBS29ILEdBQUwsR0FBV3BILEtBQUt2QixHQUFMLENBQVM7QUFBQSx5QkFBYXFpQixJQUFiO0FBQUEsU0FBVCxFQUFnQzNYLElBQWhDLENBQXFDLEVBQXJDLENBQVg7QUFDQSxhQUFLK2tCLEtBQUwsR0FBYUEsS0FBYjtBQUNBLGFBQUtyVixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLNFIsWUFBTCxHQUFvQkEsWUFBcEI7QUFDSDs7Ozs4QkFDSzhJLEksRUFBTWxkLEssRUFBT29VLFksRUFBY3RGLFEsRUFBd0I7QUFBQSxnQkFBZHhQLE9BQWMsdUVBQUosRUFBSTs7QUFDckQsZ0JBQUlVLEtBQUosRUFBVztBQUNQLHVCQUFPLEtBQUtqRCxNQUFMLENBQVlpRCxLQUFaLEVBQW1Cb1UsWUFBbkIsRUFBaUN0RixRQUFqQyxFQUEyQ3FPLE1BQTNDLENBQWtERCxJQUFsRCxFQUF3RDVkLE9BQXhELENBQVA7QUFDSDtBQUNELG1CQUFPLEtBQUs2ZCxNQUFMLENBQVlELElBQVosRUFBa0I1ZCxPQUFsQixDQUFQO0FBQ0g7OzsrQkFDTTRkLEksRUFBTTVkLE8sRUFBUztBQUNsQixnQkFBSTRkLFNBQVMsSUFBVCxJQUFpQixPQUFPQSxJQUFQLEtBQWdCLFFBQWpDLElBQTZDLE9BQU9BLElBQVAsS0FBZ0IsU0FBN0QsSUFBMEUsT0FBT0EsSUFBUCxLQUFnQixRQUE5RixFQUF3RztBQUNwR0EsdUJBQU8sQ0FDSCxTQURHLEVBRUhBLElBRkcsQ0FBUDtBQUlIO0FBQ0QscUJBQVNFLFFBQVQsQ0FBa0J4SSxNQUFsQixFQUEwQmxvQixJQUExQixFQUFnQzJ3QixjQUFoQyxFQUFnRDtBQUM1QyxvQkFBSUEsbUJBQW1CLFFBQXZCLEVBQWlDO0FBQzdCLDJCQUFPLElBQUk5SSxTQUFKLENBQWM3bkIsSUFBZCxFQUFvQixDQUFDa29CLE1BQUQsQ0FBcEIsQ0FBUDtBQUNILGlCQUZELE1BRU8sSUFBSXlJLG1CQUFtQixRQUF2QixFQUFpQztBQUNwQywyQkFBTyxJQUFJN0gsUUFBSixDQUFhOW9CLElBQWIsRUFBbUIsQ0FBQ2tvQixNQUFELENBQW5CLENBQVA7QUFDSCxpQkFGTSxNQUVBO0FBQ0gsMkJBQU9BLE1BQVA7QUFDSDtBQUNKO0FBQ0QsZ0JBQUlodEIsTUFBTUMsT0FBTixDQUFjcTFCLElBQWQsQ0FBSixFQUF5QjtBQUNyQixvQkFBSUEsS0FBS24xQixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLDJCQUFPLEtBQUtnRSxLQUFMLHNHQUFQO0FBQ0g7QUFDRCxvQkFBTXNsQixLQUFLNkwsS0FBSyxDQUFMLENBQVg7QUFDQSxvQkFBSSxPQUFPN0wsRUFBUCxLQUFjLFFBQWxCLEVBQTRCO0FBQ3hCLHlCQUFLdGxCLEtBQUwsMERBQWtFc2xCLEVBQWxFLHlDQUFrRUEsRUFBbEUsMkVBQXlJLENBQXpJO0FBQ0EsMkJBQU8sSUFBUDtBQUNIO0FBQ0Qsb0JBQU1pTSxPQUFPLEtBQUsxRixRQUFMLENBQWN2RyxFQUFkLENBQWI7QUFDQSxvQkFBSWlNLElBQUosRUFBVTtBQUNOLHdCQUFJMUksU0FBUzBJLEtBQUsveUIsS0FBTCxDQUFXMnlCLElBQVgsRUFBaUIsSUFBakIsQ0FBYjtBQUNBLHdCQUFJLENBQUN0SSxNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osd0JBQUksS0FBS1IsWUFBVCxFQUF1QjtBQUNuQiw0QkFBTXJFLFdBQVcsS0FBS3FFLFlBQXRCO0FBQ0EsNEJBQU1tSixTQUFTM0ksT0FBT2xvQixJQUF0QjtBQUNBLDRCQUFJLENBQUNxakIsU0FBU2YsSUFBVCxLQUFrQixRQUFsQixJQUE4QmUsU0FBU2YsSUFBVCxLQUFrQixRQUFoRCxJQUE0RGUsU0FBU2YsSUFBVCxLQUFrQixTQUE5RSxJQUEyRmUsU0FBU2YsSUFBVCxLQUFrQixRQUE3RyxJQUF5SGUsU0FBU2YsSUFBVCxLQUFrQixPQUE1SSxLQUF3SnVPLE9BQU92TyxJQUFQLEtBQWdCLE9BQTVLLEVBQXFMO0FBQ2pMNEYscUNBQVN3SSxTQUFTeEksTUFBVCxFQUFpQjdFLFFBQWpCLEVBQTJCelEsUUFBUStkLGNBQVIsSUFBMEIsUUFBckQsQ0FBVDtBQUNILHlCQUZELE1BRU8sSUFBSSxDQUFDdE4sU0FBU2YsSUFBVCxLQUFrQixPQUFsQixJQUE2QmUsU0FBU2YsSUFBVCxLQUFrQixXQUEvQyxJQUE4RGUsU0FBU2YsSUFBVCxLQUFrQixlQUFqRixNQUFzR3VPLE9BQU92TyxJQUFQLEtBQWdCLE9BQWhCLElBQTJCdU8sT0FBT3ZPLElBQVAsS0FBZ0IsUUFBakosQ0FBSixFQUFnSztBQUNuSzRGLHFDQUFTd0ksU0FBU3hJLE1BQVQsRUFBaUI3RSxRQUFqQixFQUEyQnpRLFFBQVErZCxjQUFSLElBQTBCLFFBQXJELENBQVQ7QUFDSCx5QkFGTSxNQUVBLElBQUksS0FBS3ZOLFlBQUwsQ0FBa0JDLFFBQWxCLEVBQTRCd04sTUFBNUIsQ0FBSixFQUF5QztBQUM1QyxtQ0FBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELHdCQUFJLEVBQUUzSSxrQkFBa0JaLE9BQXBCLEtBQWdDWSxPQUFPbG9CLElBQVAsQ0FBWXNpQixJQUFaLEtBQXFCLGVBQXJELElBQXdFd08sV0FBVzVJLE1BQVgsQ0FBNUUsRUFBZ0c7QUFDNUYsNEJBQU02SSxLQUFLLElBQUl2SCxpQkFBSixFQUFYO0FBQ0EsNEJBQUk7QUFDQXRCLHFDQUFTLElBQUlaLE9BQUosQ0FBWVksT0FBT2xvQixJQUFuQixFQUF5QmtvQixPQUFPSCxRQUFQLENBQWdCZ0osRUFBaEIsQ0FBekIsQ0FBVDtBQUNILHlCQUZELENBRUUsT0FBT254QixDQUFQLEVBQVU7QUFDUixpQ0FBS1AsS0FBTCxDQUFXTyxFQUFFcWlCLE9BQWI7QUFDQSxtQ0FBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELDJCQUFPaUcsTUFBUDtBQUNIO0FBQ0QsdUJBQU8sS0FBSzdvQixLQUFMLDJCQUFtQ3NsQixFQUFuQyxtRUFBbUcsQ0FBbkcsQ0FBUDtBQUNILGFBckNELE1BcUNPLElBQUksT0FBTzZMLElBQVAsS0FBZ0IsV0FBcEIsRUFBaUM7QUFDcEMsdUJBQU8sS0FBS254QixLQUFMLGdEQUFQO0FBQ0gsYUFGTSxNQUVBLElBQUksUUFBT214QixJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQXBCLEVBQThCO0FBQ2pDLHVCQUFPLEtBQUtueEIsS0FBTCwyREFBUDtBQUNILGFBRk0sTUFFQTtBQUNILHVCQUFPLEtBQUtBLEtBQUwsMkNBQW1EbXhCLElBQW5ELHlDQUFtREEsSUFBbkQsaUJBQVA7QUFDSDtBQUNKOzs7K0JBQ01sZCxLLEVBQU9vVSxZLEVBQWN0RixRLEVBQVU7QUFDbEMsZ0JBQU1ubEIsT0FBTyxPQUFPcVcsS0FBUCxLQUFpQixRQUFqQixHQUE0QixLQUFLclcsSUFBTCxDQUFVb1QsTUFBVixDQUFpQmlELEtBQWpCLENBQTVCLEdBQXNELEtBQUtyVyxJQUF4RTtBQUNBLGdCQUFNa3VCLFFBQVEvSSxXQUFXLEtBQUsrSSxLQUFMLENBQVc5YSxNQUFYLENBQWtCK1IsUUFBbEIsQ0FBWCxHQUF5QyxLQUFLK0ksS0FBNUQ7QUFDQSxtQkFBTyxJQUFJRixjQUFKLENBQW1CLEtBQUtDLFFBQXhCLEVBQWtDanVCLElBQWxDLEVBQXdDeXFCLGdCQUFnQixJQUF4RCxFQUE4RHlELEtBQTlELEVBQXFFLEtBQUtyVixNQUExRSxDQUFQO0FBQ0g7Ozs4QkFDS3pXLE8sRUFBZ0I7QUFBQSwrQ0FBTm9VLElBQU07QUFBTkEsb0JBQU07QUFBQTs7QUFDbEIsZ0JBQU1wUCxXQUFVLEtBQUtBLEdBQWYsR0FBdUJvUCxLQUFLL1gsR0FBTCxDQUFTO0FBQUEsNkJBQVU2YixDQUFWO0FBQUEsYUFBVCxFQUEwQm5SLElBQTFCLENBQStCLEVBQS9CLENBQTdCO0FBQ0EsaUJBQUswUCxNQUFMLENBQVk5WixJQUFaLENBQWlCLElBQUlnbUIsWUFBSixDQUFpQjNkLEdBQWpCLEVBQXNCaEYsT0FBdEIsQ0FBakI7QUFDSDs7O3FDQUNZZ2tCLFEsRUFBVW5MLEMsRUFBRztBQUN0QixnQkFBTTdZLFFBQVErakIsY0FBYUMsUUFBYixFQUF1Qm5MLENBQXZCLENBQWQ7QUFDQSxnQkFBSTdZLEtBQUosRUFDSSxLQUFLQSxLQUFMLENBQVdBLEtBQVg7QUFDSixtQkFBT0EsS0FBUDtBQUNIOzs7Ozs7QUFFTCxTQUFTeXhCLFVBQVQsQ0FBb0IzbEIsVUFBcEIsRUFBZ0M7QUFDNUIsUUFBSUEsc0JBQXNCbWxCLEdBQTFCLEVBQStCO0FBQzNCLGVBQU9RLFdBQVczbEIsV0FBV29sQixlQUF0QixDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUlwbEIsc0JBQXNCc2Ysa0JBQXRCLElBQTRDdGYsV0FBV25FLElBQVgsS0FBb0IsT0FBcEUsRUFBNkU7QUFDaEYsZUFBTyxLQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUltRSxzQkFBc0JzZ0Isa0JBQTFCLEVBQThDO0FBQ2pELGVBQU8sS0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJdGdCLHNCQUFzQjZrQixNQUExQixFQUFrQztBQUNyQyxlQUFPLEtBQVA7QUFDSDtBQUNELFFBQU1nQixtQkFBbUI3bEIsc0JBQXNCMmQsUUFBdEIsSUFBa0MzZCxzQkFBc0IwYyxTQUFqRjtBQUNBLFFBQUlvSixtQkFBbUIsSUFBdkI7QUFDQTlsQixlQUFXa2UsU0FBWCxDQUFxQixpQkFBUztBQUMxQixZQUFJMkgsZ0JBQUosRUFBc0I7QUFDbEJDLCtCQUFtQkEsb0JBQW9CSCxXQUFXeEgsS0FBWCxDQUF2QztBQUNILFNBRkQsTUFFTztBQUNIMkgsK0JBQW1CQSxvQkFBb0IzSCxpQkFBaUJoQyxPQUF4RDtBQUNIO0FBQ0osS0FORDtBQU9BLFFBQUksQ0FBQzJKLGdCQUFMLEVBQXVCO0FBQ25CLGVBQU8sS0FBUDtBQUNIO0FBQ0QsV0FBT2Qsa0JBQWtCaGxCLFVBQWxCLEtBQWlDa2xCLHlCQUF5QmxsQixVQUF6QixFQUFxQyxDQUN6RSxNQUR5RSxFQUV6RSxpQkFGeUUsRUFHekUsZUFIeUUsRUFJekUscUJBSnlFLEVBS3pFLGFBTHlFLEVBTXpFLHFCQU55RSxFQU96RSxPQVB5RSxFQVF6RSxzQkFSeUUsQ0FBckMsQ0FBeEM7QUFVSDs7QUFFRCxTQUFTK2xCLHlCQUFULENBQW1DOTFCLEtBQW5DLEVBQTBDcWMsS0FBMUMsRUFBaUQ7QUFDN0MsUUFBTTBaLFlBQVkvMUIsTUFBTUMsTUFBTixHQUFlLENBQWpDO0FBQ0EsUUFBSSsxQixhQUFhLENBQWpCO0FBQ0EsUUFBSUMsYUFBYUYsU0FBakI7QUFDQSxRQUFJRyxlQUFlLENBQW5CO0FBQ0EsUUFBSTNZLHFCQUFKO0FBQUEsUUFBa0I0WSxrQkFBbEI7QUFDQSxXQUFPSCxjQUFjQyxVQUFyQixFQUFpQztBQUM3QkMsdUJBQWV0YixLQUFLL0YsS0FBTCxDQUFXLENBQUNtaEIsYUFBYUMsVUFBZCxJQUE0QixDQUF2QyxDQUFmO0FBQ0ExWSx1QkFBZXZkLE1BQU1rMkIsWUFBTixDQUFmO0FBQ0FDLG9CQUFZbjJCLE1BQU1rMkIsZUFBZSxDQUFyQixDQUFaO0FBQ0EsWUFBSTNZLGdCQUFnQmxCLEtBQXBCLEVBQTJCO0FBQ3ZCLGdCQUFJNlosaUJBQWlCSCxTQUFqQixJQUE4QjFaLFFBQVE4WixTQUExQyxFQUFxRDtBQUNqRCx1QkFBT0QsWUFBUDtBQUNIO0FBQ0RGLHlCQUFhRSxlQUFlLENBQTVCO0FBQ0gsU0FMRCxNQUtPLElBQUkzWSxlQUFlbEIsS0FBbkIsRUFBMEI7QUFDN0I0Wix5QkFBYUMsZUFBZSxDQUE1QjtBQUNILFNBRk0sTUFFQTtBQUNILGtCQUFNLElBQUkzSixZQUFKLENBQWlCLHdCQUFqQixDQUFOO0FBQ0g7QUFDSjtBQUNELFdBQU8sQ0FBUDtBQUNIOztJQUVLNkosSTtBQUNGLGtCQUFZeHhCLElBQVosRUFBa0J5WCxLQUFsQixFQUF5QnJjLEtBQXpCLEVBQWdDO0FBQUE7O0FBQzVCLGFBQUs0RSxJQUFMLEdBQVlBLElBQVo7QUFDQSxhQUFLeVgsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS25CLE1BQUwsR0FBYyxFQUFkO0FBQ0EsYUFBS21iLE9BQUwsR0FBZSxFQUFmO0FBSjRCO0FBQUE7QUFBQTs7QUFBQTtBQUs1QixtQ0FBa0NyMkIsS0FBbEMsd0lBQXlDO0FBQUE7O0FBQUE7O0FBQUEsb0JBQTdCczJCLEtBQTZCO0FBQUEsb0JBQXRCdm1CLFlBQXNCOztBQUNyQyxxQkFBS21MLE1BQUwsQ0FBWXRhLElBQVosQ0FBaUIwMUIsS0FBakI7QUFDQSxxQkFBS0QsT0FBTCxDQUFhejFCLElBQWIsQ0FBa0JtUCxZQUFsQjtBQUNIO0FBUjJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTL0I7Ozs7aUNBc0NRMmMsRyxFQUFLO0FBQ1YsZ0JBQU14UixTQUFTLEtBQUtBLE1BQXBCO0FBQ0EsZ0JBQU1tYixVQUFVLEtBQUtBLE9BQXJCO0FBQ0EsZ0JBQUluYixPQUFPamIsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUNyQix1QkFBT28yQixRQUFRLENBQVIsRUFBVzFKLFFBQVgsQ0FBb0JELEdBQXBCLENBQVA7QUFDSDtBQUNELGdCQUFNNWdCLFFBQVEsS0FBS3VRLEtBQUwsQ0FBV3NRLFFBQVgsQ0FBb0JELEdBQXBCLENBQWQ7QUFDQSxnQkFBSTVnQixTQUFTb1AsT0FBTyxDQUFQLENBQWIsRUFBd0I7QUFDcEIsdUJBQU9tYixRQUFRLENBQVIsRUFBVzFKLFFBQVgsQ0FBb0JELEdBQXBCLENBQVA7QUFDSDtBQUNELGdCQUFNNkosWUFBWXJiLE9BQU9qYixNQUF6QjtBQUNBLGdCQUFJNkwsU0FBU29QLE9BQU9xYixZQUFZLENBQW5CLENBQWIsRUFBb0M7QUFDaEMsdUJBQU9GLFFBQVFFLFlBQVksQ0FBcEIsRUFBdUI1SixRQUF2QixDQUFnQ0QsR0FBaEMsQ0FBUDtBQUNIO0FBQ0QsZ0JBQU14VSxRQUFRNGQsMEJBQTBCNWEsTUFBMUIsRUFBa0NwUCxLQUFsQyxDQUFkO0FBQ0EsbUJBQU91cUIsUUFBUW5lLEtBQVIsRUFBZXlVLFFBQWYsQ0FBd0JELEdBQXhCLENBQVA7QUFDSDs7O2tDQUNTclQsRSxFQUFJO0FBQ1ZBLGVBQUcsS0FBS2dELEtBQVI7QUFEVTtBQUFBO0FBQUE7O0FBQUE7QUFFVix1Q0FBeUIsS0FBS2dhLE9BQTlCLHdJQUF1QztBQUFBLHdCQUE1QnRtQixZQUE0Qjs7QUFDbkNzSix1QkFBR3RKLFlBQUg7QUFDSDtBQUpTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLYjs7O3dDQUNlO0FBQ1osbUJBQU8sS0FBS3NtQixPQUFMLENBQWF6SixLQUFiLENBQW1CO0FBQUEsdUJBQU9yUSxJQUFJc1EsYUFBSixFQUFQO0FBQUEsYUFBbkIsQ0FBUDtBQUNIOzs7b0NBQ1c7QUFDUixnQkFBTXRCLGFBQWEsQ0FDZixNQURlLEVBRWYsS0FBS2xQLEtBQUwsQ0FBVzhQLFNBQVgsRUFGZSxDQUFuQjtBQUlBLGlCQUFLLElBQUl2c0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUtzYixNQUFMLENBQVlqYixNQUFoQyxFQUF3Q0wsR0FBeEMsRUFBNkM7QUFDekMsb0JBQUlBLElBQUksQ0FBUixFQUFXO0FBQ1AyckIsK0JBQVczcUIsSUFBWCxDQUFnQixLQUFLc2EsTUFBTCxDQUFZdGIsQ0FBWixDQUFoQjtBQUNIO0FBQ0QyckIsMkJBQVczcUIsSUFBWCxDQUFnQixLQUFLeTFCLE9BQUwsQ0FBYXoyQixDQUFiLEVBQWdCdXNCLFNBQWhCLEVBQWhCO0FBQ0g7QUFDRCxtQkFBT1osVUFBUDtBQUNIOzs7OEJBM0VZYSxJLEVBQU1DLE8sRUFBUztBQUN4QixnQkFBSUQsS0FBS25zQixNQUFMLEdBQWMsQ0FBZCxHQUFrQixDQUF0QixFQUF5QjtBQUNyQix1QkFBT29zQixRQUFRcG9CLEtBQVIscURBQWdFbW9CLEtBQUtuc0IsTUFBTCxHQUFjLENBQTlFLFFBQVA7QUFDSDtBQUNELGdCQUFJLENBQUNtc0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBZixJQUFvQixDQUFwQixLQUEwQixDQUE5QixFQUFpQztBQUM3Qix1QkFBT29zQixRQUFRcG9CLEtBQVIseUNBQVA7QUFDSDtBQUNELGdCQUFNb1ksUUFBUWdRLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCakYsVUFBMUIsQ0FBZDtBQUNBLGdCQUFJLENBQUM5SyxLQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osZ0JBQU1yYyxRQUFRLEVBQWQ7QUFDQSxnQkFBSXcyQixhQUFhLElBQWpCO0FBQ0EsZ0JBQUluSyxRQUFRQyxZQUFSLElBQXdCRCxRQUFRQyxZQUFSLENBQXFCcEYsSUFBckIsS0FBOEIsT0FBMUQsRUFBbUU7QUFDL0RzUCw2QkFBYW5LLFFBQVFDLFlBQXJCO0FBQ0g7QUFDRCxpQkFBSyxJQUFJMXNCLElBQUksQ0FBYixFQUFnQkEsSUFBSXdzQixLQUFLbnNCLE1BQXpCLEVBQWlDTCxLQUFLLENBQXRDLEVBQXlDO0FBQ3JDLG9CQUFNMDJCLFFBQVExMkIsTUFBTSxDQUFOLEdBQVUsQ0FBQ2dZLFFBQVgsR0FBc0J3VSxLQUFLeHNCLENBQUwsQ0FBcEM7QUFDQSxvQkFBTWtNLFFBQVFzZ0IsS0FBS3hzQixJQUFJLENBQVQsQ0FBZDtBQUNBLG9CQUFNNjJCLFdBQVc3MkIsQ0FBakI7QUFDQSxvQkFBTTgyQixXQUFXOTJCLElBQUksQ0FBckI7QUFDQSxvQkFBSSxPQUFPMDJCLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0IsMkJBQU9qSyxRQUFRcG9CLEtBQVIsQ0FBYyx5SUFBZCxFQUF5Snd5QixRQUF6SixDQUFQO0FBQ0g7QUFDRCxvQkFBSXoyQixNQUFNQyxNQUFOLElBQWdCRCxNQUFNQSxNQUFNQyxNQUFOLEdBQWUsQ0FBckIsRUFBd0IsQ0FBeEIsS0FBOEJxMkIsS0FBbEQsRUFBeUQ7QUFDckQsMkJBQU9qSyxRQUFRcG9CLEtBQVIsQ0FBYywyR0FBZCxFQUEySHd5QixRQUEzSCxDQUFQO0FBQ0g7QUFDRCxvQkFBTTNKLFNBQVNULFFBQVE1cEIsS0FBUixDQUFjcUosS0FBZCxFQUFxQjRxQixRQUFyQixFQUErQkYsVUFBL0IsQ0FBZjtBQUNBLG9CQUFJLENBQUMxSixNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0owSiw2QkFBYUEsY0FBYzFKLE9BQU9sb0IsSUFBbEM7QUFDQTVFLHNCQUFNWSxJQUFOLENBQVcsQ0FDUDAxQixLQURPLEVBRVB4SixNQUZPLENBQVg7QUFJSDtBQUNELG1CQUFPLElBQUlzSixJQUFKLENBQVNJLFVBQVQsRUFBcUJuYSxLQUFyQixFQUE0QnJjLEtBQTVCLENBQVA7QUFDSDs7Ozs7O0FBMENMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQSxJQUFJMjJCLGFBQWFDLFVBQWpCOztBQUVBLFNBQVNBLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCQyxHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUNDLEdBQW5DLEVBQXdDO0FBQ3BDO0FBQ0EsU0FBS0MsRUFBTCxHQUFVLE1BQU1KLEdBQWhCO0FBQ0EsU0FBS0ssRUFBTCxHQUFVLE9BQU9ILE1BQU1GLEdBQWIsSUFBb0IsS0FBS0ksRUFBbkM7QUFDQSxTQUFLRSxFQUFMLEdBQVUsTUFBTSxLQUFLRixFQUFYLEdBQWdCLEtBQUtDLEVBQS9COztBQUVBLFNBQUtFLEVBQUwsR0FBVSxNQUFNTixHQUFoQjtBQUNBLFNBQUtPLEVBQUwsR0FBVSxPQUFPTCxNQUFNRixHQUFiLElBQW9CLEtBQUtNLEVBQW5DO0FBQ0EsU0FBS0UsRUFBTCxHQUFVLE1BQU0sS0FBS0YsRUFBWCxHQUFnQixLQUFLQyxFQUEvQjs7QUFFQSxTQUFLUixHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLQyxHQUFMLEdBQVdFLEdBQVg7QUFDQSxTQUFLRCxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLQyxHQUFMLEdBQVdBLEdBQVg7QUFDSDs7QUFFREosV0FBV3RZLFNBQVgsQ0FBcUJpWixZQUFyQixHQUFvQyxVQUFTemEsQ0FBVCxFQUFZO0FBQzVDO0FBQ0EsV0FBTyxDQUFDLENBQUMsS0FBS3FhLEVBQUwsR0FBVXJhLENBQVYsR0FBYyxLQUFLb2EsRUFBcEIsSUFBMEJwYSxDQUExQixHQUE4QixLQUFLbWEsRUFBcEMsSUFBMENuYSxDQUFqRDtBQUNILENBSEQ7O0FBS0E4WixXQUFXdFksU0FBWCxDQUFxQmtaLFlBQXJCLEdBQW9DLFVBQVMxYSxDQUFULEVBQVk7QUFDNUMsV0FBTyxDQUFDLENBQUMsS0FBS3dhLEVBQUwsR0FBVXhhLENBQVYsR0FBYyxLQUFLdWEsRUFBcEIsSUFBMEJ2YSxDQUExQixHQUE4QixLQUFLc2EsRUFBcEMsSUFBMEN0YSxDQUFqRDtBQUNILENBRkQ7O0FBSUE4WixXQUFXdFksU0FBWCxDQUFxQm1aLHNCQUFyQixHQUE4QyxVQUFTM2EsQ0FBVCxFQUFZO0FBQ3RELFdBQU8sQ0FBQyxNQUFNLEtBQUtxYSxFQUFYLEdBQWdCcmEsQ0FBaEIsR0FBb0IsTUFBTSxLQUFLb2EsRUFBaEMsSUFBc0NwYSxDQUF0QyxHQUEwQyxLQUFLbWEsRUFBdEQ7QUFDSCxDQUZEOztBQUlBTCxXQUFXdFksU0FBWCxDQUFxQm9aLFdBQXJCLEdBQW1DLFVBQVM1WSxDQUFULEVBQVk2WSxPQUFaLEVBQXFCO0FBQ3BELFFBQUksT0FBT0EsT0FBUCxLQUFtQixXQUF2QixFQUFvQ0EsVUFBVSxJQUFWOztBQUVwQyxRQUFJQyxFQUFKLEVBQVFDLEVBQVIsRUFBWUMsRUFBWixFQUFnQnBHLEVBQWhCLEVBQW9COXhCLENBQXBCOztBQUVBO0FBQ0EsU0FBS2s0QixLQUFLaFosQ0FBTCxFQUFRbGYsSUFBSSxDQUFqQixFQUFvQkEsSUFBSSxDQUF4QixFQUEyQkEsR0FBM0IsRUFBZ0M7O0FBRTVCOHhCLGFBQUssS0FBSzZGLFlBQUwsQ0FBa0JPLEVBQWxCLElBQXdCaFosQ0FBN0I7QUFDQSxZQUFJbEUsS0FBS2pHLEdBQUwsQ0FBUytjLEVBQVQsSUFBZWlHLE9BQW5CLEVBQTRCLE9BQU9HLEVBQVA7O0FBRTVCLFlBQUlDLEtBQUssS0FBS04sc0JBQUwsQ0FBNEJLLEVBQTVCLENBQVQ7QUFDQSxZQUFJbGQsS0FBS2pHLEdBQUwsQ0FBU29qQixFQUFULElBQWUsSUFBbkIsRUFBeUI7O0FBRXpCRCxhQUFLQSxLQUFLcEcsS0FBS3FHLEVBQWY7QUFDSDs7QUFFRDtBQUNBSCxTQUFLLEdBQUw7QUFDQUMsU0FBSyxHQUFMO0FBQ0FDLFNBQUtoWixDQUFMOztBQUVBLFFBQUlnWixLQUFLRixFQUFULEVBQWEsT0FBT0EsRUFBUDtBQUNiLFFBQUlFLEtBQUtELEVBQVQsRUFBYSxPQUFPQSxFQUFQOztBQUViLFdBQU9ELEtBQUtDLEVBQVosRUFBZ0I7O0FBRVpuRyxhQUFLLEtBQUs2RixZQUFMLENBQWtCTyxFQUFsQixDQUFMO0FBQ0EsWUFBSWxkLEtBQUtqRyxHQUFMLENBQVMrYyxLQUFLNVMsQ0FBZCxJQUFtQjZZLE9BQXZCLEVBQWdDLE9BQU9HLEVBQVA7O0FBRWhDLFlBQUloWixJQUFJNFMsRUFBUixFQUFZO0FBQ1JrRyxpQkFBS0UsRUFBTDtBQUNILFNBRkQsTUFFTztBQUNIRCxpQkFBS0MsRUFBTDtBQUNIOztBQUVEQSxhQUFLLENBQUNELEtBQUtELEVBQU4sSUFBWSxHQUFaLEdBQWtCQSxFQUF2QjtBQUNIOztBQUVEO0FBQ0EsV0FBT0UsRUFBUDtBQUNILENBekNEOztBQTJDQWxCLFdBQVd0WSxTQUFYLENBQXFCMFosS0FBckIsR0FBNkIsVUFBU2xaLENBQVQsRUFBWTZZLE9BQVosRUFBcUI7QUFDOUMsV0FBTyxLQUFLSCxZQUFMLENBQWtCLEtBQUtFLFdBQUwsQ0FBaUI1WSxDQUFqQixFQUFvQjZZLE9BQXBCLENBQWxCLENBQVA7QUFDSCxDQUZEOztBQUlBLFNBQVNwa0IsTUFBVCxDQUFnQjFJLENBQWhCLEVBQW1CZ2YsQ0FBbkIsRUFBc0IvTSxDQUF0QixFQUF5QjtBQUNyQixXQUFPalMsS0FBSyxJQUFJaVMsQ0FBVCxJQUFjK00sSUFBSS9NLENBQXpCO0FBQ0g7QUFDRCxTQUFTelEsS0FBVCxDQUFld1osSUFBZixFQUFxQkMsRUFBckIsRUFBeUJoSixDQUF6QixFQUE0QjtBQUN4QixXQUFPLElBQUl6WCxLQUFKLENBQVVrTyxPQUFPc1MsS0FBS25pQixDQUFaLEVBQWVvaUIsR0FBR3BpQixDQUFsQixFQUFxQm9aLENBQXJCLENBQVYsRUFBbUN2SixPQUFPc1MsS0FBSytELENBQVosRUFBZTlELEdBQUc4RCxDQUFsQixFQUFxQjlNLENBQXJCLENBQW5DLEVBQTREdkosT0FBT3NTLEtBQUtnRSxDQUFaLEVBQWUvRCxHQUFHK0QsQ0FBbEIsRUFBcUIvTSxDQUFyQixDQUE1RCxFQUFxRnZKLE9BQU9zUyxLQUFLaGIsQ0FBWixFQUFlaWIsR0FBR2piLENBQWxCLEVBQXFCaVMsQ0FBckIsQ0FBckYsQ0FBUDtBQUNIO0FBQ0QsU0FBU21iLE9BQVQsQ0FBaUJwUyxJQUFqQixFQUF1QkMsRUFBdkIsRUFBMkJoSixDQUEzQixFQUE4QjtBQUMxQixXQUFPK0ksS0FBS3ZsQixHQUFMLENBQVMsVUFBQ3l5QixDQUFELEVBQUluekIsQ0FBSixFQUFVO0FBQ3RCLGVBQU8yVCxPQUFPd2YsQ0FBUCxFQUFVak4sR0FBR2xtQixDQUFILENBQVYsRUFBaUJrZCxDQUFqQixDQUFQO0FBQ0gsS0FGTSxDQUFQO0FBR0g7O0FBRUQsSUFBSTNKLGNBQWMsYUFBYXdGLE9BQU91ZixNQUFQLENBQWM7QUFDM0NDLGVBQVcsSUFEZ0M7QUFFM0M1a0IsWUFBUUEsTUFGbUM7QUFHM0NsSCxXQUFPQSxLQUhvQztBQUkzQzBHLFdBQU9rbEI7QUFKb0MsQ0FBZCxDQUEvQjs7QUFPQSxJQUFNRyxLQUFLLE9BQVg7QUFBQSxJQUFvQkMsS0FBSyxDQUF6QjtBQUFBLElBQTRCQyxLQUFLLE9BQWpDO0FBQUEsSUFBMENWLEtBQUssSUFBSSxFQUFuRDtBQUFBLElBQXVEQyxLQUFLLElBQUksRUFBaEU7QUFBQSxJQUFvRUMsS0FBSyxJQUFJRCxFQUFKLEdBQVNBLEVBQWxGO0FBQUEsSUFBc0ZVLEtBQUtWLEtBQUtBLEVBQUwsR0FBVUEsRUFBckc7QUFBQSxJQUF5R1csVUFBVTVkLEtBQUtnVyxFQUFMLEdBQVUsR0FBN0g7QUFBQSxJQUFrSTZILFVBQVUsTUFBTTdkLEtBQUtnVyxFQUF2SjtBQUNBLFNBQVM4SCxPQUFULENBQWlCNWIsQ0FBakIsRUFBb0I7QUFDaEIsV0FBT0EsSUFBSXliLEVBQUosR0FBUzNkLEtBQUt1VyxHQUFMLENBQVNyVSxDQUFULEVBQVksSUFBSSxDQUFoQixDQUFULEdBQThCQSxJQUFJZ2IsRUFBSixHQUFTRixFQUE5QztBQUNIO0FBQ0QsU0FBU2UsT0FBVCxDQUFpQjdiLENBQWpCLEVBQW9CO0FBQ2hCLFdBQU9BLElBQUkrYSxFQUFKLEdBQVMvYSxJQUFJQSxDQUFKLEdBQVFBLENBQWpCLEdBQXFCZ2IsTUFBTWhiLElBQUk4YSxFQUFWLENBQTVCO0FBQ0g7QUFDRCxTQUFTZ0IsT0FBVCxDQUFpQjlaLENBQWpCLEVBQW9CO0FBQ2hCLFdBQU8sT0FBT0EsS0FBSyxTQUFMLEdBQWlCLFFBQVFBLENBQXpCLEdBQTZCLFFBQVFsRSxLQUFLdVcsR0FBTCxDQUFTclMsQ0FBVCxFQUFZLElBQUksR0FBaEIsQ0FBUixHQUErQixLQUFuRSxDQUFQO0FBQ0g7QUFDRCxTQUFTK1osT0FBVCxDQUFpQi9aLENBQWpCLEVBQW9CO0FBQ2hCQSxTQUFLLEdBQUw7QUFDQSxXQUFPQSxLQUFLLE9BQUwsR0FBZUEsSUFBSSxLQUFuQixHQUEyQmxFLEtBQUt1VyxHQUFMLENBQVMsQ0FBQ3JTLElBQUksS0FBTCxJQUFjLEtBQXZCLEVBQThCLEdBQTlCLENBQWxDO0FBQ0g7QUFDRCxTQUFTZ2EsUUFBVCxDQUFrQkMsUUFBbEIsRUFBNEI7QUFDeEIsUUFBTWxQLElBQUlnUCxRQUFRRSxTQUFTcjFCLENBQWpCLENBQVY7QUFBQSxRQUErQm1ILElBQUlndUIsUUFBUUUsU0FBU25QLENBQWpCLENBQW5DO0FBQUEsUUFBd0Roa0IsSUFBSWl6QixRQUFRRSxTQUFTbFAsQ0FBakIsQ0FBNUQ7QUFBQSxRQUFpRi9LLElBQUk0WixRQUFRLENBQUMsWUFBWTdPLENBQVosR0FBZ0IsWUFBWWhmLENBQTVCLEdBQWdDLFlBQVlqRixDQUE3QyxJQUFrRHd5QixFQUExRCxDQUFyRjtBQUFBLFFBQW9KdEosSUFBSTRKLFFBQVEsQ0FBQyxZQUFZN08sQ0FBWixHQUFnQixZQUFZaGYsQ0FBNUIsR0FBZ0MsV0FBV2pGLENBQTVDLElBQWlEeXlCLEVBQXpELENBQXhKO0FBQUEsUUFBc05qSCxJQUFJc0gsUUFBUSxDQUFDLFlBQVk3TyxDQUFaLEdBQWdCLFdBQVdoZixDQUEzQixHQUErQixZQUFZakYsQ0FBNUMsSUFBaUQweUIsRUFBekQsQ0FBMU47QUFDQSxXQUFPO0FBQ0gxeUIsV0FBRyxNQUFNa3BCLENBQU4sR0FBVSxFQURWO0FBRUhqa0IsV0FBRyxPQUFPaVUsSUFBSWdRLENBQVgsQ0FGQTtBQUdIakYsV0FBRyxPQUFPaUYsSUFBSXNDLENBQVgsQ0FIQTtBQUlIekgsZUFBT29QLFNBQVNsdUI7QUFKYixLQUFQO0FBTUg7QUFDRCxTQUFTbXVCLFFBQVQsQ0FBa0JDLFFBQWxCLEVBQTRCO0FBQ3hCLFFBQUluSyxJQUFJLENBQUNtSyxTQUFTcnpCLENBQVQsR0FBYSxFQUFkLElBQW9CLEdBQTVCO0FBQUEsUUFBaUNrWixJQUFJa1AsTUFBTWlMLFNBQVNwdUIsQ0FBZixJQUFvQmlrQixDQUFwQixHQUF3QkEsSUFBSW1LLFNBQVNwdUIsQ0FBVCxHQUFhLEdBQTlFO0FBQUEsUUFBbUZ1bUIsSUFBSXBELE1BQU1pTCxTQUFTcFAsQ0FBZixJQUFvQmlGLENBQXBCLEdBQXdCQSxJQUFJbUssU0FBU3BQLENBQVQsR0FBYSxHQUFoSTtBQUNBaUYsUUFBSXVKLEtBQUtNLFFBQVE3SixDQUFSLENBQVQ7QUFDQWhRLFFBQUlzWixLQUFLTyxRQUFRN1osQ0FBUixDQUFUO0FBQ0FzUyxRQUFJa0gsS0FBS0ssUUFBUXZILENBQVIsQ0FBVDtBQUNBLFdBQU8sSUFBSS9yQixLQUFKLENBQVV1ekIsUUFBUSxZQUFZOVosQ0FBWixHQUFnQixZQUFZZ1EsQ0FBNUIsR0FBZ0MsWUFBWXNDLENBQXBELENBQVYsRUFBa0V3SCxRQUFRLENBQUMsUUFBRCxHQUFZOVosQ0FBWixHQUFnQixZQUFZZ1EsQ0FBNUIsR0FBZ0MsV0FBV3NDLENBQW5ELENBQWxFLEVBQXlId0gsUUFBUSxZQUFZOVosQ0FBWixHQUFnQixZQUFZZ1EsQ0FBNUIsR0FBZ0MsWUFBWXNDLENBQXBELENBQXpILEVBQWlMNkgsU0FBU3RQLEtBQTFMLENBQVA7QUFDSDtBQUNELFNBQVN1UCxjQUFULENBQXdCclQsSUFBeEIsRUFBOEJDLEVBQTlCLEVBQWtDaEosQ0FBbEMsRUFBcUM7QUFDakMsV0FBTztBQUNIbFgsV0FBRzJOLE9BQU9zUyxLQUFLamdCLENBQVosRUFBZWtnQixHQUFHbGdCLENBQWxCLEVBQXFCa1gsQ0FBckIsQ0FEQTtBQUVIalMsV0FBRzBJLE9BQU9zUyxLQUFLaGIsQ0FBWixFQUFlaWIsR0FBR2piLENBQWxCLEVBQXFCaVMsQ0FBckIsQ0FGQTtBQUdIK00sV0FBR3RXLE9BQU9zUyxLQUFLZ0UsQ0FBWixFQUFlL0QsR0FBRytELENBQWxCLEVBQXFCL00sQ0FBckIsQ0FIQTtBQUlINk0sZUFBT3BXLE9BQU9zUyxLQUFLOEQsS0FBWixFQUFtQjdELEdBQUc2RCxLQUF0QixFQUE2QjdNLENBQTdCO0FBSkosS0FBUDtBQU1IO0FBQ0QsU0FBU3FjLFFBQVQsQ0FBa0JKLFFBQWxCLEVBQTRCO0FBQUEsb0JBQ05ELFNBQVNDLFFBQVQsQ0FETTtBQUFBLFFBQ2pCbnpCLENBRGlCLGFBQ2pCQSxDQURpQjtBQUFBLFFBQ2RpRixDQURjLGFBQ2RBLENBRGM7QUFBQSxRQUNYZ2YsQ0FEVyxhQUNYQSxDQURXOztBQUV4QixRQUFNM0csSUFBSXRJLEtBQUt3ZSxLQUFMLENBQVd2UCxDQUFYLEVBQWNoZixDQUFkLElBQW1CNHRCLE9BQTdCO0FBQ0EsV0FBTztBQUNIdlYsV0FBR0EsSUFBSSxDQUFKLEdBQVFBLElBQUksR0FBWixHQUFrQkEsQ0FEbEI7QUFFSDBLLFdBQUdoVCxLQUFLN0csSUFBTCxDQUFVbEosSUFBSUEsQ0FBSixHQUFRZ2YsSUFBSUEsQ0FBdEIsQ0FGQTtBQUdIamtCLFlBSEc7QUFJSCtqQixlQUFPb1AsU0FBU2x1QjtBQUpiLEtBQVA7QUFNSDtBQUNELFNBQVN3dUIsUUFBVCxDQUFrQkMsUUFBbEIsRUFBNEI7QUFDeEIsUUFBTXBXLElBQUlvVyxTQUFTcFcsQ0FBVCxHQUFhc1YsT0FBdkI7QUFBQSxRQUFnQzVLLElBQUkwTCxTQUFTMUwsQ0FBN0M7QUFBQSxRQUFnRGhvQixJQUFJMHpCLFNBQVMxekIsQ0FBN0Q7QUFDQSxXQUFPb3pCLFNBQVM7QUFDWnB6QixZQURZO0FBRVppRixXQUFHK1AsS0FBS3hHLEdBQUwsQ0FBUzhPLENBQVQsSUFBYzBLLENBRkw7QUFHWi9ELFdBQUdqUCxLQUFLekcsR0FBTCxDQUFTK08sQ0FBVCxJQUFjMEssQ0FITDtBQUlaakUsZUFBTzJQLFNBQVMzUDtBQUpKLEtBQVQsQ0FBUDtBQU1IO0FBQ0QsU0FBUzRQLGNBQVQsQ0FBd0IxdUIsQ0FBeEIsRUFBMkJnZixDQUEzQixFQUE4Qi9NLENBQTlCLEVBQWlDO0FBQzdCLFFBQU1pVyxJQUFJbEosSUFBSWhmLENBQWQ7QUFDQSxXQUFPQSxJQUFJaVMsS0FBS2lXLElBQUksR0FBSixJQUFXQSxJQUFJLENBQUMsR0FBaEIsR0FBc0JBLElBQUksTUFBTW5ZLEtBQUt0SyxLQUFMLENBQVd5aUIsSUFBSSxHQUFmLENBQWhDLEdBQXNEQSxDQUEzRCxDQUFYO0FBQ0g7QUFDRCxTQUFTeUcsY0FBVCxDQUF3QjNULElBQXhCLEVBQThCQyxFQUE5QixFQUFrQ2hKLENBQWxDLEVBQXFDO0FBQ2pDLFdBQU87QUFDSG9HLFdBQUdxVyxlQUFlMVQsS0FBSzNDLENBQXBCLEVBQXVCNEMsR0FBRzVDLENBQTFCLEVBQTZCcEcsQ0FBN0IsQ0FEQTtBQUVIOFEsV0FBR3JhLE9BQU9zUyxLQUFLK0gsQ0FBWixFQUFlOUgsR0FBRzhILENBQWxCLEVBQXFCOVEsQ0FBckIsQ0FGQTtBQUdIbFgsV0FBRzJOLE9BQU9zUyxLQUFLamdCLENBQVosRUFBZWtnQixHQUFHbGdCLENBQWxCLEVBQXFCa1gsQ0FBckIsQ0FIQTtBQUlINk0sZUFBT3BXLE9BQU9zUyxLQUFLOEQsS0FBWixFQUFtQjdELEdBQUc2RCxLQUF0QixFQUE2QjdNLENBQTdCO0FBSkosS0FBUDtBQU1IO0FBQ0QsSUFBTTdGLE1BQU07QUFDUndpQixhQUFTWCxRQUREO0FBRVI3UyxhQUFTK1MsUUFGRDtBQUdSN2xCLGlCQUFhK2xCO0FBSEwsQ0FBWjtBQUtBLElBQU1oaUIsTUFBTTtBQUNSdWlCLGFBQVNOLFFBREQ7QUFFUmxULGFBQVNvVCxRQUZEO0FBR1JsbUIsaUJBQWFxbUI7QUFITCxDQUFaOztBQU1BLElBQUlFLGNBQWMsYUFBYS9nQixPQUFPdWYsTUFBUCxDQUFjO0FBQzNDQyxlQUFXLElBRGdDO0FBRTNDbGhCLFNBQUtBLEdBRnNDO0FBRzNDQyxTQUFLQTtBQUhzQyxDQUFkLENBQS9COztJQU1NeWlCLFc7QUFDRix5QkFBWS8wQixJQUFaLEVBQWtCZzFCLFFBQWxCLEVBQTRCQyxhQUE1QixFQUEyQ3hkLEtBQTNDLEVBQWtEcmMsS0FBbEQsRUFBeUQ7QUFBQTs7QUFDckQsYUFBSzRFLElBQUwsR0FBWUEsSUFBWjtBQUNBLGFBQUtnMUIsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxhQUFLQyxhQUFMLEdBQXFCQSxhQUFyQjtBQUNBLGFBQUt4ZCxLQUFMLEdBQWFBLEtBQWI7QUFDQSxhQUFLbkIsTUFBTCxHQUFjLEVBQWQ7QUFDQSxhQUFLbWIsT0FBTCxHQUFlLEVBQWY7QUFOcUQ7QUFBQTtBQUFBOztBQUFBO0FBT3JELG1DQUFrQ3IyQixLQUFsQyx3SUFBeUM7QUFBQTs7QUFBQTs7QUFBQSxvQkFBN0JzMkIsS0FBNkI7QUFBQSxvQkFBdEJ2bUIsWUFBc0I7O0FBQ3JDLHFCQUFLbUwsTUFBTCxDQUFZdGEsSUFBWixDQUFpQjAxQixLQUFqQjtBQUNBLHFCQUFLRCxPQUFMLENBQWF6MUIsSUFBYixDQUFrQm1QLFlBQWxCO0FBQ0g7QUFWb0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVd4RDs7OztpQ0FrRlEyYyxHLEVBQUs7QUFDVixnQkFBTXhSLFNBQVMsS0FBS0EsTUFBcEI7QUFDQSxnQkFBTW1iLFVBQVUsS0FBS0EsT0FBckI7QUFDQSxnQkFBSW5iLE9BQU9qYixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLHVCQUFPbzJCLFFBQVEsQ0FBUixFQUFXMUosUUFBWCxDQUFvQkQsR0FBcEIsQ0FBUDtBQUNIO0FBQ0QsZ0JBQU01Z0IsUUFBUSxLQUFLdVEsS0FBTCxDQUFXc1EsUUFBWCxDQUFvQkQsR0FBcEIsQ0FBZDtBQUNBLGdCQUFJNWdCLFNBQVNvUCxPQUFPLENBQVAsQ0FBYixFQUF3QjtBQUNwQix1QkFBT21iLFFBQVEsQ0FBUixFQUFXMUosUUFBWCxDQUFvQkQsR0FBcEIsQ0FBUDtBQUNIO0FBQ0QsZ0JBQU02SixZQUFZcmIsT0FBT2piLE1BQXpCO0FBQ0EsZ0JBQUk2TCxTQUFTb1AsT0FBT3FiLFlBQVksQ0FBbkIsQ0FBYixFQUFvQztBQUNoQyx1QkFBT0YsUUFBUUUsWUFBWSxDQUFwQixFQUF1QjVKLFFBQXZCLENBQWdDRCxHQUFoQyxDQUFQO0FBQ0g7QUFDRCxnQkFBTXhVLFFBQVE0ZCwwQkFBMEI1YSxNQUExQixFQUFrQ3BQLEtBQWxDLENBQWQ7QUFDQSxnQkFBTWd1QixRQUFRNWUsT0FBT2hELEtBQVAsQ0FBZDtBQUNBLGdCQUFNNmhCLFFBQVE3ZSxPQUFPaEQsUUFBUSxDQUFmLENBQWQ7QUFDQSxnQkFBTTRFLElBQUk2YyxZQUFZSyxtQkFBWixDQUFnQyxLQUFLSCxhQUFyQyxFQUFvRC90QixLQUFwRCxFQUEyRGd1QixLQUEzRCxFQUFrRUMsS0FBbEUsQ0FBVjtBQUNBLGdCQUFNRSxjQUFjNUQsUUFBUW5lLEtBQVIsRUFBZXlVLFFBQWYsQ0FBd0JELEdBQXhCLENBQXBCO0FBQ0EsZ0JBQU13TixjQUFjN0QsUUFBUW5lLFFBQVEsQ0FBaEIsRUFBbUJ5VSxRQUFuQixDQUE0QkQsR0FBNUIsQ0FBcEI7QUFDQSxnQkFBSSxLQUFLa04sUUFBTCxLQUFrQixhQUF0QixFQUFxQztBQUNqQyx1QkFBT3ptQixZQUFZLEtBQUt2TyxJQUFMLENBQVVzaUIsSUFBVixDQUFldEosV0FBZixFQUFaLEVBQTBDcWMsV0FBMUMsRUFBdURDLFdBQXZELEVBQW9FcGQsQ0FBcEUsQ0FBUDtBQUNILGFBRkQsTUFFTyxJQUFJLEtBQUs4YyxRQUFMLEtBQWtCLGlCQUF0QixFQUF5QztBQUM1Qyx1QkFBTzFpQixJQUFJK08sT0FBSixDQUFZL08sSUFBSS9ELFdBQUosQ0FBZ0IrRCxJQUFJdWlCLE9BQUosQ0FBWVEsV0FBWixDQUFoQixFQUEwQy9pQixJQUFJdWlCLE9BQUosQ0FBWVMsV0FBWixDQUExQyxFQUFvRXBkLENBQXBFLENBQVosQ0FBUDtBQUNILGFBRk0sTUFFQTtBQUNILHVCQUFPN0YsSUFBSWdQLE9BQUosQ0FBWWhQLElBQUk5RCxXQUFKLENBQWdCOEQsSUFBSXdpQixPQUFKLENBQVlRLFdBQVosQ0FBaEIsRUFBMENoakIsSUFBSXdpQixPQUFKLENBQVlTLFdBQVosQ0FBMUMsRUFBb0VwZCxDQUFwRSxDQUFaLENBQVA7QUFDSDtBQUNKOzs7a0NBQ1N6RCxFLEVBQUk7QUFDVkEsZUFBRyxLQUFLZ0QsS0FBUjtBQURVO0FBQUE7QUFBQTs7QUFBQTtBQUVWLHVDQUF5QixLQUFLZ2EsT0FBOUIsd0lBQXVDO0FBQUEsd0JBQTVCdG1CLFlBQTRCOztBQUNuQ3NKLHVCQUFHdEosWUFBSDtBQUNIO0FBSlM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtiOzs7d0NBQ2U7QUFDWixtQkFBTyxLQUFLc21CLE9BQUwsQ0FBYXpKLEtBQWIsQ0FBbUI7QUFBQSx1QkFBT3JRLElBQUlzUSxhQUFKLEVBQVA7QUFBQSxhQUFuQixDQUFQO0FBQ0g7OztvQ0FDVztBQUNSLGdCQUFJZ04sc0JBQUo7QUFDQSxnQkFBSSxLQUFLQSxhQUFMLENBQW1CanVCLElBQW5CLEtBQTRCLFFBQWhDLEVBQTBDO0FBQ3RDaXVCLGdDQUFnQixDQUFDLFFBQUQsQ0FBaEI7QUFDSCxhQUZELE1BRU8sSUFBSSxLQUFLQSxhQUFMLENBQW1CanVCLElBQW5CLEtBQTRCLGFBQWhDLEVBQStDO0FBQ2xELG9CQUFJLEtBQUtpdUIsYUFBTCxDQUFtQm5qQixJQUFuQixLQUE0QixDQUFoQyxFQUFtQztBQUMvQm1qQixvQ0FBZ0IsQ0FBQyxRQUFELENBQWhCO0FBQ0gsaUJBRkQsTUFFTztBQUNIQSxvQ0FBZ0IsQ0FDWixhQURZLEVBRVosS0FBS0EsYUFBTCxDQUFtQm5qQixJQUZQLENBQWhCO0FBSUg7QUFDSixhQVRNLE1BU0E7QUFDSG1qQixnQ0FBZ0IsQ0FBQyxjQUFELEVBQWlCNWtCLE1BQWpCLENBQXdCLEtBQUs0a0IsYUFBTCxDQUFtQk0sYUFBM0MsQ0FBaEI7QUFDSDtBQUNELGdCQUFNNU8sYUFBYSxDQUNmLEtBQUtxTyxRQURVLEVBRWZDLGFBRmUsRUFHZixLQUFLeGQsS0FBTCxDQUFXOFAsU0FBWCxFQUhlLENBQW5CO0FBS0EsaUJBQUssSUFBSXZzQixJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS3NiLE1BQUwsQ0FBWWpiLE1BQWhDLEVBQXdDTCxHQUF4QyxFQUE2QztBQUN6QzJyQiwyQkFBVzNxQixJQUFYLENBQWdCLEtBQUtzYSxNQUFMLENBQVl0YixDQUFaLENBQWhCLEVBQWdDLEtBQUt5MkIsT0FBTCxDQUFhejJCLENBQWIsRUFBZ0J1c0IsU0FBaEIsRUFBaEM7QUFDSDtBQUNELG1CQUFPWixVQUFQO0FBQ0g7Ozs0Q0EvSTBCc08sYSxFQUFleGQsSyxFQUFPeWQsSyxFQUFPQyxLLEVBQU87QUFDM0QsZ0JBQUlqZCxJQUFJLENBQVI7QUFDQSxnQkFBSStjLGNBQWNqdUIsSUFBZCxLQUF1QixhQUEzQixFQUEwQztBQUN0Q2tSLG9CQUFJc2QseUJBQXlCL2QsS0FBekIsRUFBZ0N3ZCxjQUFjbmpCLElBQTlDLEVBQW9Eb2pCLEtBQXBELEVBQTJEQyxLQUEzRCxDQUFKO0FBQ0gsYUFGRCxNQUVPLElBQUlGLGNBQWNqdUIsSUFBZCxLQUF1QixRQUEzQixFQUFxQztBQUN4Q2tSLG9CQUFJc2QseUJBQXlCL2QsS0FBekIsRUFBZ0MsQ0FBaEMsRUFBbUN5ZCxLQUFuQyxFQUEwQ0MsS0FBMUMsQ0FBSjtBQUNILGFBRk0sTUFFQSxJQUFJRixjQUFjanVCLElBQWQsS0FBdUIsY0FBM0IsRUFBMkM7QUFDOUMsb0JBQU1naUIsSUFBSWlNLGNBQWNNLGFBQXhCO0FBQ0Esb0JBQU1FLEtBQUssSUFBSTFELFVBQUosQ0FBZS9JLEVBQUUsQ0FBRixDQUFmLEVBQXFCQSxFQUFFLENBQUYsQ0FBckIsRUFBMkJBLEVBQUUsQ0FBRixDQUEzQixFQUFpQ0EsRUFBRSxDQUFGLENBQWpDLENBQVg7QUFDQTlRLG9CQUFJdWQsR0FBR3JDLEtBQUgsQ0FBU29DLHlCQUF5Qi9kLEtBQXpCLEVBQWdDLENBQWhDLEVBQW1DeWQsS0FBbkMsRUFBMENDLEtBQTFDLENBQVQsQ0FBSjtBQUNIO0FBQ0QsbUJBQU9qZCxDQUFQO0FBQ0g7Ozs4QkFDWXNQLEksRUFBTUMsTyxFQUFTO0FBQUEsa0NBQ3dCRCxJQUR4QjtBQUFBLGdCQUNuQndOLFFBRG1CO0FBQUEsZ0JBQ1RDLGFBRFM7QUFBQSxnQkFDTXhkLEtBRE47QUFBQSxnQkFDZ0IwRixJQURoQjs7QUFFeEIsZ0JBQUksQ0FBQ2ppQixNQUFNQyxPQUFOLENBQWM4NUIsYUFBZCxDQUFELElBQWlDQSxjQUFjNTVCLE1BQWQsS0FBeUIsQ0FBOUQsRUFBaUU7QUFDN0QsdUJBQU9vc0IsUUFBUXBvQixLQUFSLCtDQUE0RCxDQUE1RCxDQUFQO0FBQ0g7QUFDRCxnQkFBSTQxQixjQUFjLENBQWQsTUFBcUIsUUFBekIsRUFBbUM7QUFDL0JBLGdDQUFnQixFQUFFanVCLE1BQU0sUUFBUixFQUFoQjtBQUNILGFBRkQsTUFFTyxJQUFJaXVCLGNBQWMsQ0FBZCxNQUFxQixhQUF6QixFQUF3QztBQUMzQyxvQkFBTW5qQixPQUFPbWpCLGNBQWMsQ0FBZCxDQUFiO0FBQ0Esb0JBQUksT0FBT25qQixJQUFQLEtBQWdCLFFBQXBCLEVBQ0ksT0FBTzJWLFFBQVFwb0IsS0FBUix1REFBb0UsQ0FBcEUsRUFBdUUsQ0FBdkUsQ0FBUDtBQUNKNDFCLGdDQUFnQjtBQUNaanVCLDBCQUFNLGFBRE07QUFFWjhLO0FBRlksaUJBQWhCO0FBSUgsYUFSTSxNQVFBLElBQUltakIsY0FBYyxDQUFkLE1BQXFCLGNBQXpCLEVBQXlDO0FBQzVDLG9CQUFNTSxnQkFBZ0JOLGNBQWM5dUIsS0FBZCxDQUFvQixDQUFwQixDQUF0QjtBQUNBLG9CQUFJb3ZCLGNBQWNsNkIsTUFBZCxLQUF5QixDQUF6QixJQUE4Qms2QixjQUFjeDBCLElBQWQsQ0FBbUI7QUFBQSwyQkFBSyxPQUFPbVgsQ0FBUCxLQUFhLFFBQWIsSUFBeUJBLElBQUksQ0FBN0IsSUFBa0NBLElBQUksQ0FBM0M7QUFBQSxpQkFBbkIsQ0FBbEMsRUFBb0c7QUFDaEcsMkJBQU91UCxRQUFRcG9CLEtBQVIsQ0FBYyx5RkFBZCxFQUF5RyxDQUF6RyxDQUFQO0FBQ0g7QUFDRDQxQixnQ0FBZ0I7QUFDWmp1QiwwQkFBTSxjQURNO0FBRVp1dUIsbUNBQWVBO0FBRkgsaUJBQWhCO0FBSUgsYUFUTSxNQVNBO0FBQ0gsdUJBQU85TixRQUFRcG9CLEtBQVIsaUNBQTZDNlcsT0FBTytlLGNBQWMsQ0FBZCxDQUFQLENBQTdDLEVBQTBFLENBQTFFLEVBQTZFLENBQTdFLENBQVA7QUFDSDtBQUNELGdCQUFJek4sS0FBS25zQixNQUFMLEdBQWMsQ0FBZCxHQUFrQixDQUF0QixFQUF5QjtBQUNyQix1QkFBT29zQixRQUFRcG9CLEtBQVIscURBQWdFbW9CLEtBQUtuc0IsTUFBTCxHQUFjLENBQTlFLFFBQVA7QUFDSDtBQUNELGdCQUFJLENBQUNtc0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBZixJQUFvQixDQUFwQixLQUEwQixDQUE5QixFQUFpQztBQUM3Qix1QkFBT29zQixRQUFRcG9CLEtBQVIseUNBQVA7QUFDSDtBQUNEb1ksb0JBQVFnUSxRQUFRNXBCLEtBQVIsQ0FBYzRaLEtBQWQsRUFBcUIsQ0FBckIsRUFBd0I4SyxVQUF4QixDQUFSO0FBQ0EsZ0JBQUksQ0FBQzlLLEtBQUwsRUFDSSxPQUFPLElBQVA7QUFDSixnQkFBTXJjLFFBQVEsRUFBZDtBQUNBLGdCQUFJdzJCLGFBQWEsSUFBakI7QUFDQSxnQkFBSW9ELGFBQWEsaUJBQWIsSUFBa0NBLGFBQWEsaUJBQW5ELEVBQXNFO0FBQ2xFcEQsNkJBQWFsUCxTQUFiO0FBQ0gsYUFGRCxNQUVPLElBQUkrRSxRQUFRQyxZQUFSLElBQXdCRCxRQUFRQyxZQUFSLENBQXFCcEYsSUFBckIsS0FBOEIsT0FBMUQsRUFBbUU7QUFDdEVzUCw2QkFBYW5LLFFBQVFDLFlBQXJCO0FBQ0g7QUFDRCxpQkFBSyxJQUFJMXNCLElBQUksQ0FBYixFQUFnQkEsSUFBSW1pQixLQUFLOWhCLE1BQXpCLEVBQWlDTCxLQUFLLENBQXRDLEVBQXlDO0FBQ3JDLG9CQUFNMDJCLFFBQVF2VSxLQUFLbmlCLENBQUwsQ0FBZDtBQUNBLG9CQUFNa00sUUFBUWlXLEtBQUtuaUIsSUFBSSxDQUFULENBQWQ7QUFDQSxvQkFBTTYyQixXQUFXNzJCLElBQUksQ0FBckI7QUFDQSxvQkFBTTgyQixXQUFXOTJCLElBQUksQ0FBckI7QUFDQSxvQkFBSSxPQUFPMDJCLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0IsMkJBQU9qSyxRQUFRcG9CLEtBQVIsQ0FBYyxnSkFBZCxFQUFnS3d5QixRQUFoSyxDQUFQO0FBQ0g7QUFDRCxvQkFBSXoyQixNQUFNQyxNQUFOLElBQWdCRCxNQUFNQSxNQUFNQyxNQUFOLEdBQWUsQ0FBckIsRUFBd0IsQ0FBeEIsS0FBOEJxMkIsS0FBbEQsRUFBeUQ7QUFDckQsMkJBQU9qSyxRQUFRcG9CLEtBQVIsQ0FBYyxrSEFBZCxFQUFrSXd5QixRQUFsSSxDQUFQO0FBQ0g7QUFDRCxvQkFBTTNKLFNBQVNULFFBQVE1cEIsS0FBUixDQUFjcUosS0FBZCxFQUFxQjRxQixRQUFyQixFQUErQkYsVUFBL0IsQ0FBZjtBQUNBLG9CQUFJLENBQUMxSixNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0owSiw2QkFBYUEsY0FBYzFKLE9BQU9sb0IsSUFBbEM7QUFDQTVFLHNCQUFNWSxJQUFOLENBQVcsQ0FDUDAxQixLQURPLEVBRVB4SixNQUZPLENBQVg7QUFJSDtBQUNELGdCQUFJMEosV0FBV3RQLElBQVgsS0FBb0IsUUFBcEIsSUFBZ0NzUCxXQUFXdFAsSUFBWCxLQUFvQixPQUFwRCxJQUErRCxFQUFFc1AsV0FBV3RQLElBQVgsS0FBb0IsT0FBcEIsSUFBK0JzUCxXQUFXM08sUUFBWCxDQUFvQlgsSUFBcEIsS0FBNkIsUUFBNUQsSUFBd0UsT0FBT3NQLFdBQVcxTyxDQUFsQixLQUF3QixRQUFsRyxDQUFuRSxFQUFnTDtBQUM1Syx1QkFBT3VFLFFBQVFwb0IsS0FBUixXQUF1QnFCLFNBQVNreEIsVUFBVCxDQUF2Qiw2QkFBUDtBQUNIO0FBQ0QsbUJBQU8sSUFBSW1ELFdBQUosQ0FBZ0JuRCxVQUFoQixFQUE0Qm9ELFFBQTVCLEVBQXNDQyxhQUF0QyxFQUFxRHhkLEtBQXJELEVBQTREcmMsS0FBNUQsQ0FBUDtBQUNIOzs7Ozs7QUFpRUwsU0FBU282Qix3QkFBVCxDQUFrQy9kLEtBQWxDLEVBQXlDM0YsSUFBekMsRUFBK0M0akIsVUFBL0MsRUFBMkRDLFVBQTNELEVBQXVFO0FBQ25FLFFBQU1DLGFBQWFELGFBQWFELFVBQWhDO0FBQ0EsUUFBTUcsV0FBV3BlLFFBQVFpZSxVQUF6QjtBQUNBLFFBQUlFLGVBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsZUFBTyxDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUk5akIsU0FBUyxDQUFiLEVBQWdCO0FBQ25CLGVBQU8rakIsV0FBV0QsVUFBbEI7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPLENBQUM1ZixLQUFLdVcsR0FBTCxDQUFTemEsSUFBVCxFQUFlK2pCLFFBQWYsSUFBMkIsQ0FBNUIsS0FBa0M3ZixLQUFLdVcsR0FBTCxDQUFTemEsSUFBVCxFQUFlOGpCLFVBQWYsSUFBNkIsQ0FBL0QsQ0FBUDtBQUNIO0FBQ0o7O0lBRUtFLFE7QUFDRixzQkFBWTkxQixJQUFaLEVBQWtCd25CLElBQWxCLEVBQXdCO0FBQUE7O0FBQ3BCLGFBQUt4bkIsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsYUFBS3duQixJQUFMLEdBQVlBLElBQVo7QUFDSDs7OztpQ0FxQlFNLEcsRUFBSztBQUNWLGdCQUFJNVQsU0FBUyxJQUFiO0FBQ0EsZ0JBQUk2aEIsV0FBVyxDQUFmO0FBQ0EsZ0JBQUlDLDJCQUFKO0FBSFU7QUFBQTtBQUFBOztBQUFBO0FBSVYsdUNBQWtCLEtBQUt4TyxJQUF2Qix3SUFBNkI7QUFBQSx3QkFBbEJuTyxHQUFrQjs7QUFDekIwYztBQUNBN2hCLDZCQUFTbUYsSUFBSTBPLFFBQUosQ0FBYUQsR0FBYixDQUFUO0FBQ0Esd0JBQUk1VCxVQUFVQSxrQkFBa0I0UyxhQUE1QixJQUE2QyxDQUFDNVMsT0FBTzZTLFNBQXpELEVBQW9FO0FBQ2hFLDRCQUFJLENBQUNpUCxrQkFBTCxFQUF5QjtBQUNyQkEsaURBQXFCOWhCLE9BQU9sTixJQUE1QjtBQUNIO0FBQ0RrTixpQ0FBUyxJQUFUO0FBQ0EsNEJBQUk2aEIsYUFBYSxLQUFLdk8sSUFBTCxDQUFVbnNCLE1BQTNCLEVBQW1DO0FBQy9CNlkscUNBQVM4aEIsa0JBQVQ7QUFDSDtBQUNKO0FBQ0Qsd0JBQUk5aEIsV0FBVyxJQUFmLEVBQ0k7QUFDUDtBQWxCUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW1CVixtQkFBT0EsTUFBUDtBQUNIOzs7a0NBQ1NPLEUsRUFBSTtBQUNWLGlCQUFLK1MsSUFBTCxDQUFVOUcsT0FBVixDQUFrQmpNLEVBQWxCO0FBQ0g7Ozt3Q0FDZTtBQUNaLG1CQUFPLEtBQUsrUyxJQUFMLENBQVVRLEtBQVYsQ0FBZ0I7QUFBQSx1QkFBTzNPLElBQUk0TyxhQUFKLEVBQVA7QUFBQSxhQUFoQixDQUFQO0FBQ0g7OztvQ0FDVztBQUNSLGdCQUFNdEIsYUFBYSxDQUFDLFVBQUQsQ0FBbkI7QUFDQSxpQkFBSzBDLFNBQUwsQ0FBZSxpQkFBUztBQUNwQjFDLDJCQUFXM3FCLElBQVgsQ0FBZ0JzdEIsTUFBTS9CLFNBQU4sRUFBaEI7QUFDSCxhQUZEO0FBR0EsbUJBQU9aLFVBQVA7QUFDSDs7OzhCQXJEWWEsSSxFQUFNQyxPLEVBQVM7QUFDeEIsZ0JBQUlELEtBQUtuc0IsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ2pCLHVCQUFPb3NCLFFBQVFwb0IsS0FBUixDQUFjLG9DQUFkLENBQVA7QUFDSDtBQUNELGdCQUFJdXlCLGFBQWEsSUFBakI7QUFDQSxnQkFBTWxLLGVBQWVELFFBQVFDLFlBQTdCO0FBQ0EsZ0JBQUlBLGdCQUFnQkEsYUFBYXBGLElBQWIsS0FBc0IsT0FBMUMsRUFBbUQ7QUFDL0NzUCw2QkFBYWxLLFlBQWI7QUFDSDtBQUNELGdCQUFNMEQsYUFBYSxFQUFuQjtBQVR3QjtBQUFBO0FBQUE7O0FBQUE7QUFVeEIsdUNBQWtCNUQsS0FBS3JoQixLQUFMLENBQVcsQ0FBWCxDQUFsQix3SUFBaUM7QUFBQSx3QkFBdEJrVCxHQUFzQjs7QUFDN0Isd0JBQU02TyxTQUFTVCxRQUFRNXBCLEtBQVIsQ0FBY3diLEdBQWQsRUFBbUIsSUFBSStSLFdBQVcvdkIsTUFBbEMsRUFBMEN1MkIsVUFBMUMsRUFBc0Q1eUIsU0FBdEQsRUFBaUUsRUFBRTJ4QixnQkFBZ0IsTUFBbEIsRUFBakUsQ0FBZjtBQUNBLHdCQUFJLENBQUN6SSxNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0owSixpQ0FBYUEsY0FBYzFKLE9BQU9sb0IsSUFBbEM7QUFDQW9yQiwrQkFBV3B2QixJQUFYLENBQWdCa3NCLE1BQWhCO0FBQ0g7QUFoQnVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaUJ4QixnQkFBTStOLGtCQUFrQnZPLGdCQUFnQjBELFdBQVdycUIsSUFBWCxDQUFnQjtBQUFBLHVCQUFPcWlCLGNBQWFzRSxZQUFiLEVBQTJCck8sSUFBSXJaLElBQS9CLENBQVA7QUFBQSxhQUFoQixDQUF4QztBQUNBLG1CQUFPaTJCLGtCQUFrQixJQUFJSCxRQUFKLENBQWFsVCxTQUFiLEVBQXdCd0ksVUFBeEIsQ0FBbEIsR0FBd0QsSUFBSTBLLFFBQUosQ0FBYWxFLFVBQWIsRUFBeUJ4RyxVQUF6QixDQUEvRDtBQUNIOzs7Ozs7SUFxQ0M4SyxHO0FBQ0YsaUJBQVk5VCxRQUFaLEVBQXNCbE8sTUFBdEIsRUFBOEI7QUFBQTs7QUFDMUIsYUFBS2xVLElBQUwsR0FBWWtVLE9BQU9sVSxJQUFuQjtBQUNBLGFBQUtvaUIsUUFBTCxHQUFnQixHQUFHL1IsTUFBSCxDQUFVK1IsUUFBVixDQUFoQjtBQUNBLGFBQUtsTyxNQUFMLEdBQWNBLE1BQWQ7QUFDSDs7OztpQ0FDUTRULEcsRUFBSztBQUNWLG1CQUFPLEtBQUs1VCxNQUFMLENBQVk2VCxRQUFaLENBQXFCRCxHQUFyQixDQUFQO0FBQ0g7OztrQ0FDU3JULEUsRUFBSTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNWLHVDQUFzQixLQUFLMk4sUUFBM0Isd0lBQXFDO0FBQUEsd0JBQTFCK1QsT0FBMEI7O0FBQ2pDMWhCLHVCQUFHMGhCLFFBQVEsQ0FBUixDQUFIO0FBQ0g7QUFIUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlWMWhCLGVBQUcsS0FBS1AsTUFBUjtBQUNIOzs7d0NBMEJlO0FBQ1osbUJBQU8sS0FBS0EsTUFBTCxDQUFZK1QsYUFBWixFQUFQO0FBQ0g7OztvQ0FDVztBQUNSLGdCQUFNdEIsYUFBYSxDQUFDLEtBQUQsQ0FBbkI7QUFEUTtBQUFBO0FBQUE7O0FBQUE7QUFFUix1Q0FBMkIsS0FBS3ZFLFFBQWhDLHdJQUEwQztBQUFBOztBQUFBOztBQUFBLHdCQUE5QnBiLElBQThCO0FBQUEsd0JBQXhCd3BCLElBQXdCOztBQUN0QzdKLCtCQUFXM3FCLElBQVgsQ0FBZ0JnTCxJQUFoQixFQUFzQndwQixLQUFLakosU0FBTCxFQUF0QjtBQUNIO0FBSk87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLUlosdUJBQVczcUIsSUFBWCxDQUFnQixLQUFLa1ksTUFBTCxDQUFZcVQsU0FBWixFQUFoQjtBQUNBLG1CQUFPWixVQUFQO0FBQ0g7Ozs4QkFuQ1lhLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsR0FBYyxDQUFsQixFQUNJLE9BQU9vc0IsUUFBUXBvQixLQUFSLGdEQUEyRG1vQixLQUFLbnNCLE1BQUwsR0FBYyxDQUF6RSxnQkFBUDtBQUNKLGdCQUFNK21CLFdBQVcsRUFBakI7QUFDQSxpQkFBSyxJQUFJcG5CLElBQUksQ0FBYixFQUFnQkEsSUFBSXdzQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFsQyxFQUFxQ0wsS0FBSyxDQUExQyxFQUE2QztBQUN6QyxvQkFBTWdNLE9BQU93Z0IsS0FBS3hzQixDQUFMLENBQWI7QUFDQSxvQkFBSSxPQUFPZ00sSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUMxQiwyQkFBT3lnQixRQUFRcG9CLEtBQVIseUNBQW9EMkgsSUFBcEQseUNBQW9EQSxJQUFwRCxrQkFBc0VoTSxDQUF0RSxDQUFQO0FBQ0g7QUFDRCxvQkFBSSxnQkFBZ0IrZCxJQUFoQixDQUFxQi9SLElBQXJCLENBQUosRUFBZ0M7QUFDNUIsMkJBQU95Z0IsUUFBUXBvQixLQUFSLHFFQUFrRnJFLENBQWxGLENBQVA7QUFDSDtBQUNELG9CQUFNa00sUUFBUXVnQixRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLeHNCLElBQUksQ0FBVCxDQUFkLEVBQTJCQSxJQUFJLENBQS9CLENBQWQ7QUFDQSxvQkFBSSxDQUFDa00sS0FBTCxFQUNJLE9BQU8sSUFBUDtBQUNKa2IseUJBQVNwbUIsSUFBVCxDQUFjLENBQ1ZnTCxJQURVLEVBRVZFLEtBRlUsQ0FBZDtBQUlIO0FBQ0QsZ0JBQU1nTixTQUFTdVQsUUFBUTVwQixLQUFSLENBQWMycEIsS0FBS0EsS0FBS25zQixNQUFMLEdBQWMsQ0FBbkIsQ0FBZCxFQUFxQ21zQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFuRCxFQUFzRG9zQixRQUFRQyxZQUE5RCxFQUE0RXRGLFFBQTVFLENBQWY7QUFDQSxnQkFBSSxDQUFDbE8sTUFBTCxFQUNJLE9BQU8sSUFBUDtBQUNKLG1CQUFPLElBQUlnaUIsR0FBSixDQUFROVQsUUFBUixFQUFrQmxPLE1BQWxCLENBQVA7QUFDSDs7Ozs7O0lBY0NraUIsRTtBQUNGLGdCQUFZcDJCLElBQVosRUFBa0JzVCxLQUFsQixFQUF5Qm1FLEtBQXpCLEVBQWdDO0FBQUE7O0FBQzVCLGFBQUt6WCxJQUFMLEdBQVlBLElBQVo7QUFDQSxhQUFLc1QsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS21FLEtBQUwsR0FBYUEsS0FBYjtBQUNIOzs7O2lDQVdRcVEsRyxFQUFLO0FBQ1YsZ0JBQU14VSxRQUFRLEtBQUtBLEtBQUwsQ0FBV3lVLFFBQVgsQ0FBb0JELEdBQXBCLENBQWQ7QUFDQSxnQkFBTTNaLFFBQVEsS0FBS3NKLEtBQUwsQ0FBV3NRLFFBQVgsQ0FBb0JELEdBQXBCLENBQWQ7QUFDQSxnQkFBSXhVLFFBQVEsQ0FBWixFQUFlO0FBQ1gsc0JBQU0sSUFBSXFVLFlBQUosaUNBQWdEclUsS0FBaEQsV0FBTjtBQUNIO0FBQ0QsZ0JBQUlBLFNBQVNuRixNQUFNOVMsTUFBbkIsRUFBMkI7QUFDdkIsc0JBQU0sSUFBSXNzQixZQUFKLGlDQUFnRHJVLEtBQWhELFlBQTZEbkYsTUFBTTlTLE1BQU4sR0FBZSxDQUE1RSxRQUFOO0FBQ0g7QUFDRCxnQkFBSWlZLFVBQVUwQyxLQUFLL0YsS0FBTCxDQUFXcUQsS0FBWCxDQUFkLEVBQWlDO0FBQzdCLHNCQUFNLElBQUlxVSxZQUFKLGdEQUErRHJVLEtBQS9ELGVBQU47QUFDSDtBQUNELG1CQUFPbkYsTUFBTW1GLEtBQU4sQ0FBUDtBQUNIOzs7a0NBQ1NtQixFLEVBQUk7QUFDVkEsZUFBRyxLQUFLbkIsS0FBUjtBQUNBbUIsZUFBRyxLQUFLZ0QsS0FBUjtBQUNIOzs7d0NBQ2U7QUFDWixtQkFBTyxLQUFQO0FBQ0g7OztvQ0FDVztBQUNSLG1CQUFPLENBQ0gsSUFERyxFQUVILEtBQUtuRSxLQUFMLENBQVdpVSxTQUFYLEVBRkcsRUFHSCxLQUFLOVAsS0FBTCxDQUFXOFAsU0FBWCxFQUhHLENBQVA7QUFLSDs7OzhCQXJDWUMsSSxFQUFNQyxPLEVBQVM7QUFDeEIsZ0JBQUlELEtBQUtuc0IsTUFBTCxLQUFnQixDQUFwQixFQUNJLE9BQU9vc0IsUUFBUXBvQixLQUFSLHVDQUFrRG1vQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFoRSxnQkFBUDtBQUNKLGdCQUFNaVksUUFBUW1VLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCakYsVUFBMUIsQ0FBZDtBQUNBLGdCQUFNOUssUUFBUWdRLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCclosTUFBTXNaLFFBQVFDLFlBQVIsSUFBd0I5RSxTQUE5QixDQUExQixDQUFkO0FBQ0EsZ0JBQUksQ0FBQ3RQLEtBQUQsSUFBVSxDQUFDbUUsS0FBZixFQUNJLE9BQU8sSUFBUDtBQUNKLGdCQUFNUyxJQUFJVCxNQUFNelgsSUFBaEI7QUFDQSxtQkFBTyxJQUFJbzJCLEVBQUosQ0FBT2xlLEVBQUUrSyxRQUFULEVBQW1CM1AsS0FBbkIsRUFBMEJtRSxLQUExQixDQUFQO0FBQ0g7Ozs7OztJQStCQzRlLEU7QUFDRixnQkFBWUMsTUFBWixFQUFvQkMsUUFBcEIsRUFBOEI7QUFBQTs7QUFDMUIsYUFBS3YyQixJQUFMLEdBQVl5aUIsV0FBWjtBQUNBLGFBQUs2VCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNIOzs7O2lDQW9CUXpPLEcsRUFBSztBQUNWLGdCQUFNd08sU0FBUyxLQUFLQSxNQUFMLENBQVl2TyxRQUFaLENBQXFCRCxHQUFyQixDQUFmO0FBQ0EsZ0JBQU15TyxXQUFXLEtBQUtBLFFBQUwsQ0FBY3hPLFFBQWQsQ0FBdUJELEdBQXZCLENBQWpCO0FBQ0EsZ0JBQUksQ0FBQ3lPLFFBQUwsRUFDSSxPQUFPLEtBQVA7QUFDSixnQkFBSSxDQUFDN1Msa0JBQWtCNFMsTUFBbEIsRUFBMEIsQ0FDdkIsU0FEdUIsRUFFdkIsUUFGdUIsRUFHdkIsUUFIdUIsRUFJdkIsTUFKdUIsQ0FBMUIsQ0FBTCxFQUtRO0FBQ0osc0JBQU0sSUFBSTNPLFlBQUosdUZBQXNHam5CLFNBQVMwbUIsT0FBT2tQLE1BQVAsQ0FBVCxDQUF0RyxlQUFOO0FBQ0g7QUFDRCxnQkFBSSxDQUFDNVMsa0JBQWtCNlMsUUFBbEIsRUFBNEIsQ0FDekIsUUFEeUIsRUFFekIsT0FGeUIsQ0FBNUIsQ0FBTCxFQUdRO0FBQ0osc0JBQU0sSUFBSTVPLFlBQUosd0VBQXVGam5CLFNBQVMwbUIsT0FBT21QLFFBQVAsQ0FBVCxDQUF2RixlQUFOO0FBQ0g7QUFDRCxtQkFBT0EsU0FBU3g2QixPQUFULENBQWlCdTZCLE1BQWpCLEtBQTRCLENBQW5DO0FBQ0g7OztrQ0FDUzdoQixFLEVBQUk7QUFDVkEsZUFBRyxLQUFLNmhCLE1BQVI7QUFDQTdoQixlQUFHLEtBQUs4aEIsUUFBUjtBQUNIOzs7d0NBQ2U7QUFDWixtQkFBTyxJQUFQO0FBQ0g7OztvQ0FDVztBQUNSLG1CQUFPLENBQ0gsSUFERyxFQUVILEtBQUtELE1BQUwsQ0FBWS9PLFNBQVosRUFGRyxFQUdILEtBQUtnUCxRQUFMLENBQWNoUCxTQUFkLEVBSEcsQ0FBUDtBQUtIOzs7OEJBckRZQyxJLEVBQU1DLE8sRUFBUztBQUN4QixnQkFBSUQsS0FBS25zQixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLHVCQUFPb3NCLFFBQVFwb0IsS0FBUix1Q0FBa0Rtb0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBaEUsZ0JBQVA7QUFDSDtBQUNELGdCQUFNaTdCLFNBQVM3TyxRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQjVFLFNBQTFCLENBQWY7QUFDQSxnQkFBTTJULFdBQVc5TyxRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQjVFLFNBQTFCLENBQWpCO0FBQ0EsZ0JBQUksQ0FBQzBULE1BQUQsSUFBVyxDQUFDQyxRQUFoQixFQUNJLE9BQU8sSUFBUDtBQUNKLGdCQUFJLENBQUNoVCxZQUFZK1MsT0FBT3QyQixJQUFuQixFQUF5QixDQUN0QnlpQixXQURzQixFQUV0QkQsVUFGc0IsRUFHdEJELFVBSHNCLEVBSXRCRixRQUpzQixFQUt0Qk8sU0FMc0IsQ0FBekIsQ0FBTCxFQU1RO0FBQ0osdUJBQU82RSxRQUFRcG9CLEtBQVIsdUZBQW1HcUIsU0FBUzQxQixPQUFPdDJCLElBQWhCLENBQW5HLGNBQVA7QUFDSDtBQUNELG1CQUFPLElBQUlxMkIsRUFBSixDQUFPQyxNQUFQLEVBQWVDLFFBQWYsQ0FBUDtBQUNIOzs7Ozs7SUFzQ0NDLE87QUFDRixxQkFBWUYsTUFBWixFQUFvQkMsUUFBcEIsRUFBOEJFLFNBQTlCLEVBQXlDO0FBQUE7O0FBQ3JDLGFBQUt6MkIsSUFBTCxHQUFZdWlCLFVBQVo7QUFDQSxhQUFLK1QsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS0MsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxhQUFLRSxTQUFMLEdBQWlCQSxTQUFqQjtBQUNIOzs7O2lDQTJCUTNPLEcsRUFBSztBQUNWLGdCQUFNd08sU0FBUyxLQUFLQSxNQUFMLENBQVl2TyxRQUFaLENBQXFCRCxHQUFyQixDQUFmO0FBQ0EsZ0JBQU15TyxXQUFXLEtBQUtBLFFBQUwsQ0FBY3hPLFFBQWQsQ0FBdUJELEdBQXZCLENBQWpCO0FBQ0EsZ0JBQUksQ0FBQ3BFLGtCQUFrQjRTLE1BQWxCLEVBQTBCLENBQ3ZCLFNBRHVCLEVBRXZCLFFBRnVCLEVBR3ZCLFFBSHVCLEVBSXZCLE1BSnVCLENBQTFCLENBQUwsRUFLUTtBQUNKLHNCQUFNLElBQUkzTyxZQUFKLHVGQUFzR2puQixTQUFTMG1CLE9BQU9rUCxNQUFQLENBQVQsQ0FBdEcsZUFBTjtBQUNIO0FBQ0QsZ0JBQUksQ0FBQzVTLGtCQUFrQjZTLFFBQWxCLEVBQTRCLENBQ3pCLFFBRHlCLEVBRXpCLE9BRnlCLENBQTVCLENBQUwsRUFHUTtBQUNKLHNCQUFNLElBQUk1TyxZQUFKLHdFQUF1RmpuQixTQUFTMG1CLE9BQU9tUCxRQUFQLENBQVQsQ0FBdkYsZUFBTjtBQUNIO0FBQ0QsZ0JBQUksS0FBS0UsU0FBVCxFQUFvQjtBQUNoQixvQkFBTUEsWUFBWSxLQUFLQSxTQUFMLENBQWUxTyxRQUFmLENBQXdCRCxHQUF4QixDQUFsQjtBQUNBLHVCQUFPeU8sU0FBU3g2QixPQUFULENBQWlCdTZCLE1BQWpCLEVBQXlCRyxTQUF6QixDQUFQO0FBQ0g7QUFDRCxtQkFBT0YsU0FBU3g2QixPQUFULENBQWlCdTZCLE1BQWpCLENBQVA7QUFDSDs7O2tDQUNTN2hCLEUsRUFBSTtBQUNWQSxlQUFHLEtBQUs2aEIsTUFBUjtBQUNBN2hCLGVBQUcsS0FBSzhoQixRQUFSO0FBQ0EsZ0JBQUksS0FBS0UsU0FBVCxFQUFvQjtBQUNoQmhpQixtQkFBRyxLQUFLZ2lCLFNBQVI7QUFDSDtBQUNKOzs7d0NBQ2U7QUFDWixtQkFBTyxLQUFQO0FBQ0g7OztvQ0FDVztBQUNSLGdCQUFJLEtBQUtBLFNBQUwsSUFBa0IsSUFBbEIsSUFBMEIsS0FBS0EsU0FBTCxLQUFtQnozQixTQUFqRCxFQUE0RDtBQUN4RCxvQkFBTXkzQixZQUFZLEtBQUtBLFNBQUwsQ0FBZWxQLFNBQWYsRUFBbEI7QUFDQSx1QkFBTyxDQUNILFVBREcsRUFFSCxLQUFLK08sTUFBTCxDQUFZL08sU0FBWixFQUZHLEVBR0gsS0FBS2dQLFFBQUwsQ0FBY2hQLFNBQWQsRUFIRyxFQUlIa1AsU0FKRyxDQUFQO0FBTUg7QUFDRCxtQkFBTyxDQUNILFVBREcsRUFFSCxLQUFLSCxNQUFMLENBQVkvTyxTQUFaLEVBRkcsRUFHSCxLQUFLZ1AsUUFBTCxDQUFjaFAsU0FBZCxFQUhHLENBQVA7QUFLSDs7OzhCQTFFWUMsSSxFQUFNQyxPLEVBQVM7QUFDeEIsZ0JBQUlELEtBQUtuc0IsTUFBTCxJQUFlLENBQWYsSUFBb0Jtc0IsS0FBS25zQixNQUFMLElBQWUsQ0FBdkMsRUFBMEM7QUFDdEMsdUJBQU9vc0IsUUFBUXBvQixLQUFSLDRDQUF1RG1vQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFyRSxnQkFBUDtBQUNIO0FBQ0QsZ0JBQU1pN0IsU0FBUzdPLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCNUUsU0FBMUIsQ0FBZjtBQUNBLGdCQUFNMlQsV0FBVzlPLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCNUUsU0FBMUIsQ0FBakI7QUFDQSxnQkFBSSxDQUFDMFQsTUFBRCxJQUFXLENBQUNDLFFBQWhCLEVBQ0ksT0FBTyxJQUFQO0FBQ0osZ0JBQUksQ0FBQ2hULFlBQVkrUyxPQUFPdDJCLElBQW5CLEVBQXlCLENBQ3RCeWlCLFdBRHNCLEVBRXRCRCxVQUZzQixFQUd0QkQsVUFIc0IsRUFJdEJGLFFBSnNCLEVBS3RCTyxTQUxzQixDQUF6QixDQUFMLEVBTVE7QUFDSix1QkFBTzZFLFFBQVFwb0IsS0FBUix1RkFBbUdxQixTQUFTNDFCLE9BQU90MkIsSUFBaEIsQ0FBbkcsY0FBUDtBQUNIO0FBQ0QsZ0JBQUl3bkIsS0FBS25zQixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLG9CQUFNbzdCLFlBQVloUCxRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQmpGLFVBQTFCLENBQWxCO0FBQ0Esb0JBQUksQ0FBQ2tVLFNBQUwsRUFDSSxPQUFPLElBQVA7QUFDSix1QkFBTyxJQUFJRCxPQUFKLENBQVlGLE1BQVosRUFBb0JDLFFBQXBCLEVBQThCRSxTQUE5QixDQUFQO0FBQ0gsYUFMRCxNQUtPO0FBQ0gsdUJBQU8sSUFBSUQsT0FBSixDQUFZRixNQUFaLEVBQW9CQyxRQUFwQixDQUFQO0FBQ0g7QUFDSjs7Ozs7O0lBb0RDRyxLO0FBQ0YsbUJBQVlDLFNBQVosRUFBdUIvRSxVQUF2QixFQUFtQ25hLEtBQW5DLEVBQTBDbWYsS0FBMUMsRUFBaURuRixPQUFqRCxFQUEwRG9GLFNBQTFELEVBQXFFO0FBQUE7O0FBQ2pFLGFBQUtGLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsYUFBSzMyQixJQUFMLEdBQVk0eEIsVUFBWjtBQUNBLGFBQUtuYSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxhQUFLbWYsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS25GLE9BQUwsR0FBZUEsT0FBZjtBQUNBLGFBQUtvRixTQUFMLEdBQWlCQSxTQUFqQjtBQUNIOzs7O2lDQXlEUS9PLEcsRUFBSztBQUNWLGdCQUFNclEsUUFBUSxLQUFLQSxLQUFMLENBQVdzUSxRQUFYLENBQW9CRCxHQUFwQixDQUFkO0FBQ0EsZ0JBQU1yUixTQUFTMlEsT0FBTzNQLEtBQVAsTUFBa0IsS0FBS2tmLFNBQXZCLElBQW9DLEtBQUtsRixPQUFMLENBQWEsS0FBS21GLEtBQUwsQ0FBV25mLEtBQVgsQ0FBYixDQUFwQyxJQUF1RSxLQUFLb2YsU0FBM0Y7QUFDQSxtQkFBT3BnQixPQUFPc1IsUUFBUCxDQUFnQkQsR0FBaEIsQ0FBUDtBQUNIOzs7a0NBQ1NyVCxFLEVBQUk7QUFDVkEsZUFBRyxLQUFLZ0QsS0FBUjtBQUNBLGlCQUFLZ2EsT0FBTCxDQUFhL1EsT0FBYixDQUFxQmpNLEVBQXJCO0FBQ0FBLGVBQUcsS0FBS29pQixTQUFSO0FBQ0g7Ozt3Q0FDZTtBQUNaLG1CQUFPLEtBQUtwRixPQUFMLENBQWF6SixLQUFiLENBQW1CO0FBQUEsdUJBQU9yUSxJQUFJc1EsYUFBSixFQUFQO0FBQUEsYUFBbkIsS0FBa0QsS0FBSzRPLFNBQUwsQ0FBZTVPLGFBQWYsRUFBekQ7QUFDSDs7O29DQUNXO0FBQUE7O0FBQ1IsZ0JBQU10QixhQUFhLENBQ2YsT0FEZSxFQUVmLEtBQUtsUCxLQUFMLENBQVc4UCxTQUFYLEVBRmUsQ0FBbkI7QUFJQSxnQkFBTXVQLGVBQWUvaUIsT0FBT04sSUFBUCxDQUFZLEtBQUttakIsS0FBakIsRUFBd0JHLElBQXhCLEVBQXJCO0FBQ0EsZ0JBQU1DLGtCQUFrQixFQUF4QjtBQUNBLGdCQUFNQyxlQUFlLEVBQXJCO0FBUFE7QUFBQTtBQUFBOztBQUFBO0FBUVIsdUNBQW9CSCxZQUFwQix3SUFBa0M7QUFBQSx3QkFBdkJwRixLQUF1Qjs7QUFDOUIsd0JBQU13RixjQUFjRCxhQUFhLEtBQUtMLEtBQUwsQ0FBV2xGLEtBQVgsQ0FBYixDQUFwQjtBQUNBLHdCQUFJd0YsZ0JBQWdCbDRCLFNBQXBCLEVBQStCO0FBQzNCaTRCLHFDQUFhLEtBQUtMLEtBQUwsQ0FBV2xGLEtBQVgsQ0FBYixJQUFrQ3NGLGdCQUFnQjM3QixNQUFsRDtBQUNBMjdCLHdDQUFnQmg3QixJQUFoQixDQUFxQixDQUNqQixLQUFLNDZCLEtBQUwsQ0FBV2xGLEtBQVgsQ0FEaUIsRUFFakIsQ0FBQ0EsS0FBRCxDQUZpQixDQUFyQjtBQUlILHFCQU5ELE1BTU87QUFDSHNGLHdDQUFnQkUsV0FBaEIsRUFBNkIsQ0FBN0IsRUFBZ0NsN0IsSUFBaEMsQ0FBcUMwMUIsS0FBckM7QUFDSDtBQUNKO0FBbkJPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBb0JSLGdCQUFNeUYsY0FBYyxTQUFkQSxXQUFjO0FBQUEsdUJBQVMsT0FBS1IsU0FBTCxDQUFlclUsSUFBZixLQUF3QixRQUF4QixHQUFtQzZHLE9BQU91SSxLQUFQLENBQW5DLEdBQW1EQSxLQUE1RDtBQUFBLGFBQXBCO0FBcEJRO0FBQUE7QUFBQTs7QUFBQTtBQXFCUix1Q0FBb0NzRixlQUFwQyx3SUFBcUQ7QUFBQTs7QUFBQTs7QUFBQSx3QkFBekNFLFdBQXlDO0FBQUEsd0JBQTVCNWdCLE1BQTRCOztBQUNqRCx3QkFBSUEsT0FBT2piLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDckJzckIsbUNBQVczcUIsSUFBWCxDQUFnQm03QixZQUFZN2dCLE9BQU8sQ0FBUCxDQUFaLENBQWhCO0FBQ0gscUJBRkQsTUFFTztBQUNIcVEsbUNBQVczcUIsSUFBWCxDQUFnQnNhLE9BQU81YSxHQUFQLENBQVd5N0IsV0FBWCxDQUFoQjtBQUNIO0FBQ0R4USwrQkFBVzNxQixJQUFYLENBQWdCLEtBQUt5MUIsT0FBTCxDQUFheUYsV0FBYixFQUEwQjNQLFNBQTFCLEVBQWhCO0FBQ0g7QUE1Qk87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUE2QlJaLHVCQUFXM3FCLElBQVgsQ0FBZ0IsS0FBSzY2QixTQUFMLENBQWV0UCxTQUFmLEVBQWhCO0FBQ0EsbUJBQU9aLFVBQVA7QUFDSDs7OzhCQXBHWWEsSSxFQUFNQyxPLEVBQVM7QUFDeEIsZ0JBQUlELEtBQUtuc0IsTUFBTCxHQUFjLENBQWxCLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIscURBQWdFbW9CLEtBQUtuc0IsTUFBTCxHQUFjLENBQTlFLFFBQVA7QUFDSixnQkFBSW1zQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFkLEtBQW9CLENBQXhCLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIseUNBQVA7QUFDSixnQkFBSXMzQixrQkFBSjtBQUNBLGdCQUFJL0UsbUJBQUo7QUFDQSxnQkFBSW5LLFFBQVFDLFlBQVIsSUFBd0JELFFBQVFDLFlBQVIsQ0FBcUJwRixJQUFyQixLQUE4QixPQUExRCxFQUFtRTtBQUMvRHNQLDZCQUFhbkssUUFBUUMsWUFBckI7QUFDSDtBQUNELGdCQUFNa1AsUUFBUSxFQUFkO0FBQ0EsZ0JBQU1uRixVQUFVLEVBQWhCO0FBQ0EsaUJBQUssSUFBSXoyQixJQUFJLENBQWIsRUFBZ0JBLElBQUl3c0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBbEMsRUFBcUNMLEtBQUssQ0FBMUMsRUFBNkM7QUFDekMsb0JBQUlzYixTQUFTa1IsS0FBS3hzQixDQUFMLENBQWI7QUFDQSxvQkFBTWtNLFFBQVFzZ0IsS0FBS3hzQixJQUFJLENBQVQsQ0FBZDtBQUNBLG9CQUFJLENBQUNFLE1BQU1DLE9BQU4sQ0FBY21iLE1BQWQsQ0FBTCxFQUE0QjtBQUN4QkEsNkJBQVMsQ0FBQ0EsTUFBRCxDQUFUO0FBQ0g7QUFDRCxvQkFBTThnQixlQUFlM1AsUUFBUXBYLE1BQVIsQ0FBZXJWLENBQWYsQ0FBckI7QUFDQSxvQkFBSXNiLE9BQU9qYixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLDJCQUFPKzdCLGFBQWEvM0IsS0FBYixDQUFtQixxQ0FBbkIsQ0FBUDtBQUNIO0FBVHdDO0FBQUE7QUFBQTs7QUFBQTtBQVV6QywyQ0FBb0JpWCxNQUFwQix3SUFBNEI7QUFBQSw0QkFBakJvYixLQUFpQjs7QUFDeEIsNEJBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QixPQUFPQSxLQUFQLEtBQWlCLFFBQWxELEVBQTREO0FBQ3hELG1DQUFPMEYsYUFBYS8zQixLQUFiLDZDQUFQO0FBQ0gseUJBRkQsTUFFTyxJQUFJLE9BQU9xeUIsS0FBUCxLQUFpQixRQUFqQixJQUE2QjFiLEtBQUtqRyxHQUFMLENBQVMyaEIsS0FBVCxJQUFrQnZJLE9BQU9rTyxnQkFBMUQsRUFBNEU7QUFDL0UsbUNBQU9ELGFBQWEvM0IsS0FBYixvREFBcUU4cEIsT0FBT2tPLGdCQUE1RSxPQUFQO0FBQ0gseUJBRk0sTUFFQSxJQUFJLE9BQU8zRixLQUFQLEtBQWlCLFFBQWpCLElBQTZCMWIsS0FBSy9GLEtBQUwsQ0FBV3loQixLQUFYLE1BQXNCQSxLQUF2RCxFQUE4RDtBQUNqRSxtQ0FBTzBGLGFBQWEvM0IsS0FBYixpREFBUDtBQUNILHlCQUZNLE1BRUEsSUFBSSxDQUFDczNCLFNBQUwsRUFBZ0I7QUFDbkJBLHdDQUFZdlAsT0FBT3NLLEtBQVAsQ0FBWjtBQUNILHlCQUZNLE1BRUEsSUFBSTBGLGFBQWFoVSxZQUFiLENBQTBCdVQsU0FBMUIsRUFBcUN2UCxPQUFPc0ssS0FBUCxDQUFyQyxDQUFKLEVBQXlEO0FBQzVELG1DQUFPLElBQVA7QUFDSDtBQUNELDRCQUFJLE9BQU9rRixNQUFNMWdCLE9BQU93YixLQUFQLENBQU4sQ0FBUCxLQUFnQyxXQUFwQyxFQUFpRDtBQUM3QyxtQ0FBTzBGLGFBQWEvM0IsS0FBYixDQUFtQiwrQkFBbkIsQ0FBUDtBQUNIO0FBQ0R1M0IsOEJBQU0xZ0IsT0FBT3diLEtBQVAsQ0FBTixJQUF1QkQsUUFBUXAyQixNQUEvQjtBQUNIO0FBMUJ3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQTJCekMsb0JBQU02WSxTQUFTdVQsUUFBUTVwQixLQUFSLENBQWNxSixLQUFkLEVBQXFCbE0sQ0FBckIsRUFBd0I0MkIsVUFBeEIsQ0FBZjtBQUNBLG9CQUFJLENBQUMxZCxNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0owZCw2QkFBYUEsY0FBYzFkLE9BQU9sVSxJQUFsQztBQUNBeXhCLHdCQUFRejFCLElBQVIsQ0FBYWtZLE1BQWI7QUFDSDtBQUNELGdCQUFNdUQsUUFBUWdRLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCNUUsU0FBMUIsQ0FBZDtBQUNBLGdCQUFJLENBQUNuTCxLQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osZ0JBQU1vZixZQUFZcFAsUUFBUTVwQixLQUFSLENBQWMycEIsS0FBS0EsS0FBS25zQixNQUFMLEdBQWMsQ0FBbkIsQ0FBZCxFQUFxQ21zQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFuRCxFQUFzRHUyQixVQUF0RCxDQUFsQjtBQUNBLGdCQUFJLENBQUNpRixTQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osZ0JBQUlwZixNQUFNelgsSUFBTixDQUFXc2lCLElBQVgsS0FBb0IsT0FBcEIsSUFBK0JtRixRQUFRcFgsTUFBUixDQUFlLENBQWYsRUFBa0IrUyxZQUFsQixDQUErQnVULFNBQS9CLEVBQTBDbGYsTUFBTXpYLElBQWhELENBQW5DLEVBQTBGO0FBQ3RGLHVCQUFPLElBQVA7QUFDSDtBQUNELG1CQUFPLElBQUkwMkIsS0FBSixDQUFVQyxTQUFWLEVBQXFCL0UsVUFBckIsRUFBaUNuYSxLQUFqQyxFQUF3Q21mLEtBQXhDLEVBQStDbkYsT0FBL0MsRUFBd0RvRixTQUF4RCxDQUFQO0FBQ0g7Ozs7OztJQWdEQ1MsSTtBQUNGLGtCQUFZdDNCLElBQVosRUFBa0J1M0IsUUFBbEIsRUFBNEJWLFNBQTVCLEVBQXVDO0FBQUE7O0FBQ25DLGFBQUs3MkIsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsYUFBS3UzQixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLGFBQUtWLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0g7Ozs7aUNBNkJRL08sRyxFQUFLO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ1YsdUNBQWlDLEtBQUt5UCxRQUF0Qyx3SUFBZ0Q7QUFBQTs7QUFBQTs7QUFBQSx3QkFBcEN4ZSxJQUFvQztBQUFBLHdCQUE5QjVOLFlBQThCOztBQUM1Qyx3QkFBSTROLEtBQUtnUCxRQUFMLENBQWNELEdBQWQsQ0FBSixFQUF3QjtBQUNwQiwrQkFBTzNjLGFBQVc0YyxRQUFYLENBQW9CRCxHQUFwQixDQUFQO0FBQ0g7QUFDSjtBQUxTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTVYsbUJBQU8sS0FBSytPLFNBQUwsQ0FBZTlPLFFBQWYsQ0FBd0JELEdBQXhCLENBQVA7QUFDSDs7O2tDQUNTclQsRSxFQUFJO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ1YsdUNBQWlDLEtBQUs4aUIsUUFBdEMsd0lBQWdEO0FBQUE7O0FBQUE7O0FBQUEsd0JBQXBDeGUsSUFBb0M7QUFBQSx3QkFBOUI1TixZQUE4Qjs7QUFDNUNzSix1QkFBR3NFLElBQUg7QUFDQXRFLHVCQUFHdEosWUFBSDtBQUNIO0FBSlM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLVnNKLGVBQUcsS0FBS29pQixTQUFSO0FBQ0g7Ozt3Q0FDZTtBQUNaLG1CQUFPLEtBQUtVLFFBQUwsQ0FBY3ZQLEtBQWQsQ0FBb0I7QUFBQTtBQUFBLG9CQUFFd1AsQ0FBRjtBQUFBLG9CQUFLN2YsR0FBTDs7QUFBQSx1QkFBY0EsSUFBSXNRLGFBQUosRUFBZDtBQUFBLGFBQXBCLEtBQTBELEtBQUs0TyxTQUFMLENBQWU1TyxhQUFmLEVBQWpFO0FBQ0g7OztvQ0FDVztBQUNSLGdCQUFNdEIsYUFBYSxDQUFDLE1BQUQsQ0FBbkI7QUFDQSxpQkFBSzBDLFNBQUwsQ0FBZSxpQkFBUztBQUNwQjFDLDJCQUFXM3FCLElBQVgsQ0FBZ0JzdEIsTUFBTS9CLFNBQU4sRUFBaEI7QUFDSCxhQUZEO0FBR0EsbUJBQU9aLFVBQVA7QUFDSDs7OzhCQXBEWWEsSSxFQUFNQyxPLEVBQVM7QUFDeEIsZ0JBQUlELEtBQUtuc0IsTUFBTCxHQUFjLENBQWxCLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIscURBQWdFbW9CLEtBQUtuc0IsTUFBTCxHQUFjLENBQTlFLFFBQVA7QUFDSixnQkFBSW1zQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFkLEtBQW9CLENBQXhCLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIsd0NBQVA7QUFDSixnQkFBSXV5QixtQkFBSjtBQUNBLGdCQUFJbkssUUFBUUMsWUFBUixJQUF3QkQsUUFBUUMsWUFBUixDQUFxQnBGLElBQXJCLEtBQThCLE9BQTFELEVBQW1FO0FBQy9Ec1AsNkJBQWFuSyxRQUFRQyxZQUFyQjtBQUNIO0FBQ0QsZ0JBQU02UCxXQUFXLEVBQWpCO0FBQ0EsaUJBQUssSUFBSXY4QixJQUFJLENBQWIsRUFBZ0JBLElBQUl3c0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBbEMsRUFBcUNMLEtBQUssQ0FBMUMsRUFBNkM7QUFDekMsb0JBQU0rZCxPQUFPME8sUUFBUTVwQixLQUFSLENBQWMycEIsS0FBS3hzQixDQUFMLENBQWQsRUFBdUJBLENBQXZCLEVBQTBCeW5CLFdBQTFCLENBQWI7QUFDQSxvQkFBSSxDQUFDMUosSUFBTCxFQUNJLE9BQU8sSUFBUDtBQUNKLG9CQUFNN0UsU0FBU3VULFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUt4c0IsSUFBSSxDQUFULENBQWQsRUFBMkJBLElBQUksQ0FBL0IsRUFBa0M0MkIsVUFBbEMsQ0FBZjtBQUNBLG9CQUFJLENBQUMxZCxNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0pxakIseUJBQVN2N0IsSUFBVCxDQUFjLENBQ1YrYyxJQURVLEVBRVY3RSxNQUZVLENBQWQ7QUFJQTBkLDZCQUFhQSxjQUFjMWQsT0FBT2xVLElBQWxDO0FBQ0g7QUFDRCxnQkFBTTYyQixZQUFZcFAsUUFBUTVwQixLQUFSLENBQWMycEIsS0FBS0EsS0FBS25zQixNQUFMLEdBQWMsQ0FBbkIsQ0FBZCxFQUFxQ21zQixLQUFLbnNCLE1BQUwsR0FBYyxDQUFuRCxFQUFzRHUyQixVQUF0RCxDQUFsQjtBQUNBLGdCQUFJLENBQUNpRixTQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osbUJBQU8sSUFBSVMsSUFBSixDQUFTMUYsVUFBVCxFQUFxQjJGLFFBQXJCLEVBQStCVixTQUEvQixDQUFQO0FBQ0g7Ozs7OztJQTRCQ1ksSztBQUNGLG1CQUFZejNCLElBQVosRUFBa0J5WCxLQUFsQixFQUF5QmlnQixVQUF6QixFQUFxQ0MsUUFBckMsRUFBK0M7QUFBQTs7QUFDM0MsYUFBSzMzQixJQUFMLEdBQVlBLElBQVo7QUFDQSxhQUFLeVgsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS2lnQixVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLGFBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0g7Ozs7aUNBeUJRN1AsRyxFQUFLO0FBQ1YsZ0JBQU1yUSxRQUFRLEtBQUtBLEtBQUwsQ0FBV3NRLFFBQVgsQ0FBb0JELEdBQXBCLENBQWQ7QUFDQSxnQkFBTTRQLGFBQWEsS0FBS0EsVUFBTCxDQUFnQjNQLFFBQWhCLENBQXlCRCxHQUF6QixDQUFuQjtBQUNBLGdCQUFJLENBQUNwRSxrQkFBa0JqTSxLQUFsQixFQUF5QixDQUN0QixRQURzQixFQUV0QixPQUZzQixDQUF6QixDQUFMLEVBR1E7QUFDSixzQkFBTSxJQUFJa1EsWUFBSix1RUFBc0ZqbkIsU0FBUzBtQixPQUFPM1AsS0FBUCxDQUFULENBQXRGLGVBQU47QUFDSDtBQUNELGdCQUFJLEtBQUtrZ0IsUUFBVCxFQUFtQjtBQUNmLG9CQUFNQSxXQUFXLEtBQUtBLFFBQUwsQ0FBYzVQLFFBQWQsQ0FBdUJELEdBQXZCLENBQWpCO0FBQ0EsdUJBQU9yUSxNQUFNdFIsS0FBTixDQUFZdXhCLFVBQVosRUFBd0JDLFFBQXhCLENBQVA7QUFDSDtBQUNELG1CQUFPbGdCLE1BQU10UixLQUFOLENBQVl1eEIsVUFBWixDQUFQO0FBQ0g7OztrQ0FDU2pqQixFLEVBQUk7QUFDVkEsZUFBRyxLQUFLZ0QsS0FBUjtBQUNBaEQsZUFBRyxLQUFLaWpCLFVBQVI7QUFDQSxnQkFBSSxLQUFLQyxRQUFULEVBQW1CO0FBQ2ZsakIsbUJBQUcsS0FBS2tqQixRQUFSO0FBQ0g7QUFDSjs7O3dDQUNlO0FBQ1osbUJBQU8sS0FBUDtBQUNIOzs7b0NBQ1c7QUFDUixnQkFBSSxLQUFLQSxRQUFMLElBQWlCLElBQWpCLElBQXlCLEtBQUtBLFFBQUwsS0FBa0IzNEIsU0FBL0MsRUFBMEQ7QUFDdEQsb0JBQU0yNEIsV0FBVyxLQUFLQSxRQUFMLENBQWNwUSxTQUFkLEVBQWpCO0FBQ0EsdUJBQU8sQ0FDSCxPQURHLEVBRUgsS0FBSzlQLEtBQUwsQ0FBVzhQLFNBQVgsRUFGRyxFQUdILEtBQUttUSxVQUFMLENBQWdCblEsU0FBaEIsRUFIRyxFQUlIb1EsUUFKRyxDQUFQO0FBTUg7QUFDRCxtQkFBTyxDQUNILE9BREcsRUFFSCxLQUFLbGdCLEtBQUwsQ0FBVzhQLFNBQVgsRUFGRyxFQUdILEtBQUttUSxVQUFMLENBQWdCblEsU0FBaEIsRUFIRyxDQUFQO0FBS0g7Ozs4QkFoRVlDLEksRUFBTUMsTyxFQUFTO0FBQ3hCLGdCQUFJRCxLQUFLbnNCLE1BQUwsSUFBZSxDQUFmLElBQW9CbXNCLEtBQUtuc0IsTUFBTCxJQUFlLENBQXZDLEVBQTBDO0FBQ3RDLHVCQUFPb3NCLFFBQVFwb0IsS0FBUiw0Q0FBdURtb0IsS0FBS25zQixNQUFMLEdBQWMsQ0FBckUsZ0JBQVA7QUFDSDtBQUNELGdCQUFNb2MsUUFBUWdRLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCNUUsU0FBMUIsQ0FBZDtBQUNBLGdCQUFNOFUsYUFBYWpRLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCakYsVUFBMUIsQ0FBbkI7QUFDQSxnQkFBSSxDQUFDOUssS0FBRCxJQUFVLENBQUNpZ0IsVUFBZixFQUNJLE9BQU8sSUFBUDtBQUNKLGdCQUFJLENBQUNuVSxZQUFZOUwsTUFBTXpYLElBQWxCLEVBQXdCLENBQ3JCbU8sTUFBTXlVLFNBQU4sQ0FEcUIsRUFFckJKLFVBRnFCLEVBR3JCSSxTQUhxQixDQUF4QixDQUFMLEVBSVE7QUFDSix1QkFBTzZFLFFBQVFwb0IsS0FBUix1RUFBbUZxQixTQUFTK1csTUFBTXpYLElBQWYsQ0FBbkYsY0FBUDtBQUNIO0FBQ0QsZ0JBQUl3bkIsS0FBS25zQixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLG9CQUFNczhCLFdBQVdsUSxRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQmpGLFVBQTFCLENBQWpCO0FBQ0Esb0JBQUksQ0FBQ29WLFFBQUwsRUFDSSxPQUFPLElBQVA7QUFDSix1QkFBTyxJQUFJRixLQUFKLENBQVVoZ0IsTUFBTXpYLElBQWhCLEVBQXNCeVgsS0FBdEIsRUFBNkJpZ0IsVUFBN0IsRUFBeUNDLFFBQXpDLENBQVA7QUFDSCxhQUxELE1BS087QUFDSCx1QkFBTyxJQUFJRixLQUFKLENBQVVoZ0IsTUFBTXpYLElBQWhCLEVBQXNCeVgsS0FBdEIsRUFBNkJpZ0IsVUFBN0IsQ0FBUDtBQUNIO0FBQ0o7Ozs7OztBQTRDTCxTQUFTRSxnQkFBVCxDQUEwQmpULEVBQTFCLEVBQThCM2tCLElBQTlCLEVBQW9DO0FBQ2hDLFFBQUkya0IsT0FBTyxJQUFQLElBQWVBLE9BQU8sSUFBMUIsRUFBZ0M7QUFDNUIsZUFBTzNrQixLQUFLc2lCLElBQUwsS0FBYyxTQUFkLElBQTJCdGlCLEtBQUtzaUIsSUFBTCxLQUFjLFFBQXpDLElBQXFEdGlCLEtBQUtzaUIsSUFBTCxLQUFjLFFBQW5FLElBQStFdGlCLEtBQUtzaUIsSUFBTCxLQUFjLE1BQTdGLElBQXVHdGlCLEtBQUtzaUIsSUFBTCxLQUFjLE9BQTVIO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBT3RpQixLQUFLc2lCLElBQUwsS0FBYyxRQUFkLElBQTBCdGlCLEtBQUtzaUIsSUFBTCxLQUFjLFFBQXhDLElBQW9EdGlCLEtBQUtzaUIsSUFBTCxLQUFjLE9BQXpFO0FBQ0g7QUFDSjtBQUNELFNBQVN4SSxFQUFULENBQVlnTyxHQUFaLEVBQWlCN2hCLENBQWpCLEVBQW9CZ2YsQ0FBcEIsRUFBdUI7QUFDbkIsV0FBT2hmLE1BQU1nZixDQUFiO0FBQ0g7QUFDRCxTQUFTNFMsR0FBVCxDQUFhL1AsR0FBYixFQUFrQjdoQixDQUFsQixFQUFxQmdmLENBQXJCLEVBQXdCO0FBQ3BCLFdBQU9oZixNQUFNZ2YsQ0FBYjtBQUNIO0FBQ0QsU0FBUzZTLEVBQVQsQ0FBWWhRLEdBQVosRUFBaUI3aEIsQ0FBakIsRUFBb0JnZixDQUFwQixFQUF1QjtBQUNuQixXQUFPaGYsSUFBSWdmLENBQVg7QUFDSDtBQUNELFNBQVM4UyxFQUFULENBQVlqUSxHQUFaLEVBQWlCN2hCLENBQWpCLEVBQW9CZ2YsQ0FBcEIsRUFBdUI7QUFDbkIsV0FBT2hmLElBQUlnZixDQUFYO0FBQ0g7QUFDRCxTQUFTK1MsSUFBVCxDQUFjbFEsR0FBZCxFQUFtQjdoQixDQUFuQixFQUFzQmdmLENBQXRCLEVBQXlCO0FBQ3JCLFdBQU9oZixLQUFLZ2YsQ0FBWjtBQUNIO0FBQ0QsU0FBU2dULElBQVQsQ0FBY25RLEdBQWQsRUFBbUI3aEIsQ0FBbkIsRUFBc0JnZixDQUF0QixFQUF5QjtBQUNyQixXQUFPaGYsS0FBS2dmLENBQVo7QUFDSDtBQUNELFNBQVNpVCxTQUFULENBQW1CcFEsR0FBbkIsRUFBd0I3aEIsQ0FBeEIsRUFBMkJnZixDQUEzQixFQUE4QitELENBQTlCLEVBQWlDO0FBQzdCLFdBQU9BLEVBQUUvQyxPQUFGLENBQVVoZ0IsQ0FBVixFQUFhZ2YsQ0FBYixNQUFvQixDQUEzQjtBQUNIO0FBQ0QsU0FBU2tULFVBQVQsQ0FBb0JyUSxHQUFwQixFQUF5QjdoQixDQUF6QixFQUE0QmdmLENBQTVCLEVBQStCK0QsQ0FBL0IsRUFBa0M7QUFDOUIsV0FBTyxDQUFDa1AsVUFBVXBRLEdBQVYsRUFBZTdoQixDQUFmLEVBQWtCZ2YsQ0FBbEIsRUFBcUIrRCxDQUFyQixDQUFSO0FBQ0g7QUFDRCxTQUFTb1AsU0FBVCxDQUFtQnRRLEdBQW5CLEVBQXdCN2hCLENBQXhCLEVBQTJCZ2YsQ0FBM0IsRUFBOEIrRCxDQUE5QixFQUFpQztBQUM3QixXQUFPQSxFQUFFL0MsT0FBRixDQUFVaGdCLENBQVYsRUFBYWdmLENBQWIsSUFBa0IsQ0FBekI7QUFDSDtBQUNELFNBQVNvVCxTQUFULENBQW1CdlEsR0FBbkIsRUFBd0I3aEIsQ0FBeEIsRUFBMkJnZixDQUEzQixFQUE4QitELENBQTlCLEVBQWlDO0FBQzdCLFdBQU9BLEVBQUUvQyxPQUFGLENBQVVoZ0IsQ0FBVixFQUFhZ2YsQ0FBYixJQUFrQixDQUF6QjtBQUNIO0FBQ0QsU0FBU3FULFdBQVQsQ0FBcUJ4USxHQUFyQixFQUEwQjdoQixDQUExQixFQUE2QmdmLENBQTdCLEVBQWdDK0QsQ0FBaEMsRUFBbUM7QUFDL0IsV0FBT0EsRUFBRS9DLE9BQUYsQ0FBVWhnQixDQUFWLEVBQWFnZixDQUFiLEtBQW1CLENBQTFCO0FBQ0g7QUFDRCxTQUFTc1QsV0FBVCxDQUFxQnpRLEdBQXJCLEVBQTBCN2hCLENBQTFCLEVBQTZCZ2YsQ0FBN0IsRUFBZ0MrRCxDQUFoQyxFQUFtQztBQUMvQixXQUFPQSxFQUFFL0MsT0FBRixDQUFVaGdCLENBQVYsRUFBYWdmLENBQWIsS0FBbUIsQ0FBMUI7QUFDSDtBQUNELFNBQVN1VCxjQUFULENBQXdCN1QsRUFBeEIsRUFBNEI4VCxZQUE1QixFQUEwQ0MsbUJBQTFDLEVBQStEO0FBQzNELFFBQU1DLG9CQUFvQmhVLE9BQU8sSUFBUCxJQUFlQSxPQUFPLElBQWhEO0FBQ0E7QUFDSSw0QkFBWW9CLEdBQVosRUFBaUJDLEdBQWpCLEVBQXNCbFgsUUFBdEIsRUFBZ0M7QUFBQTs7QUFDNUIsaUJBQUs5TyxJQUFMLEdBQVl5aUIsV0FBWjtBQUNBLGlCQUFLc0QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsaUJBQUtDLEdBQUwsR0FBV0EsR0FBWDtBQUNBLGlCQUFLbFgsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxpQkFBSzhwQixrQkFBTCxHQUEwQjdTLElBQUkvbEIsSUFBSixDQUFTc2lCLElBQVQsS0FBa0IsT0FBbEIsSUFBNkIwRCxJQUFJaG1CLElBQUosQ0FBU3NpQixJQUFULEtBQWtCLE9BQXpFO0FBQ0g7O0FBUEw7QUFBQTtBQUFBLHFDQTZDYXdGLEdBN0NiLEVBNkNrQjtBQUNWLG9CQUFNL0IsTUFBTSxLQUFLQSxHQUFMLENBQVNnQyxRQUFULENBQWtCRCxHQUFsQixDQUFaO0FBQ0Esb0JBQU05QixNQUFNLEtBQUtBLEdBQUwsQ0FBUytCLFFBQVQsQ0FBa0JELEdBQWxCLENBQVo7QUFDQSxvQkFBSTZRLHFCQUFxQixLQUFLQyxrQkFBOUIsRUFBa0Q7QUFDOUMsd0JBQU1kLE1BQUsxUSxPQUFPckIsR0FBUCxDQUFYO0FBQ0Esd0JBQU04UyxLQUFLelIsT0FBT3BCLEdBQVAsQ0FBWDtBQUNBLHdCQUFJOFIsSUFBR3hWLElBQUgsS0FBWXVXLEdBQUd2VyxJQUFmLElBQXVCLEVBQUV3VixJQUFHeFYsSUFBSCxLQUFZLFFBQVosSUFBd0J3VixJQUFHeFYsSUFBSCxLQUFZLFFBQXRDLENBQTNCLEVBQTRFO0FBQ3hFLDhCQUFNLElBQUlxRixZQUFKLCtCQUE2Q2hELEVBQTdDLGtFQUE2R21ULElBQUd4VixJQUFoSCxVQUEySHVXLEdBQUd2VyxJQUE5SCxnQkFBTjtBQUNIO0FBQ0o7QUFDRCxvQkFBSSxLQUFLeFQsUUFBTCxJQUFpQixDQUFDNnBCLGlCQUFsQixJQUF1QyxLQUFLQyxrQkFBaEQsRUFBb0U7QUFDaEUsd0JBQU1kLE9BQUsxUSxPQUFPckIsR0FBUCxDQUFYO0FBQ0Esd0JBQU04UyxNQUFLelIsT0FBT3BCLEdBQVAsQ0FBWDtBQUNBLHdCQUFJOFIsS0FBR3hWLElBQUgsS0FBWSxRQUFaLElBQXdCdVcsSUFBR3ZXLElBQUgsS0FBWSxRQUF4QyxFQUFrRDtBQUM5QywrQkFBT21XLGFBQWEzUSxHQUFiLEVBQWtCL0IsR0FBbEIsRUFBdUJDLEdBQXZCLENBQVA7QUFDSDtBQUNKO0FBQ0QsdUJBQU8sS0FBS2xYLFFBQUwsR0FBZ0I0cEIsb0JBQW9CNVEsR0FBcEIsRUFBeUIvQixHQUF6QixFQUE4QkMsR0FBOUIsRUFBbUMsS0FBS2xYLFFBQUwsQ0FBY2laLFFBQWQsQ0FBdUJELEdBQXZCLENBQW5DLENBQWhCLEdBQWtGMlEsYUFBYTNRLEdBQWIsRUFBa0IvQixHQUFsQixFQUF1QkMsR0FBdkIsQ0FBekY7QUFDSDtBQS9ETDtBQUFBO0FBQUEsc0NBZ0VjdlIsRUFoRWQsRUFnRWtCO0FBQ1ZBLG1CQUFHLEtBQUtzUixHQUFSO0FBQ0F0UixtQkFBRyxLQUFLdVIsR0FBUjtBQUNBLG9CQUFJLEtBQUtsWCxRQUFULEVBQW1CO0FBQ2YyRix1QkFBRyxLQUFLM0YsUUFBUjtBQUNIO0FBQ0o7QUF0RUw7QUFBQTtBQUFBLDRDQXVFb0I7QUFDWix1QkFBTyxJQUFQO0FBQ0g7QUF6RUw7QUFBQTtBQUFBLHdDQTBFZ0I7QUFDUixvQkFBTTZYLGFBQWEsQ0FBQ2hDLEVBQUQsQ0FBbkI7QUFDQSxxQkFBSzBFLFNBQUwsQ0FBZSxpQkFBUztBQUNwQjFDLCtCQUFXM3FCLElBQVgsQ0FBZ0JzdEIsTUFBTS9CLFNBQU4sRUFBaEI7QUFDSCxpQkFGRDtBQUdBLHVCQUFPWixVQUFQO0FBQ0g7QUFoRkw7QUFBQTtBQUFBLGtDQVFpQmEsSUFSakIsRUFRdUJDLE9BUnZCLEVBUWdDO0FBQ3hCLG9CQUFJRCxLQUFLbnNCLE1BQUwsS0FBZ0IsQ0FBaEIsSUFBcUJtc0IsS0FBS25zQixNQUFMLEtBQWdCLENBQXpDLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIsb0NBQVA7QUFDSixvQkFBTXNsQixLQUFLNkMsS0FBSyxDQUFMLENBQVg7QUFDQSxvQkFBSXpCLE1BQU0wQixRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQjVFLFNBQTFCLENBQVY7QUFDQSxvQkFBSSxDQUFDbUQsR0FBTCxFQUNJLE9BQU8sSUFBUDtBQUNKLG9CQUFJLENBQUM2UixpQkFBaUJqVCxFQUFqQixFQUFxQm9CLElBQUkvbEIsSUFBekIsQ0FBTCxFQUFxQztBQUNqQywyQkFBT3luQixRQUFRcFgsTUFBUixDQUFlLENBQWYsRUFBa0JoUixLQUFsQixRQUE2QnNsQixFQUE3QixtREFBOEVqa0IsU0FBU3FsQixJQUFJL2xCLElBQWIsQ0FBOUUsUUFBUDtBQUNIO0FBQ0Qsb0JBQUlnbUIsTUFBTXlCLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCNUUsU0FBMUIsQ0FBVjtBQUNBLG9CQUFJLENBQUNvRCxHQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osb0JBQUksQ0FBQzRSLGlCQUFpQmpULEVBQWpCLEVBQXFCcUIsSUFBSWhtQixJQUF6QixDQUFMLEVBQXFDO0FBQ2pDLDJCQUFPeW5CLFFBQVFwWCxNQUFSLENBQWUsQ0FBZixFQUFrQmhSLEtBQWxCLFFBQTZCc2xCLEVBQTdCLG1EQUE4RWprQixTQUFTc2xCLElBQUlobUIsSUFBYixDQUE5RSxRQUFQO0FBQ0g7QUFDRCxvQkFBSStsQixJQUFJL2xCLElBQUosQ0FBU3NpQixJQUFULEtBQWtCMEQsSUFBSWhtQixJQUFKLENBQVNzaUIsSUFBM0IsSUFBbUN5RCxJQUFJL2xCLElBQUosQ0FBU3NpQixJQUFULEtBQWtCLE9BQXJELElBQWdFMEQsSUFBSWhtQixJQUFKLENBQVNzaUIsSUFBVCxLQUFrQixPQUF0RixFQUErRjtBQUMzRiwyQkFBT21GLFFBQVFwb0IsS0FBUiw0QkFBd0NxQixTQUFTcWxCLElBQUkvbEIsSUFBYixDQUF4QyxlQUFzRVUsU0FBU3NsQixJQUFJaG1CLElBQWIsQ0FBdEUsUUFBUDtBQUNIO0FBQ0Qsb0JBQUkyNEIsaUJBQUosRUFBdUI7QUFDbkIsd0JBQUk1UyxJQUFJL2xCLElBQUosQ0FBU3NpQixJQUFULEtBQWtCLE9BQWxCLElBQTZCMEQsSUFBSWhtQixJQUFKLENBQVNzaUIsSUFBVCxLQUFrQixPQUFuRCxFQUE0RDtBQUN4RHlELDhCQUFNLElBQUk4QixTQUFKLENBQWM3QixJQUFJaG1CLElBQWxCLEVBQXdCLENBQUMrbEIsR0FBRCxDQUF4QixDQUFOO0FBQ0gscUJBRkQsTUFFTyxJQUFJQSxJQUFJL2xCLElBQUosQ0FBU3NpQixJQUFULEtBQWtCLE9BQWxCLElBQTZCMEQsSUFBSWhtQixJQUFKLENBQVNzaUIsSUFBVCxLQUFrQixPQUFuRCxFQUE0RDtBQUMvRDBELDhCQUFNLElBQUk2QixTQUFKLENBQWM5QixJQUFJL2xCLElBQWxCLEVBQXdCLENBQUNnbUIsR0FBRCxDQUF4QixDQUFOO0FBQ0g7QUFDSjtBQUNELG9CQUFJbFgsV0FBVyxJQUFmO0FBQ0Esb0JBQUkwWSxLQUFLbnNCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsd0JBQUkwcUIsSUFBSS9sQixJQUFKLENBQVNzaUIsSUFBVCxLQUFrQixRQUFsQixJQUE4QjBELElBQUlobUIsSUFBSixDQUFTc2lCLElBQVQsS0FBa0IsUUFBaEQsSUFBNER5RCxJQUFJL2xCLElBQUosQ0FBU3NpQixJQUFULEtBQWtCLE9BQTlFLElBQXlGMEQsSUFBSWhtQixJQUFKLENBQVNzaUIsSUFBVCxLQUFrQixPQUEvRyxFQUF3SDtBQUNwSCwrQkFBT21GLFFBQVFwb0IsS0FBUixvREFBUDtBQUNIO0FBQ0R5UCwrQkFBVzJZLFFBQVE1cEIsS0FBUixDQUFjMnBCLEtBQUssQ0FBTCxDQUFkLEVBQXVCLENBQXZCLEVBQTBCMUUsWUFBMUIsQ0FBWDtBQUNBLHdCQUFJLENBQUNoVSxRQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ1A7QUFDRCx1QkFBTyxJQUFJZ3FCLFVBQUosQ0FBZS9TLEdBQWYsRUFBb0JDLEdBQXBCLEVBQXlCbFgsUUFBekIsQ0FBUDtBQUNIO0FBNUNMOztBQUFBO0FBQUE7QUFrRkg7QUFDRCxJQUFNaXFCLFNBQVNQLGVBQWUsSUFBZixFQUFxQjFlLEVBQXJCLEVBQXlCb2UsU0FBekIsQ0FBZjtBQUNBLElBQU1jLFlBQVlSLGVBQWUsSUFBZixFQUFxQlgsR0FBckIsRUFBMEJNLFVBQTFCLENBQWxCO0FBQ0EsSUFBTWMsV0FBV1QsZUFBZSxHQUFmLEVBQW9CVixFQUFwQixFQUF3Qk0sU0FBeEIsQ0FBakI7QUFDQSxJQUFNYyxjQUFjVixlQUFlLEdBQWYsRUFBb0JULEVBQXBCLEVBQXdCTSxTQUF4QixDQUFwQjtBQUNBLElBQU1jLGtCQUFrQlgsZUFBZSxJQUFmLEVBQXFCUixJQUFyQixFQUEyQk0sV0FBM0IsQ0FBeEI7QUFDQSxJQUFNYyxxQkFBcUJaLGVBQWUsSUFBZixFQUFxQlAsSUFBckIsRUFBMkJNLFdBQTNCLENBQTNCOztJQUVNYyxZO0FBQ0YsMEJBQVkxcUIsTUFBWixFQUFvQmdYLE1BQXBCLEVBQTRCMlQsUUFBNUIsRUFBc0NDLGlCQUF0QyxFQUF5REMsaUJBQXpELEVBQTRFO0FBQUE7O0FBQ3hFLGFBQUt4NUIsSUFBTCxHQUFZd2lCLFVBQVo7QUFDQSxhQUFLN1QsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS2dYLE1BQUwsR0FBY0EsTUFBZDtBQUNBLGFBQUsyVCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLGFBQUtDLGlCQUFMLEdBQXlCQSxpQkFBekI7QUFDQSxhQUFLQyxpQkFBTCxHQUF5QkEsaUJBQXpCO0FBQ0g7Ozs7aUNBb0NRMVIsRyxFQUFLO0FBQ1YsbUJBQU8sSUFBSWpDLEtBQUt3VCxZQUFULENBQXNCLEtBQUsxVCxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZb0MsUUFBWixDQUFxQkQsR0FBckIsQ0FBZCxHQUEwQyxFQUFoRSxFQUFvRTtBQUN2RXhvQix1QkFBTyxLQUFLZzZCLFFBQUwsR0FBZ0IsVUFBaEIsR0FBNkIsU0FEbUM7QUFFdkVBLDBCQUFVLEtBQUtBLFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxDQUFjdlIsUUFBZCxDQUF1QkQsR0FBdkIsQ0FBaEIsR0FBOEM5b0IsU0FGZTtBQUd2RXk2Qix1Q0FBdUIsS0FBS0YsaUJBQUwsR0FBeUIsS0FBS0EsaUJBQUwsQ0FBdUJ4UixRQUF2QixDQUFnQ0QsR0FBaEMsQ0FBekIsR0FBZ0U5b0IsU0FIaEI7QUFJdkUwNkIsdUNBQXVCLEtBQUtGLGlCQUFMLEdBQXlCLEtBQUtBLGlCQUFMLENBQXVCelIsUUFBdkIsQ0FBZ0NELEdBQWhDLENBQXpCLEdBQWdFOW9CO0FBSmhCLGFBQXBFLEVBS0o4RSxNQUxJLENBS0csS0FBSzZLLE1BQUwsQ0FBWW9aLFFBQVosQ0FBcUJELEdBQXJCLENBTEgsQ0FBUDtBQU1IOzs7a0NBQ1NyVCxFLEVBQUk7QUFDVkEsZUFBRyxLQUFLOUYsTUFBUjtBQUNBLGdCQUFJLEtBQUtnWCxNQUFULEVBQWlCO0FBQ2JsUixtQkFBRyxLQUFLa1IsTUFBUjtBQUNIO0FBQ0QsZ0JBQUksS0FBSzJULFFBQVQsRUFBbUI7QUFDZjdrQixtQkFBRyxLQUFLNmtCLFFBQVI7QUFDSDtBQUNELGdCQUFJLEtBQUtDLGlCQUFULEVBQTRCO0FBQ3hCOWtCLG1CQUFHLEtBQUs4a0IsaUJBQVI7QUFDSDtBQUNELGdCQUFJLEtBQUtDLGlCQUFULEVBQTRCO0FBQ3hCL2tCLG1CQUFHLEtBQUsra0IsaUJBQVI7QUFDSDtBQUNKOzs7d0NBQ2U7QUFDWixtQkFBTyxLQUFQO0FBQ0g7OztvQ0FDVztBQUNSLGdCQUFNNW1CLFVBQVUsRUFBaEI7QUFDQSxnQkFBSSxLQUFLK1MsTUFBVCxFQUFpQjtBQUNiL1Msd0JBQVEsUUFBUixJQUFvQixLQUFLK1MsTUFBTCxDQUFZNEIsU0FBWixFQUFwQjtBQUNIO0FBQ0QsZ0JBQUksS0FBSytSLFFBQVQsRUFBbUI7QUFDZjFtQix3QkFBUSxVQUFSLElBQXNCLEtBQUswbUIsUUFBTCxDQUFjL1IsU0FBZCxFQUF0QjtBQUNIO0FBQ0QsZ0JBQUksS0FBS2dTLGlCQUFULEVBQTRCO0FBQ3hCM21CLHdCQUFRLHFCQUFSLElBQWlDLEtBQUsybUIsaUJBQUwsQ0FBdUJoUyxTQUF2QixFQUFqQztBQUNIO0FBQ0QsZ0JBQUksS0FBS2lTLGlCQUFULEVBQTRCO0FBQ3hCNW1CLHdCQUFRLHFCQUFSLElBQWlDLEtBQUs0bUIsaUJBQUwsQ0FBdUJqUyxTQUF2QixFQUFqQztBQUNIO0FBQ0QsbUJBQU8sQ0FDSCxlQURHLEVBRUgsS0FBSzVZLE1BQUwsQ0FBWTRZLFNBQVosRUFGRyxFQUdIM1UsT0FIRyxDQUFQO0FBS0g7Ozs4QkFoRlk0VSxJLEVBQU1DLE8sRUFBUztBQUN4QixnQkFBSUQsS0FBS25zQixNQUFMLEtBQWdCLENBQXBCLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIsMkJBQVA7QUFDSixnQkFBTXNQLFNBQVM4WSxRQUFRNXBCLEtBQVIsQ0FBYzJwQixLQUFLLENBQUwsQ0FBZCxFQUF1QixDQUF2QixFQUEwQmpGLFVBQTFCLENBQWY7QUFDQSxnQkFBSSxDQUFDNVQsTUFBTCxFQUNJLE9BQU8sSUFBUDtBQUNKLGdCQUFNaUUsVUFBVTRVLEtBQUssQ0FBTCxDQUFoQjtBQUNBLGdCQUFJLFFBQU81VSxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQStCMVgsTUFBTUMsT0FBTixDQUFjeVgsT0FBZCxDQUFuQyxFQUNJLE9BQU82VSxRQUFRcG9CLEtBQVIsb0RBQVA7QUFDSixnQkFBSXNtQixTQUFTLElBQWI7QUFDQSxnQkFBSS9TLFFBQVEsUUFBUixDQUFKLEVBQXVCO0FBQ25CK1MseUJBQVM4QixRQUFRNXBCLEtBQVIsQ0FBYytVLFFBQVEsUUFBUixDQUFkLEVBQWlDLENBQWpDLEVBQW9DNFAsVUFBcEMsQ0FBVDtBQUNBLG9CQUFJLENBQUNtRCxNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ1A7QUFDRCxnQkFBSTJULFdBQVcsSUFBZjtBQUNBLGdCQUFJMW1CLFFBQVEsVUFBUixDQUFKLEVBQXlCO0FBQ3JCMG1CLDJCQUFXN1IsUUFBUTVwQixLQUFSLENBQWMrVSxRQUFRLFVBQVIsQ0FBZCxFQUFtQyxDQUFuQyxFQUFzQzRQLFVBQXRDLENBQVg7QUFDQSxvQkFBSSxDQUFDOFcsUUFBTCxFQUNJLE9BQU8sSUFBUDtBQUNQO0FBQ0QsZ0JBQUlDLG9CQUFvQixJQUF4QjtBQUNBLGdCQUFJM21CLFFBQVEscUJBQVIsQ0FBSixFQUFvQztBQUNoQzJtQixvQ0FBb0I5UixRQUFRNXBCLEtBQVIsQ0FBYytVLFFBQVEscUJBQVIsQ0FBZCxFQUE4QyxDQUE5QyxFQUFpRDJQLFVBQWpELENBQXBCO0FBQ0Esb0JBQUksQ0FBQ2dYLGlCQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ1A7QUFDRCxnQkFBSUMsb0JBQW9CLElBQXhCO0FBQ0EsZ0JBQUk1bUIsUUFBUSxxQkFBUixDQUFKLEVBQW9DO0FBQ2hDNG1CLG9DQUFvQi9SLFFBQVE1cEIsS0FBUixDQUFjK1UsUUFBUSxxQkFBUixDQUFkLEVBQThDLENBQTlDLEVBQWlEMlAsVUFBakQsQ0FBcEI7QUFDQSxvQkFBSSxDQUFDaVgsaUJBQUwsRUFDSSxPQUFPLElBQVA7QUFDUDtBQUNELG1CQUFPLElBQUlILFlBQUosQ0FBaUIxcUIsTUFBakIsRUFBeUJnWCxNQUF6QixFQUFpQzJULFFBQWpDLEVBQTJDQyxpQkFBM0MsRUFBOERDLGlCQUE5RCxDQUFQO0FBQ0g7Ozs7OztJQWlEQ0csTTtBQUNGLG9CQUFZbGlCLEtBQVosRUFBbUI7QUFBQTs7QUFDZixhQUFLelgsSUFBTCxHQUFZdWlCLFVBQVo7QUFDQSxhQUFLOUssS0FBTCxHQUFhQSxLQUFiO0FBQ0g7Ozs7aUNBV1FxUSxHLEVBQUs7QUFDVixnQkFBTXJRLFFBQVEsS0FBS0EsS0FBTCxDQUFXc1EsUUFBWCxDQUFvQkQsR0FBcEIsQ0FBZDtBQUNBLGdCQUFJLE9BQU9yUSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLHVCQUFPQSxNQUFNcGMsTUFBYjtBQUNILGFBRkQsTUFFTyxJQUFJSCxNQUFNQyxPQUFOLENBQWNzYyxLQUFkLENBQUosRUFBMEI7QUFDN0IsdUJBQU9BLE1BQU1wYyxNQUFiO0FBQ0gsYUFGTSxNQUVBO0FBQ0gsc0JBQU0sSUFBSXNzQixZQUFKLDhEQUE2RWpuQixTQUFTMG1CLE9BQU8zUCxLQUFQLENBQVQsQ0FBN0UsZUFBTjtBQUNIO0FBQ0o7OztrQ0FDU2hELEUsRUFBSTtBQUNWQSxlQUFHLEtBQUtnRCxLQUFSO0FBQ0g7Ozt3Q0FDZTtBQUNaLG1CQUFPLEtBQVA7QUFDSDs7O29DQUNXO0FBQ1IsZ0JBQU1rUCxhQUFhLENBQUMsUUFBRCxDQUFuQjtBQUNBLGlCQUFLMEMsU0FBTCxDQUFlLGlCQUFTO0FBQ3BCMUMsMkJBQVczcUIsSUFBWCxDQUFnQnN0QixNQUFNL0IsU0FBTixFQUFoQjtBQUNILGFBRkQ7QUFHQSxtQkFBT1osVUFBUDtBQUNIOzs7OEJBaENZYSxJLEVBQU1DLE8sRUFBUztBQUN4QixnQkFBSUQsS0FBS25zQixNQUFMLEtBQWdCLENBQXBCLEVBQ0ksT0FBT29zQixRQUFRcG9CLEtBQVIsc0NBQWlEbW9CLEtBQUtuc0IsTUFBTCxHQUFjLENBQS9ELGdCQUFQO0FBQ0osZ0JBQU1vYyxRQUFRZ1EsUUFBUTVwQixLQUFSLENBQWMycEIsS0FBSyxDQUFMLENBQWQsRUFBdUIsQ0FBdkIsQ0FBZDtBQUNBLGdCQUFJLENBQUMvUCxLQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osZ0JBQUlBLE1BQU16WCxJQUFOLENBQVdzaUIsSUFBWCxLQUFvQixPQUFwQixJQUErQjdLLE1BQU16WCxJQUFOLENBQVdzaUIsSUFBWCxLQUFvQixRQUFuRCxJQUErRDdLLE1BQU16WCxJQUFOLENBQVdzaUIsSUFBWCxLQUFvQixPQUF2RixFQUNJLE9BQU9tRixRQUFRcG9CLEtBQVIsMkRBQXVFcUIsU0FBUytXLE1BQU16WCxJQUFmLENBQXZFLGVBQVA7QUFDSixtQkFBTyxJQUFJMjVCLE1BQUosQ0FBV2xpQixLQUFYLENBQVA7QUFDSDs7Ozs7O0FBMEJMLElBQU1taUIsY0FBYztBQUNoQixVQUFNYixNQURVO0FBRWhCLFVBQU1DLFNBRlU7QUFHaEIsU0FBS0UsV0FIVztBQUloQixTQUFLRCxRQUpXO0FBS2hCLFVBQU1HLGtCQUxVO0FBTWhCLFVBQU1ELGVBTlU7QUFPaEIsYUFBU3RSLFNBUE87QUFRaEIsVUFBTXVPLEVBUlU7QUFTaEIsZUFBV3ZPLFNBVEs7QUFVaEIsWUFBUXlQLElBVlE7QUFXaEIsZ0JBQVl4QixRQVhJO0FBWWhCLGdCQUFZckssa0JBWkk7QUFhaEIsY0FBVXRELGdCQWJNO0FBY2hCLGFBQVNPLGVBZE87QUFlaEIsVUFBTTJOLEVBZlU7QUFnQmhCLGdCQUFZRyxPQWhCSTtBQWlCaEIsbUJBQWV6QixXQWpCQztBQWtCaEIsdUJBQW1CQSxXQWxCSDtBQW1CaEIsdUJBQW1CQSxXQW5CSDtBQW9CaEIsY0FBVTRFLE1BcEJNO0FBcUJoQixXQUFPekQsR0FyQlM7QUFzQmhCLGVBQVc1TyxPQXRCSztBQXVCaEIsYUFBU29QLEtBdkJPO0FBd0JoQixjQUFVN08sU0F4Qk07QUF5QmhCLHFCQUFpQndSLFlBekJEO0FBMEJoQixjQUFVeFIsU0ExQk07QUEyQmhCLGFBQVM0UCxLQTNCTztBQTRCaEIsWUFBUWpHLElBNUJRO0FBNkJoQixjQUFVM0osU0E3Qk07QUE4QmhCLGtCQUFjaUIsUUE5QkU7QUErQmhCLGdCQUFZQSxRQS9CSTtBQWdDaEIsaUJBQWFBLFFBaENHO0FBaUNoQixpQkFBYUEsUUFqQ0c7QUFrQ2hCLFdBQU93SCxHQWxDUztBQW1DaEIsY0FBVU47QUFuQ00sQ0FBcEI7QUFxQ0EsU0FBU2hoQixJQUFULENBQWM4WSxHQUFkLFVBQWlDO0FBQUE7QUFBQSxRQUFiaHBCLENBQWE7QUFBQSxRQUFWa21CLENBQVU7QUFBQSxRQUFQQyxDQUFPO0FBQUEsUUFBSmhmLENBQUk7O0FBQzdCbkgsUUFBSUEsRUFBRWlwQixRQUFGLENBQVdELEdBQVgsQ0FBSjtBQUNBOUMsUUFBSUEsRUFBRStDLFFBQUYsQ0FBV0QsR0FBWCxDQUFKO0FBQ0E3QyxRQUFJQSxFQUFFOEMsUUFBRixDQUFXRCxHQUFYLENBQUo7QUFDQSxRQUFNL0MsUUFBUTllLElBQUlBLEVBQUU4aEIsUUFBRixDQUFXRCxHQUFYLENBQUosR0FBc0IsQ0FBcEM7QUFDQSxRQUFNem9CLFFBQVEybkIsYUFBYWxvQixDQUFiLEVBQWdCa21CLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQkYsS0FBdEIsQ0FBZDtBQUNBLFFBQUkxbEIsS0FBSixFQUNJLE1BQU0sSUFBSXNvQixZQUFKLENBQWlCdG9CLEtBQWpCLENBQU47QUFDSixXQUFPLElBQUlvQixLQUFKLENBQVUzQixJQUFJLEdBQUosR0FBVWltQixLQUFwQixFQUEyQkMsSUFBSSxHQUFKLEdBQVVELEtBQXJDLEVBQTRDRSxJQUFJLEdBQUosR0FBVUYsS0FBdEQsRUFBNkRBLEtBQTdELENBQVA7QUFDSDtBQUNELFNBQVN0WCxHQUFULENBQWFwSixHQUFiLEVBQWtCNk8sR0FBbEIsRUFBdUI7QUFDbkIsV0FBTzdPLE9BQU82TyxHQUFkO0FBQ0g7QUFDRCxTQUFTek0sR0FBVCxDQUFhcEMsR0FBYixFQUFrQjZPLEdBQWxCLEVBQXVCO0FBQ25CLFFBQU1vSCxJQUFJcEgsSUFBSTdPLEdBQUosQ0FBVjtBQUNBLFdBQU8sT0FBT2lXLENBQVAsS0FBYSxXQUFiLEdBQTJCLElBQTNCLEdBQWtDQSxDQUF6QztBQUNIO0FBQ0QsU0FBU3VmLFlBQVQsQ0FBc0J2ZixDQUF0QixFQUF5QnJVLENBQXpCLEVBQTRCakwsQ0FBNUIsRUFBK0IrYyxDQUEvQixFQUFrQztBQUM5QixXQUFPL2MsS0FBSytjLENBQVosRUFBZTtBQUNYLFlBQU1VLElBQUl6ZCxJQUFJK2MsQ0FBSixJQUFTLENBQW5CO0FBQ0EsWUFBSTlSLEVBQUV3UyxDQUFGLE1BQVM2QixDQUFiLEVBQ0ksT0FBTyxJQUFQO0FBQ0osWUFBSXJVLEVBQUV3UyxDQUFGLElBQU82QixDQUFYLEVBQ0l2QyxJQUFJVSxJQUFJLENBQVIsQ0FESixLQUdJemQsSUFBSXlkLElBQUksQ0FBUjtBQUNQO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTcWhCLE9BQVQsQ0FBaUI5NUIsSUFBakIsRUFBdUI7QUFDbkIsV0FBTyxFQUFFQSxVQUFGLEVBQVA7QUFDSDtBQUNEeXFCLG1CQUFtQnNQLFFBQW5CLENBQTRCSCxXQUE1QixFQUF5QztBQUNyQyxhQUFTLENBQ0wvVyxTQURLLEVBRUwsQ0FBQ0wsVUFBRCxDQUZLLEVBR0wsVUFBQ3NGLEdBQUQsVUFBYztBQUFBO0FBQUEsWUFBUHhOLENBQU87O0FBQ1YsY0FBTSxJQUFJcU4sWUFBSixDQUFpQnJOLEVBQUV5TixRQUFGLENBQVdELEdBQVgsQ0FBakIsQ0FBTjtBQUNILEtBTEksQ0FENEI7QUFRckMsY0FBVSxDQUNOdEYsVUFETSxFQUVOLENBQUNJLFNBQUQsQ0FGTSxFQUdOLFVBQUNrRixHQUFEO0FBQUE7QUFBQSxZQUFPeE4sQ0FBUDs7QUFBQSxlQUFjNVosU0FBUzBtQixPQUFPOU0sRUFBRXlOLFFBQUYsQ0FBV0QsR0FBWCxDQUFQLENBQVQsQ0FBZDtBQUFBLEtBSE0sQ0FSMkI7QUFhckMsZUFBVyxDQUNQM1osTUFBTW9VLFVBQU4sRUFBa0IsQ0FBbEIsQ0FETyxFQUVQLENBQUNHLFNBQUQsQ0FGTyxFQUdQLFVBQUNvRixHQUFELFVBQWM7QUFBQTtBQUFBLFlBQVB4TixDQUFPOztBQUNWLGVBQU9BLEVBQUV5TixRQUFGLENBQVdELEdBQVgsRUFBZ0I1QyxPQUFoQixFQUFQO0FBQ0gsS0FMTSxDQWIwQjtBQW9CckMsV0FBTyxDQUNIeEMsU0FERyxFQUVILENBQ0lILFVBREosRUFFSUEsVUFGSixFQUdJQSxVQUhKLENBRkcsRUFPSHZULElBUEcsQ0FwQjhCO0FBNkJyQyxZQUFRLENBQ0owVCxTQURJLEVBRUosQ0FDSUgsVUFESixFQUVJQSxVQUZKLEVBR0lBLFVBSEosRUFJSUEsVUFKSixDQUZJLEVBUUp2VCxJQVJJLENBN0I2QjtBQXVDckMsV0FBTztBQUNIaFAsY0FBTXlpQixXQURIO0FBRUhxSSxtQkFBVyxDQUNQLENBQ0ksQ0FBQ3RJLFVBQUQsQ0FESixFQUVJLFVBQUNzRixHQUFEO0FBQUE7QUFBQSxnQkFBT3pqQixHQUFQOztBQUFBLG1CQUFnQm9KLElBQUlwSixJQUFJMGpCLFFBQUosQ0FBYUQsR0FBYixDQUFKLEVBQXVCQSxJQUFJN1ksVUFBSixFQUF2QixDQUFoQjtBQUFBLFNBRkosQ0FETyxFQUtQLENBQ0ksQ0FDSXVULFVBREosRUFFSUcsVUFGSixDQURKLEVBS0ksVUFBQ21GLEdBQUQ7QUFBQTtBQUFBLGdCQUFPempCLEdBQVA7QUFBQSxnQkFBWTZPLEdBQVo7O0FBQUEsbUJBQXFCekYsSUFBSXBKLElBQUkwakIsUUFBSixDQUFhRCxHQUFiLENBQUosRUFBdUI1VSxJQUFJNlUsUUFBSixDQUFhRCxHQUFiLENBQXZCLENBQXJCO0FBQUEsU0FMSixDQUxPO0FBRlIsS0F2QzhCO0FBdURyQyxXQUFPO0FBQ0g5bkIsY0FBTTRpQixTQURIO0FBRUhrSSxtQkFBVyxDQUNQLENBQ0ksQ0FBQ3RJLFVBQUQsQ0FESixFQUVJLFVBQUNzRixHQUFEO0FBQUE7QUFBQSxnQkFBT3pqQixHQUFQOztBQUFBLG1CQUFnQm9DLElBQUlwQyxJQUFJMGpCLFFBQUosQ0FBYUQsR0FBYixDQUFKLEVBQXVCQSxJQUFJN1ksVUFBSixFQUF2QixDQUFoQjtBQUFBLFNBRkosQ0FETyxFQUtQLENBQ0ksQ0FDSXVULFVBREosRUFFSUcsVUFGSixDQURKLEVBS0ksVUFBQ21GLEdBQUQ7QUFBQTtBQUFBLGdCQUFPempCLEdBQVA7QUFBQSxnQkFBWTZPLEdBQVo7O0FBQUEsbUJBQXFCek0sSUFBSXBDLElBQUkwakIsUUFBSixDQUFhRCxHQUFiLENBQUosRUFBdUI1VSxJQUFJNlUsUUFBSixDQUFhRCxHQUFiLENBQXZCLENBQXJCO0FBQUEsU0FMSixDQUxPO0FBRlIsS0F2RDhCO0FBdUVyQyxxQkFBaUIsQ0FDYmxGLFNBRGEsRUFFYixDQUFDSixVQUFELENBRmEsRUFHYixVQUFDc0YsR0FBRDtBQUFBO0FBQUEsWUFBT3pqQixHQUFQOztBQUFBLGVBQWdCb0MsSUFBSXBDLElBQUkwakIsUUFBSixDQUFhRCxHQUFiLENBQUosRUFBdUJBLElBQUk2QixZQUFKLElBQW9CLEVBQTNDLENBQWhCO0FBQUEsS0FIYSxDQXZFb0I7QUE0RXJDLGtCQUFjLENBQ1ZoSCxVQURVLEVBRVYsRUFGVSxFQUdWO0FBQUEsZUFBT21GLElBQUk3WSxVQUFKLEVBQVA7QUFBQSxLQUhVLENBNUV1QjtBQWlGckMscUJBQWlCLENBQ2J1VCxVQURhLEVBRWIsRUFGYSxFQUdiO0FBQUEsZUFBT3NGLElBQUlvSSxZQUFKLEVBQVA7QUFBQSxLQUhhLENBakZvQjtBQXNGckMsVUFBTSxDQUNGdE4sU0FERSxFQUVGLEVBRkUsRUFHRjtBQUFBLGVBQU9rRixJQUFJbm9CLEVBQUosRUFBUDtBQUFBLEtBSEUsQ0F0RitCO0FBMkZyQyxZQUFRLENBQ0o0aUIsVUFESSxFQUVKLEVBRkksRUFHSjtBQUFBLGVBQU91RixJQUFJMkIsT0FBSixDQUFZcHBCLElBQW5CO0FBQUEsS0FISSxDQTNGNkI7QUFnR3JDLGFBQVMsQ0FDTGtpQixVQURLLEVBRUwsRUFGSyxFQUdMO0FBQUEsZUFBT3VGLElBQUkyQixPQUFKLENBQVluaUIsS0FBWixJQUFxQixDQUE1QjtBQUFBLEtBSEssQ0FoRzRCO0FBcUdyQyw0QkFBd0IsQ0FDcEJpYixVQURvQixFQUVwQixFQUZvQixFQUdwQjtBQUFBLGVBQU91RixJQUFJa1Msa0JBQUosRUFBUDtBQUFBLEtBSG9CLENBckdhO0FBMEdyQyx1QkFBbUIsQ0FDZnpYLFVBRGUsRUFFZixFQUZlLEVBR2Y7QUFBQSxlQUFPdUYsSUFBSTJCLE9BQUosQ0FBWXdRLGNBQVosSUFBOEIsQ0FBckM7QUFBQSxLQUhlLENBMUdrQjtBQStHckMscUJBQWlCLENBQ2IxWCxVQURhLEVBRWIsRUFGYSxFQUdiO0FBQUEsZUFBT3VGLElBQUkyQixPQUFKLENBQVl5USxZQUFaLElBQTRCLENBQW5DO0FBQUEsS0FIYSxDQS9Hb0I7QUFvSHJDLDJCQUF1QixDQUNuQjNYLFVBRG1CLEVBRW5CLEVBRm1CLEVBR25CO0FBQUEsZUFBT3VGLElBQUkyQixPQUFKLENBQVkwUSxpQkFBWixJQUFpQyxDQUF4QztBQUFBLEtBSG1CLENBcEhjO0FBeUhyQyxtQkFBZSxDQUNYdlgsU0FEVyxFQUVYLEVBRlcsRUFHWDtBQUFBLGVBQU9rRixJQUFJMkIsT0FBSixDQUFZdmEsV0FBWixLQUE0QmxRLFNBQTVCLEdBQXdDLElBQXhDLEdBQStDOG9CLElBQUkyQixPQUFKLENBQVl2YSxXQUFsRTtBQUFBLEtBSFcsQ0F6SHNCO0FBOEhyQyxTQUFLLENBQ0RxVCxVQURDLEVBRUR1WCxRQUFRdlgsVUFBUixDQUZDLEVBR0QsVUFBQ3VGLEdBQUQsRUFBTU4sSUFBTixFQUFlO0FBQ1gsWUFBSXRULFNBQVMsQ0FBYjtBQURXO0FBQUE7QUFBQTs7QUFBQTtBQUVYLG1DQUFrQnNULElBQWxCLHdJQUF3QjtBQUFBLG9CQUFibk8sR0FBYTs7QUFDcEJuRiwwQkFBVW1GLElBQUkwTyxRQUFKLENBQWFELEdBQWIsQ0FBVjtBQUNIO0FBSlU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLWCxlQUFPNVQsTUFBUDtBQUNILEtBVEEsQ0E5SGdDO0FBeUlyQyxTQUFLLENBQ0RxTyxVQURDLEVBRUR1WCxRQUFRdlgsVUFBUixDQUZDLEVBR0QsVUFBQ3VGLEdBQUQsRUFBTU4sSUFBTixFQUFlO0FBQ1gsWUFBSXRULFNBQVMsQ0FBYjtBQURXO0FBQUE7QUFBQTs7QUFBQTtBQUVYLG1DQUFrQnNULElBQWxCLHdJQUF3QjtBQUFBLG9CQUFibk8sR0FBYTs7QUFDcEJuRiwwQkFBVW1GLElBQUkwTyxRQUFKLENBQWFELEdBQWIsQ0FBVjtBQUNIO0FBSlU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFLWCxlQUFPNVQsTUFBUDtBQUNILEtBVEEsQ0F6SWdDO0FBb0pyQyxTQUFLO0FBQ0RsVSxjQUFNdWlCLFVBREw7QUFFRHVJLG1CQUFXLENBQ1AsQ0FDSSxDQUNJdkksVUFESixFQUVJQSxVQUZKLENBREosRUFLSSxVQUFDdUYsR0FBRDtBQUFBO0FBQUEsZ0JBQU83aEIsQ0FBUDtBQUFBLGdCQUFVZ2YsQ0FBVjs7QUFBQSxtQkFBaUJoZixFQUFFOGhCLFFBQUYsQ0FBV0QsR0FBWCxJQUFrQjdDLEVBQUU4QyxRQUFGLENBQVdELEdBQVgsQ0FBbkM7QUFBQSxTQUxKLENBRE8sRUFRUCxDQUNJLENBQUN2RixVQUFELENBREosRUFFSSxVQUFDdUYsR0FBRDtBQUFBO0FBQUEsZ0JBQU83aEIsQ0FBUDs7QUFBQSxtQkFBYyxDQUFDQSxFQUFFOGhCLFFBQUYsQ0FBV0QsR0FBWCxDQUFmO0FBQUEsU0FGSixDQVJPO0FBRlYsS0FwSmdDO0FBb0tyQyxTQUFLLENBQ0R2RixVQURDLEVBRUQsQ0FDSUEsVUFESixFQUVJQSxVQUZKLENBRkMsRUFNRCxVQUFDdUYsR0FBRDtBQUFBO0FBQUEsWUFBTzdoQixDQUFQO0FBQUEsWUFBVWdmLENBQVY7O0FBQUEsZUFBaUJoZixFQUFFOGhCLFFBQUYsQ0FBV0QsR0FBWCxJQUFrQjdDLEVBQUU4QyxRQUFGLENBQVdELEdBQVgsQ0FBbkM7QUFBQSxLQU5DLENBcEtnQztBQTRLckMsU0FBSyxDQUNEdkYsVUFEQyxFQUVELENBQ0lBLFVBREosRUFFSUEsVUFGSixDQUZDLEVBTUQsVUFBQ3VGLEdBQUQ7QUFBQTtBQUFBLFlBQU83aEIsQ0FBUDtBQUFBLFlBQVVnZixDQUFWOztBQUFBLGVBQWlCaGYsRUFBRThoQixRQUFGLENBQVdELEdBQVgsSUFBa0I3QyxFQUFFOEMsUUFBRixDQUFXRCxHQUFYLENBQW5DO0FBQUEsS0FOQyxDQTVLZ0M7QUFvTHJDLFdBQU8sQ0FDSHZGLFVBREcsRUFFSCxFQUZHLEVBR0g7QUFBQSxlQUFNdk0sS0FBS29rQixHQUFYO0FBQUEsS0FIRyxDQXBMOEI7QUF5THJDLFVBQU0sQ0FDRjdYLFVBREUsRUFFRixFQUZFLEVBR0Y7QUFBQSxlQUFNdk0sS0FBS2dXLEVBQVg7QUFBQSxLQUhFLENBekwrQjtBQThMckMsU0FBSyxDQUNEekosVUFEQyxFQUVELEVBRkMsRUFHRDtBQUFBLGVBQU12TSxLQUFLcWtCLENBQVg7QUFBQSxLQUhDLENBOUxnQztBQW1NckMsU0FBSyxDQUNEOVgsVUFEQyxFQUVELENBQ0lBLFVBREosRUFFSUEsVUFGSixDQUZDLEVBTUQsVUFBQ3VGLEdBQUQ7QUFBQTtBQUFBLFlBQU83QyxDQUFQO0FBQUEsWUFBVXJsQixDQUFWOztBQUFBLGVBQWlCb1csS0FBS3VXLEdBQUwsQ0FBU3RILEVBQUU4QyxRQUFGLENBQVdELEdBQVgsQ0FBVCxFQUEwQmxvQixFQUFFbW9CLFFBQUYsQ0FBV0QsR0FBWCxDQUExQixDQUFqQjtBQUFBLEtBTkMsQ0FuTWdDO0FBMk1yQyxZQUFRLENBQ0p2RixVQURJLEVBRUosQ0FBQ0EsVUFBRCxDQUZJLEVBR0osVUFBQ3VGLEdBQUQ7QUFBQTtBQUFBLFlBQU81TixDQUFQOztBQUFBLGVBQWNsRSxLQUFLN0csSUFBTCxDQUFVK0ssRUFBRTZOLFFBQUYsQ0FBV0QsR0FBWCxDQUFWLENBQWQ7QUFBQSxLQUhJLENBM002QjtBQWdOckMsYUFBUyxDQUNMdkYsVUFESyxFQUVMLENBQUNBLFVBQUQsQ0FGSyxFQUdMLFVBQUN1RixHQUFEO0FBQUE7QUFBQSxZQUFPbFEsQ0FBUDs7QUFBQSxlQUFjNUIsS0FBS2lXLEdBQUwsQ0FBU3JVLEVBQUVtUSxRQUFGLENBQVdELEdBQVgsQ0FBVCxJQUE0QjlSLEtBQUtza0IsSUFBL0M7QUFBQSxLQUhLLENBaE40QjtBQXFOckMsVUFBTSxDQUNGL1gsVUFERSxFQUVGLENBQUNBLFVBQUQsQ0FGRSxFQUdGLFVBQUN1RixHQUFEO0FBQUE7QUFBQSxZQUFPbFEsQ0FBUDs7QUFBQSxlQUFjNUIsS0FBS2lXLEdBQUwsQ0FBU3JVLEVBQUVtUSxRQUFGLENBQVdELEdBQVgsQ0FBVCxDQUFkO0FBQUEsS0FIRSxDQXJOK0I7QUEwTnJDLFlBQVEsQ0FDSnZGLFVBREksRUFFSixDQUFDQSxVQUFELENBRkksRUFHSixVQUFDdUYsR0FBRDtBQUFBO0FBQUEsWUFBT2xRLENBQVA7O0FBQUEsZUFBYzVCLEtBQUtpVyxHQUFMLENBQVNyVSxFQUFFbVEsUUFBRixDQUFXRCxHQUFYLENBQVQsSUFBNEI5UixLQUFLb2tCLEdBQS9DO0FBQUEsS0FISSxDQTFONkI7QUErTnJDLFdBQU8sQ0FDSDdYLFVBREcsRUFFSCxDQUFDQSxVQUFELENBRkcsRUFHSCxVQUFDdUYsR0FBRDtBQUFBO0FBQUEsWUFBT2xRLENBQVA7O0FBQUEsZUFBYzVCLEtBQUt6RyxHQUFMLENBQVNxSSxFQUFFbVEsUUFBRixDQUFXRCxHQUFYLENBQVQsQ0FBZDtBQUFBLEtBSEcsQ0EvTjhCO0FBb09yQyxXQUFPLENBQ0h2RixVQURHLEVBRUgsQ0FBQ0EsVUFBRCxDQUZHLEVBR0gsVUFBQ3VGLEdBQUQ7QUFBQTtBQUFBLFlBQU9sUSxDQUFQOztBQUFBLGVBQWM1QixLQUFLeEcsR0FBTCxDQUFTb0ksRUFBRW1RLFFBQUYsQ0FBV0QsR0FBWCxDQUFULENBQWQ7QUFBQSxLQUhHLENBcE84QjtBQXlPckMsV0FBTyxDQUNIdkYsVUFERyxFQUVILENBQUNBLFVBQUQsQ0FGRyxFQUdILFVBQUN1RixHQUFEO0FBQUE7QUFBQSxZQUFPbFEsQ0FBUDs7QUFBQSxlQUFjNUIsS0FBS3ZHLEdBQUwsQ0FBU21JLEVBQUVtUSxRQUFGLENBQVdELEdBQVgsQ0FBVCxDQUFkO0FBQUEsS0FIRyxDQXpPOEI7QUE4T3JDLFlBQVEsQ0FDSnZGLFVBREksRUFFSixDQUFDQSxVQUFELENBRkksRUFHSixVQUFDdUYsR0FBRDtBQUFBO0FBQUEsWUFBT2xRLENBQVA7O0FBQUEsZUFBYzVCLEtBQUt0RyxJQUFMLENBQVVrSSxFQUFFbVEsUUFBRixDQUFXRCxHQUFYLENBQVYsQ0FBZDtBQUFBLEtBSEksQ0E5TzZCO0FBbVByQyxZQUFRLENBQ0p2RixVQURJLEVBRUosQ0FBQ0EsVUFBRCxDQUZJLEVBR0osVUFBQ3VGLEdBQUQ7QUFBQTtBQUFBLFlBQU9sUSxDQUFQOztBQUFBLGVBQWM1QixLQUFLckcsSUFBTCxDQUFVaUksRUFBRW1RLFFBQUYsQ0FBV0QsR0FBWCxDQUFWLENBQWQ7QUFBQSxLQUhJLENBblA2QjtBQXdQckMsWUFBUSxDQUNKdkYsVUFESSxFQUVKLENBQUNBLFVBQUQsQ0FGSSxFQUdKLFVBQUN1RixHQUFEO0FBQUE7QUFBQSxZQUFPbFEsQ0FBUDs7QUFBQSxlQUFjNUIsS0FBS3BHLElBQUwsQ0FBVWdJLEVBQUVtUSxRQUFGLENBQVdELEdBQVgsQ0FBVixDQUFkO0FBQUEsS0FISSxDQXhQNkI7QUE2UHJDLFdBQU8sQ0FDSHZGLFVBREcsRUFFSHVYLFFBQVF2WCxVQUFSLENBRkcsRUFHSCxVQUFDdUYsR0FBRCxFQUFNTixJQUFOO0FBQUEsZUFBZXhSLEtBQUtuRyxHQUFMLGdDQUFZMlgsS0FBSzlyQixHQUFMLENBQVM7QUFBQSxtQkFBTzJkLElBQUkwTyxRQUFKLENBQWFELEdBQWIsQ0FBUDtBQUFBLFNBQVQsQ0FBWixFQUFmO0FBQUEsS0FIRyxDQTdQOEI7QUFrUXJDLFdBQU8sQ0FDSHZGLFVBREcsRUFFSHVYLFFBQVF2WCxVQUFSLENBRkcsRUFHSCxVQUFDdUYsR0FBRCxFQUFNTixJQUFOO0FBQUEsZUFBZXhSLEtBQUtsRyxHQUFMLGdDQUFZMFgsS0FBSzlyQixHQUFMLENBQVM7QUFBQSxtQkFBTzJkLElBQUkwTyxRQUFKLENBQWFELEdBQWIsQ0FBUDtBQUFBLFNBQVQsQ0FBWixFQUFmO0FBQUEsS0FIRyxDQWxROEI7QUF1UXJDLFdBQU8sQ0FDSHZGLFVBREcsRUFFSCxDQUFDQSxVQUFELENBRkcsRUFHSCxVQUFDdUYsR0FBRDtBQUFBO0FBQUEsWUFBT2xRLENBQVA7O0FBQUEsZUFBYzVCLEtBQUtqRyxHQUFMLENBQVM2SCxFQUFFbVEsUUFBRixDQUFXRCxHQUFYLENBQVQsQ0FBZDtBQUFBLEtBSEcsQ0F2UThCO0FBNFFyQyxhQUFTLENBQ0x2RixVQURLLEVBRUwsQ0FBQ0EsVUFBRCxDQUZLLEVBR0wsVUFBQ3VGLEdBQUQsVUFBYztBQUFBO0FBQUEsWUFBUGxRLENBQU87O0FBQ1YsWUFBTTBDLElBQUkxQyxFQUFFbVEsUUFBRixDQUFXRCxHQUFYLENBQVY7QUFDQSxlQUFPeE4sSUFBSSxDQUFKLEdBQVEsQ0FBQ3RFLEtBQUt0SyxLQUFMLENBQVcsQ0FBQzRPLENBQVosQ0FBVCxHQUEwQnRFLEtBQUt0SyxLQUFMLENBQVc0TyxDQUFYLENBQWpDO0FBQ0gsS0FOSSxDQTVRNEI7QUFvUnJDLGFBQVMsQ0FDTGlJLFVBREssRUFFTCxDQUFDQSxVQUFELENBRkssRUFHTCxVQUFDdUYsR0FBRDtBQUFBO0FBQUEsWUFBT2xRLENBQVA7O0FBQUEsZUFBYzVCLEtBQUsvRixLQUFMLENBQVcySCxFQUFFbVEsUUFBRixDQUFXRCxHQUFYLENBQVgsQ0FBZDtBQUFBLEtBSEssQ0FwUjRCO0FBeVJyQyxZQUFRLENBQ0p2RixVQURJLEVBRUosQ0FBQ0EsVUFBRCxDQUZJLEVBR0osVUFBQ3VGLEdBQUQ7QUFBQTtBQUFBLFlBQU9sUSxDQUFQOztBQUFBLGVBQWM1QixLQUFLaEcsSUFBTCxDQUFVNEgsRUFBRW1RLFFBQUYsQ0FBV0QsR0FBWCxDQUFWLENBQWQ7QUFBQSxLQUhJLENBelI2QjtBQThSckMsaUJBQWEsQ0FDVHJGLFdBRFMsRUFFVCxDQUNJRCxVQURKLEVBRUlJLFNBRkosQ0FGUyxFQU1ULFVBQUNrRixHQUFEO0FBQUE7QUFBQSxZQUFPdlEsQ0FBUDtBQUFBLFlBQVUrQyxDQUFWOztBQUFBLGVBQWlCd04sSUFBSTdZLFVBQUosR0FBaUJzSSxFQUFFclEsS0FBbkIsTUFBOEJvVCxFQUFFcFQsS0FBakQ7QUFBQSxLQU5TLENBOVJ3QjtBQXNTckMsb0JBQWdCLENBQ1p1YixXQURZLEVBRVosQ0FBQ0csU0FBRCxDQUZZLEVBR1osVUFBQ2tGLEdBQUQ7QUFBQTtBQUFBLFlBQU94TixDQUFQOztBQUFBLGVBQWN3TixJQUFJbm9CLEVBQUosT0FBYTJhLEVBQUVwVCxLQUE3QjtBQUFBLEtBSFksQ0F0U3FCO0FBMlNyQyxzQkFBa0IsQ0FDZHViLFdBRGMsRUFFZCxDQUFDRCxVQUFELENBRmMsRUFHZCxVQUFDc0YsR0FBRDtBQUFBO0FBQUEsWUFBT3hOLENBQVA7O0FBQUEsZUFBY3dOLElBQUlvSSxZQUFKLE9BQXVCNVYsRUFBRXBULEtBQXZDO0FBQUEsS0FIYyxDQTNTbUI7QUFnVHJDLGdCQUFZLENBQ1J1YixXQURRLEVBRVIsQ0FDSUQsVUFESixFQUVJSSxTQUZKLENBRlEsRUFNUixVQUFDa0YsR0FBRCxVQUFpQjtBQUFBO0FBQUEsWUFBVnZRLENBQVU7QUFBQSxZQUFQK0MsQ0FBTzs7QUFDYixZQUFNclUsSUFBSTZoQixJQUFJN1ksVUFBSixHQUFpQnNJLEVBQUVyUSxLQUFuQixDQUFWO0FBQ0EsWUFBTStkLElBQUkzSyxFQUFFcFQsS0FBWjtBQUNBLGVBQU8sUUFBT2pCLENBQVAseUNBQU9BLENBQVAsZUFBb0JnZixDQUFwQix5Q0FBb0JBLENBQXBCLE1BQXlCaGYsSUFBSWdmLENBQXBDO0FBQ0gsS0FWTyxDQWhUeUI7QUE0VHJDLG1CQUFlLENBQ1h4QyxXQURXLEVBRVgsQ0FBQ0csU0FBRCxDQUZXLEVBR1gsVUFBQ2tGLEdBQUQsVUFBYztBQUFBO0FBQUEsWUFBUHhOLENBQU87O0FBQ1YsWUFBTXJVLElBQUk2aEIsSUFBSW5vQixFQUFKLEVBQVY7QUFDQSxZQUFNc2xCLElBQUkzSyxFQUFFcFQsS0FBWjtBQUNBLGVBQU8sUUFBT2pCLENBQVAseUNBQU9BLENBQVAsZUFBb0JnZixDQUFwQix5Q0FBb0JBLENBQXBCLE1BQXlCaGYsSUFBSWdmLENBQXBDO0FBQ0gsS0FQVSxDQTVUc0I7QUFxVXJDLGdCQUFZLENBQ1J4QyxXQURRLEVBRVIsQ0FDSUQsVUFESixFQUVJSSxTQUZKLENBRlEsRUFNUixVQUFDa0YsR0FBRCxVQUFpQjtBQUFBO0FBQUEsWUFBVnZRLENBQVU7QUFBQSxZQUFQK0MsQ0FBTzs7QUFDYixZQUFNclUsSUFBSTZoQixJQUFJN1ksVUFBSixHQUFpQnNJLEVBQUVyUSxLQUFuQixDQUFWO0FBQ0EsWUFBTStkLElBQUkzSyxFQUFFcFQsS0FBWjtBQUNBLGVBQU8sUUFBT2pCLENBQVAseUNBQU9BLENBQVAsZUFBb0JnZixDQUFwQix5Q0FBb0JBLENBQXBCLE1BQXlCaGYsSUFBSWdmLENBQXBDO0FBQ0gsS0FWTyxDQXJVeUI7QUFpVnJDLG1CQUFlLENBQ1h4QyxXQURXLEVBRVgsQ0FBQ0csU0FBRCxDQUZXLEVBR1gsVUFBQ2tGLEdBQUQsVUFBYztBQUFBO0FBQUEsWUFBUHhOLENBQU87O0FBQ1YsWUFBTXJVLElBQUk2aEIsSUFBSW5vQixFQUFKLEVBQVY7QUFDQSxZQUFNc2xCLElBQUkzSyxFQUFFcFQsS0FBWjtBQUNBLGVBQU8sUUFBT2pCLENBQVAseUNBQU9BLENBQVAsZUFBb0JnZixDQUFwQix5Q0FBb0JBLENBQXBCLE1BQXlCaGYsSUFBSWdmLENBQXBDO0FBQ0gsS0FQVSxDQWpWc0I7QUEwVnJDLGlCQUFhLENBQ1R4QyxXQURTLEVBRVQsQ0FDSUQsVUFESixFQUVJSSxTQUZKLENBRlMsRUFNVCxVQUFDa0YsR0FBRCxVQUFpQjtBQUFBO0FBQUEsWUFBVnZRLENBQVU7QUFBQSxZQUFQK0MsQ0FBTzs7QUFDYixZQUFNclUsSUFBSTZoQixJQUFJN1ksVUFBSixHQUFpQnNJLEVBQUVyUSxLQUFuQixDQUFWO0FBQ0EsWUFBTStkLElBQUkzSyxFQUFFcFQsS0FBWjtBQUNBLGVBQU8sUUFBT2pCLENBQVAseUNBQU9BLENBQVAsZUFBb0JnZixDQUFwQix5Q0FBb0JBLENBQXBCLE1BQXlCaGYsS0FBS2dmLENBQXJDO0FBQ0gsS0FWUSxDQTFWd0I7QUFzV3JDLG9CQUFnQixDQUNaeEMsV0FEWSxFQUVaLENBQUNHLFNBQUQsQ0FGWSxFQUdaLFVBQUNrRixHQUFELFVBQWM7QUFBQTtBQUFBLFlBQVB4TixDQUFPOztBQUNWLFlBQU1yVSxJQUFJNmhCLElBQUlub0IsRUFBSixFQUFWO0FBQ0EsWUFBTXNsQixJQUFJM0ssRUFBRXBULEtBQVo7QUFDQSxlQUFPLFFBQU9qQixDQUFQLHlDQUFPQSxDQUFQLGVBQW9CZ2YsQ0FBcEIseUNBQW9CQSxDQUFwQixNQUF5QmhmLEtBQUtnZixDQUFyQztBQUNILEtBUFcsQ0F0V3FCO0FBK1dyQyxpQkFBYSxDQUNUeEMsV0FEUyxFQUVULENBQ0lELFVBREosRUFFSUksU0FGSixDQUZTLEVBTVQsVUFBQ2tGLEdBQUQsVUFBaUI7QUFBQTtBQUFBLFlBQVZ2USxDQUFVO0FBQUEsWUFBUCtDLENBQU87O0FBQ2IsWUFBTXJVLElBQUk2aEIsSUFBSTdZLFVBQUosR0FBaUJzSSxFQUFFclEsS0FBbkIsQ0FBVjtBQUNBLFlBQU0rZCxJQUFJM0ssRUFBRXBULEtBQVo7QUFDQSxlQUFPLFFBQU9qQixDQUFQLHlDQUFPQSxDQUFQLGVBQW9CZ2YsQ0FBcEIseUNBQW9CQSxDQUFwQixNQUF5QmhmLEtBQUtnZixDQUFyQztBQUNILEtBVlEsQ0EvV3dCO0FBMlhyQyxvQkFBZ0IsQ0FDWnhDLFdBRFksRUFFWixDQUFDRyxTQUFELENBRlksRUFHWixVQUFDa0YsR0FBRCxVQUFjO0FBQUE7QUFBQSxZQUFQeE4sQ0FBTzs7QUFDVixZQUFNclUsSUFBSTZoQixJQUFJbm9CLEVBQUosRUFBVjtBQUNBLFlBQU1zbEIsSUFBSTNLLEVBQUVwVCxLQUFaO0FBQ0EsZUFBTyxRQUFPakIsQ0FBUCx5Q0FBT0EsQ0FBUCxlQUFvQmdmLENBQXBCLHlDQUFvQkEsQ0FBcEIsTUFBeUJoZixLQUFLZ2YsQ0FBckM7QUFDSCxLQVBXLENBM1hxQjtBQW9ZckMsa0JBQWMsQ0FDVnhDLFdBRFUsRUFFVixDQUFDRyxTQUFELENBRlUsRUFHVixVQUFDa0YsR0FBRDtBQUFBO0FBQUEsWUFBT3ZRLENBQVA7O0FBQUEsZUFBY0EsRUFBRXJRLEtBQUYsSUFBVzRnQixJQUFJN1ksVUFBSixFQUF6QjtBQUFBLEtBSFUsQ0FwWXVCO0FBeVlyQyxxQkFBaUIsQ0FDYndULFdBRGEsRUFFYixFQUZhLEVBR2I7QUFBQSxlQUFPcUYsSUFBSW5vQixFQUFKLE9BQWEsSUFBYixJQUFxQm1vQixJQUFJbm9CLEVBQUosT0FBYVgsU0FBekM7QUFBQSxLQUhhLENBellvQjtBQThZckMsc0JBQWtCLENBQ2R5akIsV0FEYyxFQUVkLENBQUN0VSxNQUFNcVUsVUFBTixDQUFELENBRmMsRUFHZCxVQUFDc0YsR0FBRDtBQUFBO0FBQUEsWUFBT3hOLENBQVA7O0FBQUEsZUFBY0EsRUFBRXBULEtBQUYsQ0FBUW5MLE9BQVIsQ0FBZ0IrckIsSUFBSW9JLFlBQUosRUFBaEIsS0FBdUMsQ0FBckQ7QUFBQSxLQUhjLENBOVltQjtBQW1ackMsb0JBQWdCLENBQ1p6TixXQURZLEVBRVosQ0FBQ3RVLE1BQU15VSxTQUFOLENBQUQsQ0FGWSxFQUdaLFVBQUNrRixHQUFEO0FBQUE7QUFBQSxZQUFPeE4sQ0FBUDs7QUFBQSxlQUFjQSxFQUFFcFQsS0FBRixDQUFRbkwsT0FBUixDQUFnQityQixJQUFJbm9CLEVBQUosRUFBaEIsS0FBNkIsQ0FBM0M7QUFBQSxLQUhZLENBblpxQjtBQXdackMsdUJBQW1CLENBQ2Y4aUIsV0FEZSxFQUVmLENBQ0lELFVBREosRUFFSXJVLE1BQU15VSxTQUFOLENBRkosQ0FGZSxFQU1mLFVBQUNrRixHQUFEO0FBQUE7QUFBQSxZQUFPdlEsQ0FBUDtBQUFBLFlBQVUrQyxDQUFWOztBQUFBLGVBQWlCQSxFQUFFcFQsS0FBRixDQUFRbkwsT0FBUixDQUFnQityQixJQUFJN1ksVUFBSixHQUFpQnNJLEVBQUVyUSxLQUFuQixDQUFoQixLQUE4QyxDQUEvRDtBQUFBLEtBTmUsQ0F4WmtCO0FBZ2FyQyx1QkFBbUIsQ0FDZnViLFdBRGUsRUFFZixDQUNJRCxVQURKLEVBRUlyVSxNQUFNeVUsU0FBTixDQUZKLENBRmUsRUFNZixVQUFDa0YsR0FBRDtBQUFBO0FBQUEsWUFBT3ZRLENBQVA7QUFBQSxZQUFVK0MsQ0FBVjs7QUFBQSxlQUFpQnVmLGFBQWEvUixJQUFJN1ksVUFBSixHQUFpQnNJLEVBQUVyUSxLQUFuQixDQUFiLEVBQXdDb1QsRUFBRXBULEtBQTFDLEVBQWlELENBQWpELEVBQW9Eb1QsRUFBRXBULEtBQUYsQ0FBUTdMLE1BQVIsR0FBaUIsQ0FBckUsQ0FBakI7QUFBQSxLQU5lLENBaGFrQjtBQXdhckMsV0FBTztBQUNIMkUsY0FBTXlpQixXQURIO0FBRUhxSSxtQkFBVyxDQUNQLENBQ0ksQ0FDSXJJLFdBREosRUFFSUEsV0FGSixDQURKLEVBS0ksVUFBQ3FGLEdBQUQ7QUFBQTtBQUFBLGdCQUFPN2hCLENBQVA7QUFBQSxnQkFBVWdmLENBQVY7O0FBQUEsbUJBQWlCaGYsRUFBRThoQixRQUFGLENBQVdELEdBQVgsS0FBbUI3QyxFQUFFOEMsUUFBRixDQUFXRCxHQUFYLENBQXBDO0FBQUEsU0FMSixDQURPLEVBUVAsQ0FDSWdTLFFBQVFyWCxXQUFSLENBREosRUFFSSxVQUFDcUYsR0FBRCxFQUFNTixJQUFOLEVBQWU7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDWCx1Q0FBa0JBLElBQWxCLHdJQUF3QjtBQUFBLHdCQUFibk8sR0FBYTs7QUFDcEIsd0JBQUksQ0FBQ0EsSUFBSTBPLFFBQUosQ0FBYUQsR0FBYixDQUFMLEVBQ0ksT0FBTyxLQUFQO0FBQ1A7QUFKVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtYLG1CQUFPLElBQVA7QUFDSCxTQVJMLENBUk87QUFGUixLQXhhOEI7QUE4YnJDLFdBQU87QUFDSDluQixjQUFNeWlCLFdBREg7QUFFSHFJLG1CQUFXLENBQ1AsQ0FDSSxDQUNJckksV0FESixFQUVJQSxXQUZKLENBREosRUFLSSxVQUFDcUYsR0FBRDtBQUFBO0FBQUEsZ0JBQU83aEIsQ0FBUDtBQUFBLGdCQUFVZ2YsQ0FBVjs7QUFBQSxtQkFBaUJoZixFQUFFOGhCLFFBQUYsQ0FBV0QsR0FBWCxLQUFtQjdDLEVBQUU4QyxRQUFGLENBQVdELEdBQVgsQ0FBcEM7QUFBQSxTQUxKLENBRE8sRUFRUCxDQUNJZ1MsUUFBUXJYLFdBQVIsQ0FESixFQUVJLFVBQUNxRixHQUFELEVBQU1OLElBQU4sRUFBZTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNYLHVDQUFrQkEsSUFBbEIsd0lBQXdCO0FBQUEsd0JBQWJuTyxHQUFhOztBQUNwQix3QkFBSUEsSUFBSTBPLFFBQUosQ0FBYUQsR0FBYixDQUFKLEVBQ0ksT0FBTyxJQUFQO0FBQ1A7QUFKVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtYLG1CQUFPLEtBQVA7QUFDSCxTQVJMLENBUk87QUFGUixLQTliOEI7QUFvZHJDLFNBQUssQ0FDRHJGLFdBREMsRUFFRCxDQUFDQSxXQUFELENBRkMsRUFHRCxVQUFDcUYsR0FBRDtBQUFBO0FBQUEsWUFBTzdDLENBQVA7O0FBQUEsZUFBYyxDQUFDQSxFQUFFOEMsUUFBRixDQUFXRCxHQUFYLENBQWY7QUFBQSxLQUhDLENBcGRnQztBQXlkckMsMkJBQXVCLENBQ25CckYsV0FEbUIsRUFFbkIsQ0FBQ0QsVUFBRCxDQUZtQixFQUduQixVQUFDc0YsR0FBRCxXQUFjO0FBQUE7QUFBQSxZQUFQbkosQ0FBTzs7QUFDVixZQUFNNGIsb0JBQW9CelMsSUFBSTJCLE9BQUosSUFBZTNCLElBQUkyQixPQUFKLENBQVk4USxpQkFBckQ7QUFDQSxZQUFJQSxpQkFBSixFQUF1QjtBQUNuQixtQkFBT0Esa0JBQWtCNWIsRUFBRW9KLFFBQUYsQ0FBV0QsR0FBWCxDQUFsQixDQUFQO0FBQ0g7QUFDRCxlQUFPLElBQVA7QUFDSCxLQVRrQixDQXpkYztBQW9lckMsY0FBVSxDQUNOdEYsVUFETSxFQUVOLENBQUNBLFVBQUQsQ0FGTSxFQUdOLFVBQUNzRixHQUFEO0FBQUE7QUFBQSxZQUFPbkosQ0FBUDs7QUFBQSxlQUFjQSxFQUFFb0osUUFBRixDQUFXRCxHQUFYLEVBQWdCMFMsV0FBaEIsRUFBZDtBQUFBLEtBSE0sQ0FwZTJCO0FBeWVyQyxnQkFBWSxDQUNSaFksVUFEUSxFQUVSLENBQUNBLFVBQUQsQ0FGUSxFQUdSLFVBQUNzRixHQUFEO0FBQUE7QUFBQSxZQUFPbkosQ0FBUDs7QUFBQSxlQUFjQSxFQUFFb0osUUFBRixDQUFXRCxHQUFYLEVBQWdCOU8sV0FBaEIsRUFBZDtBQUFBLEtBSFEsQ0F6ZXlCO0FBOGVyQyxjQUFVLENBQ053SixVQURNLEVBRU5zWCxRQUFRbFgsU0FBUixDQUZNLEVBR04sVUFBQ2tGLEdBQUQsRUFBTU4sSUFBTjtBQUFBLGVBQWVBLEtBQUs5ckIsR0FBTCxDQUFTO0FBQUEsbUJBQU8yckIsV0FBV2hPLElBQUkwTyxRQUFKLENBQWFELEdBQWIsQ0FBWCxDQUFQO0FBQUEsU0FBVCxFQUErQzFoQixJQUEvQyxDQUFvRCxFQUFwRCxDQUFmO0FBQUEsS0FITSxDQTllMkI7QUFtZnJDLHVCQUFtQixDQUNmb2MsVUFEZSxFQUVmLENBQUNNLFlBQUQsQ0FGZSxFQUdmLFVBQUNnRixHQUFEO0FBQUE7QUFBQSxZQUFPaFosUUFBUDs7QUFBQSxlQUFxQkEsU0FBU2laLFFBQVQsQ0FBa0JELEdBQWxCLEVBQXVCMlMsY0FBdkIsRUFBckI7QUFBQSxLQUhlO0FBbmZrQixDQUF6Qzs7QUEwZkEsU0FBU0MsT0FBVCxDQUFpQnh6QixLQUFqQixFQUF3QjtBQUNwQixXQUFPO0FBQ0hnTixnQkFBUSxTQURMO0FBRUhoTjtBQUZHLEtBQVA7QUFJSDtBQUNELFNBQVM3SCxLQUFULENBQWU2SCxLQUFmLEVBQXNCO0FBQ2xCLFdBQU87QUFDSGdOLGdCQUFRLE9BREw7QUFFSGhOO0FBRkcsS0FBUDtBQUlIOztBQUVELFNBQVN5ekIsMEJBQVQsQ0FBb0NDLElBQXBDLEVBQTBDO0FBQ3RDLFdBQU9BLEtBQUssZUFBTCxNQUEwQixhQUExQixJQUEyQ0EsS0FBSyxlQUFMLE1BQTBCLHlCQUE1RTtBQUNIO0FBQ0QsU0FBU0Msc0JBQVQsQ0FBZ0NELElBQWhDLEVBQXNDO0FBQ2xDLFdBQU8sQ0FBQyxDQUFDQSxLQUFLenZCLFVBQVAsSUFBcUJ5dkIsS0FBS3p2QixVQUFMLENBQWdCRSxVQUFoQixDQUEyQnRQLE9BQTNCLENBQW1DLE1BQW5DLElBQTZDLENBQUMsQ0FBMUU7QUFDSDtBQUNELFNBQVMrK0IscUJBQVQsQ0FBK0JGLElBQS9CLEVBQXFDO0FBQ2pDLFdBQU8sQ0FBQyxDQUFDQSxLQUFLenZCLFVBQVAsSUFBcUJ5dkIsS0FBS3p2QixVQUFMLENBQWdCQyxZQUE1QztBQUNIOztBQUVELFNBQVMydkIsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDbEIsUUFBSUEsZUFBZTdSLE1BQW5CLEVBQTJCO0FBQ3ZCLGVBQU8sUUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJNlIsZUFBZTlrQixNQUFuQixFQUEyQjtBQUM5QixlQUFPLFFBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSThrQixlQUFlalMsT0FBbkIsRUFBNEI7QUFDL0IsZUFBTyxTQUFQO0FBQ0gsS0FGTSxNQUVBLElBQUk3dEIsTUFBTUMsT0FBTixDQUFjNi9CLEdBQWQsQ0FBSixFQUF3QjtBQUMzQixlQUFPLE9BQVA7QUFDSCxLQUZNLE1BRUEsSUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ3JCLGVBQU8sTUFBUDtBQUNILEtBRk0sTUFFQTtBQUNILHNCQUFjQSxHQUFkLHlDQUFjQSxHQUFkO0FBQ0g7QUFDSjs7QUFFRCxTQUFTQyxZQUFULENBQXNCL3pCLEtBQXRCLEVBQTZCO0FBQ3pCLFdBQU8sUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFqQixJQUE2QkEsVUFBVSxJQUF2QyxJQUErQyxDQUFDaE0sTUFBTUMsT0FBTixDQUFjK0wsS0FBZCxDQUF2RDtBQUNIO0FBQ0QsU0FBU2cwQixnQkFBVCxDQUEwQmhoQixDQUExQixFQUE2QjtBQUN6QixXQUFPQSxDQUFQO0FBQ0g7QUFDRCxTQUFTaWhCLGNBQVQsQ0FBd0I5dkIsVUFBeEIsRUFBb0MrdkIsWUFBcEMsRUFBa0Q7QUFDOUMsUUFBTUMsVUFBVUQsYUFBYXA3QixJQUFiLEtBQXNCLE9BQXRDO0FBQ0EsUUFBTXM3QiwwQkFBMEJqd0IsV0FBV2pRLEtBQVgsSUFBb0IsUUFBT2lRLFdBQVdqUSxLQUFYLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQVAsTUFBa0MsUUFBdEY7QUFDQSxRQUFNbWdDLG1CQUFtQkQsMkJBQTJCandCLFdBQVcwRyxRQUFYLEtBQXdCL1MsU0FBNUU7QUFDQSxRQUFNdzhCLGdCQUFnQkYsMkJBQTJCLENBQUNDLGdCQUFsRDtBQUNBLFFBQU12N0IsT0FBT3FMLFdBQVdyTCxJQUFYLEtBQW9CODZCLHNCQUFzQk0sWUFBdEIsSUFBc0MsYUFBdEMsR0FBc0QsVUFBMUUsQ0FBYjtBQUNBLFFBQUlDLE9BQUosRUFBYTtBQUNUaHdCLHFCQUFheVcsT0FBTyxFQUFQLEVBQVd6VyxVQUFYLENBQWI7QUFDQSxZQUFJQSxXQUFXalEsS0FBZixFQUFzQjtBQUNsQmlRLHVCQUFXalEsS0FBWCxHQUFtQmlRLFdBQVdqUSxLQUFYLENBQWlCTSxHQUFqQixDQUFxQixnQkFBUTtBQUM1Qyx1QkFBTyxDQUNINGxCLEtBQUssQ0FBTCxDQURHLEVBRUg3Z0IsTUFBTTVDLEtBQU4sQ0FBWXlqQixLQUFLLENBQUwsQ0FBWixDQUZHLENBQVA7QUFJSCxhQUxrQixDQUFuQjtBQU1IO0FBQ0QsWUFBSWpXLFdBQVdvd0IsT0FBZixFQUF3QjtBQUNwQnB3Qix1QkFBV293QixPQUFYLEdBQXFCaDdCLE1BQU01QyxLQUFOLENBQVl3TixXQUFXb3dCLE9BQXZCLENBQXJCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hwd0IsdUJBQVdvd0IsT0FBWCxHQUFxQmg3QixNQUFNNUMsS0FBTixDQUFZdTlCLGFBQWFLLE9BQXpCLENBQXJCO0FBQ0g7QUFDSjtBQUNELFFBQUlwd0IsV0FBVytHLFVBQVgsSUFBeUIvRyxXQUFXK0csVUFBWCxLQUEwQixLQUFuRCxJQUE0RCxDQUFDMGlCLFlBQVl6cEIsV0FBVytHLFVBQXZCLENBQWpFLEVBQXFHO0FBQ2pHLGNBQU0sSUFBSXJVLEtBQUosMkJBQW1Dc04sV0FBVytHLFVBQTlDLENBQU47QUFDSDtBQUNELFFBQUlzcEIsaUJBQUo7QUFDQSxRQUFJQyxvQkFBSjtBQUNBLFFBQUlDLDJCQUFKO0FBQ0EsUUFBSTU3QixTQUFTLGFBQWIsRUFBNEI7QUFDeEIwN0IsbUJBQVdHLDJCQUFYO0FBQ0gsS0FGRCxNQUVPLElBQUk3N0IsU0FBUyxVQUFiLEVBQXlCO0FBQzVCMDdCLG1CQUFXSSx3QkFBWDtBQUNILEtBRk0sTUFFQSxJQUFJOTdCLFNBQVMsYUFBYixFQUE0QjtBQUMvQjA3QixtQkFBV0ssMkJBQVg7QUFDQUosc0JBQWM1bkIsT0FBT2lvQixNQUFQLENBQWMsSUFBZCxDQUFkO0FBRitCO0FBQUE7QUFBQTs7QUFBQTtBQUcvQixtQ0FBbUIzd0IsV0FBV2pRLEtBQTlCLHdJQUFxQztBQUFBLG9CQUExQmttQixJQUEwQjs7QUFDakNxYSw0QkFBWXJhLEtBQUssQ0FBTCxDQUFaLElBQXVCQSxLQUFLLENBQUwsQ0FBdkI7QUFDSDtBQUw4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU0vQnNhLHFDQUE0QnZ3QixXQUFXalEsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUE1QjtBQUNILEtBUE0sTUFPQSxJQUFJNEUsU0FBUyxVQUFiLEVBQXlCO0FBQzVCMDdCLG1CQUFXTyx3QkFBWDtBQUNILEtBRk0sTUFFQTtBQUNILGNBQU0sSUFBSWwrQixLQUFKLDhCQUFxQ2lDLElBQXJDLFFBQU47QUFDSDtBQUNELFFBQUlzN0IsdUJBQUosRUFBNkI7QUFDekIsWUFBTVksbUJBQW1CLEVBQXpCO0FBQ0EsWUFBTUMsWUFBWSxFQUFsQjtBQUNBLGFBQUssSUFBSXhkLElBQUksQ0FBYixFQUFnQkEsSUFBSXRULFdBQVdqUSxLQUFYLENBQWlCQyxNQUFyQyxFQUE2Q3NqQixHQUE3QyxFQUFrRDtBQUM5QyxnQkFBTTJDLFFBQU9qVyxXQUFXalEsS0FBWCxDQUFpQnVqQixDQUFqQixDQUFiO0FBQ0EsZ0JBQU10ZSxPQUFPaWhCLE1BQUssQ0FBTCxFQUFRamhCLElBQXJCO0FBQ0EsZ0JBQUk2N0IsaUJBQWlCNzdCLElBQWpCLE1BQTJCckIsU0FBL0IsRUFBMEM7QUFDdENrOUIsaUNBQWlCNzdCLElBQWpCLElBQXlCO0FBQ3JCQSw4QkFEcUI7QUFFckJMLDBCQUFNcUwsV0FBV3JMLElBRkk7QUFHckIrUiw4QkFBVTFHLFdBQVcwRyxRQUhBO0FBSXJCMHBCLDZCQUFTcHdCLFdBQVdvd0IsT0FKQztBQUtyQnJnQywyQkFBTztBQUxjLGlCQUF6QjtBQU9BK2dDLDBCQUFVbmdDLElBQVYsQ0FBZXFFLElBQWY7QUFDSDtBQUNENjdCLDZCQUFpQjc3QixJQUFqQixFQUF1QmpGLEtBQXZCLENBQTZCWSxJQUE3QixDQUFrQyxDQUM5QnNsQixNQUFLLENBQUwsRUFBUXBhLEtBRHNCLEVBRTlCb2EsTUFBSyxDQUFMLENBRjhCLENBQWxDO0FBSUg7QUFDRCxZQUFNOGEsdUJBQXVCLEVBQTdCO0FBckJ5QjtBQUFBO0FBQUE7O0FBQUE7QUFzQnpCLG1DQUFnQkQsU0FBaEIsd0lBQTJCO0FBQUEsb0JBQWhCM1AsQ0FBZ0I7O0FBQ3ZCNFAscUNBQXFCcGdDLElBQXJCLENBQTBCLENBQ3RCa2dDLGlCQUFpQjFQLENBQWpCLEVBQW9CbnNCLElBREUsRUFFdEI4NkIsZUFBZWUsaUJBQWlCMVAsQ0FBakIsQ0FBZixFQUFvQzRPLFlBQXBDLENBRnNCLENBQTFCO0FBSUg7QUEzQndCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBNEJ6QixZQUFNaUIsb0JBQW9CLEVBQUVyMUIsTUFBTSxRQUFSLEVBQTFCO0FBQ0EsZUFBTztBQUNIc2Isa0JBQU0sV0FESDtBQUVIK1osZ0RBRkc7QUFHSGpILGlDQUFxQkwsWUFBWUssbUJBQVosQ0FBZ0NrSCxJQUFoQyxDQUFxQ3Q5QixTQUFyQyxFQUFnRHE5QixpQkFBaEQsQ0FIbEI7QUFJSEYsdUJBQVdDLHFCQUFxQjFnQyxHQUFyQixDQUF5QjtBQUFBLHVCQUFLaWpCLEVBQUUsQ0FBRixDQUFMO0FBQUEsYUFBekIsQ0FKUjtBQUtIb0osb0JBTEcsNkJBS2M5WSxVQUxkLEVBSzBCO0FBQUEsb0JBQW5CNU8sSUFBbUIsV0FBbkJBLElBQW1COztBQUN6Qix1QkFBT3c3Qiw0QkFBNEI7QUFDL0J6Z0MsMkJBQU9naEMsb0JBRHdCO0FBRS9CdHFCLDBCQUFNekcsV0FBV3lHO0FBRmMsaUJBQTVCLEVBR0pzcEIsWUFISSxFQUdVLzZCLElBSFYsRUFHZ0IwbkIsUUFIaEIsQ0FHeUIxbkIsSUFIekIsRUFHK0I0TyxVQUgvQixDQUFQO0FBSUg7QUFWRSxTQUFQO0FBWUgsS0F6Q0QsTUF5Q08sSUFBSXVzQixhQUFKLEVBQW1CO0FBQ3RCLFlBQU1hLHFCQUFvQnI4QixTQUFTLGFBQVQsR0FBeUI7QUFDL0NnSCxrQkFBTSxhQUR5QztBQUUvQzhLLGtCQUFNekcsV0FBV3lHLElBQVgsS0FBb0I5UyxTQUFwQixHQUFnQ3FNLFdBQVd5RyxJQUEzQyxHQUFrRDtBQUZULFNBQXpCLEdBR3RCLElBSEo7QUFJQSxlQUFPO0FBQ0h3USxrQkFBTSxRQURIO0FBRUgrWixpREFGRztBQUdIakgsaUNBQXFCTCxZQUFZSyxtQkFBWixDQUFnQ2tILElBQWhDLENBQXFDdDlCLFNBQXJDLEVBQWdEcTlCLGtCQUFoRCxDQUhsQjtBQUlIRix1QkFBVzl3QixXQUFXalEsS0FBWCxDQUFpQk0sR0FBakIsQ0FBcUI7QUFBQSx1QkFBS2lqQixFQUFFLENBQUYsQ0FBTDtBQUFBLGFBQXJCLENBSlI7QUFLSG9KLHNCQUFVO0FBQUEsb0JBQUUxbkIsSUFBRixXQUFFQSxJQUFGO0FBQUEsdUJBQVlxN0IsU0FBU3J3QixVQUFULEVBQXFCK3ZCLFlBQXJCLEVBQW1DLzZCLElBQW5DLEVBQXlDczdCLFdBQXpDLEVBQXNEQyxrQkFBdEQsQ0FBWjtBQUFBO0FBTFAsU0FBUDtBQU9ILEtBWk0sTUFZQTtBQUNILGVBQU87QUFDSHRaLGtCQUFNLFFBREg7QUFFSHlGLG9CQUZHLG9CQUVNeVAsQ0FGTixFQUVTOU4sT0FGVCxFQUVrQjtBQUNqQixvQkFBTXhpQixRQUFRd2lCLFdBQVdBLFFBQVF6YSxVQUFuQixHQUFnQ3lhLFFBQVF6YSxVQUFSLENBQW1CNUQsV0FBVzBHLFFBQTlCLENBQWhDLEdBQTBFL1MsU0FBeEY7QUFDQSxvQkFBSWtJLFVBQVVsSSxTQUFkLEVBQXlCO0FBQ3JCLDJCQUFPcVAsU0FBU2hELFdBQVdvd0IsT0FBcEIsRUFBNkJMLGFBQWFLLE9BQTFDLENBQVA7QUFDSDtBQUNELHVCQUFPQyxTQUFTcndCLFVBQVQsRUFBcUIrdkIsWUFBckIsRUFBbUNsMEIsS0FBbkMsRUFBMEN5MEIsV0FBMUMsRUFBdURDLGtCQUF2RCxDQUFQO0FBQ0g7QUFSRSxTQUFQO0FBVUg7QUFDSjtBQUNELFNBQVN2dEIsUUFBVCxDQUFrQnBJLENBQWxCLEVBQXFCZ2YsQ0FBckIsRUFBd0IrRCxDQUF4QixFQUEyQjtBQUN2QixRQUFJL2lCLE1BQU1qSCxTQUFWLEVBQ0ksT0FBT2lILENBQVA7QUFDSixRQUFJZ2YsTUFBTWptQixTQUFWLEVBQ0ksT0FBT2ltQixDQUFQO0FBQ0osUUFBSStELE1BQU1ocUIsU0FBVixFQUNJLE9BQU9ncUIsQ0FBUDtBQUNQO0FBQ0QsU0FBUytTLDJCQUFULENBQXFDMXdCLFVBQXJDLEVBQWlEK3ZCLFlBQWpELEVBQStEM2pCLEtBQS9ELEVBQXNFa2tCLFdBQXRFLEVBQW1GWSxPQUFuRixFQUE0RjtBQUN4RixRQUFNQyxZQUFZLFFBQU8va0IsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQjhrQixPQUFqQixHQUEyQlosWUFBWWxrQixLQUFaLENBQTNCLEdBQWdEelksU0FBbEU7QUFDQSxXQUFPcVAsU0FBU211QixTQUFULEVBQW9CbnhCLFdBQVdvd0IsT0FBL0IsRUFBd0NMLGFBQWFLLE9BQXJELENBQVA7QUFDSDtBQUNELFNBQVNLLHdCQUFULENBQWtDendCLFVBQWxDLEVBQThDK3ZCLFlBQTlDLEVBQTREM2pCLEtBQTVELEVBQW1FO0FBQy9ELFFBQUlzakIsUUFBUXRqQixLQUFSLE1BQW1CLFFBQXZCLEVBQ0ksT0FBT3BKLFNBQVNoRCxXQUFXb3dCLE9BQXBCLEVBQTZCTCxhQUFhSyxPQUExQyxDQUFQO0FBQ0osUUFBTTdqQixJQUFJdk0sV0FBV2pRLEtBQVgsQ0FBaUJDLE1BQTNCO0FBQ0EsUUFBSXVjLE1BQU0sQ0FBVixFQUNJLE9BQU92TSxXQUFXalEsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFQO0FBQ0osUUFBSXFjLFNBQVNwTSxXQUFXalEsS0FBWCxDQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFiLEVBQ0ksT0FBT2lRLFdBQVdqUSxLQUFYLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQVA7QUFDSixRQUFJcWMsU0FBU3BNLFdBQVdqUSxLQUFYLENBQWlCd2MsSUFBSSxDQUFyQixFQUF3QixDQUF4QixDQUFiLEVBQ0ksT0FBT3ZNLFdBQVdqUSxLQUFYLENBQWlCd2MsSUFBSSxDQUFyQixFQUF3QixDQUF4QixDQUFQO0FBQ0osUUFBTXRFLFFBQVE0ZCwwQkFBMEI3bEIsV0FBV2pRLEtBQVgsQ0FBaUJNLEdBQWpCLENBQXFCO0FBQUEsZUFBUTRsQixLQUFLLENBQUwsQ0FBUjtBQUFBLEtBQXJCLENBQTFCLEVBQWlFN0osS0FBakUsQ0FBZDtBQUNBLFdBQU9wTSxXQUFXalEsS0FBWCxDQUFpQmtZLEtBQWpCLEVBQXdCLENBQXhCLENBQVA7QUFDSDtBQUNELFNBQVN1b0IsMkJBQVQsQ0FBcUN4d0IsVUFBckMsRUFBaUQrdkIsWUFBakQsRUFBK0QzakIsS0FBL0QsRUFBc0U7QUFDbEUsUUFBTTNGLE9BQU96RyxXQUFXeUcsSUFBWCxLQUFvQjlTLFNBQXBCLEdBQWdDcU0sV0FBV3lHLElBQTNDLEdBQWtELENBQS9EO0FBQ0EsUUFBSWlwQixRQUFRdGpCLEtBQVIsTUFBbUIsUUFBdkIsRUFDSSxPQUFPcEosU0FBU2hELFdBQVdvd0IsT0FBcEIsRUFBNkJMLGFBQWFLLE9BQTFDLENBQVA7QUFDSixRQUFNN2pCLElBQUl2TSxXQUFXalEsS0FBWCxDQUFpQkMsTUFBM0I7QUFDQSxRQUFJdWMsTUFBTSxDQUFWLEVBQ0ksT0FBT3ZNLFdBQVdqUSxLQUFYLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQVA7QUFDSixRQUFJcWMsU0FBU3BNLFdBQVdqUSxLQUFYLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQWIsRUFDSSxPQUFPaVEsV0FBV2pRLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FBUDtBQUNKLFFBQUlxYyxTQUFTcE0sV0FBV2pRLEtBQVgsQ0FBaUJ3YyxJQUFJLENBQXJCLEVBQXdCLENBQXhCLENBQWIsRUFDSSxPQUFPdk0sV0FBV2pRLEtBQVgsQ0FBaUJ3YyxJQUFJLENBQXJCLEVBQXdCLENBQXhCLENBQVA7QUFDSixRQUFNdEUsUUFBUTRkLDBCQUEwQjdsQixXQUFXalEsS0FBWCxDQUFpQk0sR0FBakIsQ0FBcUI7QUFBQSxlQUFRNGxCLEtBQUssQ0FBTCxDQUFSO0FBQUEsS0FBckIsQ0FBMUIsRUFBaUU3SixLQUFqRSxDQUFkO0FBQ0EsUUFBTVMsSUFBSWtkLG9CQUFvQjNkLEtBQXBCLEVBQTJCM0YsSUFBM0IsRUFBaUN6RyxXQUFXalEsS0FBWCxDQUFpQmtZLEtBQWpCLEVBQXdCLENBQXhCLENBQWpDLEVBQTZEakksV0FBV2pRLEtBQVgsQ0FBaUJrWSxRQUFRLENBQXpCLEVBQTRCLENBQTVCLENBQTdELENBQVY7QUFDQSxRQUFNK2hCLGNBQWNocUIsV0FBV2pRLEtBQVgsQ0FBaUJrWSxLQUFqQixFQUF3QixDQUF4QixDQUFwQjtBQUNBLFFBQU1naUIsY0FBY2pxQixXQUFXalEsS0FBWCxDQUFpQmtZLFFBQVEsQ0FBekIsRUFBNEIsQ0FBNUIsQ0FBcEI7QUFDQSxRQUFJbXBCLFNBQVNsdUIsWUFBWTZzQixhQUFhcDdCLElBQXpCLEtBQWtDazdCLGdCQUEvQztBQUNBLFFBQUk3dkIsV0FBVytHLFVBQVgsSUFBeUIvRyxXQUFXK0csVUFBWCxLQUEwQixLQUF2RCxFQUE4RDtBQUMxRCxZQUFNc3FCLGFBQWE1SCxZQUFZenBCLFdBQVcrRyxVQUF2QixDQUFuQjtBQUNBcXFCLGlCQUFTLGdCQUFDeDJCLENBQUQsRUFBSWdmLENBQUo7QUFBQSxtQkFBVXlYLFdBQVdyYixPQUFYLENBQW1CcWIsV0FBV251QixXQUFYLENBQXVCbXVCLFdBQVc3SCxPQUFYLENBQW1CNXVCLENBQW5CLENBQXZCLEVBQThDeTJCLFdBQVc3SCxPQUFYLENBQW1CNVAsQ0FBbkIsQ0FBOUMsRUFBcUUvTSxDQUFyRSxDQUFuQixDQUFWO0FBQUEsU0FBVDtBQUNIO0FBQ0QsUUFBSSxPQUFPbWQsWUFBWXROLFFBQW5CLEtBQWdDLFVBQXBDLEVBQWdEO0FBQzVDLGVBQU87QUFDSEEsb0JBREcsc0JBQ2U7QUFBQSxtREFBTlAsSUFBTTtBQUFOQSx3QkFBTTtBQUFBOztBQUNkLG9CQUFNbVYsaUJBQWlCdEgsWUFBWXROLFFBQVosQ0FBcUJydEIsS0FBckIsQ0FBMkJzRSxTQUEzQixFQUFzQ3dvQixJQUF0QyxDQUF2QjtBQUNBLG9CQUFNb1YsaUJBQWlCdEgsWUFBWXZOLFFBQVosQ0FBcUJydEIsS0FBckIsQ0FBMkJzRSxTQUEzQixFQUFzQ3dvQixJQUF0QyxDQUF2QjtBQUNBLG9CQUFJbVYsbUJBQW1CMzlCLFNBQW5CLElBQWdDNDlCLG1CQUFtQjU5QixTQUF2RCxFQUFrRTtBQUM5RCwyQkFBT0EsU0FBUDtBQUNIO0FBQ0QsdUJBQU95OUIsT0FBT0UsY0FBUCxFQUF1QkMsY0FBdkIsRUFBdUMxa0IsQ0FBdkMsQ0FBUDtBQUNIO0FBUkUsU0FBUDtBQVVIO0FBQ0QsV0FBT3VrQixPQUFPcEgsV0FBUCxFQUFvQkMsV0FBcEIsRUFBaUNwZCxDQUFqQyxDQUFQO0FBQ0g7QUFDRCxTQUFTK2pCLHdCQUFULENBQWtDNXdCLFVBQWxDLEVBQThDK3ZCLFlBQTlDLEVBQTREM2pCLEtBQTVELEVBQW1FO0FBQy9ELFFBQUkyakIsYUFBYXA3QixJQUFiLEtBQXNCLE9BQTFCLEVBQW1DO0FBQy9CeVgsZ0JBQVFoWCxNQUFNNUMsS0FBTixDQUFZNFosS0FBWixDQUFSO0FBQ0gsS0FGRCxNQUVPLElBQUkyakIsYUFBYXA3QixJQUFiLEtBQXNCLFdBQTFCLEVBQXVDO0FBQzFDeVgsZ0JBQVErTyxVQUFVSyxVQUFWLENBQXFCcFAsTUFBTS9XLFFBQU4sRUFBckIsQ0FBUjtBQUNILEtBRk0sTUFFQSxJQUFJMDZCLGFBQWFwN0IsSUFBYixLQUFzQixlQUExQixFQUEyQztBQUM5Q3lYLGdCQUFRcVAsY0FBY0QsVUFBZCxDQUF5QnBQLE1BQU0vVyxRQUFOLEVBQXpCLENBQVI7QUFDSCxLQUZNLE1BRUEsSUFBSXE2QixRQUFRdGpCLEtBQVIsTUFBbUIyakIsYUFBYXA3QixJQUFoQyxLQUF5Q283QixhQUFhcDdCLElBQWIsS0FBc0IsTUFBdEIsSUFBZ0MsQ0FBQ283QixhQUFhdjBCLE1BQWIsQ0FBb0I0USxLQUFwQixDQUExRSxDQUFKLEVBQTJHO0FBQzlHQSxnQkFBUXpZLFNBQVI7QUFDSDtBQUNELFdBQU9xUCxTQUFTb0osS0FBVCxFQUFnQnBNLFdBQVdvd0IsT0FBM0IsRUFBb0NMLGFBQWFLLE9BQWpELENBQVA7QUFDSDtBQUNELFNBQVNyRyxtQkFBVCxDQUE2QjNkLEtBQTdCLEVBQW9DM0YsSUFBcEMsRUFBMEM0akIsVUFBMUMsRUFBc0RDLFVBQXRELEVBQWtFO0FBQzlELFFBQU1DLGFBQWFELGFBQWFELFVBQWhDO0FBQ0EsUUFBTUcsV0FBV3BlLFFBQVFpZSxVQUF6QjtBQUNBLFFBQUlFLGVBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsZUFBTyxDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUk5akIsU0FBUyxDQUFiLEVBQWdCO0FBQ25CLGVBQU8rakIsV0FBV0QsVUFBbEI7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPLENBQUM1ZixLQUFLdVcsR0FBTCxDQUFTemEsSUFBVCxFQUFlK2pCLFFBQWYsSUFBMkIsQ0FBNUIsS0FBa0M3ZixLQUFLdVcsR0FBTCxDQUFTemEsSUFBVCxFQUFlOGpCLFVBQWYsSUFBNkIsQ0FBL0QsQ0FBUDtBQUNIO0FBQ0o7O0lBRUtpSCxlO0FBQ0YsNkJBQVkxeEIsVUFBWixFQUF3Qml3QixZQUF4QixFQUFzQztBQUFBOztBQUNsQyxhQUFLandCLFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0EsYUFBSzJ4QixlQUFMLEdBQXVCLEVBQXZCO0FBQ0EsYUFBS0MsVUFBTCxHQUFrQixJQUFJdlQsaUJBQUosRUFBbEI7QUFDQSxhQUFLd1QsYUFBTCxHQUFxQjVCLGVBQWU2QixnQkFBZ0I3QixZQUFoQixDQUFmLEdBQStDLElBQXBFO0FBQ0EsYUFBSzhCLFdBQUwsR0FBbUI5QixnQkFBZ0JBLGFBQWFwN0IsSUFBYixLQUFzQixNQUF0QyxHQUErQ283QixhQUFhdjBCLE1BQTVELEdBQXFFLElBQXhGO0FBQ0g7Ozs7cURBQzRCNGlCLE8sRUFBU0MsTyxFQUFTQyxZLEVBQWNHLFMsRUFBV2xCLGUsRUFBaUJnQixnQixFQUFrQkcsZ0IsRUFBa0JDLG1CLEVBQXFCO0FBQzlJLGlCQUFLK1MsVUFBTCxDQUFnQnRULE9BQWhCLEdBQTBCQSxPQUExQjtBQUNBLGlCQUFLc1QsVUFBTCxDQUFnQnJULE9BQWhCLEdBQTBCQSxPQUExQjtBQUNBLGlCQUFLcVQsVUFBTCxDQUFnQnBULFlBQWhCLEdBQStCQSxZQUEvQjtBQUNBLGlCQUFLb1QsVUFBTCxDQUFnQmpULFNBQWhCLEdBQTRCQSxTQUE1QjtBQUNBLGlCQUFLaVQsVUFBTCxDQUFnQm5VLGVBQWhCLEdBQWtDQSxtQkFBbUIsSUFBckQ7QUFDQSxpQkFBS21VLFVBQUwsQ0FBZ0JuVCxnQkFBaEIsR0FBbUNBLGdCQUFuQztBQUNBLGlCQUFLbVQsVUFBTCxDQUFnQmhULGdCQUFoQixHQUFtQ0Esb0JBQW9CLElBQXZEO0FBQ0EsaUJBQUtnVCxVQUFMLENBQWdCL1MsbUJBQWhCLEdBQXNDQSx1QkFBdUIsSUFBN0Q7QUFDQSxtQkFBTyxLQUFLN2UsVUFBTCxDQUFnQjRjLFFBQWhCLENBQXlCLEtBQUtnVixVQUE5QixDQUFQO0FBQ0g7OztpQ0FDUXRULE8sRUFBU0MsTyxFQUFTQyxZLEVBQWNHLFMsRUFBV2xCLGUsRUFBaUJnQixnQixFQUFrQkcsZ0IsRUFBa0JDLG1CLEVBQXFCO0FBQzFILGlCQUFLK1MsVUFBTCxDQUFnQnRULE9BQWhCLEdBQTBCQSxPQUExQjtBQUNBLGlCQUFLc1QsVUFBTCxDQUFnQnJULE9BQWhCLEdBQTBCQSxXQUFXLElBQXJDO0FBQ0EsaUJBQUtxVCxVQUFMLENBQWdCcFQsWUFBaEIsR0FBK0JBLGdCQUFnQixJQUEvQztBQUNBLGlCQUFLb1QsVUFBTCxDQUFnQmpULFNBQWhCLEdBQTRCQSxTQUE1QjtBQUNBLGlCQUFLaVQsVUFBTCxDQUFnQm5VLGVBQWhCLEdBQWtDQSxtQkFBbUIsSUFBckQ7QUFDQSxpQkFBS21VLFVBQUwsQ0FBZ0JuVCxnQkFBaEIsR0FBbUNBLG9CQUFvQixJQUF2RDtBQUNBLGlCQUFLbVQsVUFBTCxDQUFnQmhULGdCQUFoQixHQUFtQ0Esb0JBQW9CLElBQXZEO0FBQ0EsaUJBQUtnVCxVQUFMLENBQWdCL1MsbUJBQWhCLEdBQXNDQSx1QkFBdUIsSUFBN0Q7QUFDQSxnQkFBSTtBQUNBLG9CQUFNZ1IsTUFBTSxLQUFLN3ZCLFVBQUwsQ0FBZ0I0YyxRQUFoQixDQUF5QixLQUFLZ1YsVUFBOUIsQ0FBWjtBQUNBLG9CQUFJL0IsUUFBUSxJQUFSLElBQWdCQSxRQUFRaDhCLFNBQXhCLElBQXFDLE9BQU9nOEIsR0FBUCxLQUFlLFFBQWYsSUFBMkJBLFFBQVFBLEdBQTVFLEVBQWlGO0FBQzdFLDJCQUFPLEtBQUtnQyxhQUFaO0FBQ0g7QUFDRCxvQkFBSSxLQUFLRSxXQUFMLElBQW9CLEVBQUVsQyxPQUFPLEtBQUtrQyxXQUFkLENBQXhCLEVBQW9EO0FBQ2hELDBCQUFNLElBQUl2VixZQUFKLGtDQUFpRDVULE9BQU9OLElBQVAsQ0FBWSxLQUFLeXBCLFdBQWpCLEVBQThCeGhDLEdBQTlCLENBQWtDO0FBQUEsK0JBQUtrQyxLQUFLOFUsU0FBTCxDQUFlNEgsQ0FBZixDQUFMO0FBQUEscUJBQWxDLEVBQTBEbFUsSUFBMUQsQ0FBK0QsSUFBL0QsQ0FBakQsb0JBQXNJeEksS0FBSzhVLFNBQUwsQ0FBZXNvQixHQUFmLENBQXRJLGVBQU47QUFDSDtBQUNELHVCQUFPQSxHQUFQO0FBQ0gsYUFURCxDQVNFLE9BQU9wN0IsQ0FBUCxFQUFVO0FBQ1Isb0JBQUksQ0FBQyxLQUFLazlCLGVBQUwsQ0FBcUJsOUIsRUFBRXFpQixPQUF2QixDQUFMLEVBQXNDO0FBQ2xDLHlCQUFLNmEsZUFBTCxDQUFxQmw5QixFQUFFcWlCLE9BQXZCLElBQWtDLElBQWxDO0FBQ0Esd0JBQUksT0FBTzdpQixPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2hDQSxnQ0FBUSs5QixJQUFSLENBQWF2OUIsRUFBRXFpQixPQUFmO0FBQ0g7QUFDSjtBQUNELHVCQUFPLEtBQUsrYSxhQUFaO0FBQ0g7QUFDSjs7Ozs7O0FBRUwsU0FBU0ksWUFBVCxDQUFzQmp5QixVQUF0QixFQUFrQztBQUM5QixXQUFPalEsTUFBTUMsT0FBTixDQUFjZ1EsVUFBZCxLQUE2QkEsV0FBVzlQLE1BQVgsR0FBb0IsQ0FBakQsSUFBc0QsT0FBTzhQLFdBQVcsQ0FBWCxDQUFQLEtBQXlCLFFBQS9FLElBQTJGQSxXQUFXLENBQVgsS0FBaUJ5dUIsV0FBbkg7QUFDSDtBQUNELFNBQVN5RCxnQkFBVCxDQUEwQmx5QixVQUExQixFQUFzQ2l3QixZQUF0QyxFQUFvRDtBQUNoRCxRQUFNa0MsU0FBUyxJQUFJclMsY0FBSixDQUFtQjJPLFdBQW5CLEVBQWdDLEVBQWhDLEVBQW9Dd0IsZUFBZW1DLGdCQUFnQm5DLFlBQWhCLENBQWYsR0FBK0NwOEIsU0FBbkYsQ0FBZjtBQUNBLFFBQU1rcEIsU0FBU29WLE9BQU96L0IsS0FBUCxDQUFhc04sVUFBYixFQUF5Qm5NLFNBQXpCLEVBQW9DQSxTQUFwQyxFQUErQ0EsU0FBL0MsRUFBMERvOEIsZ0JBQWdCQSxhQUFhcDdCLElBQWIsS0FBc0IsUUFBdEMsR0FBaUQsRUFBRTJ3QixnQkFBZ0IsUUFBbEIsRUFBakQsR0FBZ0YzeEIsU0FBMUksQ0FBZjtBQUNBLFFBQUksQ0FBQ2twQixNQUFMLEVBQWE7QUFDVCxlQUFPN29CLE1BQU1pK0IsT0FBT3huQixNQUFiLENBQVA7QUFDSDtBQUNELFdBQU80a0IsUUFBUSxJQUFJbUMsZUFBSixDQUFvQjNVLE1BQXBCLEVBQTRCa1QsWUFBNUIsQ0FBUixDQUFQO0FBQ0g7O0lBQ0tvQyxzQjtBQUNGLG9DQUFZbGIsSUFBWixFQUFrQm5YLFVBQWxCLEVBQThCO0FBQUE7O0FBQzFCLGFBQUttWCxJQUFMLEdBQVlBLElBQVo7QUFDQSxhQUFLbWIsZ0JBQUwsR0FBd0J0eUIsVUFBeEI7QUFDQSxhQUFLdXlCLGdCQUFMLEdBQXdCcGIsU0FBUyxVQUFULElBQXVCLENBQUM4TixnQkFBZ0JqbEIsV0FBV0EsVUFBM0IsQ0FBaEQ7QUFDSDs7OztxREFDNEJzZSxPLEVBQVNDLE8sRUFBU0MsWSxFQUFjRyxTLEVBQVdsQixlLEVBQWlCZ0IsZ0IsRUFBa0I7QUFDdkcsbUJBQU8sS0FBSzZULGdCQUFMLENBQXNCRSw0QkFBdEIsQ0FBbURsVSxPQUFuRCxFQUE0REMsT0FBNUQsRUFBcUVDLFlBQXJFLEVBQW1GRyxTQUFuRixFQUE4RmxCLGVBQTlGLEVBQStHZ0IsZ0JBQS9HLENBQVA7QUFDSDs7O2lDQUNRSCxPLEVBQVNDLE8sRUFBU0MsWSxFQUFjRyxTLEVBQVdsQixlLEVBQWlCZ0IsZ0IsRUFBa0I7QUFDbkYsbUJBQU8sS0FBSzZULGdCQUFMLENBQXNCMVYsUUFBdEIsQ0FBK0IwQixPQUEvQixFQUF3Q0MsT0FBeEMsRUFBaURDLFlBQWpELEVBQStERyxTQUEvRCxFQUEwRWxCLGVBQTFFLEVBQTJGZ0IsZ0JBQTNGLENBQVA7QUFDSDs7Ozs7O0lBRUNnVSx1QjtBQUNGLHFDQUFZdGIsSUFBWixFQUFrQm5YLFVBQWxCLEVBQThCZ3hCLFNBQTlCLEVBQXlDRSxpQkFBekMsRUFBNEQ7QUFBQTs7QUFDeEQsYUFBSy9aLElBQUwsR0FBWUEsSUFBWjtBQUNBLGFBQUs2WixTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLGFBQUtzQixnQkFBTCxHQUF3QnR5QixVQUF4QjtBQUNBLGFBQUt1eUIsZ0JBQUwsR0FBd0JwYixTQUFTLFFBQVQsSUFBcUIsQ0FBQzhOLGdCQUFnQmpsQixXQUFXQSxVQUEzQixDQUE5QztBQUNBLGFBQUtreEIsaUJBQUwsR0FBeUJBLGlCQUF6QjtBQUNIOzs7O3FEQUM0QjVTLE8sRUFBU0MsTyxFQUFTQyxZLEVBQWNHLFMsRUFBV2xCLGUsRUFBaUJnQixnQixFQUFrQjtBQUN2RyxtQkFBTyxLQUFLNlQsZ0JBQUwsQ0FBc0JFLDRCQUF0QixDQUFtRGxVLE9BQW5ELEVBQTREQyxPQUE1RCxFQUFxRUMsWUFBckUsRUFBbUZHLFNBQW5GLEVBQThGbEIsZUFBOUYsRUFBK0dnQixnQkFBL0csQ0FBUDtBQUNIOzs7aUNBQ1FILE8sRUFBU0MsTyxFQUFTQyxZLEVBQWNHLFMsRUFBV2xCLGUsRUFBaUJnQixnQixFQUFrQjtBQUNuRixtQkFBTyxLQUFLNlQsZ0JBQUwsQ0FBc0IxVixRQUF0QixDQUErQjBCLE9BQS9CLEVBQXdDQyxPQUF4QyxFQUFpREMsWUFBakQsRUFBK0RHLFNBQS9ELEVBQTBFbEIsZUFBMUUsRUFBMkZnQixnQkFBM0YsQ0FBUDtBQUNIOzs7NENBQ21CblMsSyxFQUFPeWQsSyxFQUFPQyxLLEVBQU87QUFDckMsZ0JBQUksS0FBS2tILGlCQUFULEVBQTRCO0FBQ3hCLHVCQUFPdEgsWUFBWUssbUJBQVosQ0FBZ0MsS0FBS2lILGlCQUFyQyxFQUF3RDVrQixLQUF4RCxFQUErRHlkLEtBQS9ELEVBQXNFQyxLQUF0RSxDQUFQO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsdUJBQU8sQ0FBUDtBQUNIO0FBQ0o7Ozs7OztBQUVMLFNBQVMwSSx3QkFBVCxDQUFrQzF5QixVQUFsQyxFQUE4Q2l3QixZQUE5QyxFQUE0RDtBQUN4RGp3QixpQkFBYWt5QixpQkFBaUJseUIsVUFBakIsRUFBNkJpd0IsWUFBN0IsQ0FBYjtBQUNBLFFBQUlqd0IsV0FBVytJLE1BQVgsS0FBc0IsT0FBMUIsRUFBbUM7QUFDL0IsZUFBTy9JLFVBQVA7QUFDSDtBQUNELFFBQU0rYyxTQUFTL2MsV0FBV2pFLEtBQVgsQ0FBaUJpRSxVQUFoQztBQUNBLFFBQU0yeUIsc0JBQXNCM04sa0JBQWtCakksTUFBbEIsQ0FBNUI7QUFDQSxRQUFJLENBQUM0VixtQkFBRCxJQUF3QixDQUFDbkQsMkJBQTJCUyxZQUEzQixDQUE3QixFQUF1RTtBQUNuRSxlQUFPLzdCLE1BQU0sQ0FBQyxJQUFJMmlCLFlBQUosQ0FBaUIsRUFBakIsRUFBcUIsZ0NBQXJCLENBQUQsQ0FBTixDQUFQO0FBQ0g7QUFDRCxRQUFNK2IsaUJBQWlCMU4seUJBQXlCbkksTUFBekIsRUFBaUMsQ0FDcEQsTUFEb0QsRUFFcEQsT0FGb0QsRUFHcEQsc0JBSG9ELENBQWpDLENBQXZCO0FBS0EsUUFBSSxDQUFDNlYsY0FBRCxJQUFtQixDQUFDbEQsdUJBQXVCTyxZQUF2QixDQUF4QixFQUE4RDtBQUMxRCxlQUFPLzdCLE1BQU0sQ0FBQyxJQUFJMmlCLFlBQUosQ0FBaUIsRUFBakIsRUFBcUIsZ0NBQXJCLENBQUQsQ0FBTixDQUFQO0FBQ0g7QUFDRCxRQUFNZ2MsWUFBWUMsY0FBYy9WLE1BQWQsQ0FBbEI7QUFDQSxRQUFJLENBQUM4VixTQUFELElBQWMsQ0FBQ0QsY0FBbkIsRUFBbUM7QUFDL0IsZUFBTzErQixNQUFNLENBQUMsSUFBSTJpQixZQUFKLENBQWlCLEVBQWpCLEVBQXFCLGdHQUFyQixDQUFELENBQU4sQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJZ2MscUJBQXFCaGMsWUFBekIsRUFBdUM7QUFDMUMsZUFBTzNpQixNQUFNLENBQUMyK0IsU0FBRCxDQUFOLENBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSUEscUJBQXFCakosV0FBckIsSUFBb0MsQ0FBQytGLHNCQUFzQk0sWUFBdEIsQ0FBekMsRUFBOEU7QUFDakYsZUFBTy83QixNQUFNLENBQUMsSUFBSTJpQixZQUFKLENBQWlCLEVBQWpCLEVBQXFCLDZEQUFyQixDQUFELENBQU4sQ0FBUDtBQUNIO0FBQ0QsUUFBSSxDQUFDZ2MsU0FBTCxFQUFnQjtBQUNaLGVBQU90RCxRQUFRb0Qsc0JBQXNCLElBQUlOLHNCQUFKLENBQTJCLFVBQTNCLEVBQXVDcnlCLFdBQVdqRSxLQUFsRCxDQUF0QixHQUFpRixJQUFJczJCLHNCQUFKLENBQTJCLFFBQTNCLEVBQXFDcnlCLFdBQVdqRSxLQUFoRCxDQUF6RixDQUFQO0FBQ0g7QUFDRCxRQUFNbTFCLG9CQUFvQjJCLHFCQUFxQmpKLFdBQXJCLEdBQW1DaUosVUFBVS9JLGFBQTdDLEdBQTZEajJCLFNBQXZGO0FBQ0EsV0FBTzA3QixRQUFRb0Qsc0JBQXNCLElBQUlGLHVCQUFKLENBQTRCLFFBQTVCLEVBQXNDenlCLFdBQVdqRSxLQUFqRCxFQUF3RDgyQixVQUFVMW5CLE1BQWxFLEVBQTBFK2xCLGlCQUExRSxDQUF0QixHQUFxSCxJQUFJdUIsdUJBQUosQ0FBNEIsV0FBNUIsRUFBeUN6eUIsV0FBV2pFLEtBQXBELEVBQTJEODJCLFVBQVUxbkIsTUFBckUsRUFBNkUrbEIsaUJBQTdFLENBQTdILENBQVA7QUFDSDs7SUFDSzZCLHFCO0FBQ0YsbUNBQVk3eUIsVUFBWixFQUF3Qjh5QixhQUF4QixFQUF1QztBQUFBOztBQUNuQyxhQUFLQyxXQUFMLEdBQW1CL3lCLFVBQW5CO0FBQ0EsYUFBS2d6QixjQUFMLEdBQXNCRixhQUF0QjtBQUNBcmMsZUFBTyxJQUFQLEVBQWFxWixlQUFlLEtBQUtpRCxXQUFwQixFQUFpQyxLQUFLQyxjQUF0QyxDQUFiO0FBQ0g7Ozs7b0NBQ2tCMVgsVSxFQUFZO0FBQzNCLG1CQUFPLElBQUl1WCxxQkFBSixDQUEwQnZYLFdBQVd5WCxXQUFyQyxFQUFrRHpYLFdBQVcwWCxjQUE3RCxDQUFQO0FBQ0g7OztrQ0FDZ0I1bUIsSyxFQUFPO0FBQ3BCLG1CQUFPO0FBQ0gybUIsNkJBQWEzbUIsTUFBTTJtQixXQURoQjtBQUVIQyxnQ0FBZ0I1bUIsTUFBTTRtQjtBQUZuQixhQUFQO0FBSUg7Ozs7OztBQUVMLFNBQVNDLDJCQUFULENBQXFDcDNCLEtBQXJDLEVBQTRDaTNCLGFBQTVDLEVBQTJEO0FBQ3ZELFFBQUlsRCxhQUFhL3pCLEtBQWIsQ0FBSixFQUF5QjtBQUNyQixlQUFPLElBQUlnM0IscUJBQUosQ0FBMEJoM0IsS0FBMUIsRUFBaUNpM0IsYUFBakMsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJZixhQUFhbDJCLEtBQWIsQ0FBSixFQUF5QjtBQUM1QixZQUFNaUUsZUFBYTB5Qix5QkFBeUIzMkIsS0FBekIsRUFBZ0NpM0IsYUFBaEMsQ0FBbkI7QUFDQSxZQUFJaHpCLGFBQVcrSSxNQUFYLEtBQXNCLE9BQTFCLEVBQW1DO0FBQy9CLGtCQUFNLElBQUluVyxLQUFKLENBQVVvTixhQUFXakUsS0FBWCxDQUFpQnhMLEdBQWpCLENBQXFCO0FBQUEsdUJBQVd5RCxJQUFJa0YsR0FBZixVQUF5QmxGLElBQUk4aUIsT0FBN0I7QUFBQSxhQUFyQixFQUE4RDdiLElBQTlELENBQW1FLElBQW5FLENBQVYsQ0FBTjtBQUNIO0FBQ0QsZUFBTytFLGFBQVdqRSxLQUFsQjtBQUNILEtBTk0sTUFNQTtBQUNILFlBQUlxTCxXQUFXckwsS0FBZjtBQUNBLFlBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QmkzQixjQUFjbitCLElBQWQsS0FBdUIsT0FBeEQsRUFBaUU7QUFDN0R1Uyx1QkFBVzlSLE1BQU01QyxLQUFOLENBQVlxSixLQUFaLENBQVg7QUFDSDtBQUNELGVBQU87QUFDSG9iLGtCQUFNLFVBREg7QUFFSHlGLHNCQUFVO0FBQUEsdUJBQU14VixRQUFOO0FBQUE7QUFGUCxTQUFQO0FBSUg7QUFDSjtBQUNELFNBQVMwckIsYUFBVCxDQUF1Qjl5QixVQUF2QixFQUFtQztBQUMvQixRQUFJK0ksU0FBUyxJQUFiO0FBQ0EsUUFBSS9JLHNCQUFzQitxQixHQUExQixFQUErQjtBQUMzQmhpQixpQkFBUytwQixjQUFjOXlCLFdBQVcrSSxNQUF6QixDQUFUO0FBQ0gsS0FGRCxNQUVPLElBQUkvSSxzQkFBc0IycUIsUUFBMUIsRUFBb0M7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDdkMsbUNBQWtCM3FCLFdBQVdxYyxJQUE3Qix3SUFBbUM7QUFBQSxvQkFBeEJuTyxHQUF3Qjs7QUFDL0JuRix5QkFBUytwQixjQUFjNWtCLEdBQWQsQ0FBVDtBQUNBLG9CQUFJbkYsTUFBSixFQUFZO0FBQ1I7QUFDSDtBQUNKO0FBTnNDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPMUMsS0FQTSxNQU9BLElBQUksQ0FBQy9JLHNCQUFzQnFtQixJQUF0QixJQUE4QnJtQixzQkFBc0I0cEIsV0FBckQsS0FBcUU1cEIsV0FBV3NNLEtBQVgsWUFBNEJnVCxrQkFBakcsSUFBdUh0ZixXQUFXc00sS0FBWCxDQUFpQnpRLElBQWpCLEtBQTBCLE1BQXJKLEVBQTZKO0FBQ2hLa04saUJBQVMvSSxVQUFUO0FBQ0g7QUFDRCxRQUFJK0ksa0JBQWtCOE4sWUFBdEIsRUFBb0M7QUFDaEMsZUFBTzlOLE1BQVA7QUFDSDtBQUNEL0ksZUFBV2tlLFNBQVgsQ0FBcUIsaUJBQVM7QUFDMUIsWUFBTWtWLGNBQWNOLGNBQWMzVSxLQUFkLENBQXBCO0FBQ0EsWUFBSWlWLHVCQUF1QnZjLFlBQTNCLEVBQXlDO0FBQ3JDOU4scUJBQVNxcUIsV0FBVDtBQUNILFNBRkQsTUFFTyxJQUFJLENBQUNycUIsTUFBRCxJQUFXcXFCLFdBQWYsRUFBNEI7QUFDL0JycUIscUJBQVMsSUFBSThOLFlBQUosQ0FBaUIsRUFBakIsRUFBcUIsZ0dBQXJCLENBQVQ7QUFDSCxTQUZNLE1BRUEsSUFBSTlOLFVBQVVxcUIsV0FBVixJQUF5QnJxQixXQUFXcXFCLFdBQXhDLEVBQXFEO0FBQ3hEcnFCLHFCQUFTLElBQUk4TixZQUFKLENBQWlCLEVBQWpCLEVBQXFCLHlGQUFyQixDQUFUO0FBQ0g7QUFDSixLQVREO0FBVUEsV0FBTzlOLE1BQVA7QUFDSDtBQUNELFNBQVNxcEIsZUFBVCxDQUF5QjNDLElBQXpCLEVBQStCO0FBQzNCLFFBQU1oVCxRQUFRO0FBQ1ZuZ0IsZUFBT2liLFNBREc7QUFFVmhVLGdCQUFROFQsVUFGRTtBQUdWN1QsZ0JBQVE0VCxVQUhFO0FBSVZpYyxjQUFNaGMsVUFKSTtBQUtWNVQsaUJBQVM2VCxXQUxDO0FBTVZnYyxtQkFBVzFiLGFBTkQ7QUFPVjJiLHVCQUFlMWI7QUFQTCxLQUFkO0FBU0EsUUFBSTRYLEtBQUs1NkIsSUFBTCxLQUFjLE9BQWxCLEVBQTJCO0FBQ3ZCLGVBQU9tTyxNQUFNeVosTUFBTWdULEtBQUsxekIsS0FBWCxLQUFxQjBiLFNBQTNCLEVBQXNDZ1ksS0FBS3YvQixNQUEzQyxDQUFQO0FBQ0g7QUFDRCxXQUFPdXNCLE1BQU1nVCxLQUFLNTZCLElBQVgsQ0FBUDtBQUNIO0FBQ0QsU0FBU2k5QixlQUFULENBQXlCckMsSUFBekIsRUFBK0I7QUFDM0IsUUFBSUEsS0FBSzU2QixJQUFMLEtBQWMsT0FBZCxJQUF5Qmk3QixhQUFhTCxLQUFLYSxPQUFsQixDQUE3QixFQUF5RDtBQUNyRCxlQUFPLElBQUloN0IsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSW02QixLQUFLNTZCLElBQUwsS0FBYyxPQUFsQixFQUEyQjtBQUM5QixlQUFPUyxNQUFNNUMsS0FBTixDQUFZKzhCLEtBQUthLE9BQWpCLEtBQTZCLElBQXBDO0FBQ0gsS0FGTSxNQUVBLElBQUliLEtBQUthLE9BQUwsS0FBaUJ6OEIsU0FBckIsRUFBZ0M7QUFDbkMsZUFBTyxJQUFQO0FBQ0gsS0FGTSxNQUVBO0FBQ0gsZUFBTzQ3QixLQUFLYSxPQUFaO0FBQ0g7QUFDSjs7QUFFRCxTQUFTa0QsY0FBVCxDQUF3QnozQixLQUF4QixFQUErQjtBQUMzQixXQUFPLFFBQU9BLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBakIsR0FBNEIsQ0FDL0IsU0FEK0IsRUFFL0JBLEtBRitCLENBQTVCLEdBR0hBLEtBSEo7QUFJSDtBQUNELFNBQVMwM0IsZUFBVCxDQUF5QnZ6QixVQUF6QixFQUFxQyt2QixZQUFyQyxFQUFtRDtBQUMvQyxRQUFJaGdDLFFBQVFpUSxXQUFXalEsS0FBdkI7QUFDQSxRQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNSLGVBQU95akMsd0JBQXdCeHpCLFVBQXhCLEVBQW9DK3ZCLFlBQXBDLENBQVA7QUFDSDtBQUNELFFBQU1FLDBCQUEwQmxnQyxTQUFTLFFBQU9BLE1BQU0sQ0FBTixFQUFTLENBQVQsQ0FBUCxNQUF1QixRQUFoRTtBQUNBLFFBQU1tZ0MsbUJBQW1CRCwyQkFBMkJqd0IsV0FBVzBHLFFBQVgsS0FBd0IvUyxTQUE1RTtBQUNBLFFBQU13OEIsZ0JBQWdCRiwyQkFBMkIsQ0FBQ0MsZ0JBQWxEO0FBQ0FuZ0MsWUFBUUEsTUFBTU0sR0FBTixDQUFVLGdCQUFRO0FBQ3RCLFlBQUksQ0FBQzYvQixnQkFBRCxJQUFxQkgsYUFBYTl1QixNQUFsQyxJQUE0QyxPQUFPZ1YsS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBbkUsRUFBNkU7QUFDekUsbUJBQU8sQ0FDSEEsS0FBSyxDQUFMLENBREcsRUFFSHdkLG1CQUFtQnhkLEtBQUssQ0FBTCxDQUFuQixDQUZHLENBQVA7QUFJSDtBQUNELGVBQU8sQ0FDSEEsS0FBSyxDQUFMLENBREcsRUFFSHFkLGVBQWVyZCxLQUFLLENBQUwsQ0FBZixDQUZHLENBQVA7QUFJSCxLQVhPLENBQVI7QUFZQSxRQUFJZ2EsdUJBQUosRUFBNkI7QUFDekIsZUFBT3lELCtCQUErQjF6QixVQUEvQixFQUEyQyt2QixZQUEzQyxFQUF5RGhnQyxLQUF6RCxDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUlvZ0MsYUFBSixFQUFtQjtBQUN0QixlQUFPd0Qsb0JBQW9CM3pCLFVBQXBCLEVBQWdDK3ZCLFlBQWhDLEVBQThDaGdDLEtBQTlDLENBQVA7QUFDSCxLQUZNLE1BRUE7QUFDSCxlQUFPNmpDLHdCQUF3QjV6QixVQUF4QixFQUFvQyt2QixZQUFwQyxFQUFrRGhnQyxLQUFsRCxDQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVN5akMsdUJBQVQsQ0FBaUN4ekIsVUFBakMsRUFBNkMrdkIsWUFBN0MsRUFBMkQ7QUFDdkQsUUFBTTMwQixNQUFNLENBQ1IsS0FEUSxFQUVSNEUsV0FBVzBHLFFBRkgsQ0FBWjtBQUlBLFFBQUkxRyxXQUFXb3dCLE9BQVgsS0FBdUJ6OEIsU0FBM0IsRUFBc0M7QUFDbEMsZUFBT284QixhQUFhcDdCLElBQWIsS0FBc0IsUUFBdEIsR0FBaUMsQ0FDcEMsUUFEb0MsRUFFcEN5RyxHQUZvQyxDQUFqQyxHQUdIQSxHQUhKO0FBSUgsS0FMRCxNQUtPLElBQUkyMEIsYUFBYXA3QixJQUFiLEtBQXNCLE1BQTFCLEVBQWtDO0FBQ3JDLGVBQU8sQ0FDSCxPQURHLEVBRUh5RyxHQUZHLEVBR0hzTixPQUFPTixJQUFQLENBQVkybkIsYUFBYXYwQixNQUF6QixDQUhHLEVBSUhKLEdBSkcsRUFLSDRFLFdBQVdvd0IsT0FMUixDQUFQO0FBT0gsS0FSTSxNQVFBO0FBQ0gsWUFBTXR3QixlQUFhLENBQ2Zpd0IsYUFBYXA3QixJQUFiLEtBQXNCLE9BQXRCLEdBQWdDLFVBQWhDLEdBQTZDbzdCLGFBQWFwN0IsSUFEM0MsRUFFZnlHLEdBRmUsRUFHZms0QixlQUFldHpCLFdBQVdvd0IsT0FBMUIsQ0FIZSxDQUFuQjtBQUtBLFlBQUlMLGFBQWFwN0IsSUFBYixLQUFzQixPQUExQixFQUFtQztBQUMvQm1MLHlCQUFXa04sTUFBWCxDQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QitpQixhQUFhbDBCLEtBQXJDLEVBQTRDazBCLGFBQWEvL0IsTUFBYixJQUF1QixJQUFuRTtBQUNIO0FBQ0QsZUFBTzhQLFlBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBUyt6QixzQkFBVCxDQUFnQzd6QixVQUFoQyxFQUE0QztBQUN4QyxZQUFRQSxXQUFXK0csVUFBbkI7QUFDQSxhQUFLLEtBQUw7QUFDSSxtQkFBTyxpQkFBUDtBQUNKLGFBQUssS0FBTDtBQUNJLG1CQUFPLGlCQUFQO0FBQ0o7QUFDSSxtQkFBTyxhQUFQO0FBTko7QUFRSDtBQUNELFNBQVMyc0IsOEJBQVQsQ0FBd0MxekIsVUFBeEMsRUFBb0QrdkIsWUFBcEQsRUFBa0VoZ0MsS0FBbEUsRUFBeUU7QUFDckUsUUFBTStqQyw0QkFBNEIsRUFBbEM7QUFDQSxRQUFNL0MsdUJBQXVCLEVBQTdCO0FBQ0EsUUFBTUQsWUFBWSxFQUFsQjtBQUNBLFNBQUssSUFBSXhkLElBQUksQ0FBYixFQUFnQkEsSUFBSXZqQixNQUFNQyxNQUExQixFQUFrQ3NqQixHQUFsQyxFQUF1QztBQUNuQyxZQUFNMkMsT0FBT2xtQixNQUFNdWpCLENBQU4sQ0FBYjtBQUNBLFlBQU10ZSxPQUFPaWhCLEtBQUssQ0FBTCxFQUFRamhCLElBQXJCO0FBQ0EsWUFBSTgrQiwwQkFBMEI5K0IsSUFBMUIsTUFBb0NyQixTQUF4QyxFQUFtRDtBQUMvQ21nQyxzQ0FBMEI5K0IsSUFBMUIsSUFBa0M7QUFDOUJBLDBCQUQ4QjtBQUU5Qkwsc0JBQU1xTCxXQUFXckwsSUFGYTtBQUc5QitSLDBCQUFVMUcsV0FBVzBHLFFBSFM7QUFJOUIwcEIseUJBQVNwd0IsV0FBV293QjtBQUpVLGFBQWxDO0FBTUFXLGlDQUFxQi83QixJQUFyQixJQUE2QixFQUE3QjtBQUNBODdCLHNCQUFVbmdDLElBQVYsQ0FBZXFFLElBQWY7QUFDSDtBQUNEKzdCLDZCQUFxQi83QixJQUFyQixFQUEyQnJFLElBQTNCLENBQWdDLENBQzVCc2xCLEtBQUssQ0FBTCxFQUFRcGEsS0FEb0IsRUFFNUJvYSxLQUFLLENBQUwsQ0FGNEIsQ0FBaEM7QUFJSDtBQUNELFFBQU04ZCxlQUFlQyxnQkFBZ0IsRUFBaEIsRUFBb0JqRSxZQUFwQixDQUFyQjtBQUNBLFFBQUlnRSxpQkFBaUIsYUFBckIsRUFBb0M7QUFDaEMsWUFBTWowQixnQkFBYSxDQUNmK3pCLHVCQUF1Qjd6QixVQUF2QixDQURlLEVBRWYsQ0FBQyxRQUFELENBRmUsRUFHZixDQUFDLE1BQUQsQ0FIZSxDQUFuQjtBQURnQztBQUFBO0FBQUE7O0FBQUE7QUFNaEMsbUNBQWdCOHdCLFNBQWhCLHdJQUEyQjtBQUFBLG9CQUFoQjNQLENBQWdCOztBQUN2QixvQkFBTS9WLFNBQVN3b0Isd0JBQXdCRSwwQkFBMEIzUyxDQUExQixDQUF4QixFQUFzRDRPLFlBQXRELEVBQW9FZ0IscUJBQXFCNVAsQ0FBckIsQ0FBcEUsQ0FBZjtBQUNBOFMsK0JBQWVuMEIsYUFBZixFQUEyQnFoQixDQUEzQixFQUE4Qi9WLE1BQTlCLEVBQXNDLEtBQXRDO0FBQ0g7QUFUK0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVaEMsZUFBT3RMLGFBQVA7QUFDSCxLQVhELE1BV087QUFDSCxZQUFNQSxnQkFBYSxDQUNmLE1BRGUsRUFFZixDQUFDLE1BQUQsQ0FGZSxDQUFuQjtBQURHO0FBQUE7QUFBQTs7QUFBQTtBQUtILG1DQUFnQmd4QixTQUFoQix3SUFBMkI7QUFBQSxvQkFBaEIzUCxFQUFnQjs7QUFDdkIsb0JBQU0vVixVQUFTd29CLHdCQUF3QkUsMEJBQTBCM1MsRUFBMUIsQ0FBeEIsRUFBc0Q0TyxZQUF0RCxFQUFvRWdCLHFCQUFxQjVQLEVBQXJCLENBQXBFLENBQWY7QUFDQThTLCtCQUFlbjBCLGFBQWYsRUFBMkJxaEIsRUFBM0IsRUFBOEIvVixPQUE5QixFQUFzQyxJQUF0QztBQUNIO0FBUkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTSDhvQixpQ0FBeUJwMEIsYUFBekI7QUFDQSxlQUFPQSxhQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVNxMEIsVUFBVCxDQUFvQnY1QixDQUFwQixFQUF1QmdmLENBQXZCLEVBQTBCO0FBQ3RCLFFBQUloZixNQUFNakgsU0FBVixFQUNJLE9BQU9pSCxDQUFQO0FBQ0osUUFBSWdmLE1BQU1qbUIsU0FBVixFQUNJLE9BQU9pbUIsQ0FBUDtBQUNQO0FBQ0QsU0FBU3dhLFdBQVQsQ0FBcUJwMEIsVUFBckIsRUFBaUMrdkIsWUFBakMsRUFBK0M7QUFDM0MsUUFBTXNFLGVBQWVmLGVBQWVhLFdBQVduMEIsV0FBV293QixPQUF0QixFQUErQkwsYUFBYUssT0FBNUMsQ0FBZixDQUFyQjtBQUNBLFFBQUlpRSxpQkFBaUIxZ0MsU0FBakIsSUFBOEJvOEIsYUFBYXA3QixJQUFiLEtBQXNCLGVBQXhELEVBQXlFO0FBQ3JFLGVBQU8sRUFBUDtBQUNIO0FBQ0QsV0FBTzAvQixZQUFQO0FBQ0g7QUFDRCxTQUFTVCx1QkFBVCxDQUFpQzV6QixVQUFqQyxFQUE2Qyt2QixZQUE3QyxFQUEyRGhnQyxLQUEzRCxFQUFrRTtBQUM5RCxRQUFNNEUsT0FBT3EvQixnQkFBZ0JoMEIsVUFBaEIsRUFBNEIrdkIsWUFBNUIsQ0FBYjtBQUNBLFFBQU0zMEIsTUFBTSxDQUNSLEtBRFEsRUFFUjRFLFdBQVcwRyxRQUZILENBQVo7QUFJQSxRQUFJL1IsU0FBUyxhQUFULElBQTBCLE9BQU81RSxNQUFNLENBQU4sRUFBUyxDQUFULENBQVAsS0FBdUIsU0FBckQsRUFBZ0U7QUFDNUQsWUFBTStQLGdCQUFhLENBQUMsTUFBRCxDQUFuQjtBQUQ0RDtBQUFBO0FBQUE7O0FBQUE7QUFFNUQsbUNBQW1CL1AsS0FBbkIsd0lBQTBCO0FBQUEsb0JBQWZrbUIsSUFBZTs7QUFDdEJuVyw4QkFBV25QLElBQVgsQ0FBZ0IsQ0FDWixJQURZLEVBRVp5SyxHQUZZLEVBR1o2YSxLQUFLLENBQUwsQ0FIWSxDQUFoQixFQUlHQSxLQUFLLENBQUwsQ0FKSDtBQUtIO0FBUjJEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBUzVEblcsc0JBQVduUCxJQUFYLENBQWdCeWpDLFlBQVlwMEIsVUFBWixFQUF3Qit2QixZQUF4QixDQUFoQjtBQUNBLGVBQU9qd0IsYUFBUDtBQUNILEtBWEQsTUFXTyxJQUFJbkwsU0FBUyxhQUFiLEVBQTRCO0FBQy9CLFlBQU1tTCxnQkFBYSxDQUNmLE9BRGUsRUFFZjFFLEdBRmUsQ0FBbkI7QUFEK0I7QUFBQTtBQUFBOztBQUFBO0FBSy9CLG1DQUFtQnJMLEtBQW5CLHdJQUEwQjtBQUFBLG9CQUFma21CLE1BQWU7O0FBQ3RCZ2UsK0JBQWVuMEIsYUFBZixFQUEyQm1XLE9BQUssQ0FBTCxDQUEzQixFQUFvQ0EsT0FBSyxDQUFMLENBQXBDLEVBQTZDLEtBQTdDO0FBQ0g7QUFQOEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFRL0JuVyxzQkFBV25QLElBQVgsQ0FBZ0J5akMsWUFBWXAwQixVQUFaLEVBQXdCK3ZCLFlBQXhCLENBQWhCO0FBQ0EsZUFBT2p3QixhQUFQO0FBQ0gsS0FWTSxNQVVBLElBQUluTCxTQUFTLFVBQWIsRUFBeUI7QUFDNUIsWUFBTW1MLGdCQUFhLENBQ2YsTUFEZSxFQUVmLENBQ0ksUUFESixFQUVJMUUsR0FGSixDQUZlLENBQW5CO0FBRDRCO0FBQUE7QUFBQTs7QUFBQTtBQVE1QixtQ0FBbUJyTCxLQUFuQix3SUFBMEI7QUFBQSxvQkFBZmttQixNQUFlOztBQUN0QmdlLCtCQUFlbjBCLGFBQWYsRUFBMkJtVyxPQUFLLENBQUwsQ0FBM0IsRUFBb0NBLE9BQUssQ0FBTCxDQUFwQyxFQUE2QyxJQUE3QztBQUNIO0FBVjJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVzVCaWUsaUNBQXlCcDBCLGFBQXpCO0FBQ0EsZUFBT0UsV0FBV293QixPQUFYLEtBQXVCejhCLFNBQXZCLEdBQW1DbU0sYUFBbkMsR0FBZ0QsQ0FDbkQsTUFEbUQsRUFFbkQsQ0FDSSxJQURKLEVBRUksQ0FDSSxRQURKLEVBRUkxRSxHQUZKLENBRkosRUFNSSxRQU5KLENBRm1ELEVBVW5EMEUsYUFWbUQsRUFXbkR3ekIsZUFBZXR6QixXQUFXb3dCLE9BQTFCLENBWG1ELENBQXZEO0FBYUgsS0F6Qk0sTUF5QkEsSUFBSXo3QixTQUFTLGFBQWIsRUFBNEI7QUFDL0IsWUFBTThSLE9BQU96RyxXQUFXeUcsSUFBWCxLQUFvQjlTLFNBQXBCLEdBQWdDcU0sV0FBV3lHLElBQTNDLEdBQWtELENBQS9EO0FBQ0EsWUFBTTNHLGdCQUFhLENBQ2YrekIsdUJBQXVCN3pCLFVBQXZCLENBRGUsRUFFZnlHLFNBQVMsQ0FBVCxHQUFhLENBQUMsUUFBRCxDQUFiLEdBQTBCLENBQ3RCLGFBRHNCLEVBRXRCQSxJQUZzQixDQUZYLEVBTWYsQ0FDSSxRQURKLEVBRUlyTCxHQUZKLENBTmUsQ0FBbkI7QUFGK0I7QUFBQTtBQUFBOztBQUFBO0FBYS9CLG1DQUFtQnJMLEtBQW5CLHdJQUEwQjtBQUFBLG9CQUFma21CLE1BQWU7O0FBQ3RCZ2UsK0JBQWVuMEIsYUFBZixFQUEyQm1XLE9BQUssQ0FBTCxDQUEzQixFQUFvQ0EsT0FBSyxDQUFMLENBQXBDLEVBQTZDLEtBQTdDO0FBQ0g7QUFmOEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnQi9CLGVBQU9qVyxXQUFXb3dCLE9BQVgsS0FBdUJ6OEIsU0FBdkIsR0FBbUNtTSxhQUFuQyxHQUFnRCxDQUNuRCxNQURtRCxFQUVuRCxDQUNJLElBREosRUFFSSxDQUNJLFFBREosRUFFSTFFLEdBRkosQ0FGSixFQU1JLFFBTkosQ0FGbUQsRUFVbkQwRSxhQVZtRCxFQVduRHd6QixlQUFldHpCLFdBQVdvd0IsT0FBMUIsQ0FYbUQsQ0FBdkQ7QUFhSCxLQTdCTSxNQTZCQTtBQUNILGNBQU0sSUFBSTE5QixLQUFKLHFDQUE2Q2lDLElBQTdDLENBQU47QUFDSDtBQUNKO0FBQ0QsU0FBU2cvQixtQkFBVCxDQUE2QjN6QixVQUE3QixFQUF5Qyt2QixZQUF6QyxFQUF1RGhnQyxLQUF2RCxFQUFnRjtBQUFBLFFBQWxCcWMsS0FBa0IsdUVBQVYsQ0FBQyxNQUFELENBQVU7O0FBQzVFLFFBQU16WCxPQUFPcS9CLGdCQUFnQmgwQixVQUFoQixFQUE0Qit2QixZQUE1QixDQUFiO0FBQ0EsUUFBSWp3QixtQkFBSjtBQUNBLFFBQUl3MEIsU0FBUyxLQUFiO0FBQ0EsUUFBSTMvQixTQUFTLFVBQWIsRUFBeUI7QUFDckJtTCxxQkFBYSxDQUNULE1BRFMsRUFFVHNNLEtBRlMsQ0FBYjtBQUlBa29CLGlCQUFTLElBQVQ7QUFDSCxLQU5ELE1BTU8sSUFBSTMvQixTQUFTLGFBQWIsRUFBNEI7QUFDL0IsWUFBTThSLE9BQU96RyxXQUFXeUcsSUFBWCxLQUFvQjlTLFNBQXBCLEdBQWdDcU0sV0FBV3lHLElBQTNDLEdBQWtELENBQS9EO0FBQ0EzRyxxQkFBYSxDQUNUK3pCLHVCQUF1Qjd6QixVQUF2QixDQURTLEVBRVR5RyxTQUFTLENBQVQsR0FBYSxDQUFDLFFBQUQsQ0FBYixHQUEwQixDQUN0QixhQURzQixFQUV0QkEsSUFGc0IsQ0FGakIsRUFNVDJGLEtBTlMsQ0FBYjtBQVFILEtBVk0sTUFVQTtBQUNILGNBQU0sSUFBSTFaLEtBQUosbUNBQTBDaUMsSUFBMUMsUUFBTjtBQUNIO0FBdEIyRTtBQUFBO0FBQUE7O0FBQUE7QUF1QjVFLCtCQUFtQjVFLEtBQW5CLHdJQUEwQjtBQUFBLGdCQUFma21CLElBQWU7O0FBQ3RCZ2UsMkJBQWVuMEIsVUFBZixFQUEyQm1XLEtBQUssQ0FBTCxDQUEzQixFQUFvQ0EsS0FBSyxDQUFMLENBQXBDLEVBQTZDcWUsTUFBN0M7QUFDSDtBQXpCMkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEwQjVFSiw2QkFBeUJwMEIsVUFBekI7QUFDQSxXQUFPQSxVQUFQO0FBQ0g7QUFDRCxTQUFTbzBCLHdCQUFULENBQWtDcDBCLFVBQWxDLEVBQThDO0FBQzFDLFFBQUlBLFdBQVcsQ0FBWCxNQUFrQixNQUFsQixJQUE0QkEsV0FBVzlQLE1BQVgsS0FBc0IsQ0FBdEQsRUFBeUQ7QUFDckQ4UCxtQkFBV25QLElBQVgsQ0FBZ0IsQ0FBaEI7QUFDQW1QLG1CQUFXblAsSUFBWCxDQUFnQm1QLFdBQVcsQ0FBWCxDQUFoQjtBQUNIO0FBQ0o7QUFDRCxTQUFTbTBCLGNBQVQsQ0FBd0JNLEtBQXhCLEVBQStCbm9CLEtBQS9CLEVBQXNDaEIsTUFBdEMsRUFBOENrcEIsTUFBOUMsRUFBc0Q7QUFDbEQsUUFBSUMsTUFBTXZrQyxNQUFOLEdBQWUsQ0FBZixJQUFvQm9jLFVBQVVtb0IsTUFBTUEsTUFBTXZrQyxNQUFOLEdBQWUsQ0FBckIsQ0FBbEMsRUFBMkQ7QUFDdkQ7QUFDSDtBQUNELFFBQUksRUFBRXNrQyxVQUFVQyxNQUFNdmtDLE1BQU4sS0FBaUIsQ0FBN0IsQ0FBSixFQUFxQztBQUNqQ3VrQyxjQUFNNWpDLElBQU4sQ0FBV3liLEtBQVg7QUFDSDtBQUNEbW9CLFVBQU01akMsSUFBTixDQUFXeWEsTUFBWDtBQUNIO0FBQ0QsU0FBUzRvQixlQUFULENBQXlCaDBCLFVBQXpCLEVBQXFDK3ZCLFlBQXJDLEVBQW1EO0FBQy9DLFFBQUkvdkIsV0FBV3JMLElBQWYsRUFBcUI7QUFDakIsZUFBT3FMLFdBQVdyTCxJQUFsQjtBQUNILEtBRkQsTUFFTztBQUNILGVBQU9vN0IsYUFBYWp3QixVQUFiLENBQXdCQyxZQUF4QixHQUF1QyxhQUF2QyxHQUF1RCxVQUE5RDtBQUNIO0FBQ0o7QUFDRCxTQUFTMHpCLGtCQUFULENBQTRCbmdCLENBQTVCLEVBQStCO0FBQzNCLFFBQU16SyxTQUFTLENBQUMsUUFBRCxDQUFmO0FBQ0EsUUFBTTJyQixLQUFLLGFBQVg7QUFDQSxRQUFJQyxNQUFNLENBQVY7QUFDQSxTQUFLLElBQUl6aUMsUUFBUXdpQyxHQUFHdmlCLElBQUgsQ0FBUXFCLENBQVIsQ0FBakIsRUFBNkJ0aEIsVUFBVSxJQUF2QyxFQUE2Q0EsUUFBUXdpQyxHQUFHdmlCLElBQUgsQ0FBUXFCLENBQVIsQ0FBckQsRUFBaUU7QUFDN0QsWUFBTXpRLFVBQVV5USxFQUFFeFksS0FBRixDQUFRMjVCLEdBQVIsRUFBYUQsR0FBRzFPLFNBQUgsR0FBZTl6QixNQUFNLENBQU4sRUFBU2hDLE1BQXJDLENBQWhCO0FBQ0F5a0MsY0FBTUQsR0FBRzFPLFNBQVQ7QUFDQSxZQUFJampCLFFBQVE3UyxNQUFSLEdBQWlCLENBQXJCLEVBQ0k2WSxPQUFPbFksSUFBUCxDQUFZa1MsT0FBWjtBQUNKZ0csZUFBT2xZLElBQVAsQ0FBWSxDQUNSLEtBRFEsRUFFUnFCLE1BQU0sQ0FBTixDQUZRLENBQVo7QUFJSDtBQUNELFFBQUk2VyxPQUFPN1ksTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUNyQixlQUFPc2pCLENBQVA7QUFDSDtBQUNELFFBQUltaEIsTUFBTW5oQixFQUFFdGpCLE1BQVosRUFBb0I7QUFDaEI2WSxlQUFPbFksSUFBUCxDQUFZMmlCLEVBQUV4WSxLQUFGLENBQVEyNUIsR0FBUixDQUFaO0FBQ0gsS0FGRCxNQUVPLElBQUk1ckIsT0FBTzdZLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDNUIsZUFBTyxDQUNILFdBREcsRUFFSDZZLE9BQU8sQ0FBUCxDQUZHLENBQVA7QUFJSDtBQUNELFdBQU9BLE1BQVA7QUFDSDs7QUFFRCxTQUFTNnJCLFFBQVQsQ0FBa0I3NEIsS0FBbEIsRUFBeUI7QUFDckIsUUFBSUEsaUJBQWlCaWlCLE1BQWpCLElBQTJCamlCLGlCQUFpQmdQLE1BQTVDLElBQXNEaFAsaUJBQWlCNmhCLE9BQTNFLEVBQW9GO0FBQ2hGLGVBQU83aEIsTUFBTTg0QixPQUFOLEVBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPOTRCLEtBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBUys0QixZQUFULENBQXNCLzRCLEtBQXRCLEVBQTZCO0FBQ3pCLFFBQUloTSxNQUFNQyxPQUFOLENBQWMrTCxLQUFkLENBQUosRUFBMEI7QUFDdEIsZUFBT0EsTUFBTXhMLEdBQU4sQ0FBVXVrQyxZQUFWLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSS80QixpQkFBaUI2TSxNQUFqQixJQUEyQixFQUFFN00saUJBQWlCaWlCLE1BQWpCLElBQTJCamlCLGlCQUFpQmdQLE1BQTVDLElBQXNEaFAsaUJBQWlCNmhCLE9BQXpFLENBQS9CLEVBQWtIO0FBQ3JILFlBQU1tWCxpQkFBaUIsRUFBdkI7QUFDQSxhQUFLLElBQU03N0IsR0FBWCxJQUFrQjZDLEtBQWxCLEVBQXlCO0FBQ3JCZzVCLDJCQUFlNzdCLEdBQWYsSUFBc0I0N0IsYUFBYS80QixNQUFNN0MsR0FBTixDQUFiLENBQXRCO0FBQ0g7QUFDRCxlQUFPNjdCLGNBQVA7QUFDSDtBQUNELFdBQU9ILFNBQVM3NEIsS0FBVCxDQUFQO0FBQ0g7O0FBRUQsU0FBU2k1QixrQkFBVCxDQUE0QjMyQixNQUE1QixFQUFvQztBQUNoQyxRQUFJQSxXQUFXLElBQVgsSUFBbUJBLFdBQVcsS0FBbEMsRUFBeUM7QUFDckMsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUN0TyxNQUFNQyxPQUFOLENBQWNxTyxNQUFkLENBQUQsSUFBMEJBLE9BQU9uTyxNQUFQLEtBQWtCLENBQWhELEVBQW1EO0FBQy9DLGVBQU8sS0FBUDtBQUNIO0FBQ0QsWUFBUW1PLE9BQU8sQ0FBUCxDQUFSO0FBQ0EsYUFBSyxLQUFMO0FBQ0ksbUJBQU9BLE9BQU9uTyxNQUFQLElBQWlCLENBQWpCLElBQXNCbU8sT0FBTyxDQUFQLE1BQWMsS0FBcEMsSUFBNkNBLE9BQU8sQ0FBUCxNQUFjLE9BQWxFO0FBQ0osYUFBSyxJQUFMO0FBQ0ksbUJBQU9BLE9BQU9uTyxNQUFQLElBQWlCLENBQWpCLEtBQXVCLE9BQU9tTyxPQUFPLENBQVAsQ0FBUCxLQUFxQixRQUFyQixJQUFpQ3RPLE1BQU1DLE9BQU4sQ0FBY3FPLE9BQU8sQ0FBUCxDQUFkLENBQXhELENBQVA7QUFDSixhQUFLLEtBQUw7QUFDQSxhQUFLLE1BQUw7QUFDQSxhQUFLLE1BQUw7QUFDSSxtQkFBTyxLQUFQO0FBQ0osYUFBSyxJQUFMO0FBQ0EsYUFBSyxJQUFMO0FBQ0EsYUFBSyxHQUFMO0FBQ0EsYUFBSyxJQUFMO0FBQ0EsYUFBSyxHQUFMO0FBQ0EsYUFBSyxJQUFMO0FBQ0ksbUJBQU9BLE9BQU9uTyxNQUFQLEtBQWtCLENBQWxCLElBQXdCSCxNQUFNQyxPQUFOLENBQWNxTyxPQUFPLENBQVAsQ0FBZCxLQUE0QnRPLE1BQU1DLE9BQU4sQ0FBY3FPLE9BQU8sQ0FBUCxDQUFkLENBQTNEO0FBQ0osYUFBSyxLQUFMO0FBQ0EsYUFBSyxLQUFMO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0ksdUNBQWdCQSxPQUFPckQsS0FBUCxDQUFhLENBQWIsQ0FBaEIsd0lBQWlDO0FBQUEsd0JBQXRCNGQsQ0FBc0I7O0FBQzdCLHdCQUFJLENBQUNvYyxtQkFBbUJwYyxDQUFuQixDQUFELElBQTBCLE9BQU9BLENBQVAsS0FBYSxTQUEzQyxFQUFzRDtBQUNsRCwrQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUxMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUksbUJBQU8sSUFBUDtBQUNKO0FBQ0ksbUJBQU8sSUFBUDtBQXpCSjtBQTJCSDtBQUNELFNBQVNxYyxZQUFULENBQXNCNTJCLE1BQXRCLEVBQWtEO0FBQUEsUUFBcEI2MkIsU0FBb0IsdUVBQVIsTUFBUTs7QUFDOUMsUUFBSTcyQixXQUFXLElBQVgsSUFBbUJBLFdBQVd4SyxTQUFsQyxFQUE2QztBQUN6QyxlQUFPO0FBQ0h3SyxvQkFBUTtBQUFBLHVCQUFNLElBQU47QUFBQSxhQURMO0FBRUg4MkIsMEJBQWMsS0FGWDtBQUdIQyx5QkFBYTtBQUhWLFNBQVA7QUFLSDtBQUNELFFBQUksQ0FBQ0osbUJBQW1CMzJCLE1BQW5CLENBQUwsRUFBaUM7QUFDN0JBLGlCQUFTZzNCLGNBQWNoM0IsTUFBZCxDQUFUO0FBQ0g7QUFDRCxRQUFNaTNCLFlBQVlqM0IsTUFBbEI7QUFDQSxRQUFJazNCLGVBQWUsSUFBbkI7QUFDQSxRQUFJO0FBQ0FBLHVCQUFlQyxvQkFBb0JGLFNBQXBCLENBQWY7QUFDSCxLQUZELENBRUUsT0FBTzdnQyxDQUFQLEVBQVU7QUFDUlIsZ0JBQVErOUIsSUFBUiw2VkFLTHYvQixLQUFLOFUsU0FBTCxDQUFlK3RCLFNBQWYsRUFBMEIsSUFBMUIsRUFBZ0MsQ0FBaEMsQ0FMSztBQU9IO0FBQ0QsUUFBTUcsYUFBYS91QixlQUFjd3VCLFNBQWQsQ0FBbkI7QUFDQSxRQUFNUSx1QkFBdUJ4RCxpQkFBaUJxRCxZQUFqQixFQUErQkUsVUFBL0IsQ0FBN0I7QUFDQSxRQUFJRSxhQUFhLElBQWpCO0FBQ0EsUUFBSUQscUJBQXFCM3NCLE1BQXJCLEtBQWdDLE9BQXBDLEVBQTZDO0FBQ3pDLGNBQU0sSUFBSW5XLEtBQUosQ0FBVThpQyxxQkFBcUIzNUIsS0FBckIsQ0FBMkJ4TCxHQUEzQixDQUErQjtBQUFBLG1CQUFXeUQsSUFBSWtGLEdBQWYsVUFBeUJsRixJQUFJOGlCLE9BQTdCO0FBQUEsU0FBL0IsRUFBd0U3YixJQUF4RSxDQUE2RSxJQUE3RSxDQUFWLENBQU47QUFDSCxLQUZELE1BRU87QUFDSDA2QixxQkFBYSxvQkFBQ0MsZ0JBQUQsRUFBbUJyWCxPQUFuQixFQUE0QkksU0FBNUI7QUFBQSxtQkFBMEMrVyxxQkFBcUIzNUIsS0FBckIsQ0FBMkI2Z0IsUUFBM0IsQ0FBb0NnWixnQkFBcEMsRUFBc0RyWCxPQUF0RCxFQUErRCxFQUEvRCxFQUFtRUksU0FBbkUsQ0FBMUM7QUFBQSxTQUFiO0FBQ0g7QUFDRCxRQUFJa1gsb0JBQW9CLElBQXhCO0FBQ0EsUUFBSVQsY0FBYyxJQUFsQjtBQUNBLFFBQUlHLGlCQUFpQkQsU0FBckIsRUFBZ0M7QUFDNUIsWUFBTVEsd0JBQXdCNUQsaUJBQWlCb0QsU0FBakIsRUFBNEJHLFVBQTVCLENBQTlCO0FBQ0EsWUFBSUssc0JBQXNCL3NCLE1BQXRCLEtBQWlDLE9BQXJDLEVBQThDO0FBQzFDLGtCQUFNLElBQUluVyxLQUFKLENBQVVrakMsc0JBQXNCLzVCLEtBQXRCLENBQTRCeEwsR0FBNUIsQ0FBZ0M7QUFBQSx1QkFBV3lELElBQUlrRixHQUFmLFVBQXlCbEYsSUFBSThpQixPQUE3QjtBQUFBLGFBQWhDLEVBQXlFN2IsSUFBekUsQ0FBOEUsSUFBOUUsQ0FBVixDQUFOO0FBQ0gsU0FGRCxNQUVPO0FBQ0g0NkIsZ0NBQW9CLDJCQUFDRCxnQkFBRCxFQUFtQnJYLE9BQW5CLEVBQTRCSSxTQUE1QixFQUF1Q0MsZ0JBQXZDLEVBQXlEQyxtQkFBekQ7QUFBQSx1QkFBaUZpWCxzQkFBc0IvNUIsS0FBdEIsQ0FBNEI2Z0IsUUFBNUIsQ0FBcUNnWixnQkFBckMsRUFBdURyWCxPQUF2RCxFQUFnRSxFQUFoRSxFQUFvRUksU0FBcEUsRUFBK0U5cUIsU0FBL0UsRUFBMEZBLFNBQTFGLEVBQXFHK3FCLGdCQUFyRyxFQUF1SEMsbUJBQXZILENBQWpGO0FBQUEsYUFBcEI7QUFDQXVXLDBCQUFjLENBQUNwUSxrQkFBa0I4USxzQkFBc0IvNUIsS0FBdEIsQ0FBNEJpRSxVQUE5QyxDQUFmO0FBQ0g7QUFDSjtBQUNEMjFCLGlCQUFhQSxVQUFiO0FBQ0EsUUFBTVIsZUFBZVksZUFBZVIsWUFBZixDQUFyQjtBQUNBLFdBQU87QUFDSGwzQixnQkFBUXMzQixVQURMO0FBRUhLLHVCQUFlSCxvQkFBb0JBLGlCQUFwQixHQUF3Q2hpQyxTQUZwRDtBQUdIc2hDLGtDQUhHO0FBSUhDLHFCQUFhLENBQUMsQ0FBQ0E7QUFKWixLQUFQO0FBTUg7QUFDRCxTQUFTSSxtQkFBVCxDQUE2Qm4zQixNQUE3QixFQUFxQztBQUNqQyxRQUFJLENBQUM0M0IsZ0JBQWdCNTNCLE1BQWhCLENBQUwsRUFBOEI7QUFDMUIsZUFBT0EsTUFBUDtBQUNIO0FBQ0QsUUFBSTBLLFNBQVMrckIsYUFBYXoyQixNQUFiLENBQWI7QUFDQTYzQix5QkFBcUJudEIsTUFBckI7QUFDQUEsYUFBU290QixrQ0FBa0NwdEIsTUFBbEMsQ0FBVDtBQUNBLFdBQU9BLE1BQVA7QUFDSDtBQUNELFNBQVNvdEIsaUNBQVQsQ0FBMkNuMkIsVUFBM0MsRUFBdUQ7QUFDbkQsUUFBSSxDQUFDalEsTUFBTUMsT0FBTixDQUFjZ1EsVUFBZCxDQUFMLEVBQWdDO0FBQzVCLGVBQU9BLFVBQVA7QUFDSDtBQUNELFFBQU1vMkIsWUFBWUMsb0JBQW9CcjJCLFVBQXBCLENBQWxCO0FBQ0EsUUFBSW8yQixjQUFjLElBQWxCLEVBQXdCO0FBQ3BCLGVBQU9BLFNBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPQSxVQUFVN2xDLEdBQVYsQ0FBYztBQUFBLG1CQUFpQjRsQyxrQ0FBa0NHLGFBQWxDLENBQWpCO0FBQUEsU0FBZCxDQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVNKLG9CQUFULENBQThCNzNCLE1BQTlCLEVBQXNDO0FBQ2xDLFFBQUlrNEIseUJBQXlCLEtBQTdCO0FBQ0EsUUFBTW5LLFdBQVcsRUFBakI7QUFDQSxRQUFJL3RCLE9BQU8sQ0FBUCxNQUFjLE1BQWxCLEVBQTBCO0FBQ3RCLGFBQUssSUFBSXhPLElBQUksQ0FBYixFQUFnQkEsSUFBSXdPLE9BQU9uTyxNQUFQLEdBQWdCLENBQXBDLEVBQXVDTCxLQUFLLENBQTVDLEVBQStDO0FBQzNDMG1DLHFDQUF5QkEsMEJBQTBCTixnQkFBZ0I1M0IsT0FBT3hPLENBQVAsQ0FBaEIsQ0FBbkQ7QUFDQXU4QixxQkFBU3Y3QixJQUFULENBQWN3TixPQUFPeE8sSUFBSSxDQUFYLENBQWQ7QUFDSDtBQUNEdThCLGlCQUFTdjdCLElBQVQsQ0FBY3dOLE9BQU9BLE9BQU9uTyxNQUFQLEdBQWdCLENBQXZCLENBQWQ7QUFDSCxLQU5ELE1BTU8sSUFBSW1PLE9BQU8sQ0FBUCxNQUFjLE9BQWxCLEVBQTJCO0FBQzlCazRCLGlDQUF5QkEsMEJBQTBCTixnQkFBZ0I1M0IsT0FBTyxDQUFQLENBQWhCLENBQW5EO0FBQ0EsYUFBSyxJQUFJeE8sTUFBSSxDQUFiLEVBQWdCQSxNQUFJd08sT0FBT25PLE1BQVAsR0FBZ0IsQ0FBcEMsRUFBdUNMLE9BQUssQ0FBNUMsRUFBK0M7QUFDM0N1OEIscUJBQVN2N0IsSUFBVCxDQUFjd04sT0FBT3hPLE1BQUksQ0FBWCxDQUFkO0FBQ0g7QUFDRHU4QixpQkFBU3Y3QixJQUFULENBQWN3TixPQUFPQSxPQUFPbk8sTUFBUCxHQUFnQixDQUF2QixDQUFkO0FBQ0gsS0FOTSxNQU1BLElBQUltTyxPQUFPLENBQVAsTUFBYyxNQUFsQixFQUEwQjtBQUM3Qms0QixpQ0FBeUJBLDBCQUEwQk4sZ0JBQWdCNTNCLE9BQU8sQ0FBUCxDQUFoQixDQUFuRDtBQUNBLGFBQUssSUFBSXhPLE1BQUksQ0FBYixFQUFnQkEsTUFBSXdPLE9BQU9uTyxNQUFQLEdBQWdCLENBQXBDLEVBQXVDTCxPQUFLLENBQTVDLEVBQStDO0FBQzNDdThCLHFCQUFTdjdCLElBQVQsQ0FBY3dOLE9BQU94TyxNQUFJLENBQVgsQ0FBZDtBQUNIO0FBQ0o7QUFDRCxRQUFJMG1DLHNCQUFKLEVBQTRCO0FBQ3hCbDRCLGVBQU9uTyxNQUFQLEdBQWdCLENBQWhCO0FBQ0FtTyxlQUFPeE4sSUFBUCxnQkFBWSxLQUFaLFNBQXNCdTdCLFFBQXRCO0FBQ0g7QUFDRCxTQUFLLElBQUl2OEIsTUFBSSxDQUFiLEVBQWdCQSxNQUFJd08sT0FBT25PLE1BQTNCLEVBQW1DTCxLQUFuQyxFQUF3QztBQUNwQ3FtQyw2QkFBcUI3M0IsT0FBT3hPLEdBQVAsQ0FBckI7QUFDSDtBQUNKO0FBQ0QsU0FBU29tQyxlQUFULENBQXlCNTNCLE1BQXpCLEVBQWlDO0FBQzdCLFFBQUksQ0FBQ3RPLE1BQU1DLE9BQU4sQ0FBY3FPLE1BQWQsQ0FBTCxFQUE0QjtBQUN4QixlQUFPLEtBQVA7QUFDSDtBQUNELFFBQUltNEIsd0JBQXdCbjRCLE9BQU8sQ0FBUCxDQUF4QixDQUFKLEVBQXdDO0FBQ3BDLGVBQU8sSUFBUDtBQUNIO0FBQ0QsU0FBSyxJQUFJeE8sSUFBSSxDQUFiLEVBQWdCQSxJQUFJd08sT0FBT25PLE1BQTNCLEVBQW1DTCxHQUFuQyxFQUF3QztBQUNwQyxZQUFNc3VCLFFBQVE5ZixPQUFPeE8sQ0FBUCxDQUFkO0FBQ0EsWUFBSW9tQyxnQkFBZ0I5WCxLQUFoQixDQUFKLEVBQTRCO0FBQ3hCLG1CQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTcVksdUJBQVQsQ0FBaUN4MkIsVUFBakMsRUFBNkM7QUFDekMsV0FBT0EsZUFBZSxPQUFmLElBQTBCQSxlQUFlLHNCQUFoRDtBQUNIO0FBQ0QsSUFBTXkyQiw4QkFBOEIsSUFBSUMsR0FBSixDQUFRLENBQ3hDLElBRHdDLEVBRXhDLElBRndDLEVBR3hDLElBSHdDLEVBSXhDLEdBSndDLEVBS3hDLElBTHdDLEVBTXhDLEdBTndDLEVBT3hDLElBUHdDLEVBUXhDLFlBUndDLENBQVIsQ0FBcEM7QUFVQSxTQUFTTCxtQkFBVCxDQUE2QnIyQixVQUE3QixFQUF5QztBQUNyQyxRQUFJeTJCLDRCQUE0Qm4wQixHQUE1QixDQUFnQ3RDLFdBQVcsQ0FBWCxDQUFoQyxDQUFKLEVBQW9EO0FBQ2hELGFBQUssSUFBSW5RLElBQUksQ0FBYixFQUFnQkEsSUFBSW1RLFdBQVc5UCxNQUEvQixFQUF1Q0wsR0FBdkMsRUFBNEM7QUFDeEMsZ0JBQU04bUMsUUFBUTMyQixXQUFXblEsQ0FBWCxDQUFkO0FBQ0EsZ0JBQUlvbUMsZ0JBQWdCVSxLQUFoQixDQUFKLEVBQTRCO0FBQ3hCLHVCQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPMzJCLFVBQVA7QUFDSDtBQUNELFNBQVM4YSxPQUFULENBQWlCaGdCLENBQWpCLEVBQW9CZ2YsQ0FBcEIsRUFBdUI7QUFDbkIsV0FBT2hmLElBQUlnZixDQUFKLEdBQVEsQ0FBQyxDQUFULEdBQWFoZixJQUFJZ2YsQ0FBSixHQUFRLENBQVIsR0FBWSxDQUFoQztBQUNIO0FBQ0QsU0FBU2ljLGNBQVQsQ0FBd0IxM0IsTUFBeEIsRUFBZ0M7QUFDNUIsUUFBSSxDQUFDdE8sTUFBTUMsT0FBTixDQUFjcU8sTUFBZCxDQUFMLEVBQ0ksT0FBTyxLQUFQO0FBQ0osUUFBSUEsT0FBTyxDQUFQLE1BQWMsUUFBbEIsRUFDSSxPQUFPLElBQVA7QUFDSixTQUFLLElBQUk4SixRQUFRLENBQWpCLEVBQW9CQSxRQUFROUosT0FBT25PLE1BQW5DLEVBQTJDaVksT0FBM0MsRUFBb0Q7QUFDaEQsWUFBSTR0QixlQUFlMTNCLE9BQU84SixLQUFQLENBQWYsQ0FBSixFQUNJLE9BQU8sSUFBUDtBQUNQO0FBQ0QsV0FBTyxLQUFQO0FBQ0g7QUFDRCxTQUFTa3RCLGFBQVQsQ0FBdUJoM0IsTUFBdkIsRUFBK0I7QUFDM0IsUUFBSSxDQUFDQSxNQUFMLEVBQ0ksT0FBTyxJQUFQO0FBQ0osUUFBTW1iLEtBQUtuYixPQUFPLENBQVAsQ0FBWDtBQUNBLFFBQUlBLE9BQU9uTyxNQUFQLElBQWlCLENBQXJCLEVBQ0ksT0FBT3NwQixPQUFPLEtBQWQ7QUFDSixRQUFNb2QsWUFBWXBkLE9BQU8sSUFBUCxHQUFjcWQsb0JBQW9CeDRCLE9BQU8sQ0FBUCxDQUFwQixFQUErQkEsT0FBTyxDQUFQLENBQS9CLEVBQTBDLElBQTFDLENBQWQsR0FBZ0VtYixPQUFPLElBQVAsR0FBY3NkLGdCQUFnQkQsb0JBQW9CeDRCLE9BQU8sQ0FBUCxDQUFwQixFQUErQkEsT0FBTyxDQUFQLENBQS9CLEVBQTBDLElBQTFDLENBQWhCLENBQWQsR0FBaUZtYixPQUFPLEdBQVAsSUFBY0EsT0FBTyxHQUFyQixJQUE0QkEsT0FBTyxJQUFuQyxJQUEyQ0EsT0FBTyxJQUFsRCxHQUF5RHFkLG9CQUFvQng0QixPQUFPLENBQVAsQ0FBcEIsRUFBK0JBLE9BQU8sQ0FBUCxDQUEvQixFQUEwQ21iLEVBQTFDLENBQXpELEdBQXlHQSxPQUFPLEtBQVAsR0FBZXVkLHFCQUFxQjE0QixPQUFPckQsS0FBUCxDQUFhLENBQWIsQ0FBckIsQ0FBZixHQUF1RHdlLE9BQU8sS0FBUCxHQUFlLENBQUMsS0FBRCxFQUFRdFUsTUFBUixDQUFlN0csT0FBT3JELEtBQVAsQ0FBYSxDQUFiLEVBQWdCekssR0FBaEIsQ0FBb0I4a0MsYUFBcEIsQ0FBZixDQUFmLEdBQW9FN2IsT0FBTyxNQUFQLEdBQWdCLENBQUMsS0FBRCxFQUFRdFUsTUFBUixDQUFlN0csT0FBT3JELEtBQVAsQ0FBYSxDQUFiLEVBQWdCekssR0FBaEIsQ0FBb0I4a0MsYUFBcEIsRUFBbUM5a0MsR0FBbkMsQ0FBdUN1bUMsZUFBdkMsQ0FBZixDQUFoQixHQUEwRnRkLE9BQU8sSUFBUCxHQUFjd2QsWUFBWTM0QixPQUFPLENBQVAsQ0FBWixFQUF1QkEsT0FBT3JELEtBQVAsQ0FBYSxDQUFiLENBQXZCLENBQWQsR0FBd0R3ZSxPQUFPLEtBQVAsR0FBZXNkLGdCQUFnQkUsWUFBWTM0QixPQUFPLENBQVAsQ0FBWixFQUF1QkEsT0FBT3JELEtBQVAsQ0FBYSxDQUFiLENBQXZCLENBQWhCLENBQWYsR0FBMEV3ZSxPQUFPLEtBQVAsR0FBZXlkLGFBQWE1NEIsT0FBTyxDQUFQLENBQWIsQ0FBZixHQUF5Q21iLE9BQU8sTUFBUCxHQUFnQnNkLGdCQUFnQkcsYUFBYTU0QixPQUFPLENBQVAsQ0FBYixDQUFoQixDQUFoQixHQUEyRG1iLE9BQU8sUUFBUCxHQUFrQm5iLE1BQWxCLEdBQTJCLElBQWx1QjtBQUNBLFdBQU91NEIsU0FBUDtBQUNIO0FBQ0QsU0FBU0MsbUJBQVQsQ0FBNkJqd0IsUUFBN0IsRUFBdUM3SyxLQUF2QyxFQUE4Q3lkLEVBQTlDLEVBQWtEO0FBQzlDLFlBQVE1UyxRQUFSO0FBQ0EsYUFBSyxPQUFMO0FBQ0ksbUJBQU8sa0JBQ2E0UyxFQURiLEVBRUh6ZCxLQUZHLENBQVA7QUFJSixhQUFLLEtBQUw7QUFDSSxtQkFBTyxnQkFDV3lkLEVBRFgsRUFFSHpkLEtBRkcsQ0FBUDtBQUlKO0FBQ0ksbUJBQU8sYUFDUXlkLEVBRFIsRUFFSDVTLFFBRkcsRUFHSDdLLEtBSEcsQ0FBUDtBQVpKO0FBa0JIO0FBQ0QsU0FBU2c3QixvQkFBVCxDQUE4QkcsT0FBOUIsRUFBdUM7QUFDbkMsV0FBTyxDQUFDLEtBQUQsRUFBUWh5QixNQUFSLENBQWVneUIsUUFBUTNtQyxHQUFSLENBQVk4a0MsYUFBWixDQUFmLENBQVA7QUFDSDtBQUNELFNBQVMyQixXQUFULENBQXFCcHdCLFFBQXJCLEVBQStCbEwsTUFBL0IsRUFBdUM7QUFDbkMsUUFBSUEsT0FBT3hMLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDckIsZUFBTyxLQUFQO0FBQ0g7QUFDRCxZQUFRMFcsUUFBUjtBQUNBLGFBQUssT0FBTDtBQUNJLG1CQUFPLG1CQUVILENBQ0ksU0FESixFQUVJbEwsTUFGSixDQUZHLENBQVA7QUFPSixhQUFLLEtBQUw7QUFDSSxtQkFBTyxpQkFFSCxDQUNJLFNBREosRUFFSUEsTUFGSixDQUZHLENBQVA7QUFPSjtBQUNJLGdCQUFJQSxPQUFPeEwsTUFBUCxHQUFnQixHQUFoQixJQUF1QixDQUFDd0wsT0FBTzlGLElBQVAsQ0FBWTtBQUFBLHVCQUFLLFFBQU91WixDQUFQLHlDQUFPQSxDQUFQLGVBQW9CelQsT0FBTyxDQUFQLENBQXBCLENBQUw7QUFBQSxhQUFaLENBQTVCLEVBQTZFO0FBQ3pFLHVCQUFPLENBQ0gsaUJBREcsRUFFSGtMLFFBRkcsRUFHSCxDQUNJLFNBREosRUFFSWxMLE9BQU9rd0IsSUFBUCxDQUFZOVEsT0FBWixDQUZKLENBSEcsQ0FBUDtBQVFILGFBVEQsTUFTTztBQUNILHVCQUFPLENBQ0gsaUJBREcsRUFFSGxVLFFBRkcsRUFHSCxDQUNJLFNBREosRUFFSWxMLE1BRkosQ0FIRyxDQUFQO0FBUUg7QUFwQ0w7QUFzQ0g7QUFDRCxTQUFTdTdCLFlBQVQsQ0FBc0Jyd0IsUUFBdEIsRUFBZ0M7QUFDNUIsWUFBUUEsUUFBUjtBQUNBLGFBQUssT0FBTDtBQUNJLG1CQUFPLElBQVA7QUFDSixhQUFLLEtBQUw7QUFDSSxtQkFBTyxpQkFBUDtBQUNKO0FBQ0ksbUJBQU8sZUFFSEEsUUFGRyxDQUFQO0FBTko7QUFXSDtBQUNELFNBQVNrd0IsZUFBVCxDQUF5Qno0QixNQUF6QixFQUFpQztBQUM3QixXQUFPLENBQ0gsR0FERyxFQUVIQSxNQUZHLENBQVA7QUFJSDs7QUFFRCxTQUFTODRCLGVBQVQsQ0FBeUI5NEIsTUFBekIsRUFBaUM7QUFDN0IsV0FBTys0QixlQUFlLzRCLE1BQWYsRUFBdUIsRUFBdkIsQ0FBUDtBQUNIO0FBQ0QsU0FBUys0QixjQUFULENBQXdCLzRCLE1BQXhCLEVBQWdDZzVCLGFBQWhDLEVBQStDO0FBQzNDLFFBQUlyQyxtQkFBbUIzMkIsTUFBbkIsQ0FBSixFQUFnQztBQUM1QixlQUFPQSxNQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUNBLE1BQUwsRUFDSSxPQUFPLElBQVA7QUFDSixRQUFNbWIsS0FBS25iLE9BQU8sQ0FBUCxDQUFYO0FBQ0EsUUFBSUEsT0FBT25PLE1BQVAsSUFBaUIsQ0FBckIsRUFDSSxPQUFPc3BCLE9BQU8sS0FBZDtBQUNKLFFBQUlvZCxrQkFBSjtBQUNBLFFBQUlwZCxPQUFPLElBQVAsSUFBZUEsT0FBTyxJQUF0QixJQUE4QkEsT0FBTyxHQUFyQyxJQUE0Q0EsT0FBTyxHQUFuRCxJQUEwREEsT0FBTyxJQUFqRSxJQUF5RUEsT0FBTyxJQUFwRixFQUEwRjtBQUFBLHFDQUMxRG5iLE1BRDBEO0FBQUEsWUFDN0V1SSxRQUQ2RTtBQUFBLFlBQ25FN0ssS0FEbUU7O0FBRXRGNjZCLG9CQUFZVSxzQkFBc0Ixd0IsUUFBdEIsRUFBZ0M3SyxLQUFoQyxFQUF1Q3lkLEVBQXZDLEVBQTJDNmQsYUFBM0MsQ0FBWjtBQUNILEtBSEQsTUFHTyxJQUFJN2QsT0FBTyxLQUFYLEVBQWtCO0FBQ3JCLFlBQU0rZCxXQUFXbDVCLE9BQU9yRCxLQUFQLENBQWEsQ0FBYixFQUFnQnpLLEdBQWhCLENBQW9CLGFBQUs7QUFDdEMsZ0JBQU1rc0IsUUFBUSxFQUFkO0FBQ0EsZ0JBQU0wQixRQUFRaVosZUFBZXhlLENBQWYsRUFBa0I2RCxLQUFsQixDQUFkO0FBQ0EsZ0JBQU0rYSxhQUFhQyxrQkFBa0JoYixLQUFsQixDQUFuQjtBQUNBLG1CQUFPK2EsZUFBZSxJQUFmLEdBQXNCclosS0FBdEIsR0FBOEIsQ0FDakMsTUFEaUMsRUFFakNxWixVQUZpQyxFQUdqQ3JaLEtBSGlDLEVBSWpDLEtBSmlDLENBQXJDO0FBTUgsU0FWZ0IsQ0FBakI7QUFXQSxlQUFPLENBQUMsS0FBRCxFQUFRalosTUFBUixDQUFlcXlCLFFBQWYsQ0FBUDtBQUNILEtBYk0sTUFhQSxJQUFJL2QsT0FBTyxLQUFYLEVBQWtCO0FBQUE7O0FBQ3JCLFlBQU0rZCxZQUFXbDVCLE9BQU9yRCxLQUFQLENBQWEsQ0FBYixFQUFnQnpLLEdBQWhCLENBQW9CO0FBQUEsbUJBQUs2bUMsZUFBZXhlLENBQWYsRUFBa0J5ZSxhQUFsQixDQUFMO0FBQUEsU0FBcEIsQ0FBakI7QUFDQSxlQUFPRSxVQUFTcm5DLE1BQVQsR0FBa0IsQ0FBbEIsR0FBc0IsQ0FBQyxLQUFELEVBQVFnVixNQUFSLENBQWVxeUIsU0FBZixDQUF0QixHQUFpRCxlQUFHcnlCLE1BQUgsbUNBQWFxeUIsU0FBYixFQUF4RDtBQUNILEtBSE0sTUFHQSxJQUFJL2QsT0FBTyxNQUFYLEVBQW1CO0FBQ3RCLGVBQU8sQ0FDSCxHQURHLEVBRUg0ZCxlQUFlLENBQUMsS0FBRCxFQUFRbHlCLE1BQVIsQ0FBZTdHLE9BQU9yRCxLQUFQLENBQWEsQ0FBYixDQUFmLENBQWYsRUFBZ0QsRUFBaEQsQ0FGRyxDQUFQO0FBSUgsS0FMTSxNQUtBLElBQUl3ZSxPQUFPLElBQVgsRUFBaUI7QUFDcEJvZCxvQkFBWWMsY0FBY3I1QixPQUFPLENBQVAsQ0FBZCxFQUF5QkEsT0FBT3JELEtBQVAsQ0FBYSxDQUFiLENBQXpCLENBQVo7QUFDSCxLQUZNLE1BRUEsSUFBSXdlLE9BQU8sS0FBWCxFQUFrQjtBQUNyQm9kLG9CQUFZYyxjQUFjcjVCLE9BQU8sQ0FBUCxDQUFkLEVBQXlCQSxPQUFPckQsS0FBUCxDQUFhLENBQWIsQ0FBekIsRUFBMEMsSUFBMUMsQ0FBWjtBQUNILEtBRk0sTUFFQSxJQUFJd2UsT0FBTyxLQUFYLEVBQWtCO0FBQ3JCb2Qsb0JBQVllLGVBQWV0NUIsT0FBTyxDQUFQLENBQWYsQ0FBWjtBQUNILEtBRk0sTUFFQSxJQUFJbWIsT0FBTyxNQUFYLEVBQW1CO0FBQ3RCb2Qsb0JBQVksQ0FDUixHQURRLEVBRVJlLGVBQWV0NUIsT0FBTyxDQUFQLENBQWYsQ0FGUSxDQUFaO0FBSUgsS0FMTSxNQUtBO0FBQ0h1NEIsb0JBQVksSUFBWjtBQUNIO0FBQ0QsV0FBT0EsU0FBUDtBQUNIO0FBQ0QsU0FBU2EsaUJBQVQsQ0FBMkJKLGFBQTNCLEVBQTBDO0FBQ3RDLFFBQU1PLGFBQWEsRUFBbkI7QUFDQSxTQUFLLElBQU1oeEIsUUFBWCxJQUF1Qnl3QixhQUF2QixFQUFzQztBQUNsQyxZQUFNLzdCLE9BQU1zTCxhQUFhLEtBQWIsR0FBcUIsQ0FBQyxJQUFELENBQXJCLEdBQThCLENBQ3RDLEtBRHNDLEVBRXRDQSxRQUZzQyxDQUExQztBQUlBZ3hCLG1CQUFXL21DLElBQVgsQ0FBZ0IsQ0FDWixJQURZLEVBRVosQ0FDSSxRQURKLEVBRUl5SyxJQUZKLENBRlksRUFNWis3QixjQUFjendCLFFBQWQsQ0FOWSxDQUFoQjtBQVFIO0FBQ0QsUUFBSWd4QixXQUFXMW5DLE1BQVgsS0FBc0IsQ0FBMUIsRUFDSSxPQUFPLElBQVA7QUFDSixRQUFJMG5DLFdBQVcxbkMsTUFBWCxLQUFzQixDQUExQixFQUNJLE9BQU8wbkMsV0FBVyxDQUFYLENBQVA7QUFDSixXQUFPLENBQUMsS0FBRCxFQUFRMXlCLE1BQVIsQ0FBZTB5QixVQUFmLENBQVA7QUFDSDtBQUNELFNBQVNOLHFCQUFULENBQStCMXdCLFFBQS9CLEVBQXlDN0ssS0FBekMsRUFBZ0R5ZCxFQUFoRCxFQUFvRDZkLGFBQXBELEVBQW1FO0FBQy9ELFFBQUkvN0IsWUFBSjtBQUNBLFFBQUlzTCxhQUFhLE9BQWpCLEVBQTBCO0FBQ3RCLGVBQU8sQ0FDSDRTLEVBREcsRUFFSCxDQUFDLGVBQUQsQ0FGRyxFQUdIemQsS0FIRyxDQUFQO0FBS0gsS0FORCxNQU1PLElBQUk2SyxhQUFhLEtBQWpCLEVBQXdCO0FBQzNCdEwsY0FBTSxDQUFDLElBQUQsQ0FBTjtBQUNILEtBRk0sTUFFQTtBQUNIQSxjQUFNLENBQ0YsS0FERSxFQUVGc0wsUUFGRSxDQUFOO0FBSUg7QUFDRCxRQUFJeXdCLGlCQUFpQnQ3QixVQUFVLElBQS9CLEVBQXFDO0FBQ2pDLFlBQU1sSCxjQUFja0gsS0FBZCx5Q0FBY0EsS0FBZCxDQUFOO0FBQ0FzN0Isc0JBQWN6d0IsUUFBZCxJQUEwQi9SLElBQTFCO0FBQ0g7QUFDRCxRQUFJMmtCLE9BQU8sSUFBUCxJQUFlNVMsYUFBYSxLQUE1QixJQUFxQzdLLFVBQVUsSUFBbkQsRUFBeUQ7QUFDckQsZUFBTyxDQUNILEtBREcsRUFFSCxDQUNJLEtBREosRUFFSTZLLFFBRkosQ0FGRyxFQU1ILENBQ0ksSUFESixFQUVJdEwsR0FGSixFQUdJLElBSEosQ0FORyxDQUFQO0FBWUgsS0FiRCxNQWFPLElBQUlrZSxPQUFPLElBQVAsSUFBZTVTLGFBQWEsS0FBNUIsSUFBcUM3SyxVQUFVLElBQW5ELEVBQXlEO0FBQzVELGVBQU8sQ0FDSCxLQURHLEVBRUgsQ0FDSSxHQURKLEVBRUksQ0FDSSxLQURKLEVBRUk2SyxRQUZKLENBRkosQ0FGRyxFQVNILENBQ0ksSUFESixFQUVJdEwsR0FGSixFQUdJLElBSEosQ0FURyxDQUFQO0FBZUg7QUFDRCxXQUFPLENBQ0hrZSxFQURHLEVBRUhsZSxHQUZHLEVBR0hTLEtBSEcsQ0FBUDtBQUtIO0FBQ0QsU0FBUzI3QixhQUFULENBQXVCOXdCLFFBQXZCLEVBQWlDbEwsTUFBakMsRUFBeUQ7QUFBQSxRQUFoQm04QixNQUFnQix1RUFBUCxLQUFPOztBQUNyRCxRQUFJbjhCLE9BQU94TCxNQUFQLEtBQWtCLENBQXRCLEVBQ0ksT0FBTzJuQyxNQUFQO0FBQ0osUUFBSXY4QixZQUFKO0FBQ0EsUUFBSXNMLGFBQWEsT0FBakIsRUFBMEI7QUFDdEJ0TCxjQUFNLENBQUMsZUFBRCxDQUFOO0FBQ0gsS0FGRCxNQUVPLElBQUlzTCxhQUFhLEtBQWpCLEVBQXdCO0FBQzNCdEwsY0FBTSxDQUFDLElBQUQsQ0FBTjtBQUNILEtBRk0sTUFFQTtBQUNIQSxjQUFNLENBQ0YsS0FERSxFQUVGc0wsUUFGRSxDQUFOO0FBSUg7QUFDRCxRQUFJa3hCLGVBQWUsSUFBbkI7QUFDQSxRQUFNampDLGVBQWM2RyxPQUFPLENBQVAsQ0FBZCxDQUFOO0FBZnFEO0FBQUE7QUFBQTs7QUFBQTtBQWdCckQsK0JBQW9CQSxNQUFwQix3SUFBNEI7QUFBQSxnQkFBakJLLEtBQWlCOztBQUN4QixnQkFBSSxRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCbEgsSUFBckIsRUFBMkI7QUFDdkJpakMsK0JBQWUsS0FBZjtBQUNBO0FBQ0g7QUFDSjtBQXJCb0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFzQnJELFFBQUlBLGlCQUFpQmpqQyxTQUFTLFFBQVQsSUFBcUJBLFNBQVMsUUFBL0MsQ0FBSixFQUE4RDtBQUMxRCxZQUFNa2pDLGVBQWVyOEIsT0FBT2t3QixJQUFQLEdBQWN2dEIsTUFBZCxDQUFxQixVQUFDOFEsQ0FBRCxFQUFJdGYsQ0FBSjtBQUFBLG1CQUFVQSxNQUFNLENBQU4sSUFBVzZMLE9BQU83TCxJQUFJLENBQVgsTUFBa0JzZixDQUF2QztBQUFBLFNBQXJCLENBQXJCO0FBQ0EsZUFBTyxDQUNILE9BREcsRUFFSDdULEdBRkcsRUFHSHk4QixZQUhHLEVBSUgsQ0FBQ0YsTUFKRSxFQUtIQSxNQUxHLENBQVA7QUFPSDtBQUNELFdBQU8sQ0FBQ0EsU0FBUyxLQUFULEdBQWlCLEtBQWxCLEVBQXlCM3lCLE1BQXpCLENBQWdDeEosT0FBT25MLEdBQVAsQ0FBVztBQUFBLGVBQUssQ0FDbkRzbkMsU0FBUyxJQUFULEdBQWdCLElBRG1DLEVBRW5EdjhCLEdBRm1ELEVBR25ENlQsQ0FIbUQsQ0FBTDtBQUFBLEtBQVgsQ0FBaEMsQ0FBUDtBQUtIO0FBQ0QsU0FBU3dvQixjQUFULENBQXdCL3dCLFFBQXhCLEVBQWtDO0FBQzlCLFFBQUlBLGFBQWEsT0FBakIsRUFBMEI7QUFDdEIsZUFBTyxJQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUlBLGFBQWEsS0FBakIsRUFBd0I7QUFDM0IsZUFBTyxDQUNILElBREcsRUFFSCxDQUFDLElBQUQsQ0FGRyxFQUdILElBSEcsQ0FBUDtBQUtILEtBTk0sTUFNQTtBQUNILGVBQU8sQ0FDSCxLQURHLEVBRUhBLFFBRkcsQ0FBUDtBQUlIO0FBQ0o7O0FBRUQsU0FBU294QixvQkFBVCxDQUErQjdqQyxLQUEvQixFQUFzQztBQUNsQyxRQUFNeWlDLFlBQVksRUFBbEI7QUFDQXpoQixjQUFVaGhCLEtBQVYsRUFBaUIsaUJBQVM7QUFDdEIsWUFBSTFDLE1BQU00TSxNQUFWLEVBQWtCO0FBQ2Q1TSxrQkFBTTRNLE1BQU4sR0FBZTg0QixnQkFBZ0IxbEMsTUFBTTRNLE1BQXRCLENBQWY7QUFDSDtBQUNKLEtBSkQ7QUFLQStXLGlCQUFhamhCLEtBQWIsRUFBb0I7QUFDaEJjLGVBQU8sSUFEUztBQUVoQnZELGdCQUFRO0FBRlEsS0FBcEIsRUFHRyxtQkFBbUM7QUFBQSxZQUFqQ0ksSUFBaUMsV0FBakNBLElBQWlDO0FBQUEsWUFBM0JpSyxLQUEyQixXQUEzQkEsS0FBMkI7QUFBQSxZQUFwQitNLFNBQW9CLFdBQXBCQSxTQUFvQjtBQUFBLFlBQVRuTyxHQUFTLFdBQVRBLEdBQVM7O0FBQ2xDLFlBQUlzM0IsYUFBYWwyQixLQUFiLENBQUosRUFDSTtBQUNKLFlBQUksUUFBT0EsS0FBUCx5Q0FBT0EsS0FBUCxPQUFpQixRQUFqQixJQUE2QixDQUFDaE0sTUFBTUMsT0FBTixDQUFjK0wsS0FBZCxDQUFsQyxFQUF3RDtBQUNwRHBCLGdCQUFJODRCLGdCQUFnQjEzQixLQUFoQixFQUF1QitNLFNBQXZCLENBQUo7QUFDQTh0QixzQkFBVS9sQyxJQUFWLENBQWVpQixLQUFLbUosSUFBTCxDQUFVLEdBQVYsQ0FBZjtBQUNILFNBSEQsTUFHTyxJQUFJNk4sVUFBVTNILE1BQVYsSUFBb0IsT0FBT3BGLEtBQVAsS0FBaUIsUUFBekMsRUFBbUQ7QUFDdERwQixnQkFBSWc1QixtQkFBbUI1M0IsS0FBbkIsQ0FBSjtBQUNIO0FBQ0osS0FaRDtBQWFBLFdBQU81SCxLQUFQO0FBQ0g7O0FBRUQsU0FBUzhqQyxPQUFULENBQWtCOWpDLEtBQWxCLEVBQXlCO0FBQ3JCLFFBQUkrakMsV0FBVyxLQUFmO0FBQ0EsUUFBSS9qQyxNQUFNeEIsT0FBTixLQUFrQixDQUF0QixFQUF5QjtBQUNyQndCLGdCQUFRNmhCLFlBQVk3aEIsS0FBWixDQUFSO0FBQ0ErakMsbUJBQVcsSUFBWDtBQUNIO0FBQ0QsUUFBSS9qQyxNQUFNeEIsT0FBTixLQUFrQixDQUF0QixFQUF5QjtBQUNyQnVsQyxtQkFBV0YscUJBQXFCN2pDLEtBQXJCLENBQVg7QUFDQStqQyxtQkFBVyxJQUFYO0FBQ0g7QUFDRCxRQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNYLGNBQU0sSUFBSXRsQyxLQUFKLENBQVUscUJBQVYsRUFBaUN1QixNQUFNeEIsT0FBdkMsQ0FBTjtBQUNIO0FBQ0QsV0FBT3dCLEtBQVA7QUFDSDs7QUFFRCxTQUFTZ2tDLFNBQVQsQ0FBb0Joa0MsS0FBcEIsRUFBMkI7QUFDdkIsUUFBTWlrQyxXQUFXLEVBQWpCO0FBQ0EsUUFBTUMsWUFBWSxFQUFsQjtBQUNBLFFBQU1DLHlCQUF5QixFQUEvQjtBQUNBLFNBQUssSUFBTTlqQyxFQUFYLElBQWlCTCxNQUFNeUQsT0FBdkIsRUFBZ0M7QUFDNUIsWUFBTXhGLFVBQVMrQixNQUFNeUQsT0FBTixDQUFjcEQsRUFBZCxDQUFmO0FBQ0EsWUFBSXBDLFFBQU95QyxJQUFQLEtBQWdCLFFBQXBCLEVBQ0k7QUFDSixZQUFNM0MsUUFBUSxtQkFBbUJpZ0IsSUFBbkIsQ0FBd0IvZixRQUFPUCxHQUEvQixDQUFkO0FBQ0EsWUFBSSxDQUFDSyxLQUFMLEVBQ0k7QUFDSmttQyxpQkFBU3ZuQyxJQUFULENBQWMyRCxFQUFkO0FBQ0E2akMsa0JBQVV4bkMsSUFBVixDQUFlcUIsTUFBTSxDQUFOLENBQWY7QUFDSDtBQUNELFFBQUlrbUMsU0FBU2xvQyxNQUFULEdBQWtCLENBQXRCLEVBQ0ksT0FBT2lFLEtBQVA7QUFDSmlrQyxhQUFTN2lCLE9BQVQsQ0FBaUIsY0FBTTtBQUNuQixlQUFPcGhCLE1BQU15RCxPQUFOLENBQWNwRCxFQUFkLENBQVA7QUFDSCxLQUZEO0FBR0EsUUFBTStqQyxjQUFjRixVQUFVcDlCLElBQVYsQ0FBZSxHQUFmLENBQXBCO0FBQ0E5RyxVQUFNeUQsT0FBTixDQUFjMmdDLFdBQWQsSUFBNkI7QUFDekIsZ0JBQVEsUUFEaUI7QUFFekIsNkJBQW9CQTtBQUZLLEtBQTdCO0FBSUFwa0MsVUFBTUksTUFBTixDQUFhZ2hCLE9BQWIsQ0FBcUIsaUJBQVM7QUFDMUIsWUFBSTZpQixTQUFTeG5DLE9BQVQsQ0FBaUJhLE1BQU1XLE1BQXZCLEtBQWtDLENBQXRDLEVBQXlDO0FBQ3JDWCxrQkFBTVcsTUFBTixHQUFlbW1DLFdBQWY7QUFDQSxnQkFBSSxrQkFBa0I5bUMsS0FBdEIsRUFBNkI7QUFDekIsb0JBQUk2bUMsdUJBQXVCMW5DLE9BQXZCLENBQStCYSxNQUFNLGNBQU4sQ0FBL0IsS0FBeUQsQ0FBN0QsRUFBZ0U7QUFDNUQsMEJBQU0sSUFBSW1CLEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQ0gsaUJBRkQsTUFFTztBQUNIMGxDLDJDQUF1QnpuQyxJQUF2QixDQUE0QlksTUFBTSxjQUFOLENBQTVCO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0FYRDtBQVlBLFdBQU8wQyxLQUFQO0FBQ0g7O0FBRUQsSUFBSXFrQyxnQkFBZ0IsQ0FDaEIsTUFEZ0IsRUFFaEIsUUFGZ0IsRUFHaEIsY0FIZ0IsRUFJaEIsU0FKZ0IsRUFLaEIsU0FMZ0IsRUFNaEIsUUFOZ0IsRUFPaEIsUUFQZ0IsQ0FBcEI7O0FBVUEsU0FBU0MsS0FBVCxDQUFlaG5DLEtBQWYsRUFBc0J1bEIsTUFBdEIsRUFBOEI7QUFDMUIsUUFBTWpPLFNBQVMsRUFBZjtBQUNBLFNBQUssSUFBTXFELENBQVgsSUFBZ0IzYSxLQUFoQixFQUF1QjtBQUNuQixZQUFJMmEsTUFBTSxLQUFWLEVBQWlCO0FBQ2JyRCxtQkFBT3FELENBQVAsSUFBWTNhLE1BQU0yYSxDQUFOLENBQVo7QUFDSDtBQUNKO0FBQ0Rvc0Isa0JBQWNqakIsT0FBZCxDQUFzQixhQUFLO0FBQ3ZCLFlBQUluSixLQUFLNEssTUFBVCxFQUFpQjtBQUNiak8sbUJBQU9xRCxDQUFQLElBQVk0SyxPQUFPNUssQ0FBUCxDQUFaO0FBQ0g7QUFDSixLQUpEO0FBS0EsV0FBT3JELE1BQVA7QUFDSDtBQUNELFNBQVMydkIsV0FBVCxDQUFxQm5rQyxNQUFyQixFQUE2QjtBQUN6QkEsYUFBU0EsT0FBT3lHLEtBQVAsRUFBVDtBQUNBLFFBQU16SyxNQUFNcVksT0FBT2lvQixNQUFQLENBQWMsSUFBZCxDQUFaO0FBQ0EsU0FBSyxJQUFJaGhDLElBQUksQ0FBYixFQUFnQkEsSUFBSTBFLE9BQU9yRSxNQUEzQixFQUFtQ0wsR0FBbkMsRUFBd0M7QUFDcENVLFlBQUlnRSxPQUFPMUUsQ0FBUCxFQUFVMkUsRUFBZCxJQUFvQkQsT0FBTzFFLENBQVAsQ0FBcEI7QUFDSDtBQUNELFNBQUssSUFBSUEsTUFBSSxDQUFiLEVBQWdCQSxNQUFJMEUsT0FBT3JFLE1BQTNCLEVBQW1DTCxLQUFuQyxFQUF3QztBQUNwQyxZQUFJLFNBQVMwRSxPQUFPMUUsR0FBUCxDQUFiLEVBQXdCO0FBQ3BCMEUsbUJBQU8xRSxHQUFQLElBQVk0b0MsTUFBTWxrQyxPQUFPMUUsR0FBUCxDQUFOLEVBQWlCVSxJQUFJZ0UsT0FBTzFFLEdBQVAsRUFBVWtHLEdBQWQsQ0FBakIsQ0FBWjtBQUNIO0FBQ0o7QUFDRCxXQUFPeEIsTUFBUDtBQUNIOztBQUVELFNBQVNva0MsU0FBVCxDQUFtQjc5QixDQUFuQixFQUFzQmdmLENBQXRCLEVBQXlCO0FBQ3JCLFFBQUkvcEIsTUFBTUMsT0FBTixDQUFjOEssQ0FBZCxDQUFKLEVBQXNCO0FBQ2xCLFlBQUksQ0FBQy9LLE1BQU1DLE9BQU4sQ0FBYzhwQixDQUFkLENBQUQsSUFBcUJoZixFQUFFNUssTUFBRixLQUFhNHBCLEVBQUU1cEIsTUFBeEMsRUFDSSxPQUFPLEtBQVA7QUFDSixhQUFLLElBQUlMLElBQUksQ0FBYixFQUFnQkEsSUFBSWlMLEVBQUU1SyxNQUF0QixFQUE4QkwsR0FBOUIsRUFBbUM7QUFDL0IsZ0JBQUksQ0FBQzhvQyxVQUFVNzlCLEVBQUVqTCxDQUFGLENBQVYsRUFBZ0JpcUIsRUFBRWpxQixDQUFGLENBQWhCLENBQUwsRUFDSSxPQUFPLEtBQVA7QUFDUDtBQUNELGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxRQUFPaUwsQ0FBUCx5Q0FBT0EsQ0FBUCxPQUFhLFFBQWIsSUFBeUJBLE1BQU0sSUFBL0IsSUFBdUNnZixNQUFNLElBQWpELEVBQXVEO0FBQ25ELFlBQUksRUFBRSxRQUFPQSxDQUFQLHlDQUFPQSxDQUFQLE9BQWEsUUFBZixDQUFKLEVBQ0ksT0FBTyxLQUFQO0FBQ0osWUFBTXhSLE9BQU9NLE9BQU9OLElBQVAsQ0FBWXhOLENBQVosQ0FBYjtBQUNBLFlBQUl3TixLQUFLcFksTUFBTCxLQUFnQjBZLE9BQU9OLElBQVAsQ0FBWXdSLENBQVosRUFBZTVwQixNQUFuQyxFQUNJLE9BQU8sS0FBUDtBQUNKLGFBQUssSUFBTWdKLEdBQVgsSUFBa0I0QixDQUFsQixFQUFxQjtBQUNqQixnQkFBSSxDQUFDNjlCLFVBQVU3OUIsRUFBRTVCLEdBQUYsQ0FBVixFQUFrQjRnQixFQUFFNWdCLEdBQUYsQ0FBbEIsQ0FBTCxFQUNJLE9BQU8sS0FBUDtBQUNQO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7QUFDRCxXQUFPNEIsTUFBTWdmLENBQWI7QUFDSDs7QUFFRCxJQUFNOGUsYUFBYTtBQUNmeGtDLGNBQVUsVUFESztBQUVmaUQsY0FBVSxVQUZLO0FBR2Z3aEMsaUJBQWEsYUFIRTtBQUlmQyxzQkFBa0Isa0JBSkg7QUFLZkMsdUJBQW1CLG1CQUxKO0FBTWZDLGVBQVcsV0FOSTtBQU9mQyxlQUFXLFdBUEk7QUFRZkMsa0JBQWMsY0FSQztBQVNmQywwQkFBc0Isc0JBVFA7QUFVZkMsdUJBQW1CLG1CQVZKO0FBV2ZDLHNCQUFrQixrQkFYSDtBQVlmOWlDLGVBQVcsV0FaSTtBQWFmRSxhQUFTLFNBYk07QUFjZjZpQyxnQkFBWSxZQWRHO0FBZWZDLGNBQVUsVUFmSztBQWdCZkMsZUFBVyxXQWhCSTtBQWlCZkMsZUFBVyxXQWpCSTtBQWtCZkMsbUJBQWUsZUFsQkE7QUFtQmZDLGNBQVUsVUFuQks7QUFvQmZDLGdCQUFZLFlBcEJHO0FBcUJmQyxZQUFRLFFBckJPO0FBc0JmQyxtQkFBZTtBQXRCQSxDQUFuQjtBQXdCQSxTQUFTYixTQUFULENBQW1CampDLFFBQW5CLEVBQTZCK2pDLEtBQTdCLEVBQW9DQyxRQUFwQyxFQUE4QztBQUMxQ0EsYUFBU25wQyxJQUFULENBQWM7QUFDVm9wQyxpQkFBU3JCLFdBQVdLLFNBRFY7QUFFVjVjLGNBQU0sQ0FDRnJtQixRQURFLEVBRUYrakMsTUFBTS9qQyxRQUFOLENBRkU7QUFGSSxLQUFkO0FBT0g7QUFDRCxTQUFTa2pDLFlBQVQsQ0FBc0JsakMsUUFBdEIsRUFBZ0Nna0MsUUFBaEMsRUFBMENFLGNBQTFDLEVBQTBEO0FBQ3RERixhQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLGlCQUFTckIsV0FBV00sWUFEVjtBQUVWN2MsY0FBTSxDQUFDcm1CLFFBQUQ7QUFGSSxLQUFkO0FBSUFra0MsbUJBQWVsa0MsUUFBZixJQUEyQixJQUEzQjtBQUNIO0FBQ0QsU0FBU21rQyxZQUFULENBQXNCbmtDLFFBQXRCLEVBQWdDK2pDLEtBQWhDLEVBQXVDQyxRQUF2QyxFQUFpREUsY0FBakQsRUFBaUU7QUFDN0RoQixpQkFBYWxqQyxRQUFiLEVBQXVCZ2tDLFFBQXZCLEVBQWlDRSxjQUFqQztBQUNBakIsY0FBVWpqQyxRQUFWLEVBQW9CK2pDLEtBQXBCLEVBQTJCQyxRQUEzQjtBQUNIO0FBQ0QsU0FBU0ksZ0JBQVQsQ0FBMEJDLE1BQTFCLEVBQWtDTixLQUFsQyxFQUF5Qy9qQyxRQUF6QyxFQUFtRDtBQUMvQyxRQUFJc1ksYUFBSjtBQUNBLFNBQUtBLElBQUwsSUFBYStyQixPQUFPcmtDLFFBQVAsQ0FBYixFQUErQjtBQUMzQixZQUFJLENBQUNxa0MsT0FBT3JrQyxRQUFQLEVBQWlCK1gsY0FBakIsQ0FBZ0NPLElBQWhDLENBQUwsRUFDSTtBQUNKLFlBQUlBLFNBQVMsTUFBVCxJQUFtQixDQUFDcXFCLFVBQVUwQixPQUFPcmtDLFFBQVAsRUFBaUJzWSxJQUFqQixDQUFWLEVBQWtDeXJCLE1BQU0vakMsUUFBTixFQUFnQnNZLElBQWhCLENBQWxDLENBQXhCLEVBQWtGO0FBQzlFLG1CQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsU0FBS0EsSUFBTCxJQUFheXJCLE1BQU0vakMsUUFBTixDQUFiLEVBQThCO0FBQzFCLFlBQUksQ0FBQytqQyxNQUFNL2pDLFFBQU4sRUFBZ0IrWCxjQUFoQixDQUErQk8sSUFBL0IsQ0FBTCxFQUNJO0FBQ0osWUFBSUEsU0FBUyxNQUFULElBQW1CLENBQUNxcUIsVUFBVTBCLE9BQU9ya0MsUUFBUCxFQUFpQnNZLElBQWpCLENBQVYsRUFBa0N5ckIsTUFBTS9qQyxRQUFOLEVBQWdCc1ksSUFBaEIsQ0FBbEMsQ0FBeEIsRUFBa0Y7QUFDOUUsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSDtBQUNELFNBQVNnc0IsV0FBVCxDQUFxQkQsTUFBckIsRUFBNkJOLEtBQTdCLEVBQW9DQyxRQUFwQyxFQUE4Q0UsY0FBOUMsRUFBOEQ7QUFDMURHLGFBQVNBLFVBQVUsRUFBbkI7QUFDQU4sWUFBUUEsU0FBUyxFQUFqQjtBQUNBLFFBQUkvakMsaUJBQUo7QUFDQSxTQUFLQSxRQUFMLElBQWlCcWtDLE1BQWpCLEVBQXlCO0FBQ3JCLFlBQUksQ0FBQ0EsT0FBT3RzQixjQUFQLENBQXNCL1gsUUFBdEIsQ0FBTCxFQUNJO0FBQ0osWUFBSSxDQUFDK2pDLE1BQU1oc0IsY0FBTixDQUFxQi9YLFFBQXJCLENBQUwsRUFBcUM7QUFDakNrakMseUJBQWFsakMsUUFBYixFQUF1QmdrQyxRQUF2QixFQUFpQ0UsY0FBakM7QUFDSDtBQUNKO0FBQ0QsU0FBS2xrQyxRQUFMLElBQWlCK2pDLEtBQWpCLEVBQXdCO0FBQ3BCLFlBQUksQ0FBQ0EsTUFBTWhzQixjQUFOLENBQXFCL1gsUUFBckIsQ0FBTCxFQUNJO0FBQ0osWUFBSSxDQUFDcWtDLE9BQU90c0IsY0FBUCxDQUFzQi9YLFFBQXRCLENBQUwsRUFBc0M7QUFDbENpakMsc0JBQVVqakMsUUFBVixFQUFvQitqQyxLQUFwQixFQUEyQkMsUUFBM0I7QUFDSCxTQUZELE1BRU8sSUFBSSxDQUFDckIsVUFBVTBCLE9BQU9ya0MsUUFBUCxDQUFWLEVBQTRCK2pDLE1BQU0vakMsUUFBTixDQUE1QixDQUFMLEVBQW1EO0FBQ3RELGdCQUFJcWtDLE9BQU9ya0MsUUFBUCxFQUFpQm5CLElBQWpCLEtBQTBCLFNBQTFCLElBQXVDa2xDLE1BQU0vakMsUUFBTixFQUFnQm5CLElBQWhCLEtBQXlCLFNBQWhFLElBQTZFdWxDLGlCQUFpQkMsTUFBakIsRUFBeUJOLEtBQXpCLEVBQWdDL2pDLFFBQWhDLENBQWpGLEVBQTRIO0FBQ3hIZ2tDLHlCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLDZCQUFTckIsV0FBV08sb0JBRFY7QUFFVjljLDBCQUFNLENBQ0ZybUIsUUFERSxFQUVGK2pDLE1BQU0vakMsUUFBTixFQUFnQnFFLElBRmQ7QUFGSSxpQkFBZDtBQU9ILGFBUkQsTUFRTztBQUNIOC9CLDZCQUFhbmtDLFFBQWIsRUFBdUIrakMsS0FBdkIsRUFBOEJDLFFBQTlCLEVBQXdDRSxjQUF4QztBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0QsU0FBU0ssd0JBQVQsQ0FBa0NGLE1BQWxDLEVBQTBDTixLQUExQyxFQUFpREMsUUFBakQsRUFBMkQ3K0IsT0FBM0QsRUFBb0VxL0IsS0FBcEUsRUFBMkVQLE9BQTNFLEVBQW9GO0FBQ2hGSSxhQUFTQSxVQUFVLEVBQW5CO0FBQ0FOLFlBQVFBLFNBQVMsRUFBakI7QUFDQSxRQUFJenJCLGFBQUo7QUFDQSxTQUFLQSxJQUFMLElBQWErckIsTUFBYixFQUFxQjtBQUNqQixZQUFJLENBQUNBLE9BQU90c0IsY0FBUCxDQUFzQk8sSUFBdEIsQ0FBTCxFQUNJO0FBQ0osWUFBSSxDQUFDcXFCLFVBQVUwQixPQUFPL3JCLElBQVAsQ0FBVixFQUF3QnlyQixNQUFNenJCLElBQU4sQ0FBeEIsQ0FBTCxFQUEyQztBQUN2QzByQixxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyxnQ0FEVTtBQUVWNWQsc0JBQU0sQ0FDRmxoQixPQURFLEVBRUZtVCxJQUZFLEVBR0Z5ckIsTUFBTXpyQixJQUFOLENBSEUsRUFJRmtzQixLQUpFO0FBRkksYUFBZDtBQVNIO0FBQ0o7QUFDRCxTQUFLbHNCLElBQUwsSUFBYXlyQixLQUFiLEVBQW9CO0FBQ2hCLFlBQUksQ0FBQ0EsTUFBTWhzQixjQUFOLENBQXFCTyxJQUFyQixDQUFELElBQStCK3JCLE9BQU90c0IsY0FBUCxDQUFzQk8sSUFBdEIsQ0FBbkMsRUFDSTtBQUNKLFlBQUksQ0FBQ3FxQixVQUFVMEIsT0FBTy9yQixJQUFQLENBQVYsRUFBd0J5ckIsTUFBTXpyQixJQUFOLENBQXhCLENBQUwsRUFBMkM7QUFDdkMwckIscUJBQVNucEMsSUFBVCxDQUFjO0FBQ1ZvcEMsZ0NBRFU7QUFFVjVkLHNCQUFNLENBQ0ZsaEIsT0FERSxFQUVGbVQsSUFGRSxFQUdGeXJCLE1BQU16ckIsSUFBTixDQUhFLEVBSUZrc0IsS0FKRTtBQUZJLGFBQWQ7QUFTSDtBQUNKO0FBQ0o7QUFDRCxTQUFTQyxPQUFULENBQWlCaHBDLEtBQWpCLEVBQXdCO0FBQ3BCLFdBQU9BLE1BQU0rQyxFQUFiO0FBQ0g7QUFDRCxTQUFTa21DLFNBQVQsQ0FBbUI1M0IsS0FBbkIsRUFBMEJyUixLQUExQixFQUFpQztBQUM3QnFSLFVBQU1yUixNQUFNK0MsRUFBWixJQUFrQi9DLEtBQWxCO0FBQ0EsV0FBT3FSLEtBQVA7QUFDSDtBQUNELFNBQVM2M0IsVUFBVCxDQUFvQk4sTUFBcEIsRUFBNEJOLEtBQTVCLEVBQW1DQyxRQUFuQyxFQUE2QztBQUN6Q0ssYUFBU0EsVUFBVSxFQUFuQjtBQUNBTixZQUFRQSxTQUFTLEVBQWpCO0FBQ0EsUUFBTWEsY0FBY1AsT0FBTzlwQyxHQUFQLENBQVdrcUMsT0FBWCxDQUFwQjtBQUNBLFFBQU1JLGFBQWFkLE1BQU14cEMsR0FBTixDQUFVa3FDLE9BQVYsQ0FBbkI7QUFDQSxRQUFNSyxjQUFjVCxPQUFPVSxNQUFQLENBQWNMLFNBQWQsRUFBeUIsRUFBekIsQ0FBcEI7QUFDQSxRQUFNTSxhQUFhakIsTUFBTWdCLE1BQU4sQ0FBYUwsU0FBYixFQUF3QixFQUF4QixDQUFuQjtBQUNBLFFBQU1PLFVBQVVMLFlBQVk1L0IsS0FBWixFQUFoQjtBQUNBLFFBQU1rZ0MsUUFBUXR5QixPQUFPaW9CLE1BQVAsQ0FBYyxJQUFkLENBQWQ7QUFDQSxRQUFJaGhDLFVBQUo7QUFBQSxRQUFPbXpCLFVBQVA7QUFBQSxRQUFVN25CLGdCQUFWO0FBQUEsUUFBbUJnZ0Msb0JBQW5CO0FBQUEsUUFBZ0NDLG1CQUFoQztBQUFBLFFBQTRDQyw0QkFBNUM7QUFBQSxRQUFpRS9zQixhQUFqRTtBQUNBLFNBQUt6ZSxJQUFJLENBQUosRUFBT216QixJQUFJLENBQWhCLEVBQW1CbnpCLElBQUkrcUMsWUFBWTFxQyxNQUFuQyxFQUEyQ0wsR0FBM0MsRUFBZ0Q7QUFDNUNzTCxrQkFBVXkvQixZQUFZL3FDLENBQVosQ0FBVjtBQUNBLFlBQUksQ0FBQ21yQyxXQUFXanRCLGNBQVgsQ0FBMEI1UyxPQUExQixDQUFMLEVBQXlDO0FBQ3JDNitCLHFCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLHlCQUFTckIsV0FBV0MsV0FEVjtBQUVWeGMsc0JBQU0sQ0FBQ2xoQixPQUFEO0FBRkksYUFBZDtBQUlBOC9CLG9CQUFRL3RCLE1BQVIsQ0FBZSt0QixRQUFRcnFDLE9BQVIsQ0FBZ0J1SyxPQUFoQixFQUF5QjZuQixDQUF6QixDQUFmLEVBQTRDLENBQTVDO0FBQ0gsU0FORCxNQU1PO0FBQ0hBO0FBQ0g7QUFDSjtBQUNELFNBQUtuekIsSUFBSSxDQUFKLEVBQU9tekIsSUFBSSxDQUFoQixFQUFtQm56QixJQUFJZ3JDLFdBQVczcUMsTUFBbEMsRUFBMENMLEdBQTFDLEVBQStDO0FBQzNDc0wsa0JBQVUwL0IsV0FBV0EsV0FBVzNxQyxNQUFYLEdBQW9CLENBQXBCLEdBQXdCTCxDQUFuQyxDQUFWO0FBQ0EsWUFBSW9yQyxRQUFRQSxRQUFRL3FDLE1BQVIsR0FBaUIsQ0FBakIsR0FBcUJMLENBQTdCLE1BQW9Dc0wsT0FBeEMsRUFDSTtBQUNKLFlBQUkyL0IsWUFBWS9zQixjQUFaLENBQTJCNVMsT0FBM0IsQ0FBSixFQUF5QztBQUNyQzYrQixxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyx5QkFBU3JCLFdBQVdDLFdBRFY7QUFFVnhjLHNCQUFNLENBQUNsaEIsT0FBRDtBQUZJLGFBQWQ7QUFJQTgvQixvQkFBUS90QixNQUFSLENBQWUrdEIsUUFBUWh1QixXQUFSLENBQW9COVIsT0FBcEIsRUFBNkI4L0IsUUFBUS9xQyxNQUFSLEdBQWlCOHlCLENBQTlDLENBQWYsRUFBaUUsQ0FBakU7QUFDSCxTQU5ELE1BTU87QUFDSEE7QUFDSDtBQUNEcVksOEJBQXNCSixRQUFRQSxRQUFRL3FDLE1BQVIsR0FBaUJMLENBQXpCLENBQXRCO0FBQ0FtcUMsaUJBQVNucEMsSUFBVCxDQUFjO0FBQ1ZvcEMscUJBQVNyQixXQUFXdmhDLFFBRFY7QUFFVmdsQixrQkFBTSxDQUNGMmUsV0FBVzcvQixPQUFYLENBREUsRUFFRmtnQyxtQkFGRTtBQUZJLFNBQWQ7QUFPQUosZ0JBQVEvdEIsTUFBUixDQUFlK3RCLFFBQVEvcUMsTUFBUixHQUFpQkwsQ0FBaEMsRUFBbUMsQ0FBbkMsRUFBc0NzTCxPQUF0QztBQUNBKy9CLGNBQU0vL0IsT0FBTixJQUFpQixJQUFqQjtBQUNIO0FBQ0QsU0FBS3RMLElBQUksQ0FBVCxFQUFZQSxJQUFJZ3JDLFdBQVczcUMsTUFBM0IsRUFBbUNMLEdBQW5DLEVBQXdDO0FBQ3BDc0wsa0JBQVUwL0IsV0FBV2hyQyxDQUFYLENBQVY7QUFDQXNyQyxzQkFBY0wsWUFBWTMvQixPQUFaLENBQWQ7QUFDQWlnQyxxQkFBYUosV0FBVzcvQixPQUFYLENBQWI7QUFDQSxZQUFJKy9CLE1BQU0vL0IsT0FBTixLQUFrQnc5QixVQUFVd0MsV0FBVixFQUF1QkMsVUFBdkIsQ0FBdEIsRUFDSTtBQUNKLFlBQUksQ0FBQ3pDLFVBQVV3QyxZQUFZL29DLE1BQXRCLEVBQThCZ3BDLFdBQVdocEMsTUFBekMsQ0FBRCxJQUFxRCxDQUFDdW1DLFVBQVV3QyxZQUFZLGNBQVosQ0FBVixFQUF1Q0MsV0FBVyxjQUFYLENBQXZDLENBQXRELElBQTRILENBQUN6QyxVQUFVd0MsWUFBWXRtQyxJQUF0QixFQUE0QnVtQyxXQUFXdm1DLElBQXZDLENBQWpJLEVBQStLO0FBQzNLbWxDLHFCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLHlCQUFTckIsV0FBV0MsV0FEVjtBQUVWeGMsc0JBQU0sQ0FBQ2xoQixPQUFEO0FBRkksYUFBZDtBQUlBa2dDLGtDQUFzQkosUUFBUUEsUUFBUWh1QixXQUFSLENBQW9COVIsT0FBcEIsSUFBK0IsQ0FBdkMsQ0FBdEI7QUFDQTYrQixxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyx5QkFBU3JCLFdBQVd2aEMsUUFEVjtBQUVWZ2xCLHNCQUFNLENBQ0YrZSxVQURFLEVBRUZDLG1CQUZFO0FBRkksYUFBZDtBQU9BO0FBQ0g7QUFDRGQsaUNBQXlCWSxZQUFZenBDLE1BQXJDLEVBQTZDMHBDLFdBQVcxcEMsTUFBeEQsRUFBZ0Vzb0MsUUFBaEUsRUFBMEU3K0IsT0FBMUUsRUFBbUYsSUFBbkYsRUFBeUZ5OUIsV0FBV0csaUJBQXBHO0FBQ0F3QixpQ0FBeUJZLFlBQVlsbUMsS0FBckMsRUFBNENtbUMsV0FBV25tQyxLQUF2RCxFQUE4RCtrQyxRQUE5RCxFQUF3RTcrQixPQUF4RSxFQUFpRixJQUFqRixFQUF1Rnk5QixXQUFXRSxnQkFBbEc7QUFDQSxZQUFJLENBQUNILFVBQVV3QyxZQUFZOThCLE1BQXRCLEVBQThCKzhCLFdBQVcvOEIsTUFBekMsQ0FBTCxFQUF1RDtBQUNuRDI3QixxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyx5QkFBU3JCLFdBQVdJLFNBRFY7QUFFVjNjLHNCQUFNLENBQ0ZsaEIsT0FERSxFQUVGaWdDLFdBQVcvOEIsTUFGVDtBQUZJLGFBQWQ7QUFPSDtBQUNELFlBQUksQ0FBQ3M2QixVQUFVd0MsWUFBWWhqQyxPQUF0QixFQUErQmlqQyxXQUFXampDLE9BQTFDLENBQUQsSUFBdUQsQ0FBQ3dnQyxVQUFVd0MsWUFBWWxqQyxPQUF0QixFQUErQm1qQyxXQUFXbmpDLE9BQTFDLENBQTVELEVBQWdIO0FBQzVHK2hDLHFCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLHlCQUFTckIsV0FBV1EsaUJBRFY7QUFFVi9jLHNCQUFNLENBQ0ZsaEIsT0FERSxFQUVGaWdDLFdBQVdqakMsT0FGVCxFQUdGaWpDLFdBQVduakMsT0FIVDtBQUZJLGFBQWQ7QUFRSDtBQUNELGFBQUtxVyxJQUFMLElBQWE2c0IsV0FBYixFQUEwQjtBQUN0QixnQkFBSSxDQUFDQSxZQUFZcHRCLGNBQVosQ0FBMkJPLElBQTNCLENBQUwsRUFDSTtBQUNKLGdCQUFJQSxTQUFTLFFBQVQsSUFBcUJBLFNBQVMsT0FBOUIsSUFBeUNBLFNBQVMsUUFBbEQsSUFBOERBLFNBQVMsVUFBdkUsSUFBcUZBLFNBQVMsU0FBOUYsSUFBMkdBLFNBQVMsU0FBeEgsRUFDSTtBQUNKLGdCQUFJQSxLQUFLMWQsT0FBTCxDQUFhLFFBQWIsTUFBMkIsQ0FBL0IsRUFBa0M7QUFDOUIycEMseUNBQXlCWSxZQUFZN3NCLElBQVosQ0FBekIsRUFBNEM4c0IsV0FBVzlzQixJQUFYLENBQTVDLEVBQThEMHJCLFFBQTlELEVBQXdFNytCLE9BQXhFLEVBQWlGbVQsS0FBS3RULEtBQUwsQ0FBVyxDQUFYLENBQWpGLEVBQWdHNDlCLFdBQVdFLGdCQUEzRztBQUNILGFBRkQsTUFFTyxJQUFJLENBQUNILFVBQVV3QyxZQUFZN3NCLElBQVosQ0FBVixFQUE2QjhzQixXQUFXOXNCLElBQVgsQ0FBN0IsQ0FBTCxFQUFxRDtBQUN4RDByQix5QkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyw2QkFBU3JCLFdBQVdTLGdCQURWO0FBRVZoZCwwQkFBTSxDQUNGbGhCLE9BREUsRUFFRm1ULElBRkUsRUFHRjhzQixXQUFXOXNCLElBQVgsQ0FIRTtBQUZJLGlCQUFkO0FBUUg7QUFDSjtBQUNELGFBQUtBLElBQUwsSUFBYThzQixVQUFiLEVBQXlCO0FBQ3JCLGdCQUFJLENBQUNBLFdBQVdydEIsY0FBWCxDQUEwQk8sSUFBMUIsQ0FBRCxJQUFvQzZzQixZQUFZcHRCLGNBQVosQ0FBMkJPLElBQTNCLENBQXhDLEVBQ0k7QUFDSixnQkFBSUEsU0FBUyxRQUFULElBQXFCQSxTQUFTLE9BQTlCLElBQXlDQSxTQUFTLFFBQWxELElBQThEQSxTQUFTLFVBQXZFLElBQXFGQSxTQUFTLFNBQTlGLElBQTJHQSxTQUFTLFNBQXhILEVBQ0k7QUFDSixnQkFBSUEsS0FBSzFkLE9BQUwsQ0FBYSxRQUFiLE1BQTJCLENBQS9CLEVBQWtDO0FBQzlCMnBDLHlDQUF5QlksWUFBWTdzQixJQUFaLENBQXpCLEVBQTRDOHNCLFdBQVc5c0IsSUFBWCxDQUE1QyxFQUE4RDByQixRQUE5RCxFQUF3RTcrQixPQUF4RSxFQUFpRm1ULEtBQUt0VCxLQUFMLENBQVcsQ0FBWCxDQUFqRixFQUFnRzQ5QixXQUFXRSxnQkFBM0c7QUFDSCxhQUZELE1BRU8sSUFBSSxDQUFDSCxVQUFVd0MsWUFBWTdzQixJQUFaLENBQVYsRUFBNkI4c0IsV0FBVzlzQixJQUFYLENBQTdCLENBQUwsRUFBcUQ7QUFDeEQwckIseUJBQVNucEMsSUFBVCxDQUFjO0FBQ1ZvcEMsNkJBQVNyQixXQUFXUyxnQkFEVjtBQUVWaGQsMEJBQU0sQ0FDRmxoQixPQURFLEVBRUZtVCxJQUZFLEVBR0Y4c0IsV0FBVzlzQixJQUFYLENBSEU7QUFGSSxpQkFBZDtBQVFIO0FBQ0o7QUFDSjtBQUNKO0FBQ0QsU0FBU2d0QixVQUFULENBQW9CakIsTUFBcEIsRUFBNEJOLEtBQTVCLEVBQW1DO0FBQy9CLFFBQUksQ0FBQ00sTUFBTCxFQUNJLE9BQU8sQ0FBQztBQUNBSixpQkFBU3JCLFdBQVd4a0MsUUFEcEI7QUFFQWlvQixjQUFNLENBQUMwZCxLQUFEO0FBRk4sS0FBRCxDQUFQO0FBSUosUUFBSUMsV0FBVyxFQUFmO0FBQ0EsUUFBSTtBQUNBLFlBQUksQ0FBQ3JCLFVBQVUwQixPQUFPMW5DLE9BQWpCLEVBQTBCb25DLE1BQU1wbkMsT0FBaEMsQ0FBTCxFQUErQztBQUMzQyxtQkFBTyxDQUFDO0FBQ0FzbkMseUJBQVNyQixXQUFXeGtDLFFBRHBCO0FBRUFpb0Isc0JBQU0sQ0FBQzBkLEtBQUQ7QUFGTixhQUFELENBQVA7QUFJSDtBQUNELFlBQUksQ0FBQ3BCLFVBQVUwQixPQUFPN2pDLE1BQWpCLEVBQXlCdWpDLE1BQU12akMsTUFBL0IsQ0FBTCxFQUE2QztBQUN6Q3dqQyxxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyx5QkFBU3JCLFdBQVdyaUMsU0FEVjtBQUVWOGxCLHNCQUFNLENBQUMwZCxNQUFNdmpDLE1BQVA7QUFGSSxhQUFkO0FBSUg7QUFDRCxZQUFJLENBQUNtaUMsVUFBVTBCLE9BQU9ubEMsSUFBakIsRUFBdUI2a0MsTUFBTTdrQyxJQUE3QixDQUFMLEVBQXlDO0FBQ3JDOGtDLHFCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLHlCQUFTckIsV0FBV25pQyxPQURWO0FBRVY0bEIsc0JBQU0sQ0FBQzBkLE1BQU03a0MsSUFBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQUksQ0FBQ3lqQyxVQUFVMEIsT0FBT3IrQixPQUFqQixFQUEwQis5QixNQUFNLzlCLE9BQWhDLENBQUwsRUFBK0M7QUFDM0NnK0IscUJBQVNucEMsSUFBVCxDQUFjO0FBQ1ZvcEMseUJBQVNyQixXQUFXVSxVQURWO0FBRVZqZCxzQkFBTSxDQUFDMGQsTUFBTS85QixPQUFQO0FBRkksYUFBZDtBQUlIO0FBQ0QsWUFBSSxDQUFDMjhCLFVBQVUwQixPQUFPbCtCLEtBQWpCLEVBQXdCNDlCLE1BQU01OUIsS0FBOUIsQ0FBTCxFQUEyQztBQUN2QzY5QixxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyx5QkFBU3JCLFdBQVdXLFFBRFY7QUFFVmxkLHNCQUFNLENBQUMwZCxNQUFNNTlCLEtBQVA7QUFGSSxhQUFkO0FBSUg7QUFDRCxZQUFJLENBQUN3OEIsVUFBVTBCLE9BQU9ybkMsTUFBakIsRUFBeUIrbUMsTUFBTS9tQyxNQUEvQixDQUFMLEVBQTZDO0FBQ3pDZ25DLHFCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLHlCQUFTckIsV0FBV1ksU0FEVjtBQUVWbmQsc0JBQU0sQ0FBQzBkLE1BQU0vbUMsTUFBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQUksQ0FBQzJsQyxVQUFVMEIsT0FBTzM5QixNQUFqQixFQUF5QnE5QixNQUFNcjlCLE1BQS9CLENBQUwsRUFBNkM7QUFDekNzOUIscUJBQVNucEMsSUFBVCxDQUFjO0FBQ1ZvcEMseUJBQVNyQixXQUFXYSxTQURWO0FBRVZwZCxzQkFBTSxDQUFDMGQsTUFBTXI5QixNQUFQO0FBRkksYUFBZDtBQUlIO0FBQ0QsWUFBSSxDQUFDaThCLFVBQVUwQixPQUFPMTlCLFVBQWpCLEVBQTZCbzlCLE1BQU1wOUIsVUFBbkMsQ0FBTCxFQUFxRDtBQUNqRHE5QixxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyx5QkFBU3JCLFdBQVdjLGFBRFY7QUFFVnJkLHNCQUFNLENBQUMwZCxNQUFNcDlCLFVBQVA7QUFGSSxhQUFkO0FBSUg7QUFDRCxZQUFJLENBQUNnOEIsVUFBVTBCLE9BQU9qK0IsS0FBakIsRUFBd0IyOUIsTUFBTTM5QixLQUE5QixDQUFMLEVBQTJDO0FBQ3ZDNDlCLHFCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLHlCQUFTckIsV0FBV2UsUUFEVjtBQUVWdGQsc0JBQU0sQ0FBQzBkLE1BQU0zOUIsS0FBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQUksQ0FBQ3U4QixVQUFVMEIsT0FBTzU5QixHQUFqQixFQUFzQnM5QixNQUFNdDlCLEdBQTVCLENBQUwsRUFBdUM7QUFDbkN1OUIscUJBQVNucEMsSUFBVCxDQUFjO0FBQ1ZvcEMseUJBQVNyQixXQUFXaUIsTUFEVjtBQUVWeGQsc0JBQU0sQ0FBQzBkLE1BQU10OUIsR0FBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQUksQ0FBQ2s4QixVQUFVMEIsT0FBT3Y5QixVQUFqQixFQUE2Qmk5QixNQUFNajlCLFVBQW5DLENBQUwsRUFBcUQ7QUFDakRrOUIscUJBQVNucEMsSUFBVCxDQUFjO0FBQ1ZvcEMseUJBQVNyQixXQUFXa0IsYUFEVjtBQUVWemQsc0JBQU0sQ0FBQzBkLE1BQU1qOUIsVUFBUDtBQUZJLGFBQWQ7QUFJSDtBQUNELFlBQU1vOUIsaUJBQWlCLEVBQXZCO0FBQ0EsWUFBTXFCLDRCQUE0QixFQUFsQztBQUNBakIsb0JBQVlELE9BQU96aUMsT0FBbkIsRUFBNEJtaUMsTUFBTW5pQyxPQUFsQyxFQUEyQzJqQyx5QkFBM0MsRUFBc0VyQixjQUF0RTtBQUNBLFlBQU1zQixlQUFlLEVBQXJCO0FBQ0EsWUFBSW5CLE9BQU85bEMsTUFBWCxFQUFtQjtBQUNmOGxDLG1CQUFPOWxDLE1BQVAsQ0FBY2doQixPQUFkLENBQXNCLGlCQUFTO0FBQzNCLG9CQUFJMmtCLGVBQWV6b0MsTUFBTVcsTUFBckIsQ0FBSixFQUFrQztBQUM5QjRuQyw2QkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyxpQ0FBU3JCLFdBQVdDLFdBRFY7QUFFVnhjLDhCQUFNLENBQUM1cUIsTUFBTStDLEVBQVA7QUFGSSxxQkFBZDtBQUlILGlCQUxELE1BS087QUFDSGduQyxpQ0FBYTNxQyxJQUFiLENBQWtCWSxLQUFsQjtBQUNIO0FBQ0osYUFURDtBQVVIO0FBQ0QsWUFBSWdxQyxnQkFBZ0JwQixPQUFPNzlCLE9BQTNCO0FBQ0EsWUFBSWkvQixhQUFKLEVBQW1CO0FBQ2YsZ0JBQUl2QixlQUFldUIsY0FBY3JwQyxNQUE3QixDQUFKLEVBQTBDO0FBQ3RDNG5DLHlCQUFTbnBDLElBQVQsQ0FBYztBQUNWb3BDLDZCQUFTckIsV0FBV2dCLFVBRFY7QUFFVnZkLDBCQUFNLENBQUN4b0IsU0FBRDtBQUZJLGlCQUFkO0FBSUE0bkMsZ0NBQWdCNW5DLFNBQWhCO0FBQ0g7QUFDSjtBQUNEbW1DLG1CQUFXQSxTQUFTOTBCLE1BQVQsQ0FBZ0JxMkIseUJBQWhCLENBQVg7QUFDQSxZQUFJLENBQUM1QyxVQUFVOEMsYUFBVixFQUF5QjFCLE1BQU12OUIsT0FBL0IsQ0FBTCxFQUE4QztBQUMxQ3c5QixxQkFBU25wQyxJQUFULENBQWM7QUFDVm9wQyx5QkFBU3JCLFdBQVdnQixVQURWO0FBRVZ2ZCxzQkFBTSxDQUFDMGQsTUFBTXY5QixPQUFQO0FBRkksYUFBZDtBQUlIO0FBQ0RtK0IsbUJBQVdhLFlBQVgsRUFBeUJ6QixNQUFNeGxDLE1BQS9CLEVBQXVDeWxDLFFBQXZDO0FBQ0gsS0FyR0QsQ0FxR0UsT0FBT3ZsQyxDQUFQLEVBQVU7QUFDUlIsZ0JBQVErOUIsSUFBUixDQUFhLCtCQUFiLEVBQThDdjlCLENBQTlDO0FBQ0F1bEMsbUJBQVcsQ0FBQztBQUNKQyxxQkFBU3JCLFdBQVd4a0MsUUFEaEI7QUFFSmlvQixrQkFBTSxDQUFDMGQsS0FBRDtBQUZGLFNBQUQsQ0FBWDtBQUlIO0FBQ0QsV0FBT0MsUUFBUDtBQUNIOztJQUVLMEIsZSxHQUNGLHlCQUFZeGlDLEdBQVosRUFBaUI2QyxLQUFqQixFQUF3QithLE9BQXhCLEVBQWlDNmtCLFVBQWpDLEVBQTZDO0FBQUE7O0FBQ3pDLFNBQUs3a0IsT0FBTCxHQUFlLENBQUM1ZCxNQUFVQSxHQUFWLFVBQXFCLEVBQXRCLElBQTRCNGQsT0FBM0M7QUFDQSxRQUFJNmtCLFVBQUosRUFDSSxLQUFLQSxVQUFMLEdBQWtCQSxVQUFsQjtBQUNKLFFBQUk1L0IsVUFBVSxJQUFWLElBQWtCQSxVQUFVbEksU0FBNUIsSUFBeUNrSSxNQUFNNi9CLFFBQW5ELEVBQTZEO0FBQ3pELGFBQUt0OEIsSUFBTCxHQUFZdkQsTUFBTTYvQixRQUFsQjtBQUNIO0FBQ0osQzs7SUFHQ0MsYyxHQUNGLHdCQUFZM25DLEtBQVosRUFBbUI7QUFBQTs7QUFDZixTQUFLQSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLNGlCLE9BQUwsR0FBZTVpQixNQUFNNGlCLE9BQXJCO0FBQ0EsUUFBTTVrQixRQUFRZ0MsTUFBTTRpQixPQUFOLENBQWM1a0IsS0FBZCxDQUFvQixZQUFwQixDQUFkO0FBQ0EsU0FBS29OLElBQUwsR0FBWXBOLFFBQVE4bUIsU0FBUzltQixNQUFNLENBQU4sQ0FBVCxFQUFtQixFQUFuQixDQUFSLEdBQWlDLENBQTdDO0FBQ0gsQzs7QUFHTCxTQUFTNHBDLGlCQUFULENBQTJCcjBCLE9BQTNCLEVBQW9DO0FBQ2hDLFFBQU12TyxNQUFNdU8sUUFBUXZPLEdBQXBCO0FBQ0EsUUFBTXljLFlBQVlsTyxRQUFRMUwsS0FBMUI7QUFDQSxRQUFJNFosU0FBSixFQUFlO0FBQ1gsZUFBTyxDQUFDLElBQUkrbEIsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnljLFNBQXpCLEVBQW9DLHlDQUFwQyxDQUFELENBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPLEVBQVA7QUFDSDtBQUNKOztBQUVELFNBQVNvbUIsY0FBVCxDQUF3QnQwQixPQUF4QixFQUFpQztBQUM3QixRQUFNdk8sTUFBTXVPLFFBQVF2TyxHQUFwQjtBQUNBLFFBQU13SyxTQUFTK0QsUUFBUTFMLEtBQXZCO0FBQ0EsUUFBTWlnQyxlQUFldjBCLFFBQVF3MEIsU0FBUixJQUFxQixFQUExQztBQUNBLFFBQU1DLG9CQUFvQnowQixRQUFRMDBCLHVCQUFSLElBQW1DLEVBQTdEO0FBQ0EsUUFBTWhvQyxRQUFRc1QsUUFBUXRULEtBQXRCO0FBQ0EsUUFBTWlvQyxZQUFZMzBCLFFBQVEyMEIsU0FBMUI7QUFDQSxRQUFJenhCLFNBQVMsRUFBYjtBQUNBLFFBQU05VixPQUFPKzZCLFFBQVFsc0IsTUFBUixDQUFiO0FBQ0EsUUFBSTdPLFNBQVMsUUFBYixFQUF1QjtBQUNuQixlQUFPLENBQUMsSUFBSTZtQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCd0ssTUFBekIsd0JBQXNEN08sSUFBdEQsWUFBRCxDQUFQO0FBQ0g7QUFDRCxTQUFLLElBQU13bkMsU0FBWCxJQUF3QjM0QixNQUF4QixFQUFnQztBQUM1QixZQUFNNDRCLGlCQUFpQkQsVUFBVTVyQyxLQUFWLENBQWdCLEdBQWhCLEVBQXFCLENBQXJCLENBQXZCO0FBQ0EsWUFBTThyQyxjQUFjUCxhQUFhTSxjQUFiLEtBQWdDTixhQUFhLEdBQWIsQ0FBcEQ7QUFDQSxZQUFJUSx3QkFBSjtBQUNBLFlBQUlOLGtCQUFrQkksY0FBbEIsQ0FBSixFQUF1QztBQUNuQ0UsOEJBQWtCTixrQkFBa0JJLGNBQWxCLENBQWxCO0FBQ0gsU0FGRCxNQUVPLElBQUlOLGFBQWFNLGNBQWIsQ0FBSixFQUFrQztBQUNyQ0UsOEJBQWtCQyxRQUFsQjtBQUNILFNBRk0sTUFFQSxJQUFJUCxrQkFBa0IsR0FBbEIsQ0FBSixFQUE0QjtBQUMvQk0sOEJBQWtCTixrQkFBa0IsR0FBbEIsQ0FBbEI7QUFDSCxTQUZNLE1BRUEsSUFBSUYsYUFBYSxHQUFiLENBQUosRUFBdUI7QUFDMUJRLDhCQUFrQkMsUUFBbEI7QUFDSCxTQUZNLE1BRUE7QUFDSDl4QixtQkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJ3SyxPQUFPMjRCLFNBQVAsQ0FBekIsMEJBQWtFQSxTQUFsRSxRQUFaO0FBQ0E7QUFDSDtBQUNEMXhCLGlCQUFTQSxPQUFPekYsTUFBUCxDQUFjczNCLGdCQUFnQjtBQUNuQ3RqQyxpQkFBSyxDQUFDQSxNQUFVQSxHQUFWLFNBQW9CQSxHQUFyQixJQUE0Qm1qQyxTQURFO0FBRW5DdGdDLG1CQUFPMkgsT0FBTzI0QixTQUFQLENBRjRCO0FBR25DSix1QkFBV00sV0FId0I7QUFJbkNwb0Msd0JBSm1DO0FBS25DaW9DLGdDQUxtQztBQU1uQzE0QiwwQkFObUM7QUFPbkMyNEI7QUFQbUMsU0FBaEIsRUFRcEIzNEIsTUFSb0IsQ0FBZCxDQUFUO0FBU0g7QUFDRCxTQUFLLElBQU00NEIsZUFBWCxJQUE2Qk4sWUFBN0IsRUFBMkM7QUFDdkMsWUFBSUUsa0JBQWtCSSxlQUFsQixDQUFKLEVBQXVDO0FBQ25DO0FBQ0g7QUFDRCxZQUFJTixhQUFhTSxlQUFiLEVBQTZCN2dDLFFBQTdCLElBQXlDdWdDLGFBQWFNLGVBQWIsRUFBNkIsU0FBN0IsTUFBNEN6b0MsU0FBckYsSUFBa0c2UCxPQUFPNDRCLGVBQVAsTUFBMkJ6b0MsU0FBakksRUFBNEk7QUFDeEk4VyxtQkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJ3SyxNQUF6QixtQ0FBZ0U0NEIsZUFBaEUsUUFBWjtBQUNIO0FBQ0o7QUFDRCxXQUFPM3hCLE1BQVA7QUFDSDs7QUFFRCxTQUFTK3hCLGFBQVQsQ0FBdUJqMUIsT0FBdkIsRUFBZ0M7QUFDNUIsUUFBTXpFLFFBQVF5RSxRQUFRMUwsS0FBdEI7QUFDQSxRQUFNNGdDLFlBQVlsMUIsUUFBUXcwQixTQUExQjtBQUNBLFFBQU05bkMsUUFBUXNULFFBQVF0VCxLQUF0QjtBQUNBLFFBQU1pb0MsWUFBWTMwQixRQUFRMjBCLFNBQTFCO0FBQ0EsUUFBTWxqQyxNQUFNdU8sUUFBUXZPLEdBQXBCO0FBQ0EsUUFBTTBqQyx1QkFBdUJuMUIsUUFBUW8xQixxQkFBUixJQUFpQ0osUUFBOUQ7QUFDQSxRQUFJN00sUUFBUTVzQixLQUFSLE1BQW1CLE9BQXZCLEVBQWdDO0FBQzVCLGVBQU8sQ0FBQyxJQUFJMDRCLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI4SixLQUF6Qix1QkFBb0Q0c0IsUUFBUTVzQixLQUFSLENBQXBELFlBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBSTI1QixVQUFVenNDLE1BQVYsSUFBb0I4UyxNQUFNOVMsTUFBTixLQUFpQnlzQyxVQUFVenNDLE1BQW5ELEVBQTJEO0FBQ3ZELGVBQU8sQ0FBQyxJQUFJd3JDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI4SixLQUF6QixvQkFBaUQyNUIsVUFBVXpzQyxNQUEzRCwwQkFBd0Y4UyxNQUFNOVMsTUFBOUYsWUFBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJeXNDLFVBQVUsWUFBVixLQUEyQjM1QixNQUFNOVMsTUFBTixHQUFleXNDLFVBQVUsWUFBVixDQUE5QyxFQUF1RTtBQUNuRSxlQUFPLENBQUMsSUFBSWpCLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI4SixLQUF6Qiw2QkFBMEQyNUIsVUFBVSxZQUFWLENBQTFELDBCQUF3RzM1QixNQUFNOVMsTUFBOUcsWUFBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJNHNDLG1CQUFtQjtBQUNuQixnQkFBUUgsVUFBVTVnQyxLQURDO0FBRW5CLGtCQUFVNGdDLFVBQVVqaEMsTUFGRDtBQUduQixtQkFBV2loQyxVQUFVditCLE9BSEY7QUFJbkIsbUJBQVd1K0IsVUFBVXgrQjtBQUpGLEtBQXZCO0FBTUEsUUFBSWkrQixVQUFVN2dDLFFBQVYsR0FBcUIsQ0FBekIsRUFBNEI7QUFDeEJ1aEMseUJBQWlCQyxRQUFqQixHQUE0QkosVUFBVUksUUFBdEM7QUFDSDtBQUNELFFBQUluTixRQUFRK00sVUFBVTVnQyxLQUFsQixNQUE2QixRQUFqQyxFQUEyQztBQUN2QytnQywyQkFBbUJILFVBQVU1Z0MsS0FBN0I7QUFDSDtBQUNELFFBQUk0TyxTQUFTLEVBQWI7QUFDQSxTQUFLLElBQUk5YSxJQUFJLENBQWIsRUFBZ0JBLElBQUltVCxNQUFNOVMsTUFBMUIsRUFBa0NMLEdBQWxDLEVBQXVDO0FBQ25DOGEsaUJBQVNBLE9BQU96RixNQUFQLENBQWMwM0IscUJBQXFCO0FBQ3hDNTVCLHdCQUR3QztBQUV4Q2c2Qix3QkFBWW50QyxDQUY0QjtBQUd4Q2tNLG1CQUFPaUgsTUFBTW5ULENBQU4sQ0FIaUM7QUFJeENvc0MsdUJBQVdhLGdCQUo2QjtBQUt4QzNvQyx3QkFMd0M7QUFNeENpb0MsZ0NBTndDO0FBT3hDbGpDLGlCQUFTQSxHQUFULFNBQWtCckosQ0FBbEI7QUFQd0MsU0FBckIsQ0FBZCxDQUFUO0FBU0g7QUFDRCxXQUFPOGEsTUFBUDtBQUNIOztBQUVELFNBQVNzeUIsY0FBVCxDQUF3QngxQixPQUF4QixFQUFpQztBQUM3QixRQUFNdk8sTUFBTXVPLFFBQVF2TyxHQUFwQjtBQUNBLFFBQU02QyxRQUFRMEwsUUFBUTFMLEtBQXRCO0FBQ0EsUUFBTWtnQyxZQUFZeDBCLFFBQVF3MEIsU0FBMUI7QUFDQSxRQUFJcG5DLE9BQU8rNkIsUUFBUTd6QixLQUFSLENBQVg7QUFDQSxRQUFJbEgsU0FBUyxRQUFULElBQXFCa0gsVUFBVUEsS0FBbkMsRUFBMEM7QUFDdENsSCxlQUFPLEtBQVA7QUFDSDtBQUNELFFBQUlBLFNBQVMsUUFBYixFQUF1QjtBQUNuQixlQUFPLENBQUMsSUFBSTZtQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsd0JBQXFEbEgsSUFBckQsWUFBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJLGFBQWFvbkMsU0FBakIsRUFBNEI7QUFDeEIsWUFBSWlCLFVBQVVqQixVQUFVNzlCLE9BQXhCO0FBQ0EsWUFBSXd4QixRQUFRcU0sVUFBVTc5QixPQUFsQixNQUErQixPQUFuQyxFQUE0QztBQUN4QyxnQkFBTXZPLElBQUk0WCxRQUFRdTFCLFVBQWxCO0FBQ0FFLHNCQUFVakIsVUFBVTc5QixPQUFWLENBQWtCdk8sQ0FBbEIsQ0FBVjtBQUNIO0FBQ0QsWUFBSWtNLFFBQVFtaEMsT0FBWixFQUFxQjtBQUNqQixtQkFBTyxDQUFDLElBQUl4QixlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBb0NBLEtBQXBDLHdDQUE4RW1oQyxPQUE5RSxDQUFELENBQVA7QUFDSDtBQUNKO0FBQ0QsUUFBSSxhQUFhakIsU0FBakIsRUFBNEI7QUFDeEIsWUFBSWtCLFVBQVVsQixVQUFVOTlCLE9BQXhCO0FBQ0EsWUFBSXl4QixRQUFRcU0sVUFBVTk5QixPQUFsQixNQUErQixPQUFuQyxFQUE0QztBQUN4QyxnQkFBTXRPLE1BQUk0WCxRQUFRdTFCLFVBQWxCO0FBQ0FHLHNCQUFVbEIsVUFBVTk5QixPQUFWLENBQWtCdE8sR0FBbEIsQ0FBVjtBQUNIO0FBQ0QsWUFBSWtNLFFBQVFvaEMsT0FBWixFQUFxQjtBQUNqQixtQkFBTyxDQUFDLElBQUl6QixlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBb0NBLEtBQXBDLDJDQUFpRm9oQyxPQUFqRixDQUFELENBQVA7QUFDSDtBQUNKO0FBQ0QsV0FBTyxFQUFQO0FBQ0g7O0FBRUQsU0FBU0MsZ0JBQVQsQ0FBMEIzMUIsT0FBMUIsRUFBbUM7QUFDL0IsUUFBTTQxQixvQkFBb0I1MUIsUUFBUXcwQixTQUFsQztBQUNBLFFBQU1oSSxlQUFlVyxTQUFTbnRCLFFBQVExTCxLQUFSLENBQWNsSCxJQUF2QixDQUFyQjtBQUNBLFFBQUl5b0Msb0JBQUo7QUFDQSxRQUFJQyxtQkFBbUIsRUFBdkI7QUFDQSxRQUFJQyxnQ0FBSjtBQUNBLFFBQUlDLCtCQUFKO0FBQ0EsUUFBTUMsaUJBQWlCekosaUJBQWlCLGFBQWpCLElBQWtDeHNCLFFBQVExTCxLQUFSLENBQWM2SyxRQUFkLEtBQTJCL1MsU0FBcEY7QUFDQSxRQUFNOHBDLHFCQUFxQixDQUFDRCxjQUE1QjtBQUNBLFFBQU1FLDRCQUE0QmhPLFFBQVFub0IsUUFBUTFMLEtBQVIsQ0FBYzlMLEtBQXRCLE1BQWlDLE9BQWpDLElBQTRDMi9CLFFBQVFub0IsUUFBUTFMLEtBQVIsQ0FBYzlMLEtBQWQsQ0FBb0IsQ0FBcEIsQ0FBUixNQUFvQyxPQUFoRixJQUEyRjIvQixRQUFRbm9CLFFBQVExTCxLQUFSLENBQWM5TCxLQUFkLENBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBQVIsTUFBdUMsUUFBcEs7QUFDQSxRQUFNMGEsU0FBU294QixlQUFlO0FBQzFCN2lDLGFBQUt1TyxRQUFRdk8sR0FEYTtBQUUxQjZDLGVBQU8wTCxRQUFRMUwsS0FGVztBQUcxQmtnQyxtQkFBV3gwQixRQUFRMjBCLFNBQVIsQ0FBa0JXLFFBSEg7QUFJMUI1b0MsZUFBT3NULFFBQVF0VCxLQUpXO0FBSzFCaW9DLG1CQUFXMzBCLFFBQVEyMEIsU0FMTztBQU0xQkQsaUNBQXlCO0FBQ3JCbHNDLG1CQUFPNHRDLHFCQURjO0FBRXJCdk4scUJBQVN3TjtBQUZZO0FBTkMsS0FBZixDQUFmO0FBV0EsUUFBSTdKLGlCQUFpQixVQUFqQixJQUErQnlKLGNBQW5DLEVBQW1EO0FBQy9DL3lCLGVBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQ3VPLFFBQVExTCxLQUF6QyxFQUFnRCxzQ0FBaEQsQ0FBWjtBQUNIO0FBQ0QsUUFBSWs0QixpQkFBaUIsVUFBakIsSUFBK0IsQ0FBQ3hzQixRQUFRMUwsS0FBUixDQUFjOUwsS0FBbEQsRUFBeUQ7QUFDckQwYSxlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQmowQixRQUFRdk8sR0FBNUIsRUFBaUN1TyxRQUFRMUwsS0FBekMsRUFBZ0QsbUNBQWhELENBQVo7QUFDSDtBQUNELFFBQUlrNEIsaUJBQWlCLGFBQWpCLElBQWtDeHNCLFFBQVF3MEIsU0FBUixDQUFrQmo4QixVQUFwRCxJQUFrRSxDQUFDMnZCLHNCQUFzQmxvQixRQUFRdzBCLFNBQTlCLENBQXZFLEVBQWlIO0FBQzdHdHhCLGVBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQ3VPLFFBQVExTCxLQUF6QyxFQUFnRCxxQ0FBaEQsQ0FBWjtBQUNIO0FBQ0QsUUFBSTBMLFFBQVEyMEIsU0FBUixDQUFrQjdnQyxRQUFsQixJQUE4QixDQUFsQyxFQUFxQztBQUNqQyxZQUFJb2lDLHNCQUFzQixDQUFDbk8sMkJBQTJCL25CLFFBQVF3MEIsU0FBbkMsQ0FBM0IsRUFBMEU7QUFDdEV0eEIsbUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQ3VPLFFBQVExTCxLQUF6QyxFQUFnRCxrQ0FBaEQsQ0FBWjtBQUNILFNBRkQsTUFFTyxJQUFJMmhDLGtCQUFrQixDQUFDaE8sdUJBQXVCam9CLFFBQVF3MEIsU0FBL0IsQ0FBdkIsRUFBa0U7QUFDckV0eEIsbUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQ3VPLFFBQVExTCxLQUF6QyxFQUFnRCw4QkFBaEQsQ0FBWjtBQUNIO0FBQ0o7QUFDRCxRQUFJLENBQUNrNEIsaUJBQWlCLGFBQWpCLElBQWtDMkoseUJBQW5DLEtBQWlFbjJCLFFBQVExTCxLQUFSLENBQWM2SyxRQUFkLEtBQTJCL1MsU0FBaEcsRUFBMkc7QUFDdkc4VyxlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQmowQixRQUFRdk8sR0FBNUIsRUFBaUN1TyxRQUFRMUwsS0FBekMsRUFBZ0QsaUNBQWhELENBQVo7QUFDSDtBQUNELFdBQU80TyxNQUFQO0FBQ0EsYUFBU2t6QixxQkFBVCxDQUErQnAyQixPQUEvQixFQUF3QztBQUNwQyxZQUFJd3NCLGlCQUFpQixVQUFyQixFQUFpQztBQUM3QixtQkFBTyxDQUFDLElBQUl5SCxlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQ3VPLFFBQVExTCxLQUF6QyxFQUFnRCxtREFBaEQsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxZQUFJNE8sU0FBUyxFQUFiO0FBQ0EsWUFBTTVPLFFBQVEwTCxRQUFRMUwsS0FBdEI7QUFDQTRPLGlCQUFTQSxPQUFPekYsTUFBUCxDQUFjdzNCLGNBQWM7QUFDakN4akMsaUJBQUt1TyxRQUFRdk8sR0FEb0I7QUFFakM2Qyx3QkFGaUM7QUFHakNrZ0MsdUJBQVd4MEIsUUFBUXcwQixTQUhjO0FBSWpDOW5DLG1CQUFPc1QsUUFBUXRULEtBSmtCO0FBS2pDaW9DLHVCQUFXMzBCLFFBQVEyMEIsU0FMYztBQU1qQ1MsbUNBQXVCa0I7QUFOVSxTQUFkLENBQWQsQ0FBVDtBQVFBLFlBQUluTyxRQUFRN3pCLEtBQVIsTUFBbUIsT0FBbkIsSUFBOEJBLE1BQU03TCxNQUFOLEtBQWlCLENBQW5ELEVBQXNEO0FBQ2xEeWEsbUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQzZDLEtBQWpDLEVBQXdDLG1DQUF4QyxDQUFaO0FBQ0g7QUFDRCxlQUFPNE8sTUFBUDtBQUNIO0FBQ0QsYUFBU296QixvQkFBVCxDQUE4QnQyQixPQUE5QixFQUF1QztBQUNuQyxZQUFJa0QsU0FBUyxFQUFiO0FBQ0EsWUFBTTVPLFFBQVEwTCxRQUFRMUwsS0FBdEI7QUFDQSxZQUFNN0MsTUFBTXVPLFFBQVF2TyxHQUFwQjtBQUNBLFlBQUkwMkIsUUFBUTd6QixLQUFSLE1BQW1CLE9BQXZCLEVBQWdDO0FBQzVCLG1CQUFPLENBQUMsSUFBSTIvQixlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsdUJBQW9ENnpCLFFBQVE3ekIsS0FBUixDQUFwRCxZQUFELENBQVA7QUFDSDtBQUNELFlBQUlBLE1BQU03TCxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLG1CQUFPLENBQUMsSUFBSXdyQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsdUNBQW9FQSxNQUFNN0wsTUFBMUUsWUFBRCxDQUFQO0FBQ0g7QUFDRCxZQUFJMHRDLHlCQUFKLEVBQStCO0FBQzNCLGdCQUFJaE8sUUFBUTd6QixNQUFNLENBQU4sQ0FBUixNQUFzQixRQUExQixFQUFvQztBQUNoQyx1QkFBTyxDQUFDLElBQUkyL0IsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLHdCQUFxRDZ6QixRQUFRN3pCLE1BQU0sQ0FBTixDQUFSLENBQXJELFlBQUQsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUlBLE1BQU0sQ0FBTixFQUFTN0csSUFBVCxLQUFrQnJCLFNBQXRCLEVBQWlDO0FBQzdCLHVCQUFPLENBQUMsSUFBSTZuQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MsZ0NBQWhDLENBQUQsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUlBLE1BQU0sQ0FBTixFQUFTQSxLQUFULEtBQW1CbEksU0FBdkIsRUFBa0M7QUFDOUIsdUJBQU8sQ0FBQyxJQUFJNm5DLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyxpQ0FBaEMsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxnQkFBSTBoQywwQkFBMEJBLHlCQUF5QjdJLFNBQVM3NEIsTUFBTSxDQUFOLEVBQVM3RyxJQUFsQixDQUF2RCxFQUFnRjtBQUM1RSx1QkFBTyxDQUFDLElBQUl3bUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLE1BQU0sQ0FBTixFQUFTN0csSUFBbEMsRUFBd0MsaURBQXhDLENBQUQsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUkwL0IsU0FBUzc0QixNQUFNLENBQU4sRUFBUzdHLElBQWxCLE1BQTRCdW9DLHNCQUFoQyxFQUF3RDtBQUNwREEseUNBQXlCN0ksU0FBUzc0QixNQUFNLENBQU4sRUFBUzdHLElBQWxCLENBQXpCO0FBQ0Fzb0MsMENBQTBCM3BDLFNBQTFCO0FBQ0EwcEMsbUNBQW1CLEVBQW5CO0FBQ0g7QUFDRDV5QixxQkFBU0EsT0FBT3pGLE1BQVAsQ0FBYzYyQixlQUFlO0FBQ2xDN2lDLHFCQUFTQSxHQUFULFFBRGtDO0FBRWxDNkMsdUJBQU9BLE1BQU0sQ0FBTixDQUYyQjtBQUdsQ2tnQywyQkFBVyxFQUFFL21DLE1BQU0sRUFBUixFQUh1QjtBQUlsQ2YsdUJBQU9zVCxRQUFRdFQsS0FKbUI7QUFLbENpb0MsMkJBQVczMEIsUUFBUTIwQixTQUxlO0FBTWxDRCx5Q0FBeUI7QUFDckJqbkMsMEJBQU0rbkMsY0FEZTtBQUVyQmxoQywyQkFBT2lpQztBQUZjO0FBTlMsYUFBZixDQUFkLENBQVQ7QUFXSCxTQTdCRCxNQTZCTztBQUNIcnpCLHFCQUFTQSxPQUFPekYsTUFBUCxDQUFjODRCLHdCQUF3QjtBQUMzQzlrQyxxQkFBU0EsR0FBVCxRQUQyQztBQUUzQzZDLHVCQUFPQSxNQUFNLENBQU4sQ0FGb0M7QUFHM0NrZ0MsMkJBQVcsRUFIZ0M7QUFJM0M5bkMsdUJBQU9zVCxRQUFRdFQsS0FKNEI7QUFLM0Npb0MsMkJBQVczMEIsUUFBUTIwQjtBQUx3QixhQUF4QixFQU1wQnJnQyxLQU5vQixDQUFkLENBQVQ7QUFPSDtBQUNELFlBQUlrMkIsYUFBYTZDLGFBQWEvNEIsTUFBTSxDQUFOLENBQWIsQ0FBYixDQUFKLEVBQTBDO0FBQ3RDLG1CQUFPNE8sT0FBT3pGLE1BQVAsQ0FBYyxDQUFDLElBQUl3MkIsZUFBSixDQUF3QnhpQyxHQUF4QixVQUFtQzZDLE1BQU0sQ0FBTixDQUFuQyxFQUE2QyxnREFBN0MsQ0FBRCxDQUFkLENBQVA7QUFDSDtBQUNELGVBQU80TyxPQUFPekYsTUFBUCxDQUFjdTNCLFNBQVM7QUFDMUJ2akMsaUJBQVNBLEdBQVQsUUFEMEI7QUFFMUI2QyxtQkFBT0EsTUFBTSxDQUFOLENBRm1CO0FBRzFCa2dDLHVCQUFXb0IsaUJBSGU7QUFJMUJscEMsbUJBQU9zVCxRQUFRdFQsS0FKVztBQUsxQmlvQyx1QkFBVzMwQixRQUFRMjBCO0FBTE8sU0FBVCxDQUFkLENBQVA7QUFPSDtBQUNELGFBQVM0Qix1QkFBVCxDQUFpQ3YyQixPQUFqQyxFQUEwQzBPLElBQTFDLEVBQWdEO0FBQzVDLFlBQU10aEIsT0FBTys2QixRQUFRbm9CLFFBQVExTCxLQUFoQixDQUFiO0FBQ0EsWUFBTUEsUUFBUTY0QixTQUFTbnRCLFFBQVExTCxLQUFqQixDQUFkO0FBQ0EsWUFBTWtpQyxjQUFjeDJCLFFBQVExTCxLQUFSLEtBQWtCLElBQWxCLEdBQXlCMEwsUUFBUTFMLEtBQWpDLEdBQXlDb2EsSUFBN0Q7QUFDQSxZQUFJLENBQUNtbkIsV0FBTCxFQUFrQjtBQUNkQSwwQkFBY3pvQyxJQUFkO0FBQ0gsU0FGRCxNQUVPLElBQUlBLFNBQVN5b0MsV0FBYixFQUEwQjtBQUM3QixtQkFBTyxDQUFDLElBQUk1QixlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQytrQyxXQUFqQyxFQUFrRHBwQyxJQUFsRCwrREFBa0h5b0MsV0FBbEgsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxZQUFJem9DLFNBQVMsUUFBVCxJQUFxQkEsU0FBUyxRQUE5QixJQUEwQ0EsU0FBUyxTQUF2RCxFQUFrRTtBQUM5RCxtQkFBTyxDQUFDLElBQUk2bUMsZUFBSixDQUFvQmowQixRQUFRdk8sR0FBNUIsRUFBaUMra0MsV0FBakMsRUFBOEMsd0RBQTlDLENBQUQsQ0FBUDtBQUNIO0FBQ0QsWUFBSXBwQyxTQUFTLFFBQVQsSUFBcUJvL0IsaUJBQWlCLGFBQTFDLEVBQXlEO0FBQ3JELGdCQUFJbmQsZ0NBQStCamlCLElBQS9CLFdBQUo7QUFDQSxnQkFBSTI2QiwyQkFBMkI2TixpQkFBM0IsS0FBaURwSixpQkFBaUJwZ0MsU0FBdEUsRUFBaUY7QUFDN0VpakIsMkJBQVcsbUZBQVg7QUFDSDtBQUNELG1CQUFPLENBQUMsSUFBSTRrQixlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQytrQyxXQUFqQyxFQUE4Q25uQixPQUE5QyxDQUFELENBQVA7QUFDSDtBQUNELFlBQUltZCxpQkFBaUIsYUFBakIsSUFBa0NwL0IsU0FBUyxRQUEzQyxLQUF3RCxDQUFDeWEsU0FBU3ZULEtBQVQsQ0FBRCxJQUFvQjhPLEtBQUsvRixLQUFMLENBQVcvSSxLQUFYLE1BQXNCQSxLQUFsRyxDQUFKLEVBQThHO0FBQzFHLG1CQUFPLENBQUMsSUFBSTIvQixlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQytrQyxXQUFqQywrQkFBMEVsaUMsS0FBMUUsQ0FBRCxDQUFQO0FBQ0g7QUFDRCxZQUFJazRCLGlCQUFpQixhQUFqQixJQUFrQ3AvQixTQUFTLFFBQTNDLElBQXVEMm9DLDRCQUE0QjNwQyxTQUFuRixJQUFnR2tJLFFBQVF5aEMsdUJBQTVHLEVBQXFJO0FBQ2pJLG1CQUFPLENBQUMsSUFBSTlCLGVBQUosQ0FBb0JqMEIsUUFBUXZPLEdBQTVCLEVBQWlDK2tDLFdBQWpDLEVBQThDLG1EQUE5QyxDQUFELENBQVA7QUFDSCxTQUZELE1BRU87QUFDSFQsc0NBQTBCemhDLEtBQTFCO0FBQ0g7QUFDRCxZQUFJazRCLGlCQUFpQixhQUFqQixJQUFrQ2w0QixTQUFTd2hDLGdCQUEvQyxFQUFpRTtBQUM3RCxtQkFBTyxDQUFDLElBQUk3QixlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQytrQyxXQUFqQyxFQUE4QyxtQ0FBOUMsQ0FBRCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0hWLDZCQUFpQnhoQyxLQUFqQixJQUEwQixJQUExQjtBQUNIO0FBQ0QsZUFBTyxFQUFQO0FBQ0g7QUFDRCxhQUFTK2hDLHVCQUFULENBQWlDcjJCLE9BQWpDLEVBQTBDO0FBQ3RDLGVBQU9nMUIsU0FBUztBQUNadmpDLGlCQUFLdU8sUUFBUXZPLEdBREQ7QUFFWjZDLG1CQUFPMEwsUUFBUTFMLEtBRkg7QUFHWmtnQyx1QkFBV29CLGlCQUhDO0FBSVpscEMsbUJBQU9zVCxRQUFRdFQsS0FKSDtBQUtaaW9DLHVCQUFXMzBCLFFBQVEyMEI7QUFMUCxTQUFULENBQVA7QUFPSDtBQUNKOztBQUVELFNBQVM4QixrQkFBVCxDQUE0QnoyQixPQUE1QixFQUFxQztBQUNqQyxRQUFNekgsYUFBYSxDQUFDeUgsUUFBUTAyQixpQkFBUixLQUE4QixVQUE5QixHQUEyQ3pMLHdCQUEzQyxHQUFzRVIsZ0JBQXZFLEVBQXlGNEMsYUFBYXJ0QixRQUFRMUwsS0FBckIsQ0FBekYsRUFBc0gwTCxRQUFRdzBCLFNBQTlILENBQW5CO0FBQ0EsUUFBSWo4QixXQUFXK0ksTUFBWCxLQUFzQixPQUExQixFQUFtQztBQUMvQixlQUFPL0ksV0FBV2pFLEtBQVgsQ0FBaUJ4TCxHQUFqQixDQUFxQixpQkFBUztBQUNqQyxtQkFBTyxJQUFJbXJDLGVBQUosTUFBd0JqMEIsUUFBUXZPLEdBQWhDLEdBQXdDaEYsTUFBTWdGLEdBQTlDLEVBQXNEdU8sUUFBUTFMLEtBQTlELEVBQXFFN0gsTUFBTTRpQixPQUEzRSxDQUFQO0FBQ0gsU0FGTSxDQUFQO0FBR0g7QUFDRCxRQUFNc25CLGdCQUFnQnArQixXQUFXakUsS0FBWCxDQUFpQmlFLFVBQWpCLElBQStCQSxXQUFXakUsS0FBWCxDQUFpQnUyQixnQkFBakIsQ0FBa0N0eUIsVUFBdkY7QUFDQSxRQUFJeUgsUUFBUTAyQixpQkFBUixLQUE4QixVQUE5QixJQUE0QzEyQixRQUFRNDJCLFdBQVIsS0FBd0IsV0FBcEUsSUFBbUYsQ0FBQ0QsY0FBY3RoQixhQUFkLEVBQXhGLEVBQXVIO0FBQ25ILGVBQU8sQ0FBQyxJQUFJNGUsZUFBSixDQUFvQmowQixRQUFRdk8sR0FBNUIsRUFBaUN1TyxRQUFRMUwsS0FBekMscUNBQWlGMEwsUUFBUTQyQixXQUF6Riw0RUFBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJNTJCLFFBQVEwMkIsaUJBQVIsS0FBOEIsVUFBOUIsSUFBNEMxMkIsUUFBUTZOLFlBQVIsS0FBeUIsUUFBckUsSUFBaUYsQ0FBQzJQLGdCQUFnQm1aLGFBQWhCLENBQXRGLEVBQXNIO0FBQ2xILGVBQU8sQ0FBQyxJQUFJMUMsZUFBSixDQUFvQmowQixRQUFRdk8sR0FBNUIsRUFBaUN1TyxRQUFRMUwsS0FBekMsRUFBZ0QsNEVBQWhELENBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBSTBMLFFBQVEwMkIsaUJBQVIsS0FBOEIsUUFBbEMsRUFBNEM7QUFDeEMsZUFBT0csMkJBQTJCRixhQUEzQixFQUEwQzMyQixPQUExQyxDQUFQO0FBQ0g7QUFDRCxRQUFJQSxRQUFRMDJCLGlCQUFSLElBQTZCMTJCLFFBQVEwMkIsaUJBQVIsQ0FBMEJ2dEMsT0FBMUIsQ0FBa0MsU0FBbEMsTUFBaUQsQ0FBbEYsRUFBcUY7QUFDakYsWUFBSSxDQUFDczBCLHlCQUF5QmtaLGFBQXpCLEVBQXdDLENBQ3JDLE1BRHFDLEVBRXJDLGVBRnFDLENBQXhDLENBQUwsRUFHUTtBQUNKLG1CQUFPLENBQUMsSUFBSTFDLGVBQUosQ0FBb0JqMEIsUUFBUXZPLEdBQTVCLEVBQWlDdU8sUUFBUTFMLEtBQXpDLEVBQWdELG1GQUFoRCxDQUFELENBQVA7QUFDSDtBQUNELFlBQUkwTCxRQUFRMDJCLGlCQUFSLEtBQThCLGlCQUE5QixJQUFtRCxDQUFDblosa0JBQWtCb1osYUFBbEIsQ0FBeEQsRUFBMEY7QUFDdEYsbUJBQU8sQ0FBQyxJQUFJMUMsZUFBSixDQUFvQmowQixRQUFRdk8sR0FBNUIsRUFBaUN1TyxRQUFRMUwsS0FBekMsRUFBZ0QsZ0dBQWhELENBQUQsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLEVBQVA7QUFDSDtBQUNELFNBQVN1aUMsMEJBQVQsQ0FBb0M3cEMsQ0FBcEMsRUFBdUNnVCxPQUF2QyxFQUFnRDtBQUM1QyxRQUFNODJCLHVCQUF1QixJQUFJN0gsR0FBSixDQUFRLENBQ2pDLE1BRGlDLEVBRWpDLGVBRmlDLEVBR2pDLE9BSGlDLEVBSWpDLHNCQUppQyxDQUFSLENBQTdCO0FBRDRDO0FBQUE7QUFBQTs7QUFBQTtBQU81QywrQkFBb0JqdkIsUUFBUXcwQixTQUFSLENBQWtCajhCLFVBQWxCLENBQTZCRSxVQUFqRCx3SUFBNkQ7QUFBQSxnQkFBbER5MkIsS0FBa0Q7O0FBQ3pENEgsaUNBQXFCQyxNQUFyQixDQUE0QjdILEtBQTVCO0FBQ0g7QUFUMkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVNUMsUUFBSTRILHFCQUFxQnpuQyxJQUFyQixLQUE4QixDQUFsQyxFQUFxQztBQUNqQyxlQUFPLEVBQVA7QUFDSDtBQUNELFFBQU02VCxTQUFTLEVBQWY7QUFDQSxRQUFJbFcsYUFBYTZxQixrQkFBakIsRUFBcUM7QUFDakMsWUFBSWlmLHFCQUFxQmo4QixHQUFyQixDQUF5QjdOLEVBQUVvSCxJQUEzQixDQUFKLEVBQXNDO0FBQ2xDLG1CQUFPLENBQUMsSUFBSTYvQixlQUFKLENBQW9CajBCLFFBQVF2TyxHQUE1QixFQUFpQ3VPLFFBQVExTCxLQUF6QyxVQUFzRHRILEVBQUVvSCxJQUF4RCwwREFBa0g0TCxRQUFRL0QsTUFBUixDQUFlN08sSUFBakksd0JBQTBKNFMsUUFBUS9ELE1BQVIsQ0FBZWxQLEVBQXpLLENBQUQsQ0FBUDtBQUNIO0FBQ0o7QUFDREMsTUFBRXlwQixTQUFGLENBQVksZUFBTztBQUNmdlQsZUFBTzlaLElBQVAsa0NBQWV5dEMsMkJBQTJCcHdCLEdBQTNCLEVBQWdDekcsT0FBaEMsQ0FBZjtBQUNILEtBRkQ7QUFHQSxXQUFPa0QsTUFBUDtBQUNIOztBQUVELFNBQVM4ekIsZUFBVCxDQUF5QmgzQixPQUF6QixFQUFrQztBQUM5QixRQUFNMUwsUUFBUTBMLFFBQVExTCxLQUF0QjtBQUNBLFFBQU03QyxNQUFNdU8sUUFBUXZPLEdBQXBCO0FBQ0EsUUFBTXJFLE9BQU8rNkIsUUFBUTd6QixLQUFSLENBQWI7QUFDQSxRQUFJbEgsU0FBUyxTQUFiLEVBQXdCO0FBQ3BCLGVBQU8sQ0FBQyxJQUFJNm1DLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6Qix5QkFBc0RsSCxJQUF0RCxZQUFELENBQVA7QUFDSDtBQUNELFdBQU8sRUFBUDtBQUNIOztBQUVELFNBQVM2cEMsYUFBVCxDQUF1QmozQixPQUF2QixFQUFnQztBQUM1QixRQUFNdk8sTUFBTXVPLFFBQVF2TyxHQUFwQjtBQUNBLFFBQU02QyxRQUFRMEwsUUFBUTFMLEtBQXRCO0FBQ0EsUUFBTWxILE9BQU8rNkIsUUFBUTd6QixLQUFSLENBQWI7QUFDQSxRQUFJbEgsU0FBUyxRQUFiLEVBQXVCO0FBQ25CLGVBQU8sQ0FBQyxJQUFJNm1DLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6Qix1QkFBb0RsSCxJQUFwRCxZQUFELENBQVA7QUFDSDtBQUNELFFBQUkyakIsZUFBZWEsYUFBZixDQUE2QnRkLEtBQTdCLE1BQXdDLElBQTVDLEVBQWtEO0FBQzlDLGVBQU8sQ0FBQyxJQUFJMi9CLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6Qix5QkFBcURBLEtBQXJELGNBQUQsQ0FBUDtBQUNIO0FBQ0QsV0FBTyxFQUFQO0FBQ0g7O0FBRUQsU0FBUzRpQyxZQUFULENBQXNCbDNCLE9BQXRCLEVBQStCO0FBQzNCLFFBQU12TyxNQUFNdU8sUUFBUXZPLEdBQXBCO0FBQ0EsUUFBTTZDLFFBQVEwTCxRQUFRMUwsS0FBdEI7QUFDQSxRQUFNa2dDLFlBQVl4MEIsUUFBUXcwQixTQUExQjtBQUNBLFFBQU10eEIsU0FBUyxFQUFmO0FBQ0EsUUFBSTVhLE1BQU1DLE9BQU4sQ0FBY2lzQyxVQUFVdmdDLE1BQXhCLENBQUosRUFBcUM7QUFDakMsWUFBSXVnQyxVQUFVdmdDLE1BQVYsQ0FBaUI5SyxPQUFqQixDQUF5QmdrQyxTQUFTNzRCLEtBQVQsQ0FBekIsTUFBOEMsQ0FBQyxDQUFuRCxFQUFzRDtBQUNsRDRPLG1CQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLHdCQUFxRGtnQyxVQUFVdmdDLE1BQVYsQ0FBaUJULElBQWpCLENBQXNCLElBQXRCLENBQXJELFdBQXdGeEksS0FBSzhVLFNBQUwsQ0FBZXhMLEtBQWYsQ0FBeEYsWUFBWjtBQUNIO0FBQ0osS0FKRCxNQUlPO0FBQ0gsWUFBSTZNLE9BQU9OLElBQVAsQ0FBWTJ6QixVQUFVdmdDLE1BQXRCLEVBQThCOUssT0FBOUIsQ0FBc0Nna0MsU0FBUzc0QixLQUFULENBQXRDLE1BQTJELENBQUMsQ0FBaEUsRUFBbUU7QUFDL0Q0TyxtQkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6Qix3QkFBcUQ2TSxPQUFPTixJQUFQLENBQVkyekIsVUFBVXZnQyxNQUF0QixFQUE4QlQsSUFBOUIsQ0FBbUMsSUFBbkMsQ0FBckQsV0FBcUd4SSxLQUFLOFUsU0FBTCxDQUFleEwsS0FBZixDQUFyRyxZQUFaO0FBQ0g7QUFDSjtBQUNELFdBQU80TyxNQUFQO0FBQ0g7O0FBRUQsU0FBU2kwQixjQUFULENBQXdCbjNCLE9BQXhCLEVBQWlDO0FBQzdCLFFBQUl1dEIsbUJBQW1CRixhQUFhcnRCLFFBQVExTCxLQUFyQixDQUFuQixDQUFKLEVBQXFEO0FBQ2pELFlBQU1tNUIsWUFBWUosYUFBYXJ0QixRQUFReXRCLFNBQXJCLENBQWxCO0FBQ0EsZUFBT2dKLG1CQUFtQnZuQixPQUFPLEVBQVAsRUFBV2xQLE9BQVgsRUFBb0I7QUFDMUMwMkIsK0JBQW1CLFFBRHVCO0FBRTFDbEMsdUJBQVd4MEIsUUFBUTIwQixTQUFSLGNBQTZCbEgsYUFBYSxNQUExQztBQUYrQixTQUFwQixDQUFuQixDQUFQO0FBSUgsS0FORCxNQU1PO0FBQ0gsZUFBTzJKLDRCQUE0QnAzQixPQUE1QixDQUFQO0FBQ0g7QUFDSjtBQUNELFNBQVNvM0IsMkJBQVQsQ0FBcUNwM0IsT0FBckMsRUFBOEM7QUFDMUMsUUFBTTFMLFFBQVEwTCxRQUFRMUwsS0FBdEI7QUFDQSxRQUFNN0MsTUFBTXVPLFFBQVF2TyxHQUFwQjtBQUNBLFFBQUkwMkIsUUFBUTd6QixLQUFSLE1BQW1CLE9BQXZCLEVBQWdDO0FBQzVCLGVBQU8sQ0FBQyxJQUFJMi9CLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6Qix1QkFBb0Q2ekIsUUFBUTd6QixLQUFSLENBQXBELFlBQUQsQ0FBUDtBQUNIO0FBQ0QsUUFBTXFnQyxZQUFZMzBCLFFBQVEyMEIsU0FBMUI7QUFDQSxRQUFJdm5DLGFBQUo7QUFDQSxRQUFJOFYsU0FBUyxFQUFiO0FBQ0EsUUFBSTVPLE1BQU03TCxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsZUFBTyxDQUFDLElBQUl3ckMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLDJDQUFoQyxDQUFELENBQVA7QUFDSDtBQUNENE8sYUFBU0EsT0FBT3pGLE1BQVAsQ0FBY3k1QixhQUFhO0FBQ2hDemxDLGFBQVNBLEdBQVQsUUFEZ0M7QUFFaEM2QyxlQUFPQSxNQUFNLENBQU4sQ0FGeUI7QUFHaENrZ0MsbUJBQVdHLFVBQVVqNkIsZUFIVztBQUloQ2hPLGVBQU9zVCxRQUFRdFQsS0FKaUI7QUFLaENpb0MsbUJBQVczMEIsUUFBUTIwQjtBQUxhLEtBQWIsQ0FBZCxDQUFUO0FBT0EsWUFBUXhILFNBQVM3NEIsTUFBTSxDQUFOLENBQVQsQ0FBUjtBQUNBLGFBQUssR0FBTDtBQUNBLGFBQUssSUFBTDtBQUNBLGFBQUssR0FBTDtBQUNBLGFBQUssSUFBTDtBQUNJLGdCQUFJQSxNQUFNN0wsTUFBTixJQUFnQixDQUFoQixJQUFxQjBrQyxTQUFTNzRCLE1BQU0sQ0FBTixDQUFULE1BQXVCLE9BQWhELEVBQXlEO0FBQ3JENE8sdUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsK0NBQXlFQSxNQUFNLENBQU4sQ0FBekUsUUFBWjtBQUNIO0FBQ0wsYUFBSyxJQUFMO0FBQ0EsYUFBSyxJQUFMO0FBQ0ksZ0JBQUlBLE1BQU03TCxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3BCeWEsdUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsbUNBQStEQSxNQUFNLENBQU4sQ0FBL0QsNkJBQVo7QUFDSDtBQUNMLGFBQUssSUFBTDtBQUNBLGFBQUssS0FBTDtBQUNJLGdCQUFJQSxNQUFNN0wsTUFBTixJQUFnQixDQUFwQixFQUF1QjtBQUNuQjJFLHVCQUFPKzZCLFFBQVE3ekIsTUFBTSxDQUFOLENBQVIsQ0FBUDtBQUNBLG9CQUFJbEgsU0FBUyxRQUFiLEVBQXVCO0FBQ25COFYsMkJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQXdCeGlDLEdBQXhCLFVBQW1DNkMsTUFBTSxDQUFOLENBQW5DLHdCQUFrRWxILElBQWxFLFlBQVo7QUFDSDtBQUNKO0FBQ0QsaUJBQUssSUFBSWhGLElBQUksQ0FBYixFQUFnQkEsSUFBSWtNLE1BQU03TCxNQUExQixFQUFrQ0wsR0FBbEMsRUFBdUM7QUFDbkNnRix1QkFBTys2QixRQUFRN3pCLE1BQU1sTSxDQUFOLENBQVIsQ0FBUDtBQUNBLG9CQUFJK2tDLFNBQVM3NEIsTUFBTSxDQUFOLENBQVQsTUFBdUIsT0FBM0IsRUFBb0M7QUFDaEM0Tyw2QkFBU0EsT0FBT3pGLE1BQVAsQ0FBY3k1QixhQUFhO0FBQ2hDemxDLDZCQUFTQSxHQUFULFNBQWtCckosQ0FBbEIsTUFEZ0M7QUFFaENrTSwrQkFBT0EsTUFBTWxNLENBQU4sQ0FGeUI7QUFHaENvc0MsbUNBQVdHLFVBQVU1NUIsYUFIVztBQUloQ3JPLCtCQUFPc1QsUUFBUXRULEtBSmlCO0FBS2hDaW9DLG1DQUFXMzBCLFFBQVEyMEI7QUFMYSxxQkFBYixDQUFkLENBQVQ7QUFPSCxpQkFSRCxNQVFPLElBQUl2bkMsU0FBUyxRQUFULElBQXFCQSxTQUFTLFFBQTlCLElBQTBDQSxTQUFTLFNBQXZELEVBQWtFO0FBQ3JFOFYsMkJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQXdCeGlDLEdBQXhCLFNBQWlDckosQ0FBakMsUUFBd0NrTSxNQUFNbE0sQ0FBTixDQUF4Qyw0Q0FBMkZnRixJQUEzRixZQUFaO0FBQ0g7QUFDSjtBQUNEO0FBQ0osYUFBSyxLQUFMO0FBQ0EsYUFBSyxLQUFMO0FBQ0EsYUFBSyxNQUFMO0FBQ0ksaUJBQUssSUFBSWhGLE9BQUksQ0FBYixFQUFnQkEsT0FBSWtNLE1BQU03TCxNQUExQixFQUFrQ0wsTUFBbEMsRUFBdUM7QUFDbkM4YSx5QkFBU0EsT0FBT3pGLE1BQVAsQ0FBYzI1Qiw0QkFBNEI7QUFDL0MzbEMseUJBQVNBLEdBQVQsU0FBa0JySixJQUFsQixNQUQrQztBQUUvQ2tNLDJCQUFPQSxNQUFNbE0sSUFBTixDQUZ3QztBQUcvQ3NFLDJCQUFPc1QsUUFBUXRULEtBSGdDO0FBSS9DaW9DLCtCQUFXMzBCLFFBQVEyMEI7QUFKNEIsaUJBQTVCLENBQWQsQ0FBVDtBQU1IO0FBQ0Q7QUFDSixhQUFLLEtBQUw7QUFDQSxhQUFLLE1BQUw7QUFDSXZuQyxtQkFBTys2QixRQUFRN3pCLE1BQU0sQ0FBTixDQUFSLENBQVA7QUFDQSxnQkFBSUEsTUFBTTdMLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDcEJ5YSx1QkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6QiwwQkFBc0RBLE1BQU0sQ0FBTixDQUF0RCxzQ0FBWjtBQUNILGFBRkQsTUFFTyxJQUFJbEgsU0FBUyxRQUFiLEVBQXVCO0FBQzFCOFYsdUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQXdCeGlDLEdBQXhCLFVBQW1DNkMsTUFBTSxDQUFOLENBQW5DLHdCQUFrRWxILElBQWxFLFlBQVo7QUFDSDtBQUNEO0FBQ0osYUFBSyxRQUFMO0FBQ0lBLG1CQUFPKzZCLFFBQVE3ekIsTUFBTSxDQUFOLENBQVIsQ0FBUDtBQUNBLGdCQUFJQSxNQUFNN0wsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUNwQnlhLHVCQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLDBCQUFzREEsTUFBTSxDQUFOLENBQXRELHNDQUFaO0FBQ0gsYUFGRCxNQUVPLElBQUlsSCxTQUFTLFFBQWIsRUFBdUI7QUFDMUI4Vix1QkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBd0J4aUMsR0FBeEIsVUFBbUM2QyxNQUFNLENBQU4sQ0FBbkMsd0JBQWtFbEgsSUFBbEUsWUFBWjtBQUNIO0FBQ0Q7QUFoRUo7QUFrRUEsV0FBTzhWLE1BQVA7QUFDSDs7QUFFRCxTQUFTbTBCLGdCQUFULENBQTBCcjNCLE9BQTFCLEVBQW1DNk4sWUFBbkMsRUFBaUQ7QUFDN0MsUUFBTXBjLE1BQU11TyxRQUFRdk8sR0FBcEI7QUFDQSxRQUFNL0UsUUFBUXNULFFBQVF0VCxLQUF0QjtBQUNBLFFBQU1pb0MsWUFBWTMwQixRQUFRMjBCLFNBQTFCO0FBQ0EsUUFBTXJnQyxRQUFRMEwsUUFBUTFMLEtBQXRCO0FBQ0EsUUFBTXNpQyxjQUFjNTJCLFFBQVE0MEIsU0FBNUI7QUFDQSxRQUFNMEMsWUFBWTNDLFVBQWM5bUIsWUFBZCxTQUFnQzdOLFFBQVF5dEIsU0FBeEMsQ0FBbEI7QUFDQSxRQUFJLENBQUM2SixTQUFMLEVBQ0ksT0FBTyxFQUFQO0FBQ0osUUFBTUMsa0JBQWtCWCxZQUFZbnNDLEtBQVosQ0FBa0IsbUJBQWxCLENBQXhCO0FBQ0EsUUFBSW9qQixpQkFBaUIsT0FBakIsSUFBNEIwcEIsZUFBNUIsSUFBK0NELFVBQVVDLGdCQUFnQixDQUFoQixDQUFWLENBQS9DLElBQWdGRCxVQUFVQyxnQkFBZ0IsQ0FBaEIsQ0FBVixFQUE4QnJpQyxVQUFsSCxFQUE4SDtBQUMxSCxlQUFPOC9CLFNBQVM7QUFDWnZqQyxvQkFEWTtBQUVaNkMsd0JBRlk7QUFHWmtnQyx1QkFBV0csVUFBVXovQixVQUhUO0FBSVp4SSx3QkFKWTtBQUtaaW9DO0FBTFksU0FBVCxDQUFQO0FBT0g7QUFDRCxRQUFNSCxZQUFZeDBCLFFBQVF3MEIsU0FBUixJQUFxQjhDLFVBQVVWLFdBQVYsQ0FBdkM7QUFDQSxRQUFJLENBQUNwQyxTQUFMLEVBQWdCO0FBQ1osZUFBTyxDQUFDLElBQUlQLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6QiwwQkFBc0RzaUMsV0FBdEQsUUFBRCxDQUFQO0FBQ0g7QUFDRCxRQUFJWSxtQkFBSjtBQUNBLFFBQUlyUCxRQUFRN3pCLEtBQVIsTUFBbUIsUUFBbkIsSUFBK0J5ekIsMkJBQTJCeU0sU0FBM0IsQ0FBL0IsSUFBd0UsQ0FBQ0EsVUFBVTk2QixNQUFuRixLQUE4Rjg5QixhQUFhLGNBQWM5c0IsSUFBZCxDQUFtQnBXLEtBQW5CLENBQTNHLENBQUosRUFBMkk7QUFDdkksZUFBTyxDQUFDLElBQUkyL0IsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLE9BQUtzaUMsV0FBTCw0SUFBa0o1ckMsS0FBSzhVLFNBQUwsQ0FBZTAzQixXQUFXLENBQVgsQ0FBZixDQUFsSixVQUFoQyxDQUFELENBQVA7QUFDSDtBQUNELFFBQU10MEIsU0FBUyxFQUFmO0FBQ0EsUUFBSWxELFFBQVF5dEIsU0FBUixLQUFzQixRQUExQixFQUFvQztBQUNoQyxZQUFJbUosZ0JBQWdCLFlBQWhCLElBQWdDbHFDLEtBQWhDLElBQXlDLENBQUNBLE1BQU11SSxNQUFwRCxFQUE0RDtBQUN4RGlPLG1CQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLHdEQUFoQyxDQUFaO0FBQ0g7QUFDRCxZQUFJc2lDLGdCQUFnQixXQUFoQixJQUErQnZPLGFBQWFnRixhQUFhLzRCLEtBQWIsQ0FBYixDQUEvQixJQUFvRTY0QixTQUFTNzRCLE1BQU1sSCxJQUFmLE1BQXlCLFVBQWpHLEVBQTZHO0FBQ3pHOFYsbUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsRUFBZ0MsaURBQWhDLENBQVo7QUFDSDtBQUNKO0FBQ0QsV0FBTzRPLE9BQU96RixNQUFQLENBQWN1M0IsU0FBUztBQUMxQnZqQyxhQUFLdU8sUUFBUXZPLEdBRGE7QUFFMUI2QyxvQkFGMEI7QUFHMUJrZ0MsNEJBSDBCO0FBSTFCOW5DLG9CQUowQjtBQUsxQmlvQyw0QkFMMEI7QUFNMUIrQiwyQkFBbUIsVUFOTztBQU8xQjdvQixrQ0FQMEI7QUFRMUIrb0I7QUFSMEIsS0FBVCxDQUFkLENBQVA7QUFVSDs7QUFFRCxTQUFTYSxxQkFBVCxDQUErQnozQixPQUEvQixFQUF3QztBQUNwQyxXQUFPcTNCLGlCQUFpQnIzQixPQUFqQixFQUEwQixPQUExQixDQUFQO0FBQ0g7O0FBRUQsU0FBUzAzQixzQkFBVCxDQUFnQzEzQixPQUFoQyxFQUF5QztBQUNyQyxXQUFPcTNCLGlCQUFpQnIzQixPQUFqQixFQUEwQixRQUExQixDQUFQO0FBQ0g7O0FBRUQsU0FBUzIzQixhQUFULENBQXVCMzNCLE9BQXZCLEVBQWdDO0FBQzVCLFFBQUlrRCxTQUFTLEVBQWI7QUFDQSxRQUFNbFosUUFBUWdXLFFBQVExTCxLQUF0QjtBQUNBLFFBQU03QyxNQUFNdU8sUUFBUXZPLEdBQXBCO0FBQ0EsUUFBTS9FLFFBQVFzVCxRQUFRdFQsS0FBdEI7QUFDQSxRQUFNaW9DLFlBQVkzMEIsUUFBUTIwQixTQUExQjtBQUNBLFFBQUksQ0FBQzNxQyxNQUFNb0QsSUFBUCxJQUFlLENBQUNwRCxNQUFNc0UsR0FBMUIsRUFBK0I7QUFDM0I0VSxlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnpILEtBQXpCLEVBQWdDLG9DQUFoQyxDQUFaO0FBQ0g7QUFDRCxRQUFJb0QsT0FBTysvQixTQUFTbmpDLE1BQU1vRCxJQUFmLENBQVg7QUFDQSxRQUFNa0IsTUFBTTYrQixTQUFTbmpDLE1BQU1zRSxHQUFmLENBQVo7QUFDQSxRQUFJdEUsTUFBTStDLEVBQVYsRUFBYztBQUNWLFlBQU0yRyxVQUFVeTVCLFNBQVNuakMsTUFBTStDLEVBQWYsQ0FBaEI7QUFDQSxhQUFLLElBQUkzRSxJQUFJLENBQWIsRUFBZ0JBLElBQUk0WCxRQUFRdTFCLFVBQTVCLEVBQXdDbnRDLEdBQXhDLEVBQTZDO0FBQ3pDLGdCQUFNd3ZDLGFBQWFsckMsTUFBTUksTUFBTixDQUFhMUUsQ0FBYixDQUFuQjtBQUNBLGdCQUFJK2tDLFNBQVN5SyxXQUFXN3FDLEVBQXBCLE1BQTRCMkcsT0FBaEMsRUFBeUM7QUFDckN3UCx1QkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJ6SCxNQUFNK0MsRUFBL0IsNEJBQTJEL0MsTUFBTStDLEVBQWpFLG9DQUFtRzZxQyxXQUFXN3FDLEVBQVgsQ0FBY29uQyxRQUFqSCxDQUFaO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsUUFBSSxTQUFTbnFDLEtBQWIsRUFBb0I7QUFDaEIsU0FDSSxNQURKLEVBRUksUUFGSixFQUdJLGNBSEosRUFJSSxRQUpKLEVBS0ksUUFMSixFQU1FOGpCLE9BTkYsQ0FNVSxhQUFLO0FBQ1gsZ0JBQUlyQyxLQUFLemhCLEtBQVQsRUFBZ0I7QUFDWmtaLHVCQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnpILE1BQU15aEIsQ0FBTixDQUF6QixTQUF3Q0EsQ0FBeEMscUNBQVo7QUFDSDtBQUNKLFNBVkQ7QUFXQSxZQUFJOEQsZUFBSjtBQUNBN2lCLGNBQU1JLE1BQU4sQ0FBYWdoQixPQUFiLENBQXFCLGlCQUFTO0FBQzFCLGdCQUFJcWYsU0FBU25qQyxNQUFNK0MsRUFBZixNQUF1QnVCLEdBQTNCLEVBQ0lpaEIsU0FBU3ZsQixLQUFUO0FBQ1AsU0FIRDtBQUlBLFlBQUksQ0FBQ3VsQixNQUFMLEVBQWE7QUFDVHJNLG1CQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnpILE1BQU1zRSxHQUEvQixtQkFBbURBLEdBQW5ELGtCQUFaO0FBQ0gsU0FGRCxNQUVPLElBQUlpaEIsT0FBT2poQixHQUFYLEVBQWdCO0FBQ25CNFUsbUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCekgsTUFBTXNFLEdBQS9CLEVBQW9DLHdDQUFwQyxDQUFaO0FBQ0gsU0FGTSxNQUVBO0FBQ0hsQixtQkFBTysvQixTQUFTNWQsT0FBT25pQixJQUFoQixDQUFQO0FBQ0g7QUFDSixLQXhCRCxNQXdCTyxJQUFJLEVBQUVBLFNBQVMsWUFBVCxJQUF5QkEsU0FBUyxLQUFwQyxDQUFKLEVBQWdEO0FBQ25ELFlBQUksQ0FBQ3BELE1BQU1XLE1BQVgsRUFBbUI7QUFDZnVZLG1CQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnpILEtBQXpCLEVBQWdDLG9DQUFoQyxDQUFaO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZ0JBQU1XLFdBQVMrQixNQUFNeUQsT0FBTixJQUFpQnpELE1BQU15RCxPQUFOLENBQWNuRyxNQUFNVyxNQUFwQixDQUFoQztBQUNBLGdCQUFNa3RDLGFBQWFsdEMsWUFBVXdpQyxTQUFTeGlDLFNBQU95QyxJQUFoQixDQUE3QjtBQUNBLGdCQUFJLENBQUN6QyxRQUFMLEVBQWE7QUFDVHVZLHVCQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnpILE1BQU1XLE1BQS9CLGdCQUFtRFgsTUFBTVcsTUFBekQsa0JBQVo7QUFDSCxhQUZELE1BRU8sSUFBSWt0QyxlQUFlLFFBQWYsSUFBMkJ6cUMsU0FBUyxRQUF4QyxFQUFrRDtBQUNyRDhWLHVCQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnpILE1BQU1XLE1BQS9CLGVBQWtEWCxNQUFNK0MsRUFBeEQsaUNBQVo7QUFDSCxhQUZNLE1BRUEsSUFBSThxQyxlQUFlLFFBQWYsSUFBMkJ6cUMsU0FBUyxRQUF4QyxFQUFrRDtBQUNyRDhWLHVCQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnpILE1BQU1XLE1BQS9CLGVBQWtEWCxNQUFNK0MsRUFBeEQsaUNBQVo7QUFDSCxhQUZNLE1BRUEsSUFBSThxQyxlQUFlLFFBQWYsSUFBMkIsQ0FBQzd0QyxNQUFNLGNBQU4sQ0FBaEMsRUFBdUQ7QUFDMURrWix1QkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJ6SCxLQUF6QixlQUEyQ0EsTUFBTStDLEVBQWpELHdDQUFaO0FBQ0gsYUFGTSxNQUVBLElBQUk4cUMsZUFBZSxZQUFmLElBQStCenFDLFNBQVMsV0FBNUMsRUFBeUQ7QUFDNUQ4Vix1QkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJ6SCxNQUFNVyxNQUEvQixFQUF1QyxtRUFBdkMsQ0FBWjtBQUNILGFBRk0sTUFFQSxJQUFJeUMsU0FBUyxNQUFULElBQW1CcEQsTUFBTXdELEtBQXpCLElBQWtDeEQsTUFBTXdELEtBQU4sQ0FBWSxlQUFaLENBQWxDLEtBQW1FcXFDLGVBQWUsU0FBZixJQUE0QixDQUFDbHRDLFNBQU93TSxXQUF2RyxDQUFKLEVBQXlIO0FBQzVIK0wsdUJBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCekgsS0FBekIsZUFBMkNBLE1BQU0rQyxFQUFqRCwrRkFBWjtBQUNIO0FBQ0o7QUFDSjtBQUNEbVcsYUFBU0EsT0FBT3pGLE1BQVAsQ0FBYzYyQixlQUFlO0FBQ2xDN2lDLGdCQURrQztBQUVsQzZDLGVBQU90SyxLQUYyQjtBQUdsQ3dxQyxtQkFBV0csVUFBVTNxQyxLQUhhO0FBSWxDMEMsZUFBT3NULFFBQVF0VCxLQUptQjtBQUtsQ2lvQyxtQkFBVzMwQixRQUFRMjBCLFNBTGU7QUFNbENELGlDQUF5QjtBQUNyQixlQURxQixlQUNmO0FBQ0YsdUJBQU8sRUFBUDtBQUNILGFBSG9CO0FBSXJCdG5DLGdCQUpxQixrQkFJZDtBQUNILHVCQUFPNG5DLFNBQVM7QUFDWnZqQyx5QkFBU0EsR0FBVCxVQURZO0FBRVo2QywyQkFBT3RLLE1BQU1vRCxJQUZEO0FBR1pvbkMsK0JBQVdHLFVBQVUzcUMsS0FBVixDQUFnQm9ELElBSGY7QUFJWlYsMkJBQU9zVCxRQUFRdFQsS0FKSDtBQUtaaW9DLCtCQUFXMzBCLFFBQVEyMEIsU0FMUDtBQU1aMTRCLDRCQUFRalMsS0FOSTtBQU9aNHFDLCtCQUFXO0FBUEMsaUJBQVQsQ0FBUDtBQVNILGFBZG9CO0FBZXJCaCtCLGtCQWZxQixrQkFlZG9KLE9BZmMsRUFlTDtBQUNaLHVCQUFPbTNCLGVBQWVqb0IsT0FBTyxFQUFFdWUsV0FBV3JnQyxJQUFiLEVBQVAsRUFBNEI0UyxPQUE1QixDQUFmLENBQVA7QUFDSCxhQWpCb0I7QUFrQnJCL1Ysa0JBbEJxQixrQkFrQmQrVixPQWxCYyxFQWtCTDtBQUNaLHVCQUFPczBCLGVBQWU7QUFDbEJ0cUMsZ0NBRGtCO0FBRWxCeUgseUJBQUt1TyxRQUFRdk8sR0FGSztBQUdsQjZDLDJCQUFPMEwsUUFBUTFMLEtBSEc7QUFJbEI1SCwyQkFBT3NULFFBQVF0VCxLQUpHO0FBS2xCaW9DLCtCQUFXMzBCLFFBQVEyMEIsU0FMRDtBQU1sQkQsNkNBQXlCO0FBQ3JCLDJCQURxQixhQUNqQjEwQixPQURpQixFQUNSO0FBQ1QsbUNBQU8wM0IsdUJBQXVCeG9CLE9BQU8sRUFBRXVlLFdBQVdyZ0MsSUFBYixFQUFQLEVBQTRCNFMsT0FBNUIsQ0FBdkIsQ0FBUDtBQUNIO0FBSG9CO0FBTlAsaUJBQWYsQ0FBUDtBQVlILGFBL0JvQjtBQWdDckJ4UyxpQkFoQ3FCLGlCQWdDZndTLE9BaENlLEVBZ0NOO0FBQ1gsdUJBQU9zMEIsZUFBZTtBQUNsQnRxQyxnQ0FEa0I7QUFFbEJ5SCx5QkFBS3VPLFFBQVF2TyxHQUZLO0FBR2xCNkMsMkJBQU8wTCxRQUFRMUwsS0FIRztBQUlsQjVILDJCQUFPc1QsUUFBUXRULEtBSkc7QUFLbEJpb0MsK0JBQVczMEIsUUFBUTIwQixTQUxEO0FBTWxCRCw2Q0FBeUI7QUFDckIsMkJBRHFCLGFBQ2pCMTBCLE9BRGlCLEVBQ1I7QUFDVCxtQ0FBT3kzQixzQkFBc0J2b0IsT0FBTyxFQUFFdWUsV0FBV3JnQyxJQUFiLEVBQVAsRUFBNEI0UyxPQUE1QixDQUF0QixDQUFQO0FBQ0g7QUFIb0I7QUFOUCxpQkFBZixDQUFQO0FBWUg7QUE3Q29CO0FBTlMsS0FBZixDQUFkLENBQVQ7QUFzREEsV0FBT2tELE1BQVA7QUFDSDs7QUFFRCxTQUFTNDBCLGNBQVQsQ0FBd0I5M0IsT0FBeEIsRUFBaUM7QUFDN0IsUUFBTTFMLFFBQVEwTCxRQUFRMUwsS0FBdEI7QUFDQSxRQUFNN0MsTUFBTXVPLFFBQVF2TyxHQUFwQjtBQUNBLFFBQU1yRSxPQUFPKzZCLFFBQVE3ekIsS0FBUixDQUFiO0FBQ0EsUUFBSWxILFNBQVMsUUFBYixFQUF1QjtBQUNuQixlQUFPLENBQUMsSUFBSTZtQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCNkMsS0FBekIsd0JBQXFEbEgsSUFBckQsWUFBRCxDQUFQO0FBQ0g7QUFDRCxXQUFPLEVBQVA7QUFDSDs7QUFFRCxJQUFNc25DLDBCQUEwQixFQUFFNytCLFdBQVdraUMsaUJBQWIsRUFBaEM7QUFDQSxTQUFTQyxjQUFULENBQXdCaDRCLE9BQXhCLEVBQWlDO0FBQzdCLFFBQU0xTCxRQUFRMEwsUUFBUTFMLEtBQXRCO0FBQ0EsUUFBTTdDLE1BQU11TyxRQUFRdk8sR0FBcEI7QUFDQSxRQUFNa2pDLFlBQVkzMEIsUUFBUTIwQixTQUExQjtBQUNBLFFBQU1qb0MsUUFBUXNULFFBQVF0VCxLQUF0QjtBQUNBLFFBQUksQ0FBQzRILE1BQU1sSCxJQUFYLEVBQWlCO0FBQ2IsZUFBTyxDQUFDLElBQUk2bUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLG9CQUFoQyxDQUFELENBQVA7QUFDSDtBQUNELFFBQU1sSCxPQUFPKy9CLFNBQVM3NEIsTUFBTWxILElBQWYsQ0FBYjtBQUNBLFFBQUk4VixlQUFKO0FBQ0EsWUFBUTlWLElBQVI7QUFDQSxhQUFLLFFBQUw7QUFDQSxhQUFLLFFBQUw7QUFDQSxhQUFLLFlBQUw7QUFDSThWLHFCQUFTb3hCLGVBQWU7QUFDcEI3aUMsd0JBRG9CO0FBRXBCNkMsNEJBRm9CO0FBR3BCa2dDLDJCQUFXRyxzQkFBcUJ2bkMsS0FBS25FLE9BQUwsQ0FBYSxHQUFiLEVBQWtCLEdBQWxCLENBQXJCLENBSFM7QUFJcEJ5RCx1QkFBT3NULFFBQVF0VCxLQUpLO0FBS3BCaW9DLG9DQUxvQjtBQU1wQkQ7QUFOb0IsYUFBZixDQUFUO0FBUUEsbUJBQU94eEIsTUFBUDtBQUNKLGFBQUssU0FBTDtBQUNJQSxxQkFBU294QixlQUFlO0FBQ3BCN2lDLHdCQURvQjtBQUVwQjZDLDRCQUZvQjtBQUdwQmtnQywyQkFBV0csVUFBVXArQixjQUhEO0FBSXBCN0osNEJBSm9CO0FBS3BCaW9DLG9DQUxvQjtBQU1wQkQ7QUFOb0IsYUFBZixDQUFUO0FBUUEsZ0JBQUlwZ0MsTUFBTXdDLE9BQVYsRUFBbUI7QUFDZixxQkFBSyxJQUFNK1AsSUFBWCxJQUFtQnZTLE1BQU00QyxpQkFBekIsRUFBNEM7QUFBQTs7QUFBQSwrREFDWjVDLE1BQU00QyxpQkFBTixDQUF3QjJQLElBQXhCLENBRFk7QUFBQSx3QkFDakN1YixRQURpQztBQUFBLHdCQUN2QjZWLE9BRHVCOztBQUV4Qyx3QkFBTUMsYUFBYSxPQUFPOVYsUUFBUCxLQUFvQixRQUFwQixHQUErQixDQUM5Q0EsUUFEOEMsRUFFOUMsQ0FBQyxhQUFELENBRjhDLEVBRzlDLENBQ0ksS0FESixFQUVJdmIsSUFGSixDQUg4QyxDQUEvQixHQU9mdWIsUUFQSjtBQVFBLHVDQUFPaDVCLElBQVAsbUNBQWVxdEMsbUJBQW1CO0FBQzlCaGxDLDZCQUFTQSxHQUFULFNBQWtCb1YsSUFBbEIsU0FEOEI7QUFFOUJ2UywrQkFBTzJqQyxPQUZ1QjtBQUc5QnZCLDJDQUFtQjtBQUhXLHFCQUFuQixDQUFmO0FBS0Esd0NBQU90dEMsSUFBUCxvQ0FBZXF0QyxtQkFBbUI7QUFDOUJobEMsNkJBQVNBLEdBQVQsU0FBa0JvVixJQUFsQixZQUQ4QjtBQUU5QnZTLCtCQUFPNGpDLFVBRnVCO0FBRzlCeEIsMkNBQW1CO0FBSFcscUJBQW5CLENBQWY7QUFLSDtBQUNKO0FBQ0QsbUJBQU94ekIsTUFBUDtBQUNKLGFBQUssT0FBTDtBQUNJLG1CQUFPb3hCLGVBQWU7QUFDbEI3aUMsd0JBRGtCO0FBRWxCNkMsNEJBRmtCO0FBR2xCa2dDLDJCQUFXRyxVQUFVdDlCLFlBSEg7QUFJbEIzSyw0QkFKa0I7QUFLbEJpb0M7QUFMa0IsYUFBZixDQUFQO0FBT0osYUFBSyxPQUFMO0FBQ0ksbUJBQU9MLGVBQWU7QUFDbEI3aUMsd0JBRGtCO0FBRWxCNkMsNEJBRmtCO0FBR2xCa2dDLDJCQUFXRyxVQUFVbjlCLFlBSEg7QUFJbEI5Syw0QkFKa0I7QUFLbEJpb0M7QUFMa0IsYUFBZixDQUFQO0FBT0osYUFBSyxRQUFMO0FBQ0ksbUJBQU8sQ0FBQyxJQUFJVixlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCLElBQXpCLCtGQUE0SCxlQUE1SCxDQUFELENBQVA7QUFDSjtBQUNJLG1CQUFPeWxDLGFBQWE7QUFDaEJ6bEMscUJBQVNBLEdBQVQsVUFEZ0I7QUFFaEI2Qyx1QkFBT0EsTUFBTWxILElBRkc7QUFHaEJvbkMsMkJBQVc7QUFDUHZnQyw0QkFBUSxDQUNKLFFBREksRUFFSixRQUZJLEVBR0osWUFISSxFQUlKLFNBSkksRUFLSixPQUxJLEVBTUosT0FOSTtBQURELGlCQUhLO0FBYWhCdkgsNEJBYmdCO0FBY2hCaW9DO0FBZGdCLGFBQWIsQ0FBUDtBQWpFSjtBQWtGSDtBQUNELFNBQVNvRCxpQkFBVCxVQUF5QztBQUFBLFFBQWJ0bUMsR0FBYSxXQUFiQSxHQUFhO0FBQUEsUUFBUjZDLEtBQVEsV0FBUkEsS0FBUTs7QUFDckMsUUFBSTZ6QixRQUFRN3pCLEtBQVIsTUFBbUIsUUFBdkIsRUFBaUM7QUFDN0IsZUFBT3dqQyxlQUFlO0FBQ2xCcm1DLG9CQURrQjtBQUVsQjZDO0FBRmtCLFNBQWYsQ0FBUDtBQUlILEtBTEQsTUFLTztBQUNILFlBQU00TyxTQUFTLEVBQWY7QUFDQSxhQUFLLElBQU0yRCxJQUFYLElBQW1CdlMsS0FBbkIsRUFBMEI7QUFDdEI0TyxtQkFBTzlaLElBQVAsa0NBQWUwdUMsZUFBZTtBQUMxQnJtQyxxQkFBU0EsR0FBVCxTQUFrQm9WLElBRFE7QUFFMUJ2Uyx1QkFBT0EsTUFBTXVTLElBQU47QUFGbUIsYUFBZixDQUFmO0FBSUg7QUFDRCxlQUFPM0QsTUFBUDtBQUNIO0FBQ0o7O0FBRUQsU0FBU2kxQixhQUFULENBQXVCbjRCLE9BQXZCLEVBQWdDO0FBQzVCLFFBQU1yTCxRQUFRcUwsUUFBUTFMLEtBQXRCO0FBQ0EsUUFBTXFnQyxZQUFZMzBCLFFBQVEyMEIsU0FBMUI7QUFDQSxRQUFNeUQsWUFBWXpELFVBQVVoZ0MsS0FBNUI7QUFDQSxRQUFNakksUUFBUXNULFFBQVF0VCxLQUF0QjtBQUNBLFFBQUl3VyxTQUFTLEVBQWI7QUFDQSxRQUFNbTFCLFdBQVdsUSxRQUFReHpCLEtBQVIsQ0FBakI7QUFDQSxRQUFJQSxVQUFVdkksU0FBZCxFQUF5QjtBQUNyQixlQUFPOFcsTUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJbTFCLGFBQWEsUUFBakIsRUFBMkI7QUFDOUJuMUIsaUJBQVNBLE9BQU96RixNQUFQLENBQWMsQ0FBQyxJQUFJdzJCLGVBQUosQ0FBb0IsT0FBcEIsRUFBNkJ0L0IsS0FBN0Isd0JBQXlEMGpDLFFBQXpELFlBQUQsQ0FBZCxDQUFUO0FBQ0EsZUFBT24xQixNQUFQO0FBQ0g7QUFDRCxTQUFLLElBQU16UixHQUFYLElBQWtCa0QsS0FBbEIsRUFBeUI7QUFDckIsWUFBTTRpQyxrQkFBa0I5bEMsSUFBSWhILEtBQUosQ0FBVSxtQkFBVixDQUF4QjtBQUNBLFlBQUk4c0MsbUJBQW1CYSxVQUFVYixnQkFBZ0IsQ0FBaEIsQ0FBVixDQUFuQixJQUFvRGEsVUFBVWIsZ0JBQWdCLENBQWhCLENBQVYsRUFBOEJyaUMsVUFBdEYsRUFBa0c7QUFDOUZnTyxxQkFBU0EsT0FBT3pGLE1BQVAsQ0FBY3UzQixTQUFTO0FBQzVCdmpDLHdCQUQ0QjtBQUU1QjZDLHVCQUFPSyxNQUFNbEQsR0FBTixDQUZxQjtBQUc1QitpQywyQkFBV0csVUFBVXovQixVQUhPO0FBSTVCeEksNEJBSjRCO0FBSzVCaW9DO0FBTDRCLGFBQVQsQ0FBZCxDQUFUO0FBT0gsU0FSRCxNQVFPLElBQUl5RCxVQUFVM21DLEdBQVYsQ0FBSixFQUFvQjtBQUN2QnlSLHFCQUFTQSxPQUFPekYsTUFBUCxDQUFjdTNCLFNBQVM7QUFDNUJ2akMsd0JBRDRCO0FBRTVCNkMsdUJBQU9LLE1BQU1sRCxHQUFOLENBRnFCO0FBRzVCK2lDLDJCQUFXNEQsVUFBVTNtQyxHQUFWLENBSGlCO0FBSTVCL0UsNEJBSjRCO0FBSzVCaW9DO0FBTDRCLGFBQVQsQ0FBZCxDQUFUO0FBT0gsU0FSTSxNQVFBO0FBQ0h6eEIscUJBQVNBLE9BQU96RixNQUFQLENBQWMsQ0FBQyxJQUFJdzJCLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJrRCxNQUFNbEQsR0FBTixDQUF6QiwwQkFBMkRBLEdBQTNELFFBQUQsQ0FBZCxDQUFUO0FBQ0g7QUFDSjtBQUNELFdBQU95UixNQUFQO0FBQ0g7O0FBRUQsU0FBU28xQixlQUFULENBQXlCdDRCLE9BQXpCLEVBQWtDO0FBQzlCLFFBQU1qTCxVQUFVaUwsUUFBUTFMLEtBQXhCO0FBQ0EsUUFBTTdDLE1BQU11TyxRQUFRdk8sR0FBcEI7QUFDQSxRQUFNL0UsUUFBUXNULFFBQVF0VCxLQUF0QjtBQUNBLFFBQU1pb0MsWUFBWTMwQixRQUFRMjBCLFNBQTFCO0FBQ0EsUUFBTTRELGNBQWM1RCxVQUFVNS9CLE9BQTlCO0FBQ0EsUUFBSW1PLFNBQVMsRUFBYjtBQUNBLFFBQU1tMUIsV0FBV2xRLFFBQVFwekIsT0FBUixDQUFqQjtBQUNBLFFBQUlBLFlBQVkzSSxTQUFoQixFQUEyQjtBQUN2QixlQUFPOFcsTUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJbTFCLGFBQWEsUUFBakIsRUFBMkI7QUFDOUJuMUIsaUJBQVNBLE9BQU96RixNQUFQLENBQWMsQ0FBQyxJQUFJdzJCLGVBQUosQ0FBb0IsU0FBcEIsRUFBK0JsL0IsT0FBL0Isd0JBQTZEc2pDLFFBQTdELFlBQUQsQ0FBZCxDQUFUO0FBQ0EsZUFBT24xQixNQUFQO0FBQ0g7QUFDRCxTQUFLLElBQU16UixLQUFYLElBQWtCc0QsT0FBbEIsRUFBMkI7QUFDdkIsWUFBTXdpQyxrQkFBa0I5bEMsTUFBSWhILEtBQUosQ0FBVSxtQkFBVixDQUF4QjtBQUNBLFlBQUk4c0MsbUJBQW1CZ0IsWUFBWWhCLGdCQUFnQixDQUFoQixDQUFaLENBQW5CLElBQXNEZ0IsWUFBWWhCLGdCQUFnQixDQUFoQixDQUFaLEVBQWdDcmlDLFVBQTFGLEVBQXNHO0FBQ2xHZ08scUJBQVNBLE9BQU96RixNQUFQLENBQWN1M0IsU0FBUztBQUM1QnZqQywwQkFENEI7QUFFNUI2Qyx1QkFBT1MsUUFBUXRELEtBQVIsQ0FGcUI7QUFHNUIraUMsMkJBQVdHLFVBQVV6L0IsVUFITztBQUk1QnhJLDRCQUo0QjtBQUs1QmlvQztBQUw0QixhQUFULENBQWQsQ0FBVDtBQU9ILFNBUkQsTUFRTyxJQUFJNEQsWUFBWTltQyxLQUFaLENBQUosRUFBc0I7QUFDekJ5UixxQkFBU0EsT0FBT3pGLE1BQVAsQ0FBY3UzQixTQUFTO0FBQzVCdmpDLDBCQUQ0QjtBQUU1QjZDLHVCQUFPUyxRQUFRdEQsS0FBUixDQUZxQjtBQUc1QitpQywyQkFBVytELFlBQVk5bUMsS0FBWixDQUhpQjtBQUk1Qi9FLDRCQUo0QjtBQUs1QmlvQztBQUw0QixhQUFULENBQWQsQ0FBVDtBQU9ILFNBUk0sTUFRQTtBQUNIenhCLHFCQUFTQSxPQUFPekYsTUFBUCxDQUFjLENBQUMsSUFBSXcyQixlQUFKLENBQW9CeGlDLEtBQXBCLEVBQXlCc0QsUUFBUXRELEtBQVIsQ0FBekIsMEJBQTZEQSxLQUE3RCxRQUFELENBQWQsQ0FBVDtBQUNIO0FBQ0o7QUFDRCxRQUFJLENBQUNzRCxRQUFRcEssTUFBYixFQUFxQjtBQUNqQnVZLGVBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CeGlDLEdBQXBCLEVBQXlCc0QsT0FBekIsb0RBQVo7QUFDSCxLQUZELE1BRU87QUFDSCxZQUFNcEssV0FBUytCLE1BQU15RCxPQUFOLElBQWlCekQsTUFBTXlELE9BQU4sQ0FBYzRFLFFBQVFwSyxNQUF0QixDQUFoQztBQUNBLFlBQU1rdEMsYUFBYWx0QyxZQUFVd2lDLFNBQVN4aUMsU0FBT3lDLElBQWhCLENBQTdCO0FBQ0EsWUFBSSxDQUFDekMsUUFBTCxFQUFhO0FBQ1R1WSxtQkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJzRCxRQUFRcEssTUFBakMsZ0JBQXFEb0ssUUFBUXBLLE1BQTdELGtCQUFaO0FBQ0gsU0FGRCxNQUVPLElBQUlrdEMsZUFBZSxZQUFuQixFQUFpQztBQUNwQzMwQixtQkFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUJzRCxRQUFRcEssTUFBakMsb0RBQTBGa3RDLFVBQTFGLHlEQUFaO0FBQ0g7QUFDSjtBQUNELFdBQU8zMEIsTUFBUDtBQUNIOztBQUVELFNBQVNzMUIsV0FBVCxDQUFxQng0QixPQUFyQixFQUE4QjtBQUMxQixRQUFNaEwsTUFBTWdMLFFBQVExTCxLQUFwQjtBQUNBLFFBQU01SCxRQUFRc1QsUUFBUXRULEtBQXRCO0FBQ0EsUUFBTWlvQyxZQUFZMzBCLFFBQVEyMEIsU0FBMUI7QUFDQSxRQUFNOEQsVUFBVTlELFVBQVUzL0IsR0FBMUI7QUFDQSxRQUFJa08sU0FBUyxFQUFiO0FBQ0EsUUFBTW0xQixXQUFXbFEsUUFBUW56QixHQUFSLENBQWpCO0FBQ0EsUUFBSUEsUUFBUTVJLFNBQVosRUFBdUI7QUFDbkIsZUFBTzhXLE1BQVA7QUFDSCxLQUZELE1BRU8sSUFBSW0xQixhQUFhLFFBQWpCLEVBQTJCO0FBQzlCbjFCLGlCQUFTQSxPQUFPekYsTUFBUCxDQUFjLENBQUMsSUFBSXcyQixlQUFKLENBQW9CLEtBQXBCLEVBQTJCai9CLEdBQTNCLHdCQUFxRHFqQyxRQUFyRCxZQUFELENBQWQsQ0FBVDtBQUNBLGVBQU9uMUIsTUFBUDtBQUNIO0FBQ0QsU0FBSyxJQUFNelIsR0FBWCxJQUFrQnVELEdBQWxCLEVBQXVCO0FBQ25CLFlBQU11aUMsa0JBQWtCOWxDLElBQUloSCxLQUFKLENBQVUsbUJBQVYsQ0FBeEI7QUFDQSxZQUFJOHNDLG1CQUFtQmtCLFFBQVFsQixnQkFBZ0IsQ0FBaEIsQ0FBUixDQUFuQixJQUFrRGtCLFFBQVFsQixnQkFBZ0IsQ0FBaEIsQ0FBUixFQUE0QnJpQyxVQUFsRixFQUE4RjtBQUMxRmdPLHFCQUFTQSxPQUFPekYsTUFBUCxDQUFjdTNCLFNBQVM7QUFDNUJ2akMsd0JBRDRCO0FBRTVCNkMsdUJBQU9VLElBQUl2RCxHQUFKLENBRnFCO0FBRzVCK2lDLDJCQUFXRyxVQUFVei9CLFVBSE87QUFJNUJ4SSw0QkFKNEI7QUFLNUJpb0M7QUFMNEIsYUFBVCxDQUFkLENBQVQ7QUFPSCxTQVJELE1BUU8sSUFBSThELFFBQVFobkMsR0FBUixDQUFKLEVBQWtCO0FBQ3JCeVIscUJBQVNBLE9BQU96RixNQUFQLENBQWN1M0IsU0FBUztBQUM1QnZqQyx3QkFENEI7QUFFNUI2Qyx1QkFBT1UsSUFBSXZELEdBQUosQ0FGcUI7QUFHNUIraUMsMkJBQVdpRSxRQUFRaG5DLEdBQVIsQ0FIaUI7QUFJNUIvRSw0QkFKNEI7QUFLNUJpb0M7QUFMNEIsYUFBVCxDQUFkLENBQVQ7QUFPSCxTQVJNLE1BUUE7QUFDSHp4QixxQkFBU0EsT0FBT3pGLE1BQVAsQ0FBYyxDQUFDLElBQUl3MkIsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QnVELElBQUl2RCxHQUFKLENBQXpCLDBCQUF5REEsR0FBekQsUUFBRCxDQUFkLENBQVQ7QUFDSDtBQUNKO0FBQ0QsV0FBT3lSLE1BQVA7QUFDSDs7QUFFRCxTQUFTdzFCLGlCQUFULENBQTJCMTRCLE9BQTNCLEVBQW9DO0FBQ2hDLFFBQUk4M0IsZUFBZTkzQixPQUFmLEVBQXdCdlgsTUFBeEIsS0FBbUMsQ0FBdkMsRUFBMEM7QUFDdEMsZUFBTyxFQUFQO0FBQ0g7QUFDRCxXQUFPZ3VDLG1CQUFtQnoyQixPQUFuQixDQUFQO0FBQ0g7O0FBRUQsU0FBUzI0QixhQUFULENBQXVCMzRCLE9BQXZCLEVBQWdDO0FBQzVCLFFBQUk4M0IsZUFBZTkzQixPQUFmLEVBQXdCdlgsTUFBeEIsS0FBbUMsQ0FBdkMsRUFBMEM7QUFDdEMsZUFBTyxFQUFQO0FBQ0g7QUFDRCxXQUFPZ3VDLG1CQUFtQnoyQixPQUFuQixDQUFQO0FBQ0g7O0FBRUQsU0FBUzQ0QixrQkFBVCxDQUE0QjU0QixPQUE1QixFQUFxQztBQUNqQyxRQUFNM0ssYUFBYTJLLFFBQVExTCxLQUEzQjtBQUNBLFFBQU1xZ0MsWUFBWTMwQixRQUFRMjBCLFNBQTFCO0FBQ0EsUUFBTWtFLGlCQUFpQmxFLFVBQVV0L0IsVUFBakM7QUFDQSxRQUFNM0ksUUFBUXNULFFBQVF0VCxLQUF0QjtBQUNBLFFBQUl3VyxTQUFTLEVBQWI7QUFDQSxRQUFNbTFCLFdBQVdsUSxRQUFROXlCLFVBQVIsQ0FBakI7QUFDQSxRQUFJZ2pDLGFBQWEsUUFBakIsRUFBMkI7QUFDdkIsYUFBSyxJQUFNNW1DLEdBQVgsSUFBa0I0RCxVQUFsQixFQUE4QjtBQUMxQjZOLHFCQUFTQSxPQUFPekYsTUFBUCxDQUFjdTNCLFNBQVM7QUFDNUJ2akMsd0JBRDRCO0FBRTVCNkMsdUJBQU9lLFdBQVc1RCxHQUFYLENBRnFCO0FBRzVCK2lDLDJCQUFXcUUsZUFBZXBuQyxHQUFmLENBSGlCO0FBSTVCL0UsNEJBSjRCO0FBSzVCaW9DO0FBTDRCLGFBQVQsQ0FBZCxDQUFUO0FBT0g7QUFDSixLQVZELE1BVU8sSUFBSTBELGFBQWEsUUFBakIsRUFBMkI7QUFDOUJuMUIsaUJBQVNBLE9BQU96RixNQUFQLENBQWMsQ0FBQyxJQUFJdzJCLGVBQUosQ0FBb0IsWUFBcEIsRUFBa0M1K0IsVUFBbEMsa0NBQTZFZ2pDLFFBQTdFLFlBQUQsQ0FBZCxDQUFUO0FBQ0g7QUFDRCxXQUFPbjFCLE1BQVA7QUFDSDs7QUFFRCxJQUFNNDFCLGFBQWE7QUFDZixPQURlLGVBQ1Q7QUFDRixlQUFPLEVBQVA7QUFDSCxLQUhjOztBQUlmLGFBQVM3RCxhQUpNO0FBS2YsZUFBVytCLGVBTEk7QUFNZixjQUFVeEIsY0FOSztBQU9mLGFBQVN5QixhQVBNO0FBUWYsaUJBQWE1QyxpQkFSRTtBQVNmLFlBQVE2QyxZQVRPO0FBVWYsY0FBVUMsY0FWSztBQVdmLGdCQUFZeEIsZ0JBWEc7QUFZZixhQUFTZ0MsYUFaTTtBQWFmLGNBQVVyRCxjQWJLO0FBY2YsY0FBVTBELGNBZEs7QUFlZixhQUFTRyxhQWZNO0FBZ0JmLGVBQVdHLGVBaEJJO0FBaUJmLFdBQU9FLFdBakJRO0FBa0JmLGNBQVVWLGNBbEJLO0FBbUJmLGlCQUFhWSxpQkFuQkU7QUFvQmYscUJBQWlCQyxhQXBCRjtBQXFCZixrQkFBY0M7QUFyQkMsQ0FBbkI7QUF1QkEsU0FBUzVELFFBQVQsQ0FBa0JoMUIsT0FBbEIsRUFBMkI7QUFDdkIsUUFBTTFMLFFBQVEwTCxRQUFRMUwsS0FBdEI7QUFDQSxRQUFNa2dDLFlBQVl4MEIsUUFBUXcwQixTQUExQjtBQUNBLFFBQU1HLFlBQVkzMEIsUUFBUTIwQixTQUExQjtBQUNBLFFBQUlILFVBQVVqOEIsVUFBVixJQUF3Qjh2QixhQUFhOEUsU0FBUzc0QixLQUFULENBQWIsQ0FBNUIsRUFBMkQ7QUFDdkQsZUFBT3FoQyxpQkFBaUIzMUIsT0FBakIsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJdzBCLFVBQVVqOEIsVUFBVixJQUF3Qml5QixhQUFhNkMsYUFBYS80QixLQUFiLENBQWIsQ0FBNUIsRUFBK0Q7QUFDbEUsZUFBT21pQyxtQkFBbUJ6MkIsT0FBbkIsQ0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJdzBCLFVBQVVwbkMsSUFBVixJQUFrQjByQyxXQUFXdEUsVUFBVXBuQyxJQUFyQixDQUF0QixFQUFrRDtBQUNyRCxlQUFPMHJDLFdBQVd0RSxVQUFVcG5DLElBQXJCLEVBQTJCNFMsT0FBM0IsQ0FBUDtBQUNILEtBRk0sTUFFQTtBQUNILFlBQU0rNEIsUUFBUXpFLGVBQWVwbEIsT0FBTyxFQUFQLEVBQVdsUCxPQUFYLEVBQW9CLEVBQUV3MEIsV0FBV0EsVUFBVXBuQyxJQUFWLEdBQWlCdW5DLFVBQVVILFVBQVVwbkMsSUFBcEIsQ0FBakIsR0FBNkNvbkMsU0FBMUQsRUFBcEIsQ0FBZixDQUFkO0FBQ0EsZUFBT3VFLEtBQVA7QUFDSDtBQUNKOztBQUVELFNBQVNDLGlCQUFULENBQTRCaDVCLE9BQTVCLEVBQXFDO0FBQ2pDLFFBQU0xTCxRQUFRMEwsUUFBUTFMLEtBQXRCO0FBQ0EsUUFBTTdDLE1BQU11TyxRQUFRdk8sR0FBcEI7QUFDQSxRQUFNeVIsU0FBUzQwQixlQUFlOTNCLE9BQWYsQ0FBZjtBQUNBLFFBQUlrRCxPQUFPemEsTUFBWCxFQUNJLE9BQU95YSxNQUFQO0FBQ0osUUFBSTVPLE1BQU1uTCxPQUFOLENBQWMsYUFBZCxNQUFpQyxDQUFDLENBQXRDLEVBQXlDO0FBQ3JDK1osZUFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0J4aUMsR0FBcEIsRUFBeUI2QyxLQUF6QixFQUFnQyxpREFBaEMsQ0FBWjtBQUNIO0FBQ0QsUUFBSUEsTUFBTW5MLE9BQU4sQ0FBYyxTQUFkLE1BQTZCLENBQUMsQ0FBbEMsRUFBcUM7QUFDakMrWixlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnhpQyxHQUFwQixFQUF5QjZDLEtBQXpCLEVBQWdDLDZDQUFoQyxDQUFaO0FBQ0g7QUFDRCxXQUFPNE8sTUFBUDtBQUNIOztBQUVELFNBQVMrMUIsZ0JBQVQsQ0FBMEJ2c0MsS0FBMUIsRUFBaUQ7QUFBQSxRQUFoQmlvQyxTQUFnQix1RUFBSjExQixFQUFJOztBQUM3QyxRQUFJaUUsU0FBUyxFQUFiO0FBQ0FBLGFBQVNBLE9BQU96RixNQUFQLENBQWN1M0IsU0FBUztBQUM1QnZqQyxhQUFLLEVBRHVCO0FBRTVCNkMsZUFBTzVILEtBRnFCO0FBRzVCOG5DLG1CQUFXRyxVQUFVNWdDLEtBSE87QUFJNUI0Z0MsNEJBSjRCO0FBSzVCam9DLG9CQUw0QjtBQU01QmdvQyxpQ0FBeUI7QUFDckJ6L0Isb0JBQVErakMsaUJBRGE7QUFFckIsZUFGcUIsZUFFZjtBQUNGLHVCQUFPLEVBQVA7QUFDSDtBQUpvQjtBQU5HLEtBQVQsQ0FBZCxDQUFUO0FBYUEsUUFBSXRzQyxNQUFNd2hCLFNBQVYsRUFBcUI7QUFDakJoTCxpQkFBU0EsT0FBT3pGLE1BQVAsQ0FBYzQyQixrQkFBa0I7QUFDckM1aUMsaUJBQUssV0FEZ0M7QUFFckM2QyxtQkFBTzVILE1BQU13aEIsU0FGd0I7QUFHckN4aEIsd0JBSHFDO0FBSXJDaW9DO0FBSnFDLFNBQWxCLENBQWQsQ0FBVDtBQU1IO0FBQ0QsV0FBT3VFLFdBQVdoMkIsTUFBWCxDQUFQO0FBQ0g7QUFDRCsxQixpQkFBaUJ0dUMsTUFBakIsR0FBMEJ3dUMsZ0JBQWdCbkIsY0FBaEIsQ0FBMUI7QUFDQWlCLGlCQUFpQnRrQyxLQUFqQixHQUF5QndrQyxnQkFBZ0JoQixhQUFoQixDQUF6QjtBQUNBYyxpQkFBaUJsa0MsT0FBakIsR0FBMkJva0MsZ0JBQWdCYixlQUFoQixDQUEzQjtBQUNBVyxpQkFBaUJqa0MsR0FBakIsR0FBdUJta0MsZ0JBQWdCWCxXQUFoQixDQUF2QjtBQUNBUyxpQkFBaUJqdkMsS0FBakIsR0FBeUJtdkMsZ0JBQWdCeEIsYUFBaEIsQ0FBekI7QUFDQXNCLGlCQUFpQnJpQyxNQUFqQixHQUEwQnVpQyxnQkFBZ0JoQyxjQUFoQixDQUExQjtBQUNBOEIsaUJBQWlCRyxhQUFqQixHQUFpQ0QsZ0JBQWdCMUIscUJBQWhCLENBQWpDO0FBQ0F3QixpQkFBaUJJLGNBQWpCLEdBQWtDRixnQkFBZ0J6QixzQkFBaEIsQ0FBbEM7QUFDQSxTQUFTd0IsVUFBVCxDQUFvQmgyQixNQUFwQixFQUE0QjtBQUN4QixXQUFPLEdBQUd6RixNQUFILENBQVV5RixNQUFWLEVBQWtCaWhCLElBQWxCLENBQXVCLFVBQUM5d0IsQ0FBRCxFQUFJZ2YsQ0FBSixFQUFVO0FBQ3BDLGVBQU9oZixFQUFFd0UsSUFBRixHQUFTd2EsRUFBRXhhLElBQWxCO0FBQ0gsS0FGTSxDQUFQO0FBR0g7QUFDRCxTQUFTc2hDLGVBQVQsQ0FBeUJ2ckIsS0FBekIsRUFBZ0M7QUFDNUIsV0FBTyxZQUFtQjtBQUFBLDJDQUFOZ0gsSUFBTTtBQUFOQSxnQkFBTTtBQUFBOztBQUN0QixlQUFPc2tCLFdBQVd0ckIsTUFBTTlsQixLQUFOLENBQVksSUFBWixFQUFrQjhzQixJQUFsQixDQUFYLENBQVA7QUFDSCxLQUZEO0FBR0g7O0FBRUQ7O0FBRUEsSUFBSTBrQixXQUFXMTNCLHFCQUFxQixVQUFVRSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUMvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0VBLFFBQUkyb0IsU0FBVSxZQUFVO0FBQ3hCLFlBQUk2TyxJQUFFLFdBQVM1MEIsQ0FBVCxFQUFXK0MsQ0FBWCxFQUFhNnhCLEVBQWIsRUFBZW5yQyxDQUFmLEVBQWlCO0FBQUMsaUJBQUltckMsS0FBRUEsTUFBRyxFQUFMLEVBQVFuckMsSUFBRXVXLEVBQUVsYyxNQUFoQixFQUF1QjJGLEdBQXZCLEVBQTJCbXJDLEdBQUU1MEIsRUFBRXZXLENBQUYsQ0FBRixJQUFRc1osQ0FBbkMsSUFBc0MsT0FBTzZ4QixFQUFQO0FBQVMsU0FBdkU7QUFBQSxZQUF3RUMsTUFBSSxDQUFDLENBQUQsRUFBRyxFQUFILENBQTVFO0FBQUEsWUFBbUZDLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUF2RjtBQUFBLFlBQThGQyxNQUFJLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBbEc7QUFBQSxZQUF3R0MsTUFBSSxDQUFDLENBQUQsRUFBRyxFQUFILENBQTVHO0FBQUEsWUFBbUhDLE1BQUksQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUF2SDtBQUFBLFlBQThIQyxNQUFJLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBbEk7QUFBQSxZQUF5SUMsTUFBSSxDQUFDLENBQUQsRUFBRyxFQUFILENBQTdJO0FBQUEsWUFBb0pDLE1BQUksQ0FBQyxFQUFELEVBQUksRUFBSixFQUFPLEVBQVAsRUFBVSxFQUFWLENBQXhKO0FBQUEsWUFBc0tDLE1BQUksQ0FBQyxFQUFELEVBQUksRUFBSixDQUExSztBQUFBLFlBQWtMQyxNQUFJLENBQUMsRUFBRCxFQUFJLEVBQUosQ0FBdEw7QUFDQSxZQUFJdlAsU0FBUyxFQUFDd1AsT0FBTyxTQUFTQSxLQUFULEdBQWlCLENBQUcsQ0FBNUI7QUFDYkMsZ0JBQUksRUFEUztBQUViQyxzQkFBVSxFQUFDLFNBQVEsQ0FBVCxFQUFXLGNBQWEsQ0FBeEIsRUFBMEIsVUFBUyxDQUFuQyxFQUFxQyxjQUFhLENBQWxELEVBQW9ELFVBQVMsQ0FBN0QsRUFBK0QsbUJBQWtCLENBQWpGLEVBQW1GLFFBQU8sQ0FBMUYsRUFBNEYsc0JBQXFCLENBQWpILEVBQW1ILFFBQU8sRUFBMUgsRUFBNkgsU0FBUSxFQUFySSxFQUF3SSxZQUFXLEVBQW5KLEVBQXNKLGFBQVksRUFBbEssRUFBcUssT0FBTSxFQUEzSyxFQUE4SyxjQUFhLEVBQTNMLEVBQThMLGFBQVksRUFBMU0sRUFBNk0sS0FBSSxFQUFqTixFQUFvTixLQUFJLEVBQXhOLEVBQTJOLGtCQUFpQixFQUE1TyxFQUErTyxjQUFhLEVBQTVQLEVBQStQLEtBQUksRUFBblEsRUFBc1EsS0FBSSxFQUExUSxFQUE2USxLQUFJLEVBQWpSLEVBQW9SLEtBQUksRUFBeFIsRUFBMlIsbUJBQWtCLEVBQTdTLEVBQWdULFdBQVUsQ0FBMVQsRUFBNFQsUUFBTyxDQUFuVSxFQUZHO0FBR2JDLHdCQUFZLEVBQUMsR0FBRSxPQUFILEVBQVcsR0FBRSxRQUFiLEVBQXNCLEdBQUUsUUFBeEIsRUFBaUMsR0FBRSxNQUFuQyxFQUEwQyxJQUFHLE1BQTdDLEVBQW9ELElBQUcsT0FBdkQsRUFBK0QsSUFBRyxLQUFsRSxFQUF3RSxJQUFHLEdBQTNFLEVBQStFLElBQUcsR0FBbEYsRUFBc0YsSUFBRyxHQUF6RixFQUE2RixJQUFHLEdBQWhHLEVBQW9HLElBQUcsR0FBdkcsRUFBMkcsSUFBRyxHQUE5RyxFQUhDO0FBSWJDLDBCQUFjLENBQUMsQ0FBRCxFQUFHLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBSCxFQUFTLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBVCxFQUFlLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBZixFQUFxQixDQUFDLENBQUQsRUFBRyxDQUFILENBQXJCLEVBQTJCLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBM0IsRUFBaUMsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFqQyxFQUF3QyxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXhDLEVBQStDLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBL0MsRUFBc0QsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUF0RCxFQUE2RCxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQTdELEVBQW9FLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBcEUsRUFBMkUsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUEzRSxFQUFrRixDQUFDLEVBQUQsRUFBSSxDQUFKLENBQWxGLEVBQXlGLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBekYsRUFBZ0csQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFoRyxFQUF1RyxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQXZHLEVBQThHLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBOUcsRUFBcUgsQ0FBQyxFQUFELEVBQUksQ0FBSixDQUFySCxFQUE0SCxDQUFDLEVBQUQsRUFBSSxDQUFKLENBQTVILEVBQW1JLENBQUMsRUFBRCxFQUFJLENBQUosQ0FBbkksRUFBMEksQ0FBQyxFQUFELEVBQUksQ0FBSixDQUExSSxDQUpEO0FBS2JDLDJCQUFlLFNBQVNDLFNBQVQsQ0FBbUJDLE1BQW5CLEVBQTJCQyxNQUEzQixFQUFtQ0MsUUFBbkMsRUFBNkNSLEVBQTdDLEVBQWlEUyxPQUFqRCxDQUF5RCxlQUF6RCxFQUEwRUMsRUFBMUUsQ0FBNkUsWUFBN0UsRUFBMkZDLEVBQTNGLENBQThGLFlBQTlGLEVBQTRHO0FBQzNIOztBQUVBLG9CQUFJQyxLQUFLRixHQUFHcHlDLE1BQUgsR0FBWSxDQUFyQjtBQUNBLHdCQUFRbXlDLE9BQVI7QUFDQSx5QkFBSyxDQUFMO0FBQ0M7QUFDUyw2QkFBS0ksQ0FBTCxHQUFTLElBQUkxM0IsTUFBSixDQUFXbTNCLE9BQU94eEMsT0FBUCxDQUFlLFdBQWYsRUFBNEIsTUFBSSxHQUFoQyxFQUNSQSxPQURRLENBQ0EsTUFEQSxFQUNPLElBRFAsRUFFUkEsT0FGUSxDQUVBLE1BRkEsRUFFTyxJQUZQLEVBR1JBLE9BSFEsQ0FHQSxNQUhBLEVBR08sSUFIUCxFQUlSQSxPQUpRLENBSUEsTUFKQSxFQUlPLElBSlAsRUFLUkEsT0FMUSxDQUtBLE1BTEEsRUFLTyxJQUxQLEVBTVJBLE9BTlEsQ0FNQSxNQU5BLEVBTU8sSUFOUCxDQUFYLENBQVQ7QUFPQSw2QkFBSyt4QyxDQUFMLENBQU83RyxRQUFQLEdBQW1CLEtBQUsyRyxFQUFMLENBQVFHLFVBQTNCOztBQUVWO0FBQ0EseUJBQUssQ0FBTDs7QUFFWSw2QkFBS0QsQ0FBTCxHQUFTLElBQUl6a0IsTUFBSixDQUFXa2tCLE1BQVgsQ0FBVDtBQUNBLDZCQUFLTyxDQUFMLENBQU83RyxRQUFQLEdBQW1CLEtBQUsyRyxFQUFMLENBQVFHLFVBQTNCOztBQUVaO0FBQ0EseUJBQUssQ0FBTDs7QUFFWSw2QkFBS0QsQ0FBTCxHQUFTLElBQVQ7O0FBRVo7QUFDQSx5QkFBSyxDQUFMOztBQUVZLDZCQUFLQSxDQUFMLEdBQVMsSUFBSTdrQixPQUFKLENBQVksSUFBWixDQUFUO0FBQ0EsNkJBQUs2a0IsQ0FBTCxDQUFPN0csUUFBUCxHQUFrQixLQUFLMkcsRUFBTCxDQUFRRyxVQUExQjs7QUFFWjtBQUNBLHlCQUFLLENBQUw7O0FBRVksNkJBQUtELENBQUwsR0FBUyxJQUFJN2tCLE9BQUosQ0FBWSxLQUFaLENBQVQ7QUFDQSw2QkFBSzZrQixDQUFMLENBQU83RyxRQUFQLEdBQWtCLEtBQUsyRyxFQUFMLENBQVFHLFVBQTFCOztBQUVaO0FBQ0EseUJBQUssQ0FBTDtBQUNBLCtCQUFPLEtBQUtELENBQUwsR0FBU0gsR0FBR0UsS0FBRyxDQUFOLENBQWhCO0FBQ0EseUJBQUssRUFBTDtBQUNBLDZCQUFLQyxDQUFMLEdBQVMsRUFBVCxDQUFhNzVCLE9BQU8rNUIsY0FBUCxDQUFzQixLQUFLRixDQUEzQixFQUE4QixVQUE5QixFQUEwQztBQUMzQzFtQyxtQ0FBTyxLQUFLd21DLEVBQUwsQ0FBUUcsVUFENEI7QUFFM0NFLHdDQUFZO0FBRitCLHlCQUExQztBQUliO0FBQ0EseUJBQUssRUFBTCxDQUFTLEtBQUssRUFBTDtBQUNULDZCQUFLSCxDQUFMLEdBQVNILEdBQUdFLEtBQUcsQ0FBTixDQUFULENBQW1CNTVCLE9BQU8rNUIsY0FBUCxDQUFzQixLQUFLRixDQUEzQixFQUE4QixVQUE5QixFQUEwQztBQUNqRDFtQyxtQ0FBTyxLQUFLd21DLEVBQUwsQ0FBUUcsVUFEa0M7QUFFakRFLHdDQUFZO0FBRnFDLHlCQUExQztBQUluQjtBQUNBLHlCQUFLLEVBQUw7QUFDQSw2QkFBS0gsQ0FBTCxHQUFTLENBQUNILEdBQUdFLEtBQUcsQ0FBTixDQUFELEVBQVdGLEdBQUdFLEVBQUgsQ0FBWCxDQUFUO0FBQ0E7QUFDQSx5QkFBSyxFQUFMO0FBQ0EsNkJBQUtDLENBQUwsR0FBUyxFQUFULENBQWEsS0FBS0EsQ0FBTCxDQUFPSCxHQUFHRSxFQUFILEVBQU8sQ0FBUCxDQUFQLElBQW9CRixHQUFHRSxFQUFILEVBQU8sQ0FBUCxDQUFwQjtBQUNiO0FBQ0EseUJBQUssRUFBTDtBQUNBLDZCQUFLQyxDQUFMLEdBQVNILEdBQUdFLEtBQUcsQ0FBTixDQUFULENBQW1CRixHQUFHRSxLQUFHLENBQU4sRUFBU0YsR0FBR0UsRUFBSCxFQUFPLENBQVAsQ0FBVCxJQUFzQkYsR0FBR0UsRUFBSCxFQUFPLENBQVAsQ0FBdEI7QUFDbkI7QUFDQSx5QkFBSyxFQUFMO0FBQ0EsNkJBQUtDLENBQUwsR0FBUyxFQUFULENBQWE3NUIsT0FBTys1QixjQUFQLENBQXNCLEtBQUtGLENBQTNCLEVBQThCLFVBQTlCLEVBQTBDO0FBQzNDMW1DLG1DQUFPLEtBQUt3bUMsRUFBTCxDQUFRRyxVQUQ0QjtBQUUzQ0Usd0NBQVk7QUFGK0IseUJBQTFDO0FBSWI7QUFDQSx5QkFBSyxFQUFMO0FBQ0EsNkJBQUtILENBQUwsR0FBUyxDQUFDSCxHQUFHRSxFQUFILENBQUQsQ0FBVDtBQUNBO0FBQ0EseUJBQUssRUFBTDtBQUNBLDZCQUFLQyxDQUFMLEdBQVNILEdBQUdFLEtBQUcsQ0FBTixDQUFULENBQW1CRixHQUFHRSxLQUFHLENBQU4sRUFBUzN4QyxJQUFULENBQWN5eEMsR0FBR0UsRUFBSCxDQUFkO0FBQ25CO0FBdEVBO0FBd0VDLGFBakZZO0FBa0ZiSyxtQkFBTyxDQUFDLEVBQUMsR0FBRSxDQUFILEVBQUssR0FBRTVCLEdBQVAsRUFBVyxHQUFFLENBQWIsRUFBZSxHQUFFQyxHQUFqQixFQUFxQixHQUFFLENBQXZCLEVBQXlCLEdBQUVDLEdBQTNCLEVBQStCLEdBQUUsQ0FBakMsRUFBbUMsSUFBR0MsR0FBdEMsRUFBMEMsSUFBR0MsR0FBN0MsRUFBaUQsSUFBRyxDQUFwRCxFQUFzRCxJQUFHLENBQXpELEVBQTJELElBQUcsQ0FBOUQsRUFBZ0UsSUFBRyxDQUFuRSxFQUFxRSxJQUFHQyxHQUF4RSxFQUE0RSxJQUFHQyxHQUEvRSxFQUFELEVBQXFGLEVBQUMsR0FBRSxDQUFDLENBQUQsQ0FBSCxFQUFyRixFQUE2RixFQUFDLElBQUcsQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFKLEVBQTdGLEVBQXlHUCxFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFOLENBQXpHLEVBQXNIUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFOLENBQXRILEVBQW1JUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFOLENBQW5JLEVBQWdKUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQWhKLEVBQThKUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQTlKLEVBQTRLUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQTVLLEVBQTBMUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFOLENBQTFMLEVBQXVNUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFOLENBQXZNLEVBQW9OUixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFOLENBQXBOLEVBQWlPUixFQUFFLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLEVBQVUsRUFBVixFQUFhLEVBQWIsQ0FBRixFQUFtQixDQUFDLENBQUQsRUFBRyxDQUFILENBQW5CLENBQWpPLEVBQTJQQSxFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFOLENBQTNQLEVBQXdRLEVBQUMsR0FBRSxFQUFILEVBQU0sR0FBRVAsR0FBUixFQUFZLElBQUcsQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFmLEVBQXNCLElBQUcsRUFBekIsRUFBNEIsSUFBRyxFQUEvQixFQUF4USxFQUEyUyxFQUFDLEdBQUUsQ0FBSCxFQUFLLEdBQUVBLEdBQVAsRUFBVyxHQUFFLENBQWIsRUFBZSxHQUFFQyxHQUFqQixFQUFxQixHQUFFLENBQXZCLEVBQXlCLEdBQUVDLEdBQTNCLEVBQStCLEdBQUUsQ0FBakMsRUFBbUMsSUFBR0MsR0FBdEMsRUFBMEMsSUFBR0MsR0FBN0MsRUFBaUQsSUFBRyxFQUFwRCxFQUF1RCxJQUFHLENBQTFELEVBQTRELElBQUcsQ0FBL0QsRUFBaUUsSUFBR0MsR0FBcEUsRUFBd0UsSUFBR0MsR0FBM0UsRUFBK0UsSUFBRyxDQUFDLENBQUQsRUFBRyxFQUFILENBQWxGLEVBQXlGLElBQUcsRUFBNUYsRUFBM1MsRUFBMlksRUFBQyxHQUFFLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBSCxFQUEzWSxFQUFxWlAsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUFyWixFQUFtYSxFQUFDLElBQUcsQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFKLEVBQVcsSUFBRyxDQUFDLENBQUQsRUFBRyxFQUFILENBQWQsRUFBbmEsRUFBeWJSLEVBQUVTLEdBQUYsRUFBTSxDQUFDLENBQUQsRUFBRyxFQUFILENBQU4sQ0FBemIsRUFBdWMsRUFBQyxJQUFHLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBSixFQUF2YyxFQUFtZFQsRUFBRVEsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUFuZCxFQUFpZSxFQUFDLElBQUcsQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFKLEVBQVcsSUFBRyxDQUFDLENBQUQsRUFBRyxFQUFILENBQWQsRUFBamUsRUFBdWZSLEVBQUVVLEdBQUYsRUFBTSxDQUFDLENBQUQsRUFBRyxFQUFILENBQU4sQ0FBdmYsRUFBcWdCVixFQUFFUSxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQXJnQixFQUFtaEIsRUFBQyxHQUFFLEVBQUgsRUFBTSxHQUFFUCxHQUFSLEVBQVksSUFBRyxFQUFmLEVBQW5oQixFQUFzaUIsRUFBQyxHQUFFLENBQUgsRUFBSyxHQUFFQSxHQUFQLEVBQVcsR0FBRSxDQUFiLEVBQWUsR0FBRUMsR0FBakIsRUFBcUIsR0FBRSxDQUF2QixFQUF5QixHQUFFQyxHQUEzQixFQUErQixHQUFFLENBQWpDLEVBQW1DLElBQUdDLEdBQXRDLEVBQTBDLElBQUdDLEdBQTdDLEVBQWlELElBQUcsRUFBcEQsRUFBdUQsSUFBRyxDQUExRCxFQUE0RCxJQUFHLENBQS9ELEVBQWlFLElBQUdDLEdBQXBFLEVBQXdFLElBQUdDLEdBQTNFLEVBQXRpQixFQUFzbkJQLEVBQUVRLEdBQUYsRUFBTSxDQUFDLENBQUQsRUFBRyxFQUFILENBQU4sQ0FBdG5CLEVBQW9vQixFQUFDLEdBQUUsQ0FBSCxFQUFLLEdBQUVQLEdBQVAsRUFBVyxHQUFFLENBQWIsRUFBZSxHQUFFQyxHQUFqQixFQUFxQixHQUFFLENBQXZCLEVBQXlCLEdBQUVDLEdBQTNCLEVBQStCLEdBQUUsQ0FBakMsRUFBbUMsSUFBR0MsR0FBdEMsRUFBMEMsSUFBR0MsR0FBN0MsRUFBaUQsSUFBRyxFQUFwRCxFQUF1RCxJQUFHLENBQTFELEVBQTRELElBQUcsQ0FBL0QsRUFBaUUsSUFBR0MsR0FBcEUsRUFBd0UsSUFBR0MsR0FBM0UsRUFBcG9CLEVBQW90QlAsRUFBRVMsR0FBRixFQUFNLENBQUMsQ0FBRCxFQUFHLEVBQUgsQ0FBTixDQUFwdEIsRUFBa3VCVCxFQUFFUyxHQUFGLEVBQU0sQ0FBQyxDQUFELEVBQUcsRUFBSCxDQUFOLENBQWx1QixFQUFndkJULEVBQUVVLEdBQUYsRUFBTSxDQUFDLENBQUQsRUFBRyxFQUFILENBQU4sQ0FBaHZCLENBbEZNO0FBbUZib0IsNEJBQWdCLEVBQUMsSUFBRyxDQUFDLENBQUQsRUFBRyxDQUFILENBQUosRUFuRkg7QUFvRmJDLHdCQUFZLFNBQVNBLFVBQVQsQ0FBb0JqcUIsR0FBcEIsRUFBeUJ2SSxJQUF6QixFQUErQjtBQUN2QyxvQkFBSUEsS0FBS3l5QixXQUFULEVBQXNCO0FBQ2xCLHlCQUFLckIsS0FBTCxDQUFXN29CLEdBQVg7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsMEJBQU0sSUFBSWxtQixLQUFKLENBQVVrbUIsR0FBVixDQUFOO0FBQ0g7QUFDSixhQTFGWTtBQTJGYnBtQixtQkFBTyxTQUFTQSxLQUFULENBQWU0WixLQUFmLEVBQXNCO0FBQ3pCLG9CQUFJbEQsT0FBTyxJQUFYO0FBQUEsb0JBQWlCNjVCLFFBQVEsQ0FBQyxDQUFELENBQXpCO0FBQUEsb0JBQThCQyxTQUFTLENBQUMsSUFBRCxDQUF2QztBQUFBLG9CQUErQ0MsU0FBUyxFQUF4RDtBQUFBLG9CQUE0RE4sUUFBUSxLQUFLQSxLQUF6RTtBQUFBLG9CQUFnRlgsU0FBUyxFQUF6RjtBQUFBLG9CQUE2RkUsV0FBVyxDQUF4RztBQUFBLG9CQUEyR0QsU0FBUyxDQUFwSDtBQUFBLG9CQUF1SGlCLFNBQVMsQ0FBaEk7QUFBQSxvQkFBbUlDLE1BQU0sQ0FBekk7QUFDQSxvQkFBSWhuQixPQUFPOG1CLE9BQU9ub0MsS0FBUCxDQUFhd1QsSUFBYixDQUFrQjgwQixTQUFsQixFQUE2QixDQUE3QixDQUFYO0FBQ0Esb0JBQUlDLFFBQVEzNkIsT0FBT2lvQixNQUFQLENBQWMsS0FBSzBTLEtBQW5CLENBQVo7QUFDQSxvQkFBSUMsY0FBYyxFQUFFNUIsSUFBSSxFQUFOLEVBQWxCO0FBQ0EscUJBQUssSUFBSXgxQixDQUFULElBQWMsS0FBS3cxQixFQUFuQixFQUF1QjtBQUNuQix3QkFBSWg1QixPQUFPMkYsU0FBUCxDQUFpQlIsY0FBakIsQ0FBZ0NTLElBQWhDLENBQXFDLEtBQUtvekIsRUFBMUMsRUFBOEN4MUIsQ0FBOUMsQ0FBSixFQUFzRDtBQUNsRG8zQixvQ0FBWTVCLEVBQVosQ0FBZXgxQixDQUFmLElBQW9CLEtBQUt3MUIsRUFBTCxDQUFReDFCLENBQVIsQ0FBcEI7QUFDSDtBQUNKO0FBQ0RtM0Isc0JBQU1FLFFBQU4sQ0FBZW4zQixLQUFmLEVBQXNCazNCLFlBQVk1QixFQUFsQztBQUNBNEIsNEJBQVk1QixFQUFaLENBQWUyQixLQUFmLEdBQXVCQSxLQUF2QjtBQUNBQyw0QkFBWTVCLEVBQVosQ0FBZXpQLE1BQWYsR0FBd0IsSUFBeEI7QUFDQSxvQkFBSSxPQUFPb1IsTUFBTUcsTUFBYixJQUF1QixXQUEzQixFQUF3QztBQUNwQ0gsMEJBQU1HLE1BQU4sR0FBZSxFQUFmO0FBQ0g7QUFDRCxvQkFBSUMsUUFBUUosTUFBTUcsTUFBbEI7QUFDQVAsdUJBQU90eUMsSUFBUCxDQUFZOHlDLEtBQVo7QUFDQSxvQkFBSUMsU0FBU0wsTUFBTTk3QixPQUFOLElBQWlCODdCLE1BQU05N0IsT0FBTixDQUFjbThCLE1BQTVDO0FBQ0Esb0JBQUksT0FBT0osWUFBWTVCLEVBQVosQ0FBZW1CLFVBQXRCLEtBQXFDLFVBQXpDLEVBQXFEO0FBQ2pELHlCQUFLQSxVQUFMLEdBQWtCUyxZQUFZNUIsRUFBWixDQUFlbUIsVUFBakM7QUFDSCxpQkFGRCxNQUVPO0FBQ0gseUJBQUtBLFVBQUwsR0FBa0JuNkIsT0FBT2k3QixjQUFQLENBQXNCLElBQXRCLEVBQTRCZCxVQUE5QztBQUNIOztBQUVHLHlCQUFTZSxHQUFULEdBQWU7QUFDWCx3QkFBSUMsS0FBSjtBQUNBQSw0QkFBUVIsTUFBTU8sR0FBTixNQUFlVCxHQUF2QjtBQUNBLHdCQUFJLE9BQU9VLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0JBLGdDQUFRMzZCLEtBQUt5NEIsUUFBTCxDQUFja0MsS0FBZCxLQUF3QkEsS0FBaEM7QUFDSDtBQUNELDJCQUFPQSxLQUFQO0FBQ0g7QUFDTCxvQkFBSXhrQyxNQUFKO0FBQUEsb0JBQVl5a0MsS0FBWjtBQUFBLG9CQUFtQkMsTUFBbkI7QUFBQSxvQkFBMkJ0d0MsQ0FBM0I7QUFBQSxvQkFBOEJ1d0MsUUFBUSxFQUF0QztBQUFBLG9CQUEwQ2h4QixDQUExQztBQUFBLG9CQUE2Q3BFLEdBQTdDO0FBQUEsb0JBQWtEcTFCLFFBQWxEO0FBQUEsb0JBQTREanNCLFFBQTVEO0FBQ0EsdUJBQU8sSUFBUCxFQUFhO0FBQ1Q4ckIsNEJBQVFmLE1BQU1BLE1BQU0veUMsTUFBTixHQUFlLENBQXJCLENBQVI7QUFDQSx3QkFBSSxLQUFLNHlDLGNBQUwsQ0FBb0JrQixLQUFwQixDQUFKLEVBQWdDO0FBQzVCQyxpQ0FBUyxLQUFLbkIsY0FBTCxDQUFvQmtCLEtBQXBCLENBQVQ7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsNEJBQUl6a0MsV0FBVyxJQUFYLElBQW1CLE9BQU9BLE1BQVAsSUFBaUIsV0FBeEMsRUFBcUQ7QUFDakRBLHFDQUFTdWtDLEtBQVQ7QUFDSDtBQUNERyxpQ0FBU3BCLE1BQU1tQixLQUFOLEtBQWdCbkIsTUFBTW1CLEtBQU4sRUFBYXprQyxNQUFiLENBQXpCO0FBQ0g7QUFDVyx3QkFBSSxPQUFPMGtDLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsQ0FBQ0EsT0FBTy96QyxNQUF6QyxJQUFtRCxDQUFDK3pDLE9BQU8sQ0FBUCxDQUF4RCxFQUFtRTtBQUN2RSw0QkFBSUcsU0FBUyxFQUFiO0FBQ0Fsc0IsbUNBQVcsRUFBWDtBQUNBLDZCQUFLaEYsQ0FBTCxJQUFVMnZCLE1BQU1tQixLQUFOLENBQVYsRUFBd0I7QUFDcEIsZ0NBQUksS0FBS2xDLFVBQUwsQ0FBZ0I1dUIsQ0FBaEIsS0FBc0JBLElBQUlrd0IsTUFBOUIsRUFBc0M7QUFDbENsckIseUNBQVNybkIsSUFBVCxDQUFjLE9BQU8sS0FBS2l4QyxVQUFMLENBQWdCNXVCLENBQWhCLENBQVAsR0FBNEIsSUFBMUM7QUFDSDtBQUNKO0FBQ0QsNEJBQUlxd0IsTUFBTWMsWUFBVixFQUF3QjtBQUNwQkQscUNBQVMsMEJBQTBCaEMsV0FBVyxDQUFyQyxJQUEwQyxLQUExQyxHQUFrRG1CLE1BQU1jLFlBQU4sRUFBbEQsR0FBeUUsY0FBekUsR0FBMEZuc0IsU0FBU2pkLElBQVQsQ0FBYyxJQUFkLENBQTFGLEdBQWdILFVBQWhILElBQThILEtBQUs2bUMsVUFBTCxDQUFnQnZpQyxNQUFoQixLQUEyQkEsTUFBekosSUFBbUssSUFBNUs7QUFDSCx5QkFGRCxNQUVPO0FBQ0g2a0MscUNBQVMsMEJBQTBCaEMsV0FBVyxDQUFyQyxJQUEwQyxlQUExQyxJQUE2RDdpQyxVQUFVOGpDLEdBQVYsR0FBZ0IsY0FBaEIsR0FBaUMsUUFBUSxLQUFLdkIsVUFBTCxDQUFnQnZpQyxNQUFoQixLQUEyQkEsTUFBbkMsSUFBNkMsSUFBM0ksQ0FBVDtBQUNIO0FBQ0QsNkJBQUt3akMsVUFBTCxDQUFnQnFCLE1BQWhCLEVBQXdCO0FBQ3BCbnBCLGtDQUFNc29CLE1BQU1yeEMsS0FEUTtBQUVwQjZ4QyxtQ0FBTyxLQUFLakMsVUFBTCxDQUFnQnZpQyxNQUFoQixLQUEyQkEsTUFGZDtBQUdwQkQsa0NBQU1pa0MsTUFBTW5CLFFBSFE7QUFJcEJrQyxpQ0FBS1gsS0FKZTtBQUtwQnpyQixzQ0FBVUE7QUFMVSx5QkFBeEI7QUFPSDtBQUNMLHdCQUFJK3JCLE9BQU8sQ0FBUCxhQUFxQmwwQyxLQUFyQixJQUE4QmswQyxPQUFPL3pDLE1BQVAsR0FBZ0IsQ0FBbEQsRUFBcUQ7QUFDakQsOEJBQU0sSUFBSTBDLEtBQUosQ0FBVSxzREFBc0RveEMsS0FBdEQsR0FBOEQsV0FBOUQsR0FBNEV6a0MsTUFBdEYsQ0FBTjtBQUNIO0FBQ0QsNEJBQVEwa0MsT0FBTyxDQUFQLENBQVI7QUFDQSw2QkFBSyxDQUFMO0FBQ0loQixrQ0FBTXB5QyxJQUFOLENBQVcwTyxNQUFYO0FBQ0EyakMsbUNBQU9yeUMsSUFBUCxDQUFZMHlDLE1BQU1yQixNQUFsQjtBQUNBaUIsbUNBQU90eUMsSUFBUCxDQUFZMHlDLE1BQU1HLE1BQWxCO0FBQ0FULGtDQUFNcHlDLElBQU4sQ0FBV296QyxPQUFPLENBQVAsQ0FBWDtBQUNBMWtDLHFDQUFTLElBQVQ7QUFDQTtBQUNJNGlDLHlDQUFTb0IsTUFBTXBCLE1BQWY7QUFDQUQseUNBQVNxQixNQUFNckIsTUFBZjtBQUNBRSwyQ0FBV21CLE1BQU1uQixRQUFqQjtBQUNBdUIsd0NBQVFKLE1BQU1HLE1BQWQ7QUFDSDtBQUNEO0FBQ0osNkJBQUssQ0FBTDtBQUNJNTBCLGtDQUFNLEtBQUtpekIsWUFBTCxDQUFrQmtDLE9BQU8sQ0FBUCxDQUFsQixFQUE2QixDQUE3QixDQUFOO0FBQ0FDLGtDQUFNekIsQ0FBTixHQUFVUyxPQUFPQSxPQUFPaHpDLE1BQVAsR0FBZ0I0ZSxHQUF2QixDQUFWO0FBQ0FvMUIsa0NBQU0zQixFQUFOLEdBQVc7QUFDUEcsNENBQVlTLE9BQU9BLE9BQU9qekMsTUFBUCxJQUFpQjRlLE9BQU8sQ0FBeEIsQ0FBUCxFQUFtQzR6QixVQUR4QztBQUVQNkIsMkNBQVdwQixPQUFPQSxPQUFPanpDLE1BQVAsR0FBZ0IsQ0FBdkIsRUFBMEJxMEMsU0FGOUI7QUFHUEMsOENBQWNyQixPQUFPQSxPQUFPanpDLE1BQVAsSUFBaUI0ZSxPQUFPLENBQXhCLENBQVAsRUFBbUMwMUIsWUFIMUM7QUFJUEMsNkNBQWF0QixPQUFPQSxPQUFPanpDLE1BQVAsR0FBZ0IsQ0FBdkIsRUFBMEJ1MEM7QUFKaEMsNkJBQVg7QUFNQSxnQ0FBSWIsTUFBSixFQUFZO0FBQ1JNLHNDQUFNM0IsRUFBTixDQUFTcDlCLEtBQVQsR0FBaUIsQ0FDYmcrQixPQUFPQSxPQUFPanpDLE1BQVAsSUFBaUI0ZSxPQUFPLENBQXhCLENBQVAsRUFBbUMzSixLQUFuQyxDQUF5QyxDQUF6QyxDQURhLEVBRWJnK0IsT0FBT0EsT0FBT2p6QyxNQUFQLEdBQWdCLENBQXZCLEVBQTBCaVYsS0FBMUIsQ0FBZ0MsQ0FBaEMsQ0FGYSxDQUFqQjtBQUlIO0FBQ0R4UixnQ0FBSSxLQUFLcXVDLGFBQUwsQ0FBbUJ6eUMsS0FBbkIsQ0FBeUIyMEMsS0FBekIsRUFBZ0MsQ0FDaENoQyxNQURnQyxFQUVoQ0MsTUFGZ0MsRUFHaENDLFFBSGdDLEVBSWhDb0IsWUFBWTVCLEVBSm9CLEVBS2hDcUMsT0FBTyxDQUFQLENBTGdDLEVBTWhDZixNQU5nQyxFQU9oQ0MsTUFQZ0MsRUFRbENqK0IsTUFSa0MsQ0FRM0JtWCxJQVIyQixDQUFoQyxDQUFKO0FBU0EsZ0NBQUksT0FBTzFvQixDQUFQLEtBQWEsV0FBakIsRUFBOEI7QUFDMUIsdUNBQU9BLENBQVA7QUFDSDtBQUNELGdDQUFJbWIsR0FBSixFQUFTO0FBQ0xtMEIsd0NBQVFBLE1BQU1qb0MsS0FBTixDQUFZLENBQVosRUFBZSxDQUFDLENBQUQsR0FBSzhULEdBQUwsR0FBVyxDQUExQixDQUFSO0FBQ0FvMEIseUNBQVNBLE9BQU9sb0MsS0FBUCxDQUFhLENBQWIsRUFBZ0IsQ0FBQyxDQUFELEdBQUs4VCxHQUFyQixDQUFUO0FBQ0FxMEIseUNBQVNBLE9BQU9ub0MsS0FBUCxDQUFhLENBQWIsRUFBZ0IsQ0FBQyxDQUFELEdBQUs4VCxHQUFyQixDQUFUO0FBQ0g7QUFDRG0wQixrQ0FBTXB5QyxJQUFOLENBQVcsS0FBS2t4QyxZQUFMLENBQWtCa0MsT0FBTyxDQUFQLENBQWxCLEVBQTZCLENBQTdCLENBQVg7QUFDQWYsbUNBQU9yeUMsSUFBUCxDQUFZcXpDLE1BQU16QixDQUFsQjtBQUNBVSxtQ0FBT3R5QyxJQUFQLENBQVlxekMsTUFBTTNCLEVBQWxCO0FBQ0E0Qix1Q0FBV3RCLE1BQU1JLE1BQU1BLE1BQU0veUMsTUFBTixHQUFlLENBQXJCLENBQU4sRUFBK0IreUMsTUFBTUEsTUFBTS95QyxNQUFOLEdBQWUsQ0FBckIsQ0FBL0IsQ0FBWDtBQUNBK3lDLGtDQUFNcHlDLElBQU4sQ0FBV3N6QyxRQUFYO0FBQ0E7QUFDSiw2QkFBSyxDQUFMO0FBQ0ksbUNBQU8sSUFBUDtBQXJESjtBQXVESDtBQUNELHVCQUFPLElBQVA7QUFDSCxhQXhOWSxFQUFiO0FBeU5BO0FBQ0EsWUFBSVosUUFBUyxZQUFVO0FBQ3ZCLGdCQUFJQSxRQUFTOztBQUViRixxQkFBSSxDQUZTOztBQUliTiw0QkFBVyxTQUFTQSxVQUFULENBQW9CanFCLEdBQXBCLEVBQXlCdkksSUFBekIsRUFBK0I7QUFDbEMsd0JBQUksS0FBS3F4QixFQUFMLENBQVF6UCxNQUFaLEVBQW9CO0FBQ2hCLDZCQUFLeVAsRUFBTCxDQUFRelAsTUFBUixDQUFlNFEsVUFBZixDQUEwQmpxQixHQUExQixFQUErQnZJLElBQS9CO0FBQ0gscUJBRkQsTUFFTztBQUNILDhCQUFNLElBQUkzZCxLQUFKLENBQVVrbUIsR0FBVixDQUFOO0FBQ0g7QUFDSixpQkFWUTs7QUFZYjtBQUNBMnFCLDBCQUFTLGtCQUFVbjNCLEtBQVYsRUFBaUJzMUIsRUFBakIsRUFBcUI7QUFDdEIseUJBQUtBLEVBQUwsR0FBVUEsTUFBTSxLQUFLQSxFQUFYLElBQWlCLEVBQTNCO0FBQ0EseUJBQUs4QyxNQUFMLEdBQWNwNEIsS0FBZDtBQUNBLHlCQUFLcTRCLEtBQUwsR0FBYSxLQUFLQyxVQUFMLEdBQWtCLEtBQUtDLElBQUwsR0FBWSxLQUEzQztBQUNBLHlCQUFLekMsUUFBTCxHQUFnQixLQUFLRCxNQUFMLEdBQWMsQ0FBOUI7QUFDQSx5QkFBS0QsTUFBTCxHQUFjLEtBQUs0QyxPQUFMLEdBQWUsS0FBSzV5QyxLQUFMLEdBQWEsRUFBMUM7QUFDQSx5QkFBSzZ5QyxjQUFMLEdBQXNCLENBQUMsU0FBRCxDQUF0QjtBQUNBLHlCQUFLckIsTUFBTCxHQUFjO0FBQ1ZoQixvQ0FBWSxDQURGO0FBRVY4QixzQ0FBYyxDQUZKO0FBR1ZELG1DQUFXLENBSEQ7QUFJVkUscUNBQWE7QUFKSCxxQkFBZDtBQU1BLHdCQUFJLEtBQUtoOUIsT0FBTCxDQUFhbThCLE1BQWpCLEVBQXlCO0FBQ3JCLDZCQUFLRixNQUFMLENBQVl2K0IsS0FBWixHQUFvQixDQUFDLENBQUQsRUFBRyxDQUFILENBQXBCO0FBQ0g7QUFDRCx5QkFBSzYvQixNQUFMLEdBQWMsQ0FBZDtBQUNBLDJCQUFPLElBQVA7QUFDSCxpQkEvQlE7O0FBaUNiO0FBQ0ExNEIsdUJBQU0saUJBQVk7QUFDVix3QkFBSTI0QixLQUFLLEtBQUtQLE1BQUwsQ0FBWSxDQUFaLENBQVQ7QUFDQSx5QkFBS3hDLE1BQUwsSUFBZStDLEVBQWY7QUFDQSx5QkFBSzlDLE1BQUw7QUFDQSx5QkFBSzZDLE1BQUw7QUFDQSx5QkFBSzl5QyxLQUFMLElBQWMreUMsRUFBZDtBQUNBLHlCQUFLSCxPQUFMLElBQWdCRyxFQUFoQjtBQUNBLHdCQUFJQyxRQUFRRCxHQUFHL3lDLEtBQUgsQ0FBUyxpQkFBVCxDQUFaO0FBQ0Esd0JBQUlnekMsS0FBSixFQUFXO0FBQ1AsNkJBQUs5QyxRQUFMO0FBQ0EsNkJBQUtzQixNQUFMLENBQVlhLFNBQVo7QUFDSCxxQkFIRCxNQUdPO0FBQ0gsNkJBQUtiLE1BQUwsQ0FBWWUsV0FBWjtBQUNIO0FBQ0Qsd0JBQUksS0FBS2g5QixPQUFMLENBQWFtOEIsTUFBakIsRUFBeUI7QUFDckIsNkJBQUtGLE1BQUwsQ0FBWXYrQixLQUFaLENBQWtCLENBQWxCO0FBQ0g7O0FBRUQseUJBQUt1L0IsTUFBTCxHQUFjLEtBQUtBLE1BQUwsQ0FBWTFwQyxLQUFaLENBQWtCLENBQWxCLENBQWQ7QUFDQSwyQkFBT2lxQyxFQUFQO0FBQ0gsaUJBdERROztBQXdEYjtBQUNBRSx1QkFBTSxlQUFVRixFQUFWLEVBQWM7QUFDWix3QkFBSW4yQixNQUFNbTJCLEdBQUcvMEMsTUFBYjtBQUNBLHdCQUFJZzFDLFFBQVFELEdBQUd4MEMsS0FBSCxDQUFTLGVBQVQsQ0FBWjs7QUFFQSx5QkFBS2kwQyxNQUFMLEdBQWNPLEtBQUssS0FBS1AsTUFBeEI7QUFDQSx5QkFBS3hDLE1BQUwsR0FBYyxLQUFLQSxNQUFMLENBQVlobkMsTUFBWixDQUFtQixDQUFuQixFQUFzQixLQUFLZ25DLE1BQUwsQ0FBWWh5QyxNQUFaLEdBQXFCNGUsR0FBM0MsQ0FBZDtBQUNBO0FBQ0EseUJBQUtrMkIsTUFBTCxJQUFlbDJCLEdBQWY7QUFDQSx3QkFBSXMyQixXQUFXLEtBQUtsekMsS0FBTCxDQUFXekIsS0FBWCxDQUFpQixlQUFqQixDQUFmO0FBQ0EseUJBQUt5QixLQUFMLEdBQWEsS0FBS0EsS0FBTCxDQUFXZ0osTUFBWCxDQUFrQixDQUFsQixFQUFxQixLQUFLaEosS0FBTCxDQUFXaEMsTUFBWCxHQUFvQixDQUF6QyxDQUFiO0FBQ0EseUJBQUs0MEMsT0FBTCxHQUFlLEtBQUtBLE9BQUwsQ0FBYTVwQyxNQUFiLENBQW9CLENBQXBCLEVBQXVCLEtBQUs0cEMsT0FBTCxDQUFhNTBDLE1BQWIsR0FBc0IsQ0FBN0MsQ0FBZjs7QUFFQSx3QkFBSWcxQyxNQUFNaDFDLE1BQU4sR0FBZSxDQUFuQixFQUFzQjtBQUNsQiw2QkFBS2t5QyxRQUFMLElBQWlCOEMsTUFBTWgxQyxNQUFOLEdBQWUsQ0FBaEM7QUFDSDtBQUNELHdCQUFJeUQsSUFBSSxLQUFLK3ZDLE1BQUwsQ0FBWXYrQixLQUFwQjs7QUFFQSx5QkFBS3UrQixNQUFMLEdBQWM7QUFDVmhCLG9DQUFZLEtBQUtnQixNQUFMLENBQVloQixVQURkO0FBRVY2QixtQ0FBVyxLQUFLbkMsUUFBTCxHQUFnQixDQUZqQjtBQUdWb0Msc0NBQWMsS0FBS2QsTUFBTCxDQUFZYyxZQUhoQjtBQUlWQyxxQ0FBYVMsUUFDVCxDQUFDQSxNQUFNaDFDLE1BQU4sS0FBaUJrMUMsU0FBU2wxQyxNQUExQixHQUFtQyxLQUFLd3pDLE1BQUwsQ0FBWWMsWUFBL0MsR0FBOEQsQ0FBL0QsSUFDR1ksU0FBU0EsU0FBU2wxQyxNQUFULEdBQWtCZzFDLE1BQU1oMUMsTUFBakMsRUFBeUNBLE1BRDVDLEdBQ3FEZzFDLE1BQU0sQ0FBTixFQUFTaDFDLE1BRnJELEdBR1gsS0FBS3d6QyxNQUFMLENBQVljLFlBQVosR0FBMkIxMUI7QUFQbkIscUJBQWQ7O0FBVUEsd0JBQUksS0FBS3JILE9BQUwsQ0FBYW04QixNQUFqQixFQUF5QjtBQUNyQiw2QkFBS0YsTUFBTCxDQUFZditCLEtBQVosR0FBb0IsQ0FBQ3hSLEVBQUUsQ0FBRixDQUFELEVBQU9BLEVBQUUsQ0FBRixJQUFPLEtBQUt3dUMsTUFBWixHQUFxQnJ6QixHQUE1QixDQUFwQjtBQUNIO0FBQ0QseUJBQUtxekIsTUFBTCxHQUFjLEtBQUtELE1BQUwsQ0FBWWh5QyxNQUExQjtBQUNBLDJCQUFPLElBQVA7QUFDSCxpQkF6RlE7O0FBMkZiO0FBQ0FtMUMsc0JBQUssZ0JBQVk7QUFDVCx5QkFBS1YsS0FBTCxHQUFhLElBQWI7QUFDQSwyQkFBTyxJQUFQO0FBQ0gsaUJBL0ZROztBQWlHYjtBQUNBbnlDLHdCQUFPLGtCQUFZO0FBQ1gsd0JBQUksS0FBS2lWLE9BQUwsQ0FBYTY5QixlQUFqQixFQUFrQztBQUM5Qiw2QkFBS1YsVUFBTCxHQUFrQixJQUFsQjtBQUNILHFCQUZELE1BRU87QUFDSCwrQkFBTyxLQUFLN0IsVUFBTCxDQUFnQiw0QkFBNEIsS0FBS1gsUUFBTCxHQUFnQixDQUE1QyxJQUFpRCxrSUFBakQsR0FBc0wsS0FBS2lDLFlBQUwsRUFBdE0sRUFBMk47QUFDOU5wcEIsa0NBQU0sRUFEd047QUFFOU44b0IsbUNBQU8sSUFGdU47QUFHOU56a0Msa0NBQU0sS0FBSzhpQztBQUhtTix5QkFBM04sQ0FBUDtBQU1IO0FBQ0QsMkJBQU8sSUFBUDtBQUNILGlCQTlHUTs7QUFnSGI7QUFDQW1ELHNCQUFLLGNBQVU5NEIsQ0FBVixFQUFhO0FBQ1YseUJBQUswNEIsS0FBTCxDQUFXLEtBQUtqekMsS0FBTCxDQUFXOEksS0FBWCxDQUFpQnlSLENBQWpCLENBQVg7QUFDSCxpQkFuSFE7O0FBcUhiO0FBQ0ErNEIsMkJBQVUscUJBQVk7QUFDZCx3QkFBSUMsT0FBTyxLQUFLWCxPQUFMLENBQWE1cEMsTUFBYixDQUFvQixDQUFwQixFQUF1QixLQUFLNHBDLE9BQUwsQ0FBYTUwQyxNQUFiLEdBQXNCLEtBQUtnQyxLQUFMLENBQVdoQyxNQUF4RCxDQUFYO0FBQ0EsMkJBQU8sQ0FBQ3UxQyxLQUFLdjFDLE1BQUwsR0FBYyxFQUFkLEdBQW1CLEtBQW5CLEdBQXlCLEVBQTFCLElBQWdDdTFDLEtBQUt2cUMsTUFBTCxDQUFZLENBQUMsRUFBYixFQUFpQnhLLE9BQWpCLENBQXlCLEtBQXpCLEVBQWdDLEVBQWhDLENBQXZDO0FBQ0gsaUJBekhROztBQTJIYjtBQUNBZzFDLCtCQUFjLHlCQUFZO0FBQ2xCLHdCQUFJQyxPQUFPLEtBQUt6ekMsS0FBaEI7QUFDQSx3QkFBSXl6QyxLQUFLejFDLE1BQUwsR0FBYyxFQUFsQixFQUFzQjtBQUNsQnkxQyxnQ0FBUSxLQUFLakIsTUFBTCxDQUFZeHBDLE1BQVosQ0FBbUIsQ0FBbkIsRUFBc0IsS0FBR3lxQyxLQUFLejFDLE1BQTlCLENBQVI7QUFDSDtBQUNELDJCQUFPLENBQUN5MUMsS0FBS3pxQyxNQUFMLENBQVksQ0FBWixFQUFjLEVBQWQsS0FBcUJ5cUMsS0FBS3oxQyxNQUFMLEdBQWMsRUFBZCxHQUFtQixLQUFuQixHQUEyQixFQUFoRCxDQUFELEVBQXNEUSxPQUF0RCxDQUE4RCxLQUE5RCxFQUFxRSxFQUFyRSxDQUFQO0FBQ0gsaUJBbElROztBQW9JYjtBQUNBMnpDLDhCQUFhLHdCQUFZO0FBQ2pCLHdCQUFJdUIsTUFBTSxLQUFLSixTQUFMLEVBQVY7QUFDQSx3QkFBSTNuQixJQUFJLElBQUk5dEIsS0FBSixDQUFVNjFDLElBQUkxMUMsTUFBSixHQUFhLENBQXZCLEVBQTBCK0ssSUFBMUIsQ0FBK0IsR0FBL0IsQ0FBUjtBQUNBLDJCQUFPMnFDLE1BQU0sS0FBS0YsYUFBTCxFQUFOLEdBQTZCLElBQTdCLEdBQW9DN25CLENBQXBDLEdBQXdDLEdBQS9DO0FBQ0gsaUJBeklROztBQTJJYjtBQUNBZ29CLDRCQUFXLG9CQUFVM3pDLEtBQVYsRUFBaUI0ekMsWUFBakIsRUFBK0I7QUFDbEMsd0JBQUkvQixLQUFKLEVBQ0ltQixLQURKLEVBRUlhLE1BRko7O0FBSUEsd0JBQUksS0FBS3QrQixPQUFMLENBQWE2OUIsZUFBakIsRUFBa0M7QUFDOUI7QUFDQVMsaUNBQVM7QUFDTDNELHNDQUFVLEtBQUtBLFFBRFY7QUFFTHNCLG9DQUFRO0FBQ0poQiw0Q0FBWSxLQUFLZ0IsTUFBTCxDQUFZaEIsVUFEcEI7QUFFSjZCLDJDQUFXLEtBQUtBLFNBRlo7QUFHSkMsOENBQWMsS0FBS2QsTUFBTCxDQUFZYyxZQUh0QjtBQUlKQyw2Q0FBYSxLQUFLZixNQUFMLENBQVllO0FBSnJCLDZCQUZIO0FBUUx2QyxvQ0FBUSxLQUFLQSxNQVJSO0FBU0xod0MsbUNBQU8sS0FBS0EsS0FUUDtBQVVMOHpDLHFDQUFTLEtBQUtBLE9BVlQ7QUFXTGxCLHFDQUFTLEtBQUtBLE9BWFQ7QUFZTDNDLG9DQUFRLEtBQUtBLE1BWlI7QUFhTDZDLG9DQUFRLEtBQUtBLE1BYlI7QUFjTEwsbUNBQU8sS0FBS0EsS0FkUDtBQWVMRCxvQ0FBUSxLQUFLQSxNQWZSO0FBZ0JMOUMsZ0NBQUksS0FBS0EsRUFoQko7QUFpQkxtRCw0Q0FBZ0IsS0FBS0EsY0FBTCxDQUFvQi9wQyxLQUFwQixDQUEwQixDQUExQixDQWpCWDtBQWtCTDZwQyxrQ0FBTSxLQUFLQTtBQWxCTix5QkFBVDtBQW9CQSw0QkFBSSxLQUFLcDlCLE9BQUwsQ0FBYW04QixNQUFqQixFQUF5QjtBQUNyQm1DLG1DQUFPckMsTUFBUCxDQUFjditCLEtBQWQsR0FBc0IsS0FBS3UrQixNQUFMLENBQVl2K0IsS0FBWixDQUFrQm5LLEtBQWxCLENBQXdCLENBQXhCLENBQXRCO0FBQ0g7QUFDSjs7QUFFRGtxQyw0QkFBUWh6QyxNQUFNLENBQU4sRUFBU0EsS0FBVCxDQUFlLGlCQUFmLENBQVI7QUFDQSx3QkFBSWd6QyxLQUFKLEVBQVc7QUFDUCw2QkFBSzlDLFFBQUwsSUFBaUI4QyxNQUFNaDFDLE1BQXZCO0FBQ0g7QUFDRCx5QkFBS3d6QyxNQUFMLEdBQWM7QUFDVmhCLG9DQUFZLEtBQUtnQixNQUFMLENBQVlhLFNBRGQ7QUFFVkEsbUNBQVcsS0FBS25DLFFBQUwsR0FBZ0IsQ0FGakI7QUFHVm9DLHNDQUFjLEtBQUtkLE1BQUwsQ0FBWWUsV0FIaEI7QUFJVkEscUNBQWFTLFFBQ0FBLE1BQU1BLE1BQU1oMUMsTUFBTixHQUFlLENBQXJCLEVBQXdCQSxNQUF4QixHQUFpQ2cxQyxNQUFNQSxNQUFNaDFDLE1BQU4sR0FBZSxDQUFyQixFQUF3QmdDLEtBQXhCLENBQThCLFFBQTlCLEVBQXdDLENBQXhDLEVBQTJDaEMsTUFENUUsR0FFQSxLQUFLd3pDLE1BQUwsQ0FBWWUsV0FBWixHQUEwQnZ5QyxNQUFNLENBQU4sRUFBU2hDO0FBTnRDLHFCQUFkO0FBUUEseUJBQUtneUMsTUFBTCxJQUFlaHdDLE1BQU0sQ0FBTixDQUFmO0FBQ0EseUJBQUtBLEtBQUwsSUFBY0EsTUFBTSxDQUFOLENBQWQ7QUFDQSx5QkFBSzh6QyxPQUFMLEdBQWU5ekMsS0FBZjtBQUNBLHlCQUFLaXdDLE1BQUwsR0FBYyxLQUFLRCxNQUFMLENBQVloeUMsTUFBMUI7QUFDQSx3QkFBSSxLQUFLdVgsT0FBTCxDQUFhbThCLE1BQWpCLEVBQXlCO0FBQ3JCLDZCQUFLRixNQUFMLENBQVl2K0IsS0FBWixHQUFvQixDQUFDLEtBQUs2L0IsTUFBTixFQUFjLEtBQUtBLE1BQUwsSUFBZSxLQUFLN0MsTUFBbEMsQ0FBcEI7QUFDSDtBQUNELHlCQUFLd0MsS0FBTCxHQUFhLEtBQWI7QUFDQSx5QkFBS0MsVUFBTCxHQUFrQixLQUFsQjtBQUNBLHlCQUFLRixNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZMXBDLEtBQVosQ0FBa0I5SSxNQUFNLENBQU4sRUFBU2hDLE1BQTNCLENBQWQ7QUFDQSx5QkFBSzQwQyxPQUFMLElBQWdCNXlDLE1BQU0sQ0FBTixDQUFoQjtBQUNBNnhDLDRCQUFRLEtBQUsvQixhQUFMLENBQW1CeHpCLElBQW5CLENBQXdCLElBQXhCLEVBQThCLEtBQUtvekIsRUFBbkMsRUFBdUMsSUFBdkMsRUFBNkNrRSxZQUE3QyxFQUEyRCxLQUFLZixjQUFMLENBQW9CLEtBQUtBLGNBQUwsQ0FBb0I3MEMsTUFBcEIsR0FBNkIsQ0FBakQsQ0FBM0QsQ0FBUjtBQUNBLHdCQUFJLEtBQUsyMEMsSUFBTCxJQUFhLEtBQUtILE1BQXRCLEVBQThCO0FBQzFCLDZCQUFLRyxJQUFMLEdBQVksS0FBWjtBQUNIO0FBQ0Qsd0JBQUlkLEtBQUosRUFBVztBQUNQLCtCQUFPQSxLQUFQO0FBQ0gscUJBRkQsTUFFTyxJQUFJLEtBQUthLFVBQVQsRUFBcUI7QUFDeEI7QUFDQSw2QkFBSyxJQUFJeDRCLENBQVQsSUFBYzI1QixNQUFkLEVBQXNCO0FBQ2xCLGlDQUFLMzVCLENBQUwsSUFBVTI1QixPQUFPMzVCLENBQVAsQ0FBVjtBQUNIO0FBQ0QsK0JBQU8sS0FBUCxDQUx3QixDQUtWO0FBQ2pCO0FBQ0QsMkJBQU8sS0FBUDtBQUNILGlCQWpOUTs7QUFtTmI7QUFDQXU1QixzQkFBSyxnQkFBWTtBQUNULHdCQUFJLEtBQUtkLElBQVQsRUFBZTtBQUNYLCtCQUFPLEtBQUt4QixHQUFaO0FBQ0g7QUFDRCx3QkFBSSxDQUFDLEtBQUtxQixNQUFWLEVBQWtCO0FBQ2QsNkJBQUtHLElBQUwsR0FBWSxJQUFaO0FBQ0g7O0FBRUQsd0JBQUlkLEtBQUosRUFDSTd4QyxLQURKLEVBRUkrekMsU0FGSixFQUdJOTlCLEtBSEo7QUFJQSx3QkFBSSxDQUFDLEtBQUt3OEIsS0FBVixFQUFpQjtBQUNiLDZCQUFLekMsTUFBTCxHQUFjLEVBQWQ7QUFDQSw2QkFBS2h3QyxLQUFMLEdBQWEsRUFBYjtBQUNIO0FBQ0Qsd0JBQUlnMEMsUUFBUSxLQUFLQyxhQUFMLEVBQVo7QUFDQSx5QkFBSyxJQUFJdDJDLElBQUksQ0FBYixFQUFnQkEsSUFBSXEyQyxNQUFNaDJDLE1BQTFCLEVBQWtDTCxHQUFsQyxFQUF1QztBQUNuQ28yQyxvQ0FBWSxLQUFLdkIsTUFBTCxDQUFZeHlDLEtBQVosQ0FBa0IsS0FBS2cwQyxLQUFMLENBQVdBLE1BQU1yMkMsQ0FBTixDQUFYLENBQWxCLENBQVo7QUFDQSw0QkFBSW8yQyxjQUFjLENBQUMvekMsS0FBRCxJQUFVK3pDLFVBQVUsQ0FBVixFQUFhLzFDLE1BQWIsR0FBc0JnQyxNQUFNLENBQU4sRUFBU2hDLE1BQXZELENBQUosRUFBb0U7QUFDaEVnQyxvQ0FBUSt6QyxTQUFSO0FBQ0E5OUIsb0NBQVF0WSxDQUFSO0FBQ0EsZ0NBQUksS0FBSzRYLE9BQUwsQ0FBYTY5QixlQUFqQixFQUFrQztBQUM5QnZCLHdDQUFRLEtBQUs4QixVQUFMLENBQWdCSSxTQUFoQixFQUEyQkMsTUFBTXIyQyxDQUFOLENBQTNCLENBQVI7QUFDQSxvQ0FBSWswQyxVQUFVLEtBQWQsRUFBcUI7QUFDakIsMkNBQU9BLEtBQVA7QUFDSCxpQ0FGRCxNQUVPLElBQUksS0FBS2EsVUFBVCxFQUFxQjtBQUN4QjF5Qyw0Q0FBUSxLQUFSO0FBQ0EsNkNBRndCLENBRWQ7QUFDYixpQ0FITSxNQUdBO0FBQ0g7QUFDQSwyQ0FBTyxLQUFQO0FBQ0g7QUFDSiw2QkFYRCxNQVdPLElBQUksQ0FBQyxLQUFLdVYsT0FBTCxDQUFhMitCLElBQWxCLEVBQXdCO0FBQzNCO0FBQ0g7QUFDSjtBQUNKO0FBQ0Qsd0JBQUlsMEMsS0FBSixFQUFXO0FBQ1A2eEMsZ0NBQVEsS0FBSzhCLFVBQUwsQ0FBZ0IzekMsS0FBaEIsRUFBdUJnMEMsTUFBTS85QixLQUFOLENBQXZCLENBQVI7QUFDQSw0QkFBSTQ3QixVQUFVLEtBQWQsRUFBcUI7QUFDakIsbUNBQU9BLEtBQVA7QUFDSDtBQUNEO0FBQ0EsK0JBQU8sS0FBUDtBQUNIO0FBQ0Qsd0JBQUksS0FBS1csTUFBTCxLQUFnQixFQUFwQixFQUF3QjtBQUNwQiwrQkFBTyxLQUFLckIsR0FBWjtBQUNILHFCQUZELE1BRU87QUFDSCwrQkFBTyxLQUFLTixVQUFMLENBQWdCLDRCQUE0QixLQUFLWCxRQUFMLEdBQWdCLENBQTVDLElBQWlELHdCQUFqRCxHQUE0RSxLQUFLaUMsWUFBTCxFQUE1RixFQUFpSDtBQUNwSHBwQixrQ0FBTSxFQUQ4RztBQUVwSDhvQixtQ0FBTyxJQUY2RztBQUdwSHprQyxrQ0FBTSxLQUFLOGlDO0FBSHlHLHlCQUFqSCxDQUFQO0FBS0g7QUFDSixpQkEzUVE7O0FBNlFiO0FBQ0EwQixxQkFBSSxTQUFTQSxHQUFULEdBQWU7QUFDWCx3QkFBSW53QyxJQUFJLEtBQUtneUMsSUFBTCxFQUFSO0FBQ0Esd0JBQUloeUMsQ0FBSixFQUFPO0FBQ0gsK0JBQU9BLENBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sS0FBS213QyxHQUFMLEVBQVA7QUFDSDtBQUNKLGlCQXJSUTs7QUF1UmI7QUFDQXVDLHVCQUFNLFNBQVNBLEtBQVQsQ0FBZUMsU0FBZixFQUEwQjtBQUN4Qix5QkFBS3ZCLGNBQUwsQ0FBb0JsMEMsSUFBcEIsQ0FBeUJ5MUMsU0FBekI7QUFDSCxpQkExUlE7O0FBNFJiO0FBQ0FDLDBCQUFTLFNBQVNBLFFBQVQsR0FBb0I7QUFDckIsd0JBQUk5NUIsSUFBSSxLQUFLczRCLGNBQUwsQ0FBb0I3MEMsTUFBcEIsR0FBNkIsQ0FBckM7QUFDQSx3QkFBSXVjLElBQUksQ0FBUixFQUFXO0FBQ1AsK0JBQU8sS0FBS3M0QixjQUFMLENBQW9CdHdCLEdBQXBCLEVBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sS0FBS3N3QixjQUFMLENBQW9CLENBQXBCLENBQVA7QUFDSDtBQUNKLGlCQXBTUTs7QUFzU2I7QUFDQW9CLCtCQUFjLFNBQVNBLGFBQVQsR0FBeUI7QUFDL0Isd0JBQUksS0FBS3BCLGNBQUwsQ0FBb0I3MEMsTUFBcEIsSUFBOEIsS0FBSzYwQyxjQUFMLENBQW9CLEtBQUtBLGNBQUwsQ0FBb0I3MEMsTUFBcEIsR0FBNkIsQ0FBakQsQ0FBbEMsRUFBdUY7QUFDbkYsK0JBQU8sS0FBSzBuQyxVQUFMLENBQWdCLEtBQUttTixjQUFMLENBQW9CLEtBQUtBLGNBQUwsQ0FBb0I3MEMsTUFBcEIsR0FBNkIsQ0FBakQsQ0FBaEIsRUFBcUVnMkMsS0FBNUU7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sS0FBS3RPLFVBQUwsQ0FBZ0IsU0FBaEIsRUFBMkJzTyxLQUFsQztBQUNIO0FBQ0osaUJBN1NROztBQStTYjtBQUNBTSwwQkFBUyxTQUFTQSxRQUFULENBQWtCLzVCLENBQWxCLEVBQXFCO0FBQ3RCQSx3QkFBSSxLQUFLczRCLGNBQUwsQ0FBb0I3MEMsTUFBcEIsR0FBNkIsQ0FBN0IsR0FBaUMyYSxLQUFLakcsR0FBTCxDQUFTNkgsS0FBSyxDQUFkLENBQXJDO0FBQ0Esd0JBQUlBLEtBQUssQ0FBVCxFQUFZO0FBQ1IsK0JBQU8sS0FBS3M0QixjQUFMLENBQW9CdDRCLENBQXBCLENBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsK0JBQU8sU0FBUDtBQUNIO0FBQ0osaUJBdlRROztBQXlUYjtBQUNBZzZCLDJCQUFVLFNBQVNBLFNBQVQsQ0FBbUJILFNBQW5CLEVBQThCO0FBQ2hDLHlCQUFLRCxLQUFMLENBQVdDLFNBQVg7QUFDSCxpQkE1VFE7O0FBOFRiO0FBQ0FJLGdDQUFlLFNBQVNBLGNBQVQsR0FBMEI7QUFDakMsMkJBQU8sS0FBSzNCLGNBQUwsQ0FBb0I3MEMsTUFBM0I7QUFDSCxpQkFqVVE7QUFrVWJ1WCx5QkFBUyxFQWxVSTtBQW1VYnU2QiwrQkFBZSxTQUFTQyxTQUFULENBQW1CTCxFQUFuQixFQUFzQitFLEdBQXRCLEVBQTBCQyx5QkFBMUIsRUFBb0RDLFFBQXBELEVBQThEO0FBQzdFLDRCQUFPRCx5QkFBUDtBQUNBLDZCQUFLLENBQUw7QUFBTztBQUNQO0FBQ0EsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLENBQVA7QUFDUCw2QkFBSyxDQUFMO0FBQU9ELGdDQUFJekUsTUFBSixHQUFheUUsSUFBSXpFLE1BQUosQ0FBV2huQyxNQUFYLENBQWtCLENBQWxCLEVBQW9CeXJDLElBQUl4RSxNQUFKLEdBQVcsQ0FBL0IsQ0FBYixDQUFnRCxPQUFPLENBQVA7QUFDdkQsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLEVBQVA7QUFDUCw2QkFBSyxDQUFMO0FBQU8sbUNBQU8sRUFBUDtBQUNQLDZCQUFLLENBQUw7QUFBTyxtQ0FBTyxFQUFQO0FBQ1AsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLEVBQVA7QUFDUCw2QkFBSyxDQUFMO0FBQU8sbUNBQU8sRUFBUDtBQUNQLDZCQUFLLENBQUw7QUFBTyxtQ0FBTyxFQUFQO0FBQ1AsNkJBQUssQ0FBTDtBQUFPLG1DQUFPLEVBQVA7QUFDUCw2QkFBSyxFQUFMO0FBQVEsbUNBQU8sRUFBUDtBQUNSLDZCQUFLLEVBQUw7QUFBUSxtQ0FBTyxDQUFQO0FBQ1IsNkJBQUssRUFBTDtBQUFRLG1DQUFPLEVBQVA7QUFDUiw2QkFBSyxFQUFMO0FBQVEsbUNBQU8sU0FBUDtBQWZSO0FBaUJDLGlCQXJWWTtBQXNWYitELHVCQUFPLENBQUMsVUFBRCxFQUFZLDZEQUFaLEVBQTBFLG9FQUExRSxFQUErSSxTQUEvSSxFQUF5SixTQUF6SixFQUFtSyxTQUFuSyxFQUE2SyxTQUE3SyxFQUF1TCxRQUF2TCxFQUFnTSxRQUFoTSxFQUF5TSxhQUF6TSxFQUF1TixjQUF2TixFQUFzTyxhQUF0TyxFQUFvUCxRQUFwUCxFQUE2UCxRQUE3UCxDQXRWTTtBQXVWYnRPLDRCQUFZLEVBQUMsV0FBVSxFQUFDLFNBQVEsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUwsRUFBTyxDQUFQLEVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiLEVBQWUsQ0FBZixFQUFpQixDQUFqQixFQUFtQixDQUFuQixFQUFxQixFQUFyQixFQUF3QixFQUF4QixFQUEyQixFQUEzQixFQUE4QixFQUE5QixDQUFULEVBQTJDLGFBQVksSUFBdkQsRUFBWDtBQXZWQyxhQUFiO0FBeVZBLG1CQUFPMkwsS0FBUDtBQUNDLFNBM1ZXLEVBQVo7QUE0VkFwUixlQUFPb1IsS0FBUCxHQUFlQSxLQUFmO0FBQ0EsaUJBQVN1RCxNQUFULEdBQW1CO0FBQ2pCLGlCQUFLbEYsRUFBTCxHQUFVLEVBQVY7QUFDRDtBQUNEa0YsZUFBT3Y0QixTQUFQLEdBQW1CNGpCLE1BQW5CLENBQTBCQSxPQUFPMlUsTUFBUCxHQUFnQkEsTUFBaEI7QUFDMUIsZUFBTyxJQUFJQSxNQUFKLEVBQVA7QUFDQyxLQTlqQlksRUFBYjs7QUFpa0JBLFFBQUksT0FBT3I5QixlQUFQLEtBQTJCLFdBQTNCLElBQTBDLGFBQWEsV0FBM0QsRUFBd0U7QUFDeEVELGdCQUFRMm9CLE1BQVIsR0FBaUJBLE1BQWpCO0FBQ0Ezb0IsZ0JBQVFzOUIsTUFBUixHQUFpQjNVLE9BQU8yVSxNQUF4QjtBQUNBdDlCLGdCQUFROVcsS0FBUixHQUFnQixZQUFZO0FBQUUsbUJBQU95L0IsT0FBT3ovQixLQUFQLENBQWFuRCxLQUFiLENBQW1CNGlDLE1BQW5CLEVBQTJCbVIsU0FBM0IsQ0FBUDtBQUErQyxTQUE3RTtBQUNDO0FBQ0EsQ0Evb0JjLENBQWY7O0FBaXBCQSxTQUFTeUQsU0FBVCxDQUFtQjV5QyxLQUFuQixFQUEwQjtBQUN0QixRQUFJQSxpQkFBaUI0VyxNQUFqQixJQUEyQixPQUFPNVcsS0FBUCxLQUFpQixRQUE1QyxJQUF3REEsaUJBQWlCNnlDLE1BQTdFLEVBQXFGO0FBQ2pGLFlBQUk7QUFDQSxtQkFBT2pHLFNBQVNydUMsS0FBVCxDQUFleUIsTUFBTW9CLFFBQU4sRUFBZixDQUFQO0FBQ0gsU0FGRCxDQUVFLE9BQU9kLENBQVAsRUFBVTtBQUNSLGtCQUFNLElBQUlvbkMsY0FBSixDQUFtQnBuQyxDQUFuQixDQUFOO0FBQ0g7QUFDSjtBQUNELFdBQU9OLEtBQVA7QUFDSDs7QUFFRCxTQUFTOHlDLGFBQVQsQ0FBdUI5eUMsS0FBdkIsRUFBOEM7QUFBQSxRQUFoQmlvQyxTQUFnQix1RUFBSjExQixFQUFJOztBQUMxQyxRQUFJOE0sSUFBSXJmLEtBQVI7QUFDQSxRQUFJO0FBQ0FxZixZQUFJdXpCLFVBQVV2ekIsQ0FBVixDQUFKO0FBQ0gsS0FGRCxDQUVFLE9BQU8vZSxDQUFQLEVBQVU7QUFDUixlQUFPLENBQUNBLENBQUQsQ0FBUDtBQUNIO0FBQ0QsV0FBT2lzQyxpQkFBaUJsdEIsQ0FBakIsRUFBb0I0b0IsU0FBcEIsQ0FBUDtBQUNIOztBQUVELElBQU04Syx5QkFBeUIsQ0FBL0I7QUFDQSxJQUFNQyx1QkFBdUIsRUFBN0I7QUFDQSxTQUFTQyxPQUFULENBQWlCcnJDLEtBQWpCLEVBQXdCc3JDLEtBQXhCLEVBQStCO0FBQzNCLFFBQUksQ0FBQ3RyQyxLQUFELElBQVU2ekIsUUFBUTd6QixLQUFSLE1BQW1CLFFBQWpDLEVBQ0ksT0FBTyxJQUFQO0FBQ0osV0FBTyxDQUFDLENBQUNBLE1BQU03SixLQUFOLENBQVltMUMsS0FBWixDQUFUO0FBQ0g7QUFDRCxTQUFTQyxjQUFULENBQXdCbDFDLE1BQXhCLEVBQWdDO0FBQzVCLFFBQUlBLE9BQU9QLEdBQVgsRUFBZ0I7QUFDWixlQUFPTyxPQUFPUCxHQUFQLENBQVdwQixLQUFYLENBQWlCLEdBQWpCLEVBQXNCUCxNQUE3QjtBQUNILEtBRkQsTUFFTztBQUNILGVBQU8sQ0FBUDtBQUNIO0FBQ0o7QUFDRCxTQUFTcTNDLG1CQUFULENBQTZCeC9CLEdBQTdCLEVBQWtDTyxJQUFsQyxFQUF3Q3hXLElBQXhDLEVBQThDO0FBQzFDLFFBQU0wMUMsVUFBVSxJQUFJOVEsR0FBSixDQUFRcHVCLElBQVIsQ0FBaEI7QUFDQSxRQUFNcUMsU0FBUyxFQUFmO0FBQ0EvQixXQUFPTixJQUFQLENBQVlQLEdBQVosRUFBaUJ3TixPQUFqQixDQUF5QixhQUFLO0FBQzFCLFlBQUksQ0FBQ2l5QixRQUFRbGxDLEdBQVIsQ0FBWThKLENBQVosQ0FBTCxFQUFxQjtBQUNqQixnQkFBTWtDLE9BQU94YyxPQUFXQSxJQUFYLFNBQXFCc2EsQ0FBckIsR0FBNEIsSUFBekM7QUFDQXpCLG1CQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQnB0QixJQUFwQixFQUEwQnZHLElBQUlxRSxDQUFKLENBQTFCLDhCQUE0REEsQ0FBNUQsUUFBWjtBQUNIO0FBQ0osS0FMRDtBQU1BLFdBQU96QixNQUFQO0FBQ0g7QUFDRCxJQUFNODhCLHNCQUFzQixJQUFJL1EsR0FBSixDQUFRLENBQ2hDLFFBRGdDLEVBRWhDLFFBRmdDLEVBR2hDLFlBSGdDLENBQVIsQ0FBNUI7QUFLQSxTQUFTZ1IsZUFBVCxDQUF5QnQxQyxNQUF6QixFQUFpQ3ZDLENBQWpDLEVBQW9DO0FBQ2hDLFFBQU04YSxTQUFTLEVBQWY7QUFDQSxRQUFNZzlCLGFBQWEsQ0FDZixNQURlLEVBRWYsS0FGZSxFQUdmLFVBSGUsQ0FBbkI7QUFLQWg5QixXQUFPOVosSUFBUCxrQ0FBZTAyQyxvQkFBb0JuMUMsTUFBcEIsRUFBNEJ1MUMsVUFBNUIsRUFBd0MsUUFBeEMsQ0FBZjtBQUNBLFFBQUksQ0FBQ0Ysb0JBQW9CbmxDLEdBQXBCLENBQXdCeUksT0FBTzNZLE9BQU95QyxJQUFkLENBQXhCLENBQUwsRUFBbUQ7QUFDL0M4VixlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixjQUFnQzdyQyxDQUFoQyxhQUE0Q3VDLE9BQU95QyxJQUFuRCx3QkFBOEU5RSxNQUFNK2xCLElBQU4sQ0FBVzJ4QixtQkFBWCxFQUFnQ3hzQyxJQUFoQyxDQUFxQyxJQUFyQyxDQUE5RSxPQUFaO0FBQ0g7QUFDRCxRQUFNMnNDLG1CQUFtQixzQkFBekI7QUFDQSxRQUFJLENBQUN4MUMsT0FBT1AsR0FBUixJQUFlLENBQUN1MUMsUUFBUWgxQyxPQUFPUCxHQUFmLEVBQW9CKzFDLGdCQUFwQixDQUFwQixFQUEyRDtBQUN2RGo5QixlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixjQUFnQzdyQyxDQUFoQyxZQUEyQ3VDLE9BQU9QLEdBQWxELEVBQXVELHFDQUF2RCxDQUFaO0FBQ0g7QUFDRCxXQUFPOFksTUFBUDtBQUNIO0FBQ0QsU0FBU2s5QixnQkFBVCxDQUEwQmp3QyxPQUExQixFQUFtQztBQUMvQixRQUFNK1MsU0FBUyxFQUFmO0FBQ0EsUUFBSW05QixRQUFRLENBQVo7QUFDQWwvQixXQUFPTixJQUFQLENBQVkxUSxPQUFaLEVBQXFCMmQsT0FBckIsQ0FBNkIsVUFBQy9CLENBQUQsRUFBSTNqQixDQUFKLEVBQVU7QUFDbkMsWUFBTWs0QyxlQUFlTCxnQkFBZ0I5dkMsUUFBUTRiLENBQVIsQ0FBaEIsRUFBNEIzakIsQ0FBNUIsQ0FBckI7QUFDQSxZQUFJLENBQUNrNEMsYUFBYTczQyxNQUFsQixFQUEwQjtBQUN0QjQzQyxvQkFBUUEsUUFBUVIsZUFBZTF2QyxRQUFRNGIsQ0FBUixDQUFmLENBQWhCO0FBQ0g7QUFDRDdJLGVBQU85WixJQUFQLGtDQUFlazNDLFlBQWY7QUFDSCxLQU5EO0FBT0EsUUFBSUQsUUFBUVgsb0JBQVosRUFBa0M7QUFDOUJ4OEIsZUFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0IsU0FBcEIsRUFBK0IsSUFBL0IsMkJBQTZEeUwsb0JBQTdELHVCQUFaO0FBQ0g7QUFDRCxXQUFPeDhCLE1BQVA7QUFDSDtBQUNELFNBQVNxOUIsYUFBVCxDQUF1Qjd6QyxLQUF2QixFQUE4Qjh6QyxRQUE5QixFQUF3QztBQUNwQyxRQUFNdDlCLFNBQVMsRUFBZjtBQUNBLFFBQU11OUIseUJBQXlCLENBQzNCLE9BRDJCLEVBRTNCLElBRjJCLEVBRzNCLGNBSDJCLEVBSTNCLE9BSjJCLEVBSzNCLFNBTDJCLEVBTTNCLFVBTjJCLEVBTzNCLFlBUDJCLEVBUTNCLFdBUjJCLENBQS9CO0FBVUEsUUFBTUMsbUJBQW1CWixvQkFBb0JwekMsS0FBcEIsK0JBQ2xCOHpDLFFBRGtCLEdBRWxCQyxzQkFGa0IsRUFBekI7QUFJQXY5QixXQUFPOVosSUFBUCxrQ0FBZXMzQyxnQkFBZjtBQUNBLFFBQUloMEMsTUFBTXhCLE9BQU4sR0FBZ0J1MEMsc0JBQWhCLElBQTBDL3lDLE1BQU14QixPQUFOLEdBQWdCdTBDLHNCQUE5RCxFQUFzRjtBQUNsRnY4QixlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQixTQUFwQixFQUErQnZuQyxNQUFNeEIsT0FBckMsNkJBQXdFdTBDLHNCQUF4RSxDQUFaO0FBQ0g7QUFDRCxRQUFNa0Isa0JBQWtCLHVEQUF4QjtBQUNBLFFBQUksQ0FBQ2hCLFFBQVFqekMsTUFBTXVJLE1BQWQsRUFBc0IwckMsZUFBdEIsQ0FBTCxFQUE2QztBQUN6Q3o5QixlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQixRQUFwQixFQUE4QnZuQyxNQUFNdUksTUFBcEMsRUFBNEMsK0NBQTVDLENBQVo7QUFDSDtBQUNELFFBQU0yckMsbUJBQW1CLG1EQUF6QjtBQUNBLFFBQUksQ0FBQ2pCLFFBQVFqekMsTUFBTW5CLE1BQWQsRUFBc0JxMUMsZ0JBQXRCLENBQUwsRUFBOEM7QUFDMUMxOUIsZUFBTzlaLElBQVAsQ0FBWSxJQUFJNnFDLGVBQUosQ0FBb0IsUUFBcEIsRUFBOEJ2bkMsTUFBTW5CLE1BQXBDLEVBQTRDLGdEQUE1QyxDQUFaO0FBQ0g7QUFDRCxRQUFNczFDLG9CQUFvQixvQkFBMUI7QUFDQSxRQUFJLENBQUNsQixRQUFRanpDLE1BQU1zQixVQUFkLEVBQTBCNnlDLGlCQUExQixDQUFMLEVBQW1EO0FBQy9DMzlCLGVBQU85WixJQUFQLENBQVksSUFBSTZxQyxlQUFKLENBQW9CLFlBQXBCLEVBQWtDdm5DLE1BQU1zQixVQUF4QyxFQUFvRCw0Q0FBcEQsQ0FBWjtBQUNIO0FBQ0QsUUFBSXRCLE1BQU1vMEMsU0FBTixLQUFvQjEwQyxTQUFwQixJQUFpQys3QixRQUFRejdCLE1BQU1vMEMsU0FBZCxNQUE2QixTQUFsRSxFQUE2RTtBQUN6RTU5QixlQUFPOVosSUFBUCxDQUFZLElBQUk2cUMsZUFBSixDQUFvQixXQUFwQixFQUFpQ3ZuQyxNQUFNbzBDLFNBQXZDLEVBQWtELHdDQUFsRCxDQUFaO0FBQ0g7QUFDRCxXQUFPNTlCLE1BQVA7QUFDSDtBQUNELFNBQVM2OUIsMEJBQVQsQ0FBb0NyMEMsS0FBcEMsRUFBMkM7QUFDdkMsUUFBSXFmLElBQUlyZixLQUFSO0FBQ0EsUUFBSTtBQUNBcWYsWUFBSXV6QixVQUFVdnpCLENBQVYsQ0FBSjtBQUNILEtBRkQsQ0FFRSxPQUFPL2UsQ0FBUCxFQUFVO0FBQ1IsZUFBTyxDQUFDQSxDQUFELENBQVA7QUFDSDtBQUNELFFBQUlrVyxTQUFTKzFCLGlCQUFpQmx0QixDQUFqQixFQUFvQjlNLEVBQXBCLEVBQXdCeEIsTUFBeEIsQ0FBK0I4aUMsY0FBY3gwQixDQUFkLEVBQWlCNUssT0FBT04sSUFBUCxDQUFZNUIsR0FBR2xMLEtBQWYsQ0FBakIsQ0FBL0IsQ0FBYjtBQUNBLFFBQUlnWSxFQUFFNWIsT0FBTixFQUFlO0FBQ1grUyxpQkFBU0EsT0FBT3pGLE1BQVAsQ0FBYzJpQyxpQkFBaUJyMEIsRUFBRTViLE9BQW5CLENBQWQsQ0FBVDtBQUNIO0FBQ0QsV0FBTytTLE1BQVA7QUFDSDs7QUFFRCxJQUFNODlCLGVBQWU7QUFDakIvVyxvQ0FEaUI7QUFFakJPLDhCQUZpQjtBQUdqQitDLDBDQUhpQjtBQUlqQjlDLHNDQUppQjtBQUtqQlEsc0RBTGlCO0FBTWpCUyw0REFOaUI7QUFPakJkLGtEQVBpQjtBQVFqQkksb0RBUmlCO0FBU2pCTTtBQVRpQixDQUFyQjtBQVdBLElBQU0yVixnQkFBZ0I7QUFDbEJqVixvQ0FEa0I7QUFFbEJ6RCxrQ0FGa0I7QUFHbEJwYSxnQkFBWWthO0FBSE0sQ0FBdEI7QUFLQSxJQUFNNlksUUFBUTtBQUNWMXpCLDBCQURVO0FBRVZFLHdCQUZVO0FBR1ZDO0FBSFUsQ0FBZDtBQUtBNnhCLGNBQWNscUIsTUFBZCxHQUF1QmtxQixhQUF2QjtBQUNBQSxjQUFjMkIsTUFBZCxHQUF1QjNCLGFBQXZCOztRQUVTM3hDLEssR0FBQUEsSztRQUF5QnVoQixZLEdBQWxCZ2xCLGM7UUFBZ0NILGUsR0FBQUEsZTtRQUFpQnZELFMsR0FBQUEsUztRQUE4QjlDLGEsR0FBbkI4QixlO1FBQWtDdUIsVyxHQUFBQSxXO1FBQTJCbVEsSSxHQUFkdk4sVTtRQUFvQ3Q3QixVLEdBQWhCeW9DLFk7UUFBNENLLGEsR0FBaEI3VCxZO1FBQStCdDhCLE0sR0FBQUEsTTtRQUF5Qm9rQyxRLEdBQWpCMkwsYTtRQUFpQ0UsTSxHQUFObGlDLEU7UUFBY3V4QixPLEdBQUFBLE87UUFBU3Z4QixFLEdBQUFBLEU7UUFBcUIrMUIsUSxHQUFqQndLLGE7UUFBMkJ1QiwwQixHQUFBQSwwQjtRQUE0QkcsSyxHQUFBQSxLO0FBQy9ULG9DOzs7Ozs7Ozs7Ozs7O0FDdnJlQTs7QUFFQW4vQixRQUFRdS9CLFVBQVIsR0FBcUJBLFVBQXJCO0FBQ0F2L0IsUUFBUXcvQixXQUFSLEdBQXNCQSxXQUF0QjtBQUNBeC9CLFFBQVF5L0IsYUFBUixHQUF3QkEsYUFBeEI7O0FBRUEsSUFBSUMsU0FBUyxFQUFiO0FBQ0EsSUFBSUMsWUFBWSxFQUFoQjtBQUNBLElBQUlDLE1BQU0sT0FBT0MsVUFBUCxLQUFzQixXQUF0QixHQUFvQ0EsVUFBcEMsR0FBaUR0NUMsS0FBM0Q7O0FBRUEsSUFBSXU1QyxPQUFPLGtFQUFYO0FBQ0EsS0FBSyxJQUFJejVDLElBQUksQ0FBUixFQUFXaWYsTUFBTXc2QixLQUFLcDVDLE1BQTNCLEVBQW1DTCxJQUFJaWYsR0FBdkMsRUFBNEMsRUFBRWpmLENBQTlDLEVBQWlEO0FBQy9DcTVDLFNBQU9yNUMsQ0FBUCxJQUFZeTVDLEtBQUt6NUMsQ0FBTCxDQUFaO0FBQ0FzNUMsWUFBVUcsS0FBSzc5QixVQUFMLENBQWdCNWIsQ0FBaEIsQ0FBVixJQUFnQ0EsQ0FBaEM7QUFDRDs7QUFFRDtBQUNBO0FBQ0FzNUMsVUFBVSxJQUFJMTlCLFVBQUosQ0FBZSxDQUFmLENBQVYsSUFBK0IsRUFBL0I7QUFDQTA5QixVQUFVLElBQUkxOUIsVUFBSixDQUFlLENBQWYsQ0FBVixJQUErQixFQUEvQjs7QUFFQSxTQUFTODlCLE9BQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQ3JCLE1BQUkxNkIsTUFBTTA2QixJQUFJdDVDLE1BQWQ7O0FBRUEsTUFBSTRlLE1BQU0sQ0FBTixHQUFVLENBQWQsRUFBaUI7QUFDZixVQUFNLElBQUlsYyxLQUFKLENBQVUsZ0RBQVYsQ0FBTjtBQUNEOztBQUVEO0FBQ0E7QUFDQSxNQUFJNjJDLFdBQVdELElBQUk1NEMsT0FBSixDQUFZLEdBQVosQ0FBZjtBQUNBLE1BQUk2NEMsYUFBYSxDQUFDLENBQWxCLEVBQXFCQSxXQUFXMzZCLEdBQVg7O0FBRXJCLE1BQUk0NkIsa0JBQWtCRCxhQUFhMzZCLEdBQWIsR0FDbEIsQ0FEa0IsR0FFbEIsSUFBSzI2QixXQUFXLENBRnBCOztBQUlBLFNBQU8sQ0FBQ0EsUUFBRCxFQUFXQyxlQUFYLENBQVA7QUFDRDs7QUFFRDtBQUNBLFNBQVNYLFVBQVQsQ0FBcUJTLEdBQXJCLEVBQTBCO0FBQ3hCLE1BQUlHLE9BQU9KLFFBQVFDLEdBQVIsQ0FBWDtBQUNBLE1BQUlDLFdBQVdFLEtBQUssQ0FBTCxDQUFmO0FBQ0EsTUFBSUQsa0JBQWtCQyxLQUFLLENBQUwsQ0FBdEI7QUFDQSxTQUFRLENBQUNGLFdBQVdDLGVBQVosSUFBK0IsQ0FBL0IsR0FBbUMsQ0FBcEMsR0FBeUNBLGVBQWhEO0FBQ0Q7O0FBRUQsU0FBU0UsV0FBVCxDQUFzQkosR0FBdEIsRUFBMkJDLFFBQTNCLEVBQXFDQyxlQUFyQyxFQUFzRDtBQUNwRCxTQUFRLENBQUNELFdBQVdDLGVBQVosSUFBK0IsQ0FBL0IsR0FBbUMsQ0FBcEMsR0FBeUNBLGVBQWhEO0FBQ0Q7O0FBRUQsU0FBU1YsV0FBVCxDQUFzQlEsR0FBdEIsRUFBMkI7QUFDekIsTUFBSUssR0FBSjtBQUNBLE1BQUlGLE9BQU9KLFFBQVFDLEdBQVIsQ0FBWDtBQUNBLE1BQUlDLFdBQVdFLEtBQUssQ0FBTCxDQUFmO0FBQ0EsTUFBSUQsa0JBQWtCQyxLQUFLLENBQUwsQ0FBdEI7O0FBRUEsTUFBSUcsTUFBTSxJQUFJVixHQUFKLENBQVFRLFlBQVlKLEdBQVosRUFBaUJDLFFBQWpCLEVBQTJCQyxlQUEzQixDQUFSLENBQVY7O0FBRUEsTUFBSUssVUFBVSxDQUFkOztBQUVBO0FBQ0EsTUFBSWo3QixNQUFNNDZCLGtCQUFrQixDQUFsQixHQUNORCxXQUFXLENBREwsR0FFTkEsUUFGSjs7QUFJQSxNQUFJNTVDLENBQUo7QUFDQSxPQUFLQSxJQUFJLENBQVQsRUFBWUEsSUFBSWlmLEdBQWhCLEVBQXFCamYsS0FBSyxDQUExQixFQUE2QjtBQUMzQmc2QyxVQUNHVixVQUFVSyxJQUFJLzlCLFVBQUosQ0FBZTViLENBQWYsQ0FBVixLQUFnQyxFQUFqQyxHQUNDczVDLFVBQVVLLElBQUkvOUIsVUFBSixDQUFlNWIsSUFBSSxDQUFuQixDQUFWLEtBQW9DLEVBRHJDLEdBRUNzNUMsVUFBVUssSUFBSS85QixVQUFKLENBQWU1YixJQUFJLENBQW5CLENBQVYsS0FBb0MsQ0FGckMsR0FHQXM1QyxVQUFVSyxJQUFJLzlCLFVBQUosQ0FBZTViLElBQUksQ0FBbkIsQ0FBVixDQUpGO0FBS0FpNkMsUUFBSUMsU0FBSixJQUFrQkYsT0FBTyxFQUFSLEdBQWMsSUFBL0I7QUFDQUMsUUFBSUMsU0FBSixJQUFrQkYsT0FBTyxDQUFSLEdBQWEsSUFBOUI7QUFDQUMsUUFBSUMsU0FBSixJQUFpQkYsTUFBTSxJQUF2QjtBQUNEOztBQUVELE1BQUlILG9CQUFvQixDQUF4QixFQUEyQjtBQUN6QkcsVUFDR1YsVUFBVUssSUFBSS85QixVQUFKLENBQWU1YixDQUFmLENBQVYsS0FBZ0MsQ0FBakMsR0FDQ3M1QyxVQUFVSyxJQUFJLzlCLFVBQUosQ0FBZTViLElBQUksQ0FBbkIsQ0FBVixLQUFvQyxDQUZ2QztBQUdBaTZDLFFBQUlDLFNBQUosSUFBaUJGLE1BQU0sSUFBdkI7QUFDRDs7QUFFRCxNQUFJSCxvQkFBb0IsQ0FBeEIsRUFBMkI7QUFDekJHLFVBQ0dWLFVBQVVLLElBQUkvOUIsVUFBSixDQUFlNWIsQ0FBZixDQUFWLEtBQWdDLEVBQWpDLEdBQ0NzNUMsVUFBVUssSUFBSS85QixVQUFKLENBQWU1YixJQUFJLENBQW5CLENBQVYsS0FBb0MsQ0FEckMsR0FFQ3M1QyxVQUFVSyxJQUFJLzlCLFVBQUosQ0FBZTViLElBQUksQ0FBbkIsQ0FBVixLQUFvQyxDQUh2QztBQUlBaTZDLFFBQUlDLFNBQUosSUFBa0JGLE9BQU8sQ0FBUixHQUFhLElBQTlCO0FBQ0FDLFFBQUlDLFNBQUosSUFBaUJGLE1BQU0sSUFBdkI7QUFDRDs7QUFFRCxTQUFPQyxHQUFQO0FBQ0Q7O0FBRUQsU0FBU0UsZUFBVCxDQUEwQmpzQixHQUExQixFQUErQjtBQUM3QixTQUFPbXJCLE9BQU9uckIsT0FBTyxFQUFQLEdBQVksSUFBbkIsSUFDTG1yQixPQUFPbnJCLE9BQU8sRUFBUCxHQUFZLElBQW5CLENBREssR0FFTG1yQixPQUFPbnJCLE9BQU8sQ0FBUCxHQUFXLElBQWxCLENBRkssR0FHTG1yQixPQUFPbnJCLE1BQU0sSUFBYixDQUhGO0FBSUQ7O0FBRUQsU0FBU2tzQixXQUFULENBQXNCQyxLQUF0QixFQUE2QnpoQyxLQUE3QixFQUFvQ1AsR0FBcEMsRUFBeUM7QUFDdkMsTUFBSTJoQyxHQUFKO0FBQ0EsTUFBSXYrQixTQUFTLEVBQWI7QUFDQSxPQUFLLElBQUl6YixJQUFJNFksS0FBYixFQUFvQjVZLElBQUlxWSxHQUF4QixFQUE2QnJZLEtBQUssQ0FBbEMsRUFBcUM7QUFDbkNnNkMsVUFDRSxDQUFFSyxNQUFNcjZDLENBQU4sS0FBWSxFQUFiLEdBQW1CLFFBQXBCLEtBQ0VxNkMsTUFBTXI2QyxJQUFJLENBQVYsS0FBZ0IsQ0FBakIsR0FBc0IsTUFEdkIsS0FFQ3E2QyxNQUFNcjZDLElBQUksQ0FBVixJQUFlLElBRmhCLENBREY7QUFJQXliLFdBQU96YSxJQUFQLENBQVltNUMsZ0JBQWdCSCxHQUFoQixDQUFaO0FBQ0Q7QUFDRCxTQUFPditCLE9BQU9yUSxJQUFQLENBQVksRUFBWixDQUFQO0FBQ0Q7O0FBRUQsU0FBU2d1QyxhQUFULENBQXdCaUIsS0FBeEIsRUFBK0I7QUFDN0IsTUFBSUwsR0FBSjtBQUNBLE1BQUkvNkIsTUFBTW83QixNQUFNaDZDLE1BQWhCO0FBQ0EsTUFBSWk2QyxhQUFhcjdCLE1BQU0sQ0FBdkIsQ0FINkIsQ0FHSjtBQUN6QixNQUFJN2MsUUFBUSxFQUFaO0FBQ0EsTUFBSW00QyxpQkFBaUIsS0FBckIsQ0FMNkIsQ0FLRjs7QUFFM0I7QUFDQSxPQUFLLElBQUl2NkMsSUFBSSxDQUFSLEVBQVdxeUIsT0FBT3BULE1BQU1xN0IsVUFBN0IsRUFBeUN0NkMsSUFBSXF5QixJQUE3QyxFQUFtRHJ5QixLQUFLdTZDLGNBQXhELEVBQXdFO0FBQ3RFbjRDLFVBQU1wQixJQUFOLENBQVdvNUMsWUFBWUMsS0FBWixFQUFtQnI2QyxDQUFuQixFQUF1QkEsSUFBSXU2QyxjQUFMLEdBQXVCbG9CLElBQXZCLEdBQThCQSxJQUE5QixHQUFzQ3J5QixJQUFJdTZDLGNBQWhFLENBQVg7QUFDRDs7QUFFRDtBQUNBLE1BQUlELGVBQWUsQ0FBbkIsRUFBc0I7QUFDcEJOLFVBQU1LLE1BQU1wN0IsTUFBTSxDQUFaLENBQU47QUFDQTdjLFVBQU1wQixJQUFOLENBQ0VxNEMsT0FBT1csT0FBTyxDQUFkLElBQ0FYLE9BQVFXLE9BQU8sQ0FBUixHQUFhLElBQXBCLENBREEsR0FFQSxJQUhGO0FBS0QsR0FQRCxNQU9PLElBQUlNLGVBQWUsQ0FBbkIsRUFBc0I7QUFDM0JOLFVBQU0sQ0FBQ0ssTUFBTXA3QixNQUFNLENBQVosS0FBa0IsQ0FBbkIsSUFBd0JvN0IsTUFBTXA3QixNQUFNLENBQVosQ0FBOUI7QUFDQTdjLFVBQU1wQixJQUFOLENBQ0VxNEMsT0FBT1csT0FBTyxFQUFkLElBQ0FYLE9BQVFXLE9BQU8sQ0FBUixHQUFhLElBQXBCLENBREEsR0FFQVgsT0FBUVcsT0FBTyxDQUFSLEdBQWEsSUFBcEIsQ0FGQSxHQUdBLEdBSkY7QUFNRDs7QUFFRCxTQUFPNTNDLE1BQU1nSixJQUFOLENBQVcsRUFBWCxDQUFQO0FBQ0QsQzs7Ozs7Ozs7Ozs7O0FDckpEOzs7Ozs7QUFNQTs7QUFFQTs7QUFFQSxJQUFJb3ZDLFNBQVNDLG1CQUFPQSxDQUFDLG9EQUFSLENBQWI7QUFDQSxJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQyxnREFBUixDQUFkO0FBQ0EsSUFBSXQ2QyxVQUFVczZDLG1CQUFPQSxDQUFDLGdEQUFSLENBQWQ7O0FBRUE5Z0MsUUFBUXc5QixNQUFSLEdBQWlCQSxNQUFqQjtBQUNBeDlCLFFBQVFnaEMsVUFBUixHQUFxQkEsVUFBckI7QUFDQWhoQyxRQUFRaWhDLGlCQUFSLEdBQTRCLEVBQTVCOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkF6RCxPQUFPMEQsbUJBQVAsR0FBNkJ2aEMsT0FBT3VoQyxtQkFBUCxLQUErQjcyQyxTQUEvQixHQUN6QnNWLE9BQU91aEMsbUJBRGtCLEdBRXpCQyxtQkFGSjs7QUFJQTs7O0FBR0FuaEMsUUFBUW9oQyxVQUFSLEdBQXFCQSxZQUFyQjs7QUFFQSxTQUFTRCxpQkFBVCxHQUE4QjtBQUM1QixNQUFJO0FBQ0YsUUFBSWIsTUFBTSxJQUFJVCxVQUFKLENBQWUsQ0FBZixDQUFWO0FBQ0FTLFFBQUkxaEIsU0FBSixHQUFnQixFQUFDQSxXQUFXaWhCLFdBQVc5NkIsU0FBdkIsRUFBa0NzOEIsS0FBSyxlQUFZO0FBQUUsZUFBTyxFQUFQO0FBQVcsT0FBaEUsRUFBaEI7QUFDQSxXQUFPZixJQUFJZSxHQUFKLE9BQWMsRUFBZCxJQUFvQjtBQUN2QixXQUFPZixJQUFJZ0IsUUFBWCxLQUF3QixVQURyQixJQUNtQztBQUN0Q2hCLFFBQUlnQixRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQi9CLFVBQW5CLEtBQWtDLENBRnRDLENBSEUsQ0FLc0M7QUFDekMsR0FORCxDQU1FLE9BQU90MEMsQ0FBUCxFQUFVO0FBQ1YsV0FBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbTJDLFVBQVQsR0FBdUI7QUFDckIsU0FBTzVELE9BQU8wRCxtQkFBUCxHQUNILFVBREcsR0FFSCxVQUZKO0FBR0Q7O0FBRUQsU0FBU0ssWUFBVCxDQUF1QkMsSUFBdkIsRUFBNkI5NkMsTUFBN0IsRUFBcUM7QUFDbkMsTUFBSTA2QyxlQUFlMTZDLE1BQW5CLEVBQTJCO0FBQ3pCLFVBQU0sSUFBSSthLFVBQUosQ0FBZSw0QkFBZixDQUFOO0FBQ0Q7QUFDRCxNQUFJKzdCLE9BQU8wRCxtQkFBWCxFQUFnQztBQUM5QjtBQUNBTSxXQUFPLElBQUkzQixVQUFKLENBQWVuNUMsTUFBZixDQUFQO0FBQ0E4NkMsU0FBSzVpQixTQUFMLEdBQWlCNGUsT0FBT3o0QixTQUF4QjtBQUNELEdBSkQsTUFJTztBQUNMO0FBQ0EsUUFBSXk4QixTQUFTLElBQWIsRUFBbUI7QUFDakJBLGFBQU8sSUFBSWhFLE1BQUosQ0FBVzkyQyxNQUFYLENBQVA7QUFDRDtBQUNEODZDLFNBQUs5NkMsTUFBTCxHQUFjQSxNQUFkO0FBQ0Q7O0FBRUQsU0FBTzg2QyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxTQUFTaEUsTUFBVCxDQUFpQjk0QixHQUFqQixFQUFzQis4QixnQkFBdEIsRUFBd0MvNkMsTUFBeEMsRUFBZ0Q7QUFDOUMsTUFBSSxDQUFDODJDLE9BQU8wRCxtQkFBUixJQUErQixFQUFFLGdCQUFnQjFELE1BQWxCLENBQW5DLEVBQThEO0FBQzVELFdBQU8sSUFBSUEsTUFBSixDQUFXOTRCLEdBQVgsRUFBZ0IrOEIsZ0JBQWhCLEVBQWtDLzZDLE1BQWxDLENBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUksT0FBT2dlLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixRQUFJLE9BQU8rOEIsZ0JBQVAsS0FBNEIsUUFBaEMsRUFBMEM7QUFDeEMsWUFBTSxJQUFJcjRDLEtBQUosQ0FDSixtRUFESSxDQUFOO0FBR0Q7QUFDRCxXQUFPczRDLFlBQVksSUFBWixFQUFrQmg5QixHQUFsQixDQUFQO0FBQ0Q7QUFDRCxTQUFPNEgsS0FBSyxJQUFMLEVBQVc1SCxHQUFYLEVBQWdCKzhCLGdCQUFoQixFQUFrQy82QyxNQUFsQyxDQUFQO0FBQ0Q7O0FBRUQ4MkMsT0FBT21FLFFBQVAsR0FBa0IsSUFBbEIsQyxDQUF1Qjs7QUFFdkI7QUFDQW5FLE9BQU9vRSxRQUFQLEdBQWtCLFVBQVV0QixHQUFWLEVBQWU7QUFDL0JBLE1BQUkxaEIsU0FBSixHQUFnQjRlLE9BQU96NEIsU0FBdkI7QUFDQSxTQUFPdTdCLEdBQVA7QUFDRCxDQUhEOztBQUtBLFNBQVNoMEIsSUFBVCxDQUFlazFCLElBQWYsRUFBcUJqdkMsS0FBckIsRUFBNEJrdkMsZ0JBQTVCLEVBQThDLzZDLE1BQTlDLEVBQXNEO0FBQ3BELE1BQUksT0FBTzZMLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsVUFBTSxJQUFJNFYsU0FBSixDQUFjLHVDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJLE9BQU8wNUIsV0FBUCxLQUF1QixXQUF2QixJQUFzQ3R2QyxpQkFBaUJzdkMsV0FBM0QsRUFBd0U7QUFDdEUsV0FBT0MsZ0JBQWdCTixJQUFoQixFQUFzQmp2QyxLQUF0QixFQUE2Qmt2QyxnQkFBN0IsRUFBK0MvNkMsTUFBL0MsQ0FBUDtBQUNEOztBQUVELE1BQUksT0FBTzZMLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBTzJmLFdBQVdzdkIsSUFBWCxFQUFpQmp2QyxLQUFqQixFQUF3Qmt2QyxnQkFBeEIsQ0FBUDtBQUNEOztBQUVELFNBQU9NLFdBQVdQLElBQVgsRUFBaUJqdkMsS0FBakIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBaXJDLE9BQU9seEIsSUFBUCxHQUFjLFVBQVUvWixLQUFWLEVBQWlCa3ZDLGdCQUFqQixFQUFtQy82QyxNQUFuQyxFQUEyQztBQUN2RCxTQUFPNGxCLEtBQUssSUFBTCxFQUFXL1osS0FBWCxFQUFrQmt2QyxnQkFBbEIsRUFBb0MvNkMsTUFBcEMsQ0FBUDtBQUNELENBRkQ7O0FBSUEsSUFBSTgyQyxPQUFPMEQsbUJBQVgsRUFBZ0M7QUFDOUIxRCxTQUFPejRCLFNBQVAsQ0FBaUI2WixTQUFqQixHQUE2QmloQixXQUFXOTZCLFNBQXhDO0FBQ0F5NEIsU0FBTzVlLFNBQVAsR0FBbUJpaEIsVUFBbkI7QUFDQSxNQUFJLE9BQU9tQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPQyxPQUF4QyxJQUNBekUsT0FBT3dFLE9BQU9DLE9BQWQsTUFBMkJ6RSxNQUQvQixFQUN1QztBQUNyQztBQUNBcCtCLFdBQU8rNUIsY0FBUCxDQUFzQnFFLE1BQXRCLEVBQThCd0UsT0FBT0MsT0FBckMsRUFBOEM7QUFDNUMxdkMsYUFBTyxJQURxQztBQUU1QzJ2QyxvQkFBYztBQUY4QixLQUE5QztBQUlEO0FBQ0Y7O0FBRUQsU0FBU0MsVUFBVCxDQUFxQjcwQyxJQUFyQixFQUEyQjtBQUN6QixNQUFJLE9BQU9BLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDNUIsVUFBTSxJQUFJNmEsU0FBSixDQUFjLGtDQUFkLENBQU47QUFDRCxHQUZELE1BRU8sSUFBSTdhLE9BQU8sQ0FBWCxFQUFjO0FBQ25CLFVBQU0sSUFBSW1VLFVBQUosQ0FBZSxzQ0FBZixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTMmdDLEtBQVQsQ0FBZ0JaLElBQWhCLEVBQXNCbDBDLElBQXRCLEVBQTRCcUksSUFBNUIsRUFBa0N0QixRQUFsQyxFQUE0QztBQUMxQzh0QyxhQUFXNzBDLElBQVg7QUFDQSxNQUFJQSxRQUFRLENBQVosRUFBZTtBQUNiLFdBQU9pMEMsYUFBYUMsSUFBYixFQUFtQmwwQyxJQUFuQixDQUFQO0FBQ0Q7QUFDRCxNQUFJcUksU0FBU3RMLFNBQWIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsV0FBTyxPQUFPZ0ssUUFBUCxLQUFvQixRQUFwQixHQUNIa3RDLGFBQWFDLElBQWIsRUFBbUJsMEMsSUFBbkIsRUFBeUJxSSxJQUF6QixDQUE4QkEsSUFBOUIsRUFBb0N0QixRQUFwQyxDQURHLEdBRUhrdEMsYUFBYUMsSUFBYixFQUFtQmwwQyxJQUFuQixFQUF5QnFJLElBQXpCLENBQThCQSxJQUE5QixDQUZKO0FBR0Q7QUFDRCxTQUFPNHJDLGFBQWFDLElBQWIsRUFBbUJsMEMsSUFBbkIsQ0FBUDtBQUNEOztBQUVEOzs7O0FBSUFrd0MsT0FBTzRFLEtBQVAsR0FBZSxVQUFVOTBDLElBQVYsRUFBZ0JxSSxJQUFoQixFQUFzQnRCLFFBQXRCLEVBQWdDO0FBQzdDLFNBQU8rdEMsTUFBTSxJQUFOLEVBQVk5MEMsSUFBWixFQUFrQnFJLElBQWxCLEVBQXdCdEIsUUFBeEIsQ0FBUDtBQUNELENBRkQ7O0FBSUEsU0FBU3F0QyxXQUFULENBQXNCRixJQUF0QixFQUE0QmwwQyxJQUE1QixFQUFrQztBQUNoQzYwQyxhQUFXNzBDLElBQVg7QUFDQWswQyxTQUFPRCxhQUFhQyxJQUFiLEVBQW1CbDBDLE9BQU8sQ0FBUCxHQUFXLENBQVgsR0FBZSswQyxRQUFRLzBDLElBQVIsSUFBZ0IsQ0FBbEQsQ0FBUDtBQUNBLE1BQUksQ0FBQ2t3QyxPQUFPMEQsbUJBQVosRUFBaUM7QUFDL0IsU0FBSyxJQUFJNzZDLElBQUksQ0FBYixFQUFnQkEsSUFBSWlILElBQXBCLEVBQTBCLEVBQUVqSCxDQUE1QixFQUErQjtBQUM3Qm03QyxXQUFLbjdDLENBQUwsSUFBVSxDQUFWO0FBQ0Q7QUFDRjtBQUNELFNBQU9tN0MsSUFBUDtBQUNEOztBQUVEOzs7QUFHQWhFLE9BQU9rRSxXQUFQLEdBQXFCLFVBQVVwMEMsSUFBVixFQUFnQjtBQUNuQyxTQUFPbzBDLFlBQVksSUFBWixFQUFrQnAwQyxJQUFsQixDQUFQO0FBQ0QsQ0FGRDtBQUdBOzs7QUFHQWt3QyxPQUFPOEUsZUFBUCxHQUF5QixVQUFVaDFDLElBQVYsRUFBZ0I7QUFDdkMsU0FBT28wQyxZQUFZLElBQVosRUFBa0JwMEMsSUFBbEIsQ0FBUDtBQUNELENBRkQ7O0FBSUEsU0FBUzRrQixVQUFULENBQXFCc3ZCLElBQXJCLEVBQTJCem5DLE1BQTNCLEVBQW1DMUYsUUFBbkMsRUFBNkM7QUFDM0MsTUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXBCLElBQWdDQSxhQUFhLEVBQWpELEVBQXFEO0FBQ25EQSxlQUFXLE1BQVg7QUFDRDs7QUFFRCxNQUFJLENBQUNtcEMsT0FBTytFLFVBQVAsQ0FBa0JsdUMsUUFBbEIsQ0FBTCxFQUFrQztBQUNoQyxVQUFNLElBQUk4VCxTQUFKLENBQWMsNENBQWQsQ0FBTjtBQUNEOztBQUVELE1BQUl6aEIsU0FBUzY0QyxXQUFXeGxDLE1BQVgsRUFBbUIxRixRQUFuQixJQUErQixDQUE1QztBQUNBbXRDLFNBQU9ELGFBQWFDLElBQWIsRUFBbUI5NkMsTUFBbkIsQ0FBUDs7QUFFQSxNQUFJdzFCLFNBQVNzbEIsS0FBS2dCLEtBQUwsQ0FBV3pvQyxNQUFYLEVBQW1CMUYsUUFBbkIsQ0FBYjs7QUFFQSxNQUFJNm5CLFdBQVd4MUIsTUFBZixFQUF1QjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTg2QyxXQUFPQSxLQUFLaHdDLEtBQUwsQ0FBVyxDQUFYLEVBQWMwcUIsTUFBZCxDQUFQO0FBQ0Q7O0FBRUQsU0FBT3NsQixJQUFQO0FBQ0Q7O0FBRUQsU0FBU2lCLGFBQVQsQ0FBd0JqQixJQUF4QixFQUE4QmhvQyxLQUE5QixFQUFxQztBQUNuQyxNQUFJOVMsU0FBUzhTLE1BQU05UyxNQUFOLEdBQWUsQ0FBZixHQUFtQixDQUFuQixHQUF1QjI3QyxRQUFRN29DLE1BQU05UyxNQUFkLElBQXdCLENBQTVEO0FBQ0E4NkMsU0FBT0QsYUFBYUMsSUFBYixFQUFtQjk2QyxNQUFuQixDQUFQO0FBQ0EsT0FBSyxJQUFJTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCTCxLQUFLLENBQWpDLEVBQW9DO0FBQ2xDbTdDLFNBQUtuN0MsQ0FBTCxJQUFVbVQsTUFBTW5ULENBQU4sSUFBVyxHQUFyQjtBQUNEO0FBQ0QsU0FBT203QyxJQUFQO0FBQ0Q7O0FBRUQsU0FBU00sZUFBVCxDQUEwQk4sSUFBMUIsRUFBZ0Nob0MsS0FBaEMsRUFBdUNrcEMsVUFBdkMsRUFBbURoOEMsTUFBbkQsRUFBMkQ7QUFDekQ4UyxRQUFNK2xDLFVBQU4sQ0FEeUQsQ0FDeEM7O0FBRWpCLE1BQUltRCxhQUFhLENBQWIsSUFBa0JscEMsTUFBTStsQyxVQUFOLEdBQW1CbUQsVUFBekMsRUFBcUQ7QUFDbkQsVUFBTSxJQUFJamhDLFVBQUosQ0FBZSw2QkFBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSWpJLE1BQU0rbEMsVUFBTixHQUFtQm1ELGNBQWNoOEMsVUFBVSxDQUF4QixDQUF2QixFQUFtRDtBQUNqRCxVQUFNLElBQUkrYSxVQUFKLENBQWUsNkJBQWYsQ0FBTjtBQUNEOztBQUVELE1BQUlpaEMsZUFBZXI0QyxTQUFmLElBQTRCM0QsV0FBVzJELFNBQTNDLEVBQXNEO0FBQ3BEbVAsWUFBUSxJQUFJcW1DLFVBQUosQ0FBZXJtQyxLQUFmLENBQVI7QUFDRCxHQUZELE1BRU8sSUFBSTlTLFdBQVcyRCxTQUFmLEVBQTBCO0FBQy9CbVAsWUFBUSxJQUFJcW1DLFVBQUosQ0FBZXJtQyxLQUFmLEVBQXNCa3BDLFVBQXRCLENBQVI7QUFDRCxHQUZNLE1BRUE7QUFDTGxwQyxZQUFRLElBQUlxbUMsVUFBSixDQUFlcm1DLEtBQWYsRUFBc0JrcEMsVUFBdEIsRUFBa0NoOEMsTUFBbEMsQ0FBUjtBQUNEOztBQUVELE1BQUk4MkMsT0FBTzBELG1CQUFYLEVBQWdDO0FBQzlCO0FBQ0FNLFdBQU9ob0MsS0FBUDtBQUNBZ29DLFNBQUs1aUIsU0FBTCxHQUFpQjRlLE9BQU96NEIsU0FBeEI7QUFDRCxHQUpELE1BSU87QUFDTDtBQUNBeThCLFdBQU9pQixjQUFjakIsSUFBZCxFQUFvQmhvQyxLQUFwQixDQUFQO0FBQ0Q7QUFDRCxTQUFPZ29DLElBQVA7QUFDRDs7QUFFRCxTQUFTTyxVQUFULENBQXFCUCxJQUFyQixFQUEyQmpqQyxHQUEzQixFQUFnQztBQUM5QixNQUFJaS9CLE9BQU9tRixRQUFQLENBQWdCcGtDLEdBQWhCLENBQUosRUFBMEI7QUFDeEIsUUFBSStHLE1BQU0rOEIsUUFBUTlqQyxJQUFJN1gsTUFBWixJQUFzQixDQUFoQztBQUNBODZDLFdBQU9ELGFBQWFDLElBQWIsRUFBbUJsOEIsR0FBbkIsQ0FBUDs7QUFFQSxRQUFJazhCLEtBQUs5NkMsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixhQUFPODZDLElBQVA7QUFDRDs7QUFFRGpqQyxRQUFJcWtDLElBQUosQ0FBU3BCLElBQVQsRUFBZSxDQUFmLEVBQWtCLENBQWxCLEVBQXFCbDhCLEdBQXJCO0FBQ0EsV0FBT2s4QixJQUFQO0FBQ0Q7O0FBRUQsTUFBSWpqQyxHQUFKLEVBQVM7QUFDUCxRQUFLLE9BQU9zakMsV0FBUCxLQUF1QixXQUF2QixJQUNEdGpDLElBQUk3SixNQUFKLFlBQXNCbXRDLFdBRHRCLElBQ3NDLFlBQVl0akMsR0FEdEQsRUFDMkQ7QUFDekQsVUFBSSxPQUFPQSxJQUFJN1gsTUFBWCxLQUFzQixRQUF0QixJQUFrQ204QyxNQUFNdGtDLElBQUk3WCxNQUFWLENBQXRDLEVBQXlEO0FBQ3ZELGVBQU82NkMsYUFBYUMsSUFBYixFQUFtQixDQUFuQixDQUFQO0FBQ0Q7QUFDRCxhQUFPaUIsY0FBY2pCLElBQWQsRUFBb0JqakMsR0FBcEIsQ0FBUDtBQUNEOztBQUVELFFBQUlBLElBQUlsVCxJQUFKLEtBQWEsUUFBYixJQUF5QjdFLFFBQVErWCxJQUFJMU4sSUFBWixDQUE3QixFQUFnRDtBQUM5QyxhQUFPNHhDLGNBQWNqQixJQUFkLEVBQW9CampDLElBQUkxTixJQUF4QixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxRQUFNLElBQUlzWCxTQUFKLENBQWMsb0ZBQWQsQ0FBTjtBQUNEOztBQUVELFNBQVNrNkIsT0FBVCxDQUFrQjM3QyxNQUFsQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0EsTUFBSUEsVUFBVTA2QyxZQUFkLEVBQTRCO0FBQzFCLFVBQU0sSUFBSTMvQixVQUFKLENBQWUsb0RBQ0EsVUFEQSxHQUNhMi9CLGFBQWFyMUMsUUFBYixDQUFzQixFQUF0QixDQURiLEdBQ3lDLFFBRHhELENBQU47QUFFRDtBQUNELFNBQU9yRixTQUFTLENBQWhCO0FBQ0Q7O0FBRUQsU0FBU3M2QyxVQUFULENBQXFCdDZDLE1BQXJCLEVBQTZCO0FBQzNCLE1BQUksQ0FBQ0EsTUFBRCxJQUFXQSxNQUFmLEVBQXVCO0FBQUU7QUFDdkJBLGFBQVMsQ0FBVDtBQUNEO0FBQ0QsU0FBTzgyQyxPQUFPNEUsS0FBUCxDQUFhLENBQUMxN0MsTUFBZCxDQUFQO0FBQ0Q7O0FBRUQ4MkMsT0FBT21GLFFBQVAsR0FBa0IsU0FBU0EsUUFBVCxDQUFtQnJ5QixDQUFuQixFQUFzQjtBQUN0QyxTQUFPLENBQUMsRUFBRUEsS0FBSyxJQUFMLElBQWFBLEVBQUV3eUIsU0FBakIsQ0FBUjtBQUNELENBRkQ7O0FBSUF0RixPQUFPbHNCLE9BQVAsR0FBaUIsU0FBU0EsT0FBVCxDQUFrQmhnQixDQUFsQixFQUFxQmdmLENBQXJCLEVBQXdCO0FBQ3ZDLE1BQUksQ0FBQ2t0QixPQUFPbUYsUUFBUCxDQUFnQnJ4QyxDQUFoQixDQUFELElBQXVCLENBQUNrc0MsT0FBT21GLFFBQVAsQ0FBZ0JyeUIsQ0FBaEIsQ0FBNUIsRUFBZ0Q7QUFDOUMsVUFBTSxJQUFJbkksU0FBSixDQUFjLDJCQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJN1csTUFBTWdmLENBQVYsRUFBYSxPQUFPLENBQVA7O0FBRWIsTUFBSS9LLElBQUlqVSxFQUFFNUssTUFBVjtBQUNBLE1BQUk2dUIsSUFBSWpGLEVBQUU1cEIsTUFBVjs7QUFFQSxPQUFLLElBQUlMLElBQUksQ0FBUixFQUFXaWYsTUFBTWpFLEtBQUtuRyxHQUFMLENBQVNxSyxDQUFULEVBQVlnUSxDQUFaLENBQXRCLEVBQXNDbHZCLElBQUlpZixHQUExQyxFQUErQyxFQUFFamYsQ0FBakQsRUFBb0Q7QUFDbEQsUUFBSWlMLEVBQUVqTCxDQUFGLE1BQVNpcUIsRUFBRWpxQixDQUFGLENBQWIsRUFBbUI7QUFDakJrZixVQUFJalUsRUFBRWpMLENBQUYsQ0FBSjtBQUNBa3ZCLFVBQUlqRixFQUFFanFCLENBQUYsQ0FBSjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJa2YsSUFBSWdRLENBQVIsRUFBVyxPQUFPLENBQUMsQ0FBUjtBQUNYLE1BQUlBLElBQUloUSxDQUFSLEVBQVcsT0FBTyxDQUFQO0FBQ1gsU0FBTyxDQUFQO0FBQ0QsQ0FyQkQ7O0FBdUJBaTRCLE9BQU8rRSxVQUFQLEdBQW9CLFNBQVNBLFVBQVQsQ0FBcUJsdUMsUUFBckIsRUFBK0I7QUFDakQsVUFBUWtOLE9BQU9sTixRQUFQLEVBQWlCZ1EsV0FBakIsRUFBUjtBQUNFLFNBQUssS0FBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssU0FBTDtBQUNBLFNBQUssVUFBTDtBQUNFLGFBQU8sSUFBUDtBQUNGO0FBQ0UsYUFBTyxLQUFQO0FBZEo7QUFnQkQsQ0FqQkQ7O0FBbUJBbTVCLE9BQU85aEMsTUFBUCxHQUFnQixTQUFTQSxNQUFULENBQWlCcW5DLElBQWpCLEVBQXVCcjhDLE1BQXZCLEVBQStCO0FBQzdDLE1BQUksQ0FBQ0YsUUFBUXU4QyxJQUFSLENBQUwsRUFBb0I7QUFDbEIsVUFBTSxJQUFJNTZCLFNBQUosQ0FBYyw2Q0FBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSTQ2QixLQUFLcjhDLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsV0FBTzgyQyxPQUFPNEUsS0FBUCxDQUFhLENBQWIsQ0FBUDtBQUNEOztBQUVELE1BQUkvN0MsQ0FBSjtBQUNBLE1BQUlLLFdBQVcyRCxTQUFmLEVBQTBCO0FBQ3hCM0QsYUFBUyxDQUFUO0FBQ0EsU0FBS0wsSUFBSSxDQUFULEVBQVlBLElBQUkwOEMsS0FBS3I4QyxNQUFyQixFQUE2QixFQUFFTCxDQUEvQixFQUFrQztBQUNoQ0ssZ0JBQVVxOEMsS0FBSzE4QyxDQUFMLEVBQVFLLE1BQWxCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJZ08sU0FBUzhvQyxPQUFPa0UsV0FBUCxDQUFtQmg3QyxNQUFuQixDQUFiO0FBQ0EsTUFBSXlrQyxNQUFNLENBQVY7QUFDQSxPQUFLOWtDLElBQUksQ0FBVCxFQUFZQSxJQUFJMDhDLEtBQUtyOEMsTUFBckIsRUFBNkIsRUFBRUwsQ0FBL0IsRUFBa0M7QUFDaEMsUUFBSTI4QyxNQUFNRCxLQUFLMThDLENBQUwsQ0FBVjtBQUNBLFFBQUksQ0FBQ20zQyxPQUFPbUYsUUFBUCxDQUFnQkssR0FBaEIsQ0FBTCxFQUEyQjtBQUN6QixZQUFNLElBQUk3NkIsU0FBSixDQUFjLDZDQUFkLENBQU47QUFDRDtBQUNENjZCLFFBQUlKLElBQUosQ0FBU2x1QyxNQUFULEVBQWlCeTJCLEdBQWpCO0FBQ0FBLFdBQU82WCxJQUFJdDhDLE1BQVg7QUFDRDtBQUNELFNBQU9nTyxNQUFQO0FBQ0QsQ0E1QkQ7O0FBOEJBLFNBQVM2cUMsVUFBVCxDQUFxQnhsQyxNQUFyQixFQUE2QjFGLFFBQTdCLEVBQXVDO0FBQ3JDLE1BQUltcEMsT0FBT21GLFFBQVAsQ0FBZ0I1b0MsTUFBaEIsQ0FBSixFQUE2QjtBQUMzQixXQUFPQSxPQUFPclQsTUFBZDtBQUNEO0FBQ0QsTUFBSSxPQUFPbTdDLFdBQVAsS0FBdUIsV0FBdkIsSUFBc0MsT0FBT0EsWUFBWW9CLE1BQW5CLEtBQThCLFVBQXBFLEtBQ0NwQixZQUFZb0IsTUFBWixDQUFtQmxwQyxNQUFuQixLQUE4QkEsa0JBQWtCOG5DLFdBRGpELENBQUosRUFDbUU7QUFDakUsV0FBTzluQyxPQUFPd2xDLFVBQWQ7QUFDRDtBQUNELE1BQUksT0FBT3hsQyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCQSxhQUFTLEtBQUtBLE1BQWQ7QUFDRDs7QUFFRCxNQUFJdUwsTUFBTXZMLE9BQU9yVCxNQUFqQjtBQUNBLE1BQUk0ZSxRQUFRLENBQVosRUFBZSxPQUFPLENBQVA7O0FBRWY7QUFDQSxNQUFJNDlCLGNBQWMsS0FBbEI7QUFDQSxXQUFTO0FBQ1AsWUFBUTd1QyxRQUFSO0FBQ0UsV0FBSyxPQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBT2lSLEdBQVA7QUFDRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLamIsU0FBTDtBQUNFLGVBQU84NEMsWUFBWXBwQyxNQUFaLEVBQW9CclQsTUFBM0I7QUFDRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLFNBQUw7QUFDQSxXQUFLLFVBQUw7QUFDRSxlQUFPNGUsTUFBTSxDQUFiO0FBQ0YsV0FBSyxLQUFMO0FBQ0UsZUFBT0EsUUFBUSxDQUFmO0FBQ0YsV0FBSyxRQUFMO0FBQ0UsZUFBTzg5QixjQUFjcnBDLE1BQWQsRUFBc0JyVCxNQUE3QjtBQUNGO0FBQ0UsWUFBSXc4QyxXQUFKLEVBQWlCLE9BQU9DLFlBQVlwcEMsTUFBWixFQUFvQnJULE1BQTNCLENBRG5CLENBQ3FEO0FBQ25EMk4sbUJBQVcsQ0FBQyxLQUFLQSxRQUFOLEVBQWdCZ1EsV0FBaEIsRUFBWDtBQUNBNitCLHNCQUFjLElBQWQ7QUFyQko7QUF1QkQ7QUFDRjtBQUNEMUYsT0FBTytCLFVBQVAsR0FBb0JBLFVBQXBCOztBQUVBLFNBQVM4RCxZQUFULENBQXVCaHZDLFFBQXZCLEVBQWlDNEssS0FBakMsRUFBd0NQLEdBQXhDLEVBQTZDO0FBQzNDLE1BQUl3a0MsY0FBYyxLQUFsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSWprQyxVQUFVNVUsU0FBVixJQUF1QjRVLFFBQVEsQ0FBbkMsRUFBc0M7QUFDcENBLFlBQVEsQ0FBUjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLE1BQUlBLFFBQVEsS0FBS3ZZLE1BQWpCLEVBQXlCO0FBQ3ZCLFdBQU8sRUFBUDtBQUNEOztBQUVELE1BQUlnWSxRQUFRclUsU0FBUixJQUFxQnFVLE1BQU0sS0FBS2hZLE1BQXBDLEVBQTRDO0FBQzFDZ1ksVUFBTSxLQUFLaFksTUFBWDtBQUNEOztBQUVELE1BQUlnWSxPQUFPLENBQVgsRUFBYztBQUNaLFdBQU8sRUFBUDtBQUNEOztBQUVEO0FBQ0FBLFdBQVMsQ0FBVDtBQUNBTyxhQUFXLENBQVg7O0FBRUEsTUFBSVAsT0FBT08sS0FBWCxFQUFrQjtBQUNoQixXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFJLENBQUM1SyxRQUFMLEVBQWVBLFdBQVcsTUFBWDs7QUFFZixTQUFPLElBQVAsRUFBYTtBQUNYLFlBQVFBLFFBQVI7QUFDRSxXQUFLLEtBQUw7QUFDRSxlQUFPaXZDLFNBQVMsSUFBVCxFQUFlcmtDLEtBQWYsRUFBc0JQLEdBQXRCLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFBTzZrQyxVQUFVLElBQVYsRUFBZ0J0a0MsS0FBaEIsRUFBdUJQLEdBQXZCLENBQVA7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsZUFBTzhrQyxXQUFXLElBQVgsRUFBaUJ2a0MsS0FBakIsRUFBd0JQLEdBQXhCLENBQVA7O0FBRUYsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBTytrQyxZQUFZLElBQVosRUFBa0J4a0MsS0FBbEIsRUFBeUJQLEdBQXpCLENBQVA7O0FBRUYsV0FBSyxRQUFMO0FBQ0UsZUFBT2dsQyxZQUFZLElBQVosRUFBa0J6a0MsS0FBbEIsRUFBeUJQLEdBQXpCLENBQVA7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBT2lsQyxhQUFhLElBQWIsRUFBbUIxa0MsS0FBbkIsRUFBMEJQLEdBQTFCLENBQVA7O0FBRUY7QUFDRSxZQUFJd2tDLFdBQUosRUFBaUIsTUFBTSxJQUFJLzZCLFNBQUosQ0FBYyx1QkFBdUI5VCxRQUFyQyxDQUFOO0FBQ2pCQSxtQkFBVyxDQUFDQSxXQUFXLEVBQVosRUFBZ0JnUSxXQUFoQixFQUFYO0FBQ0E2K0Isc0JBQWMsSUFBZDtBQTNCSjtBQTZCRDtBQUNGOztBQUVEO0FBQ0E7QUFDQTFGLE9BQU96NEIsU0FBUCxDQUFpQis5QixTQUFqQixHQUE2QixJQUE3Qjs7QUFFQSxTQUFTYyxJQUFULENBQWV0ekIsQ0FBZixFQUFrQnJOLENBQWxCLEVBQXFCYSxDQUFyQixFQUF3QjtBQUN0QixNQUFJemQsSUFBSWlxQixFQUFFck4sQ0FBRixDQUFSO0FBQ0FxTixJQUFFck4sQ0FBRixJQUFPcU4sRUFBRXhNLENBQUYsQ0FBUDtBQUNBd00sSUFBRXhNLENBQUYsSUFBT3pkLENBQVA7QUFDRDs7QUFFRG0zQyxPQUFPejRCLFNBQVAsQ0FBaUI4K0IsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxHQUFtQjtBQUMzQyxNQUFJditCLE1BQU0sS0FBSzVlLE1BQWY7QUFDQSxNQUFJNGUsTUFBTSxDQUFOLEtBQVksQ0FBaEIsRUFBbUI7QUFDakIsVUFBTSxJQUFJN0QsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDtBQUNELE9BQUssSUFBSXBiLElBQUksQ0FBYixFQUFnQkEsSUFBSWlmLEdBQXBCLEVBQXlCamYsS0FBSyxDQUE5QixFQUFpQztBQUMvQnU5QyxTQUFLLElBQUwsRUFBV3Y5QyxDQUFYLEVBQWNBLElBQUksQ0FBbEI7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNELENBVEQ7O0FBV0FtM0MsT0FBT3o0QixTQUFQLENBQWlCKytCLE1BQWpCLEdBQTBCLFNBQVNBLE1BQVQsR0FBbUI7QUFDM0MsTUFBSXgrQixNQUFNLEtBQUs1ZSxNQUFmO0FBQ0EsTUFBSTRlLE1BQU0sQ0FBTixLQUFZLENBQWhCLEVBQW1CO0FBQ2pCLFVBQU0sSUFBSTdELFVBQUosQ0FBZSwyQ0FBZixDQUFOO0FBQ0Q7QUFDRCxPQUFLLElBQUlwYixJQUFJLENBQWIsRUFBZ0JBLElBQUlpZixHQUFwQixFQUF5QmpmLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0J1OUMsU0FBSyxJQUFMLEVBQVd2OUMsQ0FBWCxFQUFjQSxJQUFJLENBQWxCO0FBQ0F1OUMsU0FBSyxJQUFMLEVBQVd2OUMsSUFBSSxDQUFmLEVBQWtCQSxJQUFJLENBQXRCO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVZEOztBQVlBbTNDLE9BQU96NEIsU0FBUCxDQUFpQmcvQixNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQUl6K0IsTUFBTSxLQUFLNWUsTUFBZjtBQUNBLE1BQUk0ZSxNQUFNLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUk3RCxVQUFKLENBQWUsMkNBQWYsQ0FBTjtBQUNEO0FBQ0QsT0FBSyxJQUFJcGIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaWYsR0FBcEIsRUFBeUJqZixLQUFLLENBQTlCLEVBQWlDO0FBQy9CdTlDLFNBQUssSUFBTCxFQUFXdjlDLENBQVgsRUFBY0EsSUFBSSxDQUFsQjtBQUNBdTlDLFNBQUssSUFBTCxFQUFXdjlDLElBQUksQ0FBZixFQUFrQkEsSUFBSSxDQUF0QjtBQUNBdTlDLFNBQUssSUFBTCxFQUFXdjlDLElBQUksQ0FBZixFQUFrQkEsSUFBSSxDQUF0QjtBQUNBdTlDLFNBQUssSUFBTCxFQUFXdjlDLElBQUksQ0FBZixFQUFrQkEsSUFBSSxDQUF0QjtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0QsQ0FaRDs7QUFjQW0zQyxPQUFPejRCLFNBQVAsQ0FBaUJoWixRQUFqQixHQUE0QixTQUFTQSxRQUFULEdBQXFCO0FBQy9DLE1BQUlyRixTQUFTLEtBQUtBLE1BQUwsR0FBYyxDQUEzQjtBQUNBLE1BQUlBLFdBQVcsQ0FBZixFQUFrQixPQUFPLEVBQVA7QUFDbEIsTUFBSW96QyxVQUFVcHpDLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEIsT0FBTzY4QyxVQUFVLElBQVYsRUFBZ0IsQ0FBaEIsRUFBbUI3OEMsTUFBbkIsQ0FBUDtBQUM1QixTQUFPMjhDLGFBQWF0OUMsS0FBYixDQUFtQixJQUFuQixFQUF5Qit6QyxTQUF6QixDQUFQO0FBQ0QsQ0FMRDs7QUFPQTBELE9BQU96NEIsU0FBUCxDQUFpQmkvQixNQUFqQixHQUEwQixTQUFTQSxNQUFULENBQWlCMXpCLENBQWpCLEVBQW9CO0FBQzVDLE1BQUksQ0FBQ2t0QixPQUFPbUYsUUFBUCxDQUFnQnJ5QixDQUFoQixDQUFMLEVBQXlCLE1BQU0sSUFBSW5JLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ3pCLE1BQUksU0FBU21JLENBQWIsRUFBZ0IsT0FBTyxJQUFQO0FBQ2hCLFNBQU9rdEIsT0FBT2xzQixPQUFQLENBQWUsSUFBZixFQUFxQmhCLENBQXJCLE1BQTRCLENBQW5DO0FBQ0QsQ0FKRDs7QUFNQWt0QixPQUFPejRCLFNBQVAsQ0FBaUJrL0IsT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxHQUFvQjtBQUM3QyxNQUFJMzBCLE1BQU0sRUFBVjtBQUNBLE1BQUluVSxNQUFNNkUsUUFBUWloQyxpQkFBbEI7QUFDQSxNQUFJLEtBQUt2NkMsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ25CNG9CLFVBQU0sS0FBS3ZqQixRQUFMLENBQWMsS0FBZCxFQUFxQixDQUFyQixFQUF3Qm9QLEdBQXhCLEVBQTZCelMsS0FBN0IsQ0FBbUMsT0FBbkMsRUFBNEMrSSxJQUE1QyxDQUFpRCxHQUFqRCxDQUFOO0FBQ0EsUUFBSSxLQUFLL0ssTUFBTCxHQUFjeVUsR0FBbEIsRUFBdUJtVSxPQUFPLE9BQVA7QUFDeEI7QUFDRCxTQUFPLGFBQWFBLEdBQWIsR0FBbUIsR0FBMUI7QUFDRCxDQVJEOztBQVVBa3VCLE9BQU96NEIsU0FBUCxDQUFpQnVNLE9BQWpCLEdBQTJCLFNBQVNBLE9BQVQsQ0FBa0JqZ0IsTUFBbEIsRUFBMEI0TixLQUExQixFQUFpQ1AsR0FBakMsRUFBc0N3bEMsU0FBdEMsRUFBaURDLE9BQWpELEVBQTBEO0FBQ25GLE1BQUksQ0FBQzNHLE9BQU9tRixRQUFQLENBQWdCdHhDLE1BQWhCLENBQUwsRUFBOEI7QUFDNUIsVUFBTSxJQUFJOFcsU0FBSixDQUFjLDJCQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJbEosVUFBVTVVLFNBQWQsRUFBeUI7QUFDdkI0VSxZQUFRLENBQVI7QUFDRDtBQUNELE1BQUlQLFFBQVFyVSxTQUFaLEVBQXVCO0FBQ3JCcVUsVUFBTXJOLFNBQVNBLE9BQU8zSyxNQUFoQixHQUF5QixDQUEvQjtBQUNEO0FBQ0QsTUFBSXc5QyxjQUFjNzVDLFNBQWxCLEVBQTZCO0FBQzNCNjVDLGdCQUFZLENBQVo7QUFDRDtBQUNELE1BQUlDLFlBQVk5NUMsU0FBaEIsRUFBMkI7QUFDekI4NUMsY0FBVSxLQUFLejlDLE1BQWY7QUFDRDs7QUFFRCxNQUFJdVksUUFBUSxDQUFSLElBQWFQLE1BQU1yTixPQUFPM0ssTUFBMUIsSUFBb0N3OUMsWUFBWSxDQUFoRCxJQUFxREMsVUFBVSxLQUFLejlDLE1BQXhFLEVBQWdGO0FBQzlFLFVBQU0sSUFBSSthLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSXlpQyxhQUFhQyxPQUFiLElBQXdCbGxDLFNBQVNQLEdBQXJDLEVBQTBDO0FBQ3hDLFdBQU8sQ0FBUDtBQUNEO0FBQ0QsTUFBSXdsQyxhQUFhQyxPQUFqQixFQUEwQjtBQUN4QixXQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0QsTUFBSWxsQyxTQUFTUCxHQUFiLEVBQWtCO0FBQ2hCLFdBQU8sQ0FBUDtBQUNEOztBQUVETyxhQUFXLENBQVg7QUFDQVAsV0FBUyxDQUFUO0FBQ0F3bEMsaUJBQWUsQ0FBZjtBQUNBQyxlQUFhLENBQWI7O0FBRUEsTUFBSSxTQUFTOXlDLE1BQWIsRUFBcUIsT0FBTyxDQUFQOztBQUVyQixNQUFJa1UsSUFBSTQrQixVQUFVRCxTQUFsQjtBQUNBLE1BQUkzdUIsSUFBSTdXLE1BQU1PLEtBQWQ7QUFDQSxNQUFJcUcsTUFBTWpFLEtBQUtuRyxHQUFMLENBQVNxSyxDQUFULEVBQVlnUSxDQUFaLENBQVY7O0FBRUEsTUFBSTZ1QixXQUFXLEtBQUs1eUMsS0FBTCxDQUFXMHlDLFNBQVgsRUFBc0JDLE9BQXRCLENBQWY7QUFDQSxNQUFJRSxhQUFhaHpDLE9BQU9HLEtBQVAsQ0FBYXlOLEtBQWIsRUFBb0JQLEdBQXBCLENBQWpCOztBQUVBLE9BQUssSUFBSXJZLElBQUksQ0FBYixFQUFnQkEsSUFBSWlmLEdBQXBCLEVBQXlCLEVBQUVqZixDQUEzQixFQUE4QjtBQUM1QixRQUFJKzlDLFNBQVMvOUMsQ0FBVCxNQUFnQmcrQyxXQUFXaCtDLENBQVgsQ0FBcEIsRUFBbUM7QUFDakNrZixVQUFJNitCLFNBQVMvOUMsQ0FBVCxDQUFKO0FBQ0FrdkIsVUFBSTh1QixXQUFXaCtDLENBQVgsQ0FBSjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJa2YsSUFBSWdRLENBQVIsRUFBVyxPQUFPLENBQUMsQ0FBUjtBQUNYLE1BQUlBLElBQUloUSxDQUFSLEVBQVcsT0FBTyxDQUFQO0FBQ1gsU0FBTyxDQUFQO0FBQ0QsQ0F6REQ7O0FBMkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMrK0Isb0JBQVQsQ0FBK0I1dkMsTUFBL0IsRUFBdUMyeEIsR0FBdkMsRUFBNENxYyxVQUE1QyxFQUF3RHJ1QyxRQUF4RCxFQUFrRWt3QyxHQUFsRSxFQUF1RTtBQUNyRTtBQUNBLE1BQUk3dkMsT0FBT2hPLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUIsT0FBTyxDQUFDLENBQVI7O0FBRXpCO0FBQ0EsTUFBSSxPQUFPZzhDLFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7QUFDbENydUMsZUFBV3F1QyxVQUFYO0FBQ0FBLGlCQUFhLENBQWI7QUFDRCxHQUhELE1BR08sSUFBSUEsYUFBYSxVQUFqQixFQUE2QjtBQUNsQ0EsaUJBQWEsVUFBYjtBQUNELEdBRk0sTUFFQSxJQUFJQSxhQUFhLENBQUMsVUFBbEIsRUFBOEI7QUFDbkNBLGlCQUFhLENBQUMsVUFBZDtBQUNEO0FBQ0RBLGVBQWEsQ0FBQ0EsVUFBZCxDQWJxRSxDQWEzQztBQUMxQixNQUFJanVCLE1BQU1pdUIsVUFBTixDQUFKLEVBQXVCO0FBQ3JCO0FBQ0FBLGlCQUFhNkIsTUFBTSxDQUFOLEdBQVc3dkMsT0FBT2hPLE1BQVAsR0FBZ0IsQ0FBeEM7QUFDRDs7QUFFRDtBQUNBLE1BQUlnOEMsYUFBYSxDQUFqQixFQUFvQkEsYUFBYWh1QyxPQUFPaE8sTUFBUCxHQUFnQmc4QyxVQUE3QjtBQUNwQixNQUFJQSxjQUFjaHVDLE9BQU9oTyxNQUF6QixFQUFpQztBQUMvQixRQUFJNjlDLEdBQUosRUFBUyxPQUFPLENBQUMsQ0FBUixDQUFULEtBQ0s3QixhQUFhaHVDLE9BQU9oTyxNQUFQLEdBQWdCLENBQTdCO0FBQ04sR0FIRCxNQUdPLElBQUlnOEMsYUFBYSxDQUFqQixFQUFvQjtBQUN6QixRQUFJNkIsR0FBSixFQUFTN0IsYUFBYSxDQUFiLENBQVQsS0FDSyxPQUFPLENBQUMsQ0FBUjtBQUNOOztBQUVEO0FBQ0EsTUFBSSxPQUFPcmMsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCQSxVQUFNbVgsT0FBT2x4QixJQUFQLENBQVkrWixHQUFaLEVBQWlCaHlCLFFBQWpCLENBQU47QUFDRDs7QUFFRDtBQUNBLE1BQUltcEMsT0FBT21GLFFBQVAsQ0FBZ0J0YyxHQUFoQixDQUFKLEVBQTBCO0FBQ3hCO0FBQ0EsUUFBSUEsSUFBSTMvQixNQUFKLEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsYUFBTyxDQUFDLENBQVI7QUFDRDtBQUNELFdBQU84OUMsYUFBYTl2QyxNQUFiLEVBQXFCMnhCLEdBQXJCLEVBQTBCcWMsVUFBMUIsRUFBc0NydUMsUUFBdEMsRUFBZ0Rrd0MsR0FBaEQsQ0FBUDtBQUNELEdBTkQsTUFNTyxJQUFJLE9BQU9sZSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbENBLFVBQU1BLE1BQU0sSUFBWixDQURrQyxDQUNqQjtBQUNqQixRQUFJbVgsT0FBTzBELG1CQUFQLElBQ0EsT0FBT3JCLFdBQVc5NkIsU0FBWCxDQUFxQjNkLE9BQTVCLEtBQXdDLFVBRDVDLEVBQ3dEO0FBQ3RELFVBQUltOUMsR0FBSixFQUFTO0FBQ1AsZUFBTzFFLFdBQVc5NkIsU0FBWCxDQUFxQjNkLE9BQXJCLENBQTZCNGQsSUFBN0IsQ0FBa0N0USxNQUFsQyxFQUEwQzJ4QixHQUExQyxFQUErQ3FjLFVBQS9DLENBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPN0MsV0FBVzk2QixTQUFYLENBQXFCdEIsV0FBckIsQ0FBaUN1QixJQUFqQyxDQUFzQ3RRLE1BQXRDLEVBQThDMnhCLEdBQTlDLEVBQW1EcWMsVUFBbkQsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFPOEIsYUFBYTl2QyxNQUFiLEVBQXFCLENBQUUyeEIsR0FBRixDQUFyQixFQUE4QnFjLFVBQTlCLEVBQTBDcnVDLFFBQTFDLEVBQW9Ea3dDLEdBQXBELENBQVA7QUFDRDs7QUFFRCxRQUFNLElBQUlwOEIsU0FBSixDQUFjLHNDQUFkLENBQU47QUFDRDs7QUFFRCxTQUFTcThCLFlBQVQsQ0FBdUJsRSxHQUF2QixFQUE0QmphLEdBQTVCLEVBQWlDcWMsVUFBakMsRUFBNkNydUMsUUFBN0MsRUFBdURrd0MsR0FBdkQsRUFBNEQ7QUFDMUQsTUFBSUUsWUFBWSxDQUFoQjtBQUNBLE1BQUlDLFlBQVlwRSxJQUFJNTVDLE1BQXBCO0FBQ0EsTUFBSWkrQyxZQUFZdGUsSUFBSTMvQixNQUFwQjs7QUFFQSxNQUFJMk4sYUFBYWhLLFNBQWpCLEVBQTRCO0FBQzFCZ0ssZUFBV2tOLE9BQU9sTixRQUFQLEVBQWlCZ1EsV0FBakIsRUFBWDtBQUNBLFFBQUloUSxhQUFhLE1BQWIsSUFBdUJBLGFBQWEsT0FBcEMsSUFDQUEsYUFBYSxTQURiLElBQzBCQSxhQUFhLFVBRDNDLEVBQ3VEO0FBQ3JELFVBQUlpc0MsSUFBSTU1QyxNQUFKLEdBQWEsQ0FBYixJQUFrQjIvQixJQUFJMy9CLE1BQUosR0FBYSxDQUFuQyxFQUFzQztBQUNwQyxlQUFPLENBQUMsQ0FBUjtBQUNEO0FBQ0QrOUMsa0JBQVksQ0FBWjtBQUNBQyxtQkFBYSxDQUFiO0FBQ0FDLG1CQUFhLENBQWI7QUFDQWpDLG9CQUFjLENBQWQ7QUFDRDtBQUNGOztBQUVELFdBQVNrQyxJQUFULENBQWU1QixHQUFmLEVBQW9CMzhDLENBQXBCLEVBQXVCO0FBQ3JCLFFBQUlvK0MsY0FBYyxDQUFsQixFQUFxQjtBQUNuQixhQUFPekIsSUFBSTM4QyxDQUFKLENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPMjhDLElBQUk2QixZQUFKLENBQWlCeCtDLElBQUlvK0MsU0FBckIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXArQyxDQUFKO0FBQ0EsTUFBSWsrQyxHQUFKLEVBQVM7QUFDUCxRQUFJTyxhQUFhLENBQUMsQ0FBbEI7QUFDQSxTQUFLeitDLElBQUlxOEMsVUFBVCxFQUFxQnI4QyxJQUFJcStDLFNBQXpCLEVBQW9DcitDLEdBQXBDLEVBQXlDO0FBQ3ZDLFVBQUl1K0MsS0FBS3RFLEdBQUwsRUFBVWo2QyxDQUFWLE1BQWlCdStDLEtBQUt2ZSxHQUFMLEVBQVV5ZSxlQUFlLENBQUMsQ0FBaEIsR0FBb0IsQ0FBcEIsR0FBd0J6K0MsSUFBSXkrQyxVQUF0QyxDQUFyQixFQUF3RTtBQUN0RSxZQUFJQSxlQUFlLENBQUMsQ0FBcEIsRUFBdUJBLGFBQWF6K0MsQ0FBYjtBQUN2QixZQUFJQSxJQUFJeStDLFVBQUosR0FBaUIsQ0FBakIsS0FBdUJILFNBQTNCLEVBQXNDLE9BQU9HLGFBQWFMLFNBQXBCO0FBQ3ZDLE9BSEQsTUFHTztBQUNMLFlBQUlLLGVBQWUsQ0FBQyxDQUFwQixFQUF1QnorQyxLQUFLQSxJQUFJeStDLFVBQVQ7QUFDdkJBLHFCQUFhLENBQUMsQ0FBZDtBQUNEO0FBQ0Y7QUFDRixHQVhELE1BV087QUFDTCxRQUFJcEMsYUFBYWlDLFNBQWIsR0FBeUJELFNBQTdCLEVBQXdDaEMsYUFBYWdDLFlBQVlDLFNBQXpCO0FBQ3hDLFNBQUt0K0MsSUFBSXE4QyxVQUFULEVBQXFCcjhDLEtBQUssQ0FBMUIsRUFBNkJBLEdBQTdCLEVBQWtDO0FBQ2hDLFVBQUkwK0MsUUFBUSxJQUFaO0FBQ0EsV0FBSyxJQUFJM2hDLElBQUksQ0FBYixFQUFnQkEsSUFBSXVoQyxTQUFwQixFQUErQnZoQyxHQUEvQixFQUFvQztBQUNsQyxZQUFJd2hDLEtBQUt0RSxHQUFMLEVBQVVqNkMsSUFBSStjLENBQWQsTUFBcUJ3aEMsS0FBS3ZlLEdBQUwsRUFBVWpqQixDQUFWLENBQXpCLEVBQXVDO0FBQ3JDMmhDLGtCQUFRLEtBQVI7QUFDQTtBQUNEO0FBQ0Y7QUFDRCxVQUFJQSxLQUFKLEVBQVcsT0FBTzErQyxDQUFQO0FBQ1o7QUFDRjs7QUFFRCxTQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVEbTNDLE9BQU96NEIsU0FBUCxDQUFpQmlnQyxRQUFqQixHQUE0QixTQUFTQSxRQUFULENBQW1CM2UsR0FBbkIsRUFBd0JxYyxVQUF4QixFQUFvQ3J1QyxRQUFwQyxFQUE4QztBQUN4RSxTQUFPLEtBQUtqTixPQUFMLENBQWFpL0IsR0FBYixFQUFrQnFjLFVBQWxCLEVBQThCcnVDLFFBQTlCLE1BQTRDLENBQUMsQ0FBcEQ7QUFDRCxDQUZEOztBQUlBbXBDLE9BQU96NEIsU0FBUCxDQUFpQjNkLE9BQWpCLEdBQTJCLFNBQVNBLE9BQVQsQ0FBa0JpL0IsR0FBbEIsRUFBdUJxYyxVQUF2QixFQUFtQ3J1QyxRQUFuQyxFQUE2QztBQUN0RSxTQUFPaXdDLHFCQUFxQixJQUFyQixFQUEyQmplLEdBQTNCLEVBQWdDcWMsVUFBaEMsRUFBNENydUMsUUFBNUMsRUFBc0QsSUFBdEQsQ0FBUDtBQUNELENBRkQ7O0FBSUFtcEMsT0FBT3o0QixTQUFQLENBQWlCdEIsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQjRpQixHQUF0QixFQUEyQnFjLFVBQTNCLEVBQXVDcnVDLFFBQXZDLEVBQWlEO0FBQzlFLFNBQU9pd0MscUJBQXFCLElBQXJCLEVBQTJCamUsR0FBM0IsRUFBZ0NxYyxVQUFoQyxFQUE0Q3J1QyxRQUE1QyxFQUFzRCxLQUF0RCxDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTNHdDLFFBQVQsQ0FBbUJqQyxHQUFuQixFQUF3QmpwQyxNQUF4QixFQUFnQ3loQyxNQUFoQyxFQUF3QzkwQyxNQUF4QyxFQUFnRDtBQUM5QzgwQyxXQUFTaG5CLE9BQU9nbkIsTUFBUCxLQUFrQixDQUEzQjtBQUNBLE1BQUkwSixZQUFZbEMsSUFBSXQ4QyxNQUFKLEdBQWE4MEMsTUFBN0I7QUFDQSxNQUFJLENBQUM5MEMsTUFBTCxFQUFhO0FBQ1hBLGFBQVN3K0MsU0FBVDtBQUNELEdBRkQsTUFFTztBQUNMeCtDLGFBQVM4dEIsT0FBTzl0QixNQUFQLENBQVQ7QUFDQSxRQUFJQSxTQUFTdytDLFNBQWIsRUFBd0I7QUFDdEJ4K0MsZUFBU3crQyxTQUFUO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLE1BQUlDLFNBQVNwckMsT0FBT3JULE1BQXBCO0FBQ0EsTUFBSXkrQyxTQUFTLENBQVQsS0FBZSxDQUFuQixFQUFzQixNQUFNLElBQUloOUIsU0FBSixDQUFjLG9CQUFkLENBQU47O0FBRXRCLE1BQUl6aEIsU0FBU3krQyxTQUFTLENBQXRCLEVBQXlCO0FBQ3ZCeitDLGFBQVN5K0MsU0FBUyxDQUFsQjtBQUNEO0FBQ0QsT0FBSyxJQUFJOStDLElBQUksQ0FBYixFQUFnQkEsSUFBSUssTUFBcEIsRUFBNEIsRUFBRUwsQ0FBOUIsRUFBaUM7QUFDL0IsUUFBSWt0QixTQUFTL0QsU0FBU3pWLE9BQU9ySSxNQUFQLENBQWNyTCxJQUFJLENBQWxCLEVBQXFCLENBQXJCLENBQVQsRUFBa0MsRUFBbEMsQ0FBYjtBQUNBLFFBQUlvdUIsTUFBTWxCLE1BQU4sQ0FBSixFQUFtQixPQUFPbHRCLENBQVA7QUFDbkIyOEMsUUFBSXhILFNBQVNuMUMsQ0FBYixJQUFrQmt0QixNQUFsQjtBQUNEO0FBQ0QsU0FBT2x0QixDQUFQO0FBQ0Q7O0FBRUQsU0FBUysrQyxTQUFULENBQW9CcEMsR0FBcEIsRUFBeUJqcEMsTUFBekIsRUFBaUN5aEMsTUFBakMsRUFBeUM5MEMsTUFBekMsRUFBaUQ7QUFDL0MsU0FBTzIrQyxXQUFXbEMsWUFBWXBwQyxNQUFaLEVBQW9CaXBDLElBQUl0OEMsTUFBSixHQUFhODBDLE1BQWpDLENBQVgsRUFBcUR3SCxHQUFyRCxFQUEwRHhILE1BQTFELEVBQWtFOTBDLE1BQWxFLENBQVA7QUFDRDs7QUFFRCxTQUFTNCtDLFVBQVQsQ0FBcUJ0QyxHQUFyQixFQUEwQmpwQyxNQUExQixFQUFrQ3loQyxNQUFsQyxFQUEwQzkwQyxNQUExQyxFQUFrRDtBQUNoRCxTQUFPMitDLFdBQVdFLGFBQWF4ckMsTUFBYixDQUFYLEVBQWlDaXBDLEdBQWpDLEVBQXNDeEgsTUFBdEMsRUFBOEM5MEMsTUFBOUMsQ0FBUDtBQUNEOztBQUVELFNBQVM4K0MsV0FBVCxDQUFzQnhDLEdBQXRCLEVBQTJCanBDLE1BQTNCLEVBQW1DeWhDLE1BQW5DLEVBQTJDOTBDLE1BQTNDLEVBQW1EO0FBQ2pELFNBQU80K0MsV0FBV3RDLEdBQVgsRUFBZ0JqcEMsTUFBaEIsRUFBd0J5aEMsTUFBeEIsRUFBZ0M5MEMsTUFBaEMsQ0FBUDtBQUNEOztBQUVELFNBQVMrK0MsV0FBVCxDQUFzQnpDLEdBQXRCLEVBQTJCanBDLE1BQTNCLEVBQW1DeWhDLE1BQW5DLEVBQTJDOTBDLE1BQTNDLEVBQW1EO0FBQ2pELFNBQU8yK0MsV0FBV2pDLGNBQWNycEMsTUFBZCxDQUFYLEVBQWtDaXBDLEdBQWxDLEVBQXVDeEgsTUFBdkMsRUFBK0M5MEMsTUFBL0MsQ0FBUDtBQUNEOztBQUVELFNBQVNnL0MsU0FBVCxDQUFvQjFDLEdBQXBCLEVBQXlCanBDLE1BQXpCLEVBQWlDeWhDLE1BQWpDLEVBQXlDOTBDLE1BQXpDLEVBQWlEO0FBQy9DLFNBQU8yK0MsV0FBV00sZUFBZTVyQyxNQUFmLEVBQXVCaXBDLElBQUl0OEMsTUFBSixHQUFhODBDLE1BQXBDLENBQVgsRUFBd0R3SCxHQUF4RCxFQUE2RHhILE1BQTdELEVBQXFFOTBDLE1BQXJFLENBQVA7QUFDRDs7QUFFRDgyQyxPQUFPejRCLFNBQVAsQ0FBaUJ5OUIsS0FBakIsR0FBeUIsU0FBU0EsS0FBVCxDQUFnQnpvQyxNQUFoQixFQUF3QnloQyxNQUF4QixFQUFnQzkwQyxNQUFoQyxFQUF3QzJOLFFBQXhDLEVBQWtEO0FBQ3pFO0FBQ0EsTUFBSW1uQyxXQUFXbnhDLFNBQWYsRUFBMEI7QUFDeEJnSyxlQUFXLE1BQVg7QUFDQTNOLGFBQVMsS0FBS0EsTUFBZDtBQUNBODBDLGFBQVMsQ0FBVDtBQUNGO0FBQ0MsR0FMRCxNQUtPLElBQUk5MEMsV0FBVzJELFNBQVgsSUFBd0IsT0FBT214QyxNQUFQLEtBQWtCLFFBQTlDLEVBQXdEO0FBQzdEbm5DLGVBQVdtbkMsTUFBWDtBQUNBOTBDLGFBQVMsS0FBS0EsTUFBZDtBQUNBODBDLGFBQVMsQ0FBVDtBQUNGO0FBQ0MsR0FMTSxNQUtBLElBQUkxMUIsU0FBUzAxQixNQUFULENBQUosRUFBc0I7QUFDM0JBLGFBQVNBLFNBQVMsQ0FBbEI7QUFDQSxRQUFJMTFCLFNBQVNwZixNQUFULENBQUosRUFBc0I7QUFDcEJBLGVBQVNBLFNBQVMsQ0FBbEI7QUFDQSxVQUFJMk4sYUFBYWhLLFNBQWpCLEVBQTRCZ0ssV0FBVyxNQUFYO0FBQzdCLEtBSEQsTUFHTztBQUNMQSxpQkFBVzNOLE1BQVg7QUFDQUEsZUFBUzJELFNBQVQ7QUFDRDtBQUNIO0FBQ0MsR0FWTSxNQVVBO0FBQ0wsVUFBTSxJQUFJakIsS0FBSixDQUNKLHlFQURJLENBQU47QUFHRDs7QUFFRCxNQUFJODdDLFlBQVksS0FBS3grQyxNQUFMLEdBQWM4MEMsTUFBOUI7QUFDQSxNQUFJOTBDLFdBQVcyRCxTQUFYLElBQXdCM0QsU0FBU3crQyxTQUFyQyxFQUFnRHgrQyxTQUFTdytDLFNBQVQ7O0FBRWhELE1BQUtuckMsT0FBT3JULE1BQVAsR0FBZ0IsQ0FBaEIsS0FBc0JBLFNBQVMsQ0FBVCxJQUFjODBDLFNBQVMsQ0FBN0MsQ0FBRCxJQUFxREEsU0FBUyxLQUFLOTBDLE1BQXZFLEVBQStFO0FBQzdFLFVBQU0sSUFBSSthLFVBQUosQ0FBZSx3Q0FBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDcE4sUUFBTCxFQUFlQSxXQUFXLE1BQVg7O0FBRWYsTUFBSTZ1QyxjQUFjLEtBQWxCO0FBQ0EsV0FBUztBQUNQLFlBQVE3dUMsUUFBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU80d0MsU0FBUyxJQUFULEVBQWVsckMsTUFBZixFQUF1QnloQyxNQUF2QixFQUErQjkwQyxNQUEvQixDQUFQOztBQUVGLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNFLGVBQU8wK0MsVUFBVSxJQUFWLEVBQWdCcnJDLE1BQWhCLEVBQXdCeWhDLE1BQXhCLEVBQWdDOTBDLE1BQWhDLENBQVA7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsZUFBTzQrQyxXQUFXLElBQVgsRUFBaUJ2ckMsTUFBakIsRUFBeUJ5aEMsTUFBekIsRUFBaUM5MEMsTUFBakMsQ0FBUDs7QUFFRixXQUFLLFFBQUw7QUFDQSxXQUFLLFFBQUw7QUFDRSxlQUFPOCtDLFlBQVksSUFBWixFQUFrQnpyQyxNQUFsQixFQUEwQnloQyxNQUExQixFQUFrQzkwQyxNQUFsQyxDQUFQOztBQUVGLFdBQUssUUFBTDtBQUNFO0FBQ0EsZUFBTysrQyxZQUFZLElBQVosRUFBa0IxckMsTUFBbEIsRUFBMEJ5aEMsTUFBMUIsRUFBa0M5MEMsTUFBbEMsQ0FBUDs7QUFFRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLFNBQUw7QUFDQSxXQUFLLFVBQUw7QUFDRSxlQUFPZy9DLFVBQVUsSUFBVixFQUFnQjNyQyxNQUFoQixFQUF3QnloQyxNQUF4QixFQUFnQzkwQyxNQUFoQyxDQUFQOztBQUVGO0FBQ0UsWUFBSXc4QyxXQUFKLEVBQWlCLE1BQU0sSUFBSS82QixTQUFKLENBQWMsdUJBQXVCOVQsUUFBckMsQ0FBTjtBQUNqQkEsbUJBQVcsQ0FBQyxLQUFLQSxRQUFOLEVBQWdCZ1EsV0FBaEIsRUFBWDtBQUNBNitCLHNCQUFjLElBQWQ7QUE1Qko7QUE4QkQ7QUFDRixDQXRFRDs7QUF3RUExRixPQUFPejRCLFNBQVAsQ0FBaUI3RixNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLFNBQU87QUFDTDdULFVBQU0sUUFERDtBQUVMd0YsVUFBTXRLLE1BQU13ZSxTQUFOLENBQWdCdlQsS0FBaEIsQ0FBc0J3VCxJQUF0QixDQUEyQixLQUFLNGdDLElBQUwsSUFBYSxJQUF4QyxFQUE4QyxDQUE5QztBQUZELEdBQVA7QUFJRCxDQUxEOztBQU9BLFNBQVNsQyxXQUFULENBQXNCVixHQUF0QixFQUEyQi9qQyxLQUEzQixFQUFrQ1AsR0FBbEMsRUFBdUM7QUFDckMsTUFBSU8sVUFBVSxDQUFWLElBQWVQLFFBQVFza0MsSUFBSXQ4QyxNQUEvQixFQUF1QztBQUNyQyxXQUFPbTZDLE9BQU9wQixhQUFQLENBQXFCdUQsR0FBckIsQ0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU9uQyxPQUFPcEIsYUFBUCxDQUFxQnVELElBQUl4eEMsS0FBSixDQUFVeU4sS0FBVixFQUFpQlAsR0FBakIsQ0FBckIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBUzZrQyxTQUFULENBQW9CUCxHQUFwQixFQUF5Qi9qQyxLQUF6QixFQUFnQ1AsR0FBaEMsRUFBcUM7QUFDbkNBLFFBQU0yQyxLQUFLbkcsR0FBTCxDQUFTOG5DLElBQUl0OEMsTUFBYixFQUFxQmdZLEdBQXJCLENBQU47QUFDQSxNQUFJbW5DLE1BQU0sRUFBVjs7QUFFQSxNQUFJeC9DLElBQUk0WSxLQUFSO0FBQ0EsU0FBTzVZLElBQUlxWSxHQUFYLEVBQWdCO0FBQ2QsUUFBSW9uQyxZQUFZOUMsSUFBSTM4QyxDQUFKLENBQWhCO0FBQ0EsUUFBSStiLFlBQVksSUFBaEI7QUFDQSxRQUFJMmpDLG1CQUFvQkQsWUFBWSxJQUFiLEdBQXFCLENBQXJCLEdBQ2xCQSxZQUFZLElBQWIsR0FBcUIsQ0FBckIsR0FDQ0EsWUFBWSxJQUFiLEdBQXFCLENBQXJCLEdBQ0EsQ0FISjs7QUFLQSxRQUFJei9DLElBQUkwL0MsZ0JBQUosSUFBd0JybkMsR0FBNUIsRUFBaUM7QUFDL0IsVUFBSXNuQyxVQUFKLEVBQWdCQyxTQUFoQixFQUEyQkMsVUFBM0IsRUFBdUNDLGFBQXZDOztBQUVBLGNBQVFKLGdCQUFSO0FBQ0UsYUFBSyxDQUFMO0FBQ0UsY0FBSUQsWUFBWSxJQUFoQixFQUFzQjtBQUNwQjFqQyx3QkFBWTBqQyxTQUFaO0FBQ0Q7QUFDRDtBQUNGLGFBQUssQ0FBTDtBQUNFRSx1QkFBYWhELElBQUkzOEMsSUFBSSxDQUFSLENBQWI7QUFDQSxjQUFJLENBQUMyL0MsYUFBYSxJQUFkLE1BQXdCLElBQTVCLEVBQWtDO0FBQ2hDRyw0QkFBZ0IsQ0FBQ0wsWUFBWSxJQUFiLEtBQXNCLEdBQXRCLEdBQTZCRSxhQUFhLElBQTFEO0FBQ0EsZ0JBQUlHLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4Qi9qQywwQkFBWStqQyxhQUFaO0FBQ0Q7QUFDRjtBQUNEO0FBQ0YsYUFBSyxDQUFMO0FBQ0VILHVCQUFhaEQsSUFBSTM4QyxJQUFJLENBQVIsQ0FBYjtBQUNBNC9DLHNCQUFZakQsSUFBSTM4QyxJQUFJLENBQVIsQ0FBWjtBQUNBLGNBQUksQ0FBQzIvQyxhQUFhLElBQWQsTUFBd0IsSUFBeEIsSUFBZ0MsQ0FBQ0MsWUFBWSxJQUFiLE1BQXVCLElBQTNELEVBQWlFO0FBQy9ERSw0QkFBZ0IsQ0FBQ0wsWUFBWSxHQUFiLEtBQXFCLEdBQXJCLEdBQTJCLENBQUNFLGFBQWEsSUFBZCxLQUF1QixHQUFsRCxHQUF5REMsWUFBWSxJQUFyRjtBQUNBLGdCQUFJRSxnQkFBZ0IsS0FBaEIsS0FBMEJBLGdCQUFnQixNQUFoQixJQUEwQkEsZ0JBQWdCLE1BQXBFLENBQUosRUFBaUY7QUFDL0UvakMsMEJBQVkrakMsYUFBWjtBQUNEO0FBQ0Y7QUFDRDtBQUNGLGFBQUssQ0FBTDtBQUNFSCx1QkFBYWhELElBQUkzOEMsSUFBSSxDQUFSLENBQWI7QUFDQTQvQyxzQkFBWWpELElBQUkzOEMsSUFBSSxDQUFSLENBQVo7QUFDQTYvQyx1QkFBYWxELElBQUkzOEMsSUFBSSxDQUFSLENBQWI7QUFDQSxjQUFJLENBQUMyL0MsYUFBYSxJQUFkLE1BQXdCLElBQXhCLElBQWdDLENBQUNDLFlBQVksSUFBYixNQUF1QixJQUF2RCxJQUErRCxDQUFDQyxhQUFhLElBQWQsTUFBd0IsSUFBM0YsRUFBaUc7QUFDL0ZDLDRCQUFnQixDQUFDTCxZQUFZLEdBQWIsS0FBcUIsSUFBckIsR0FBNEIsQ0FBQ0UsYUFBYSxJQUFkLEtBQXVCLEdBQW5ELEdBQXlELENBQUNDLFlBQVksSUFBYixLQUFzQixHQUEvRSxHQUFzRkMsYUFBYSxJQUFuSDtBQUNBLGdCQUFJQyxnQkFBZ0IsTUFBaEIsSUFBMEJBLGdCQUFnQixRQUE5QyxFQUF3RDtBQUN0RC9qQywwQkFBWStqQyxhQUFaO0FBQ0Q7QUFDRjtBQWxDTDtBQW9DRDs7QUFFRCxRQUFJL2pDLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBQSxrQkFBWSxNQUFaO0FBQ0EyakMseUJBQW1CLENBQW5CO0FBQ0QsS0FMRCxNQUtPLElBQUkzakMsWUFBWSxNQUFoQixFQUF3QjtBQUM3QjtBQUNBQSxtQkFBYSxPQUFiO0FBQ0F5akMsVUFBSXgrQyxJQUFKLENBQVMrYSxjQUFjLEVBQWQsR0FBbUIsS0FBbkIsR0FBMkIsTUFBcEM7QUFDQUEsa0JBQVksU0FBU0EsWUFBWSxLQUFqQztBQUNEOztBQUVEeWpDLFFBQUl4K0MsSUFBSixDQUFTK2EsU0FBVDtBQUNBL2IsU0FBSzAvQyxnQkFBTDtBQUNEOztBQUVELFNBQU9LLHNCQUFzQlAsR0FBdEIsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUlRLHVCQUF1QixNQUEzQjs7QUFFQSxTQUFTRCxxQkFBVCxDQUFnQ0UsVUFBaEMsRUFBNEM7QUFDMUMsTUFBSWhoQyxNQUFNZ2hDLFdBQVc1L0MsTUFBckI7QUFDQSxNQUFJNGUsT0FBTytnQyxvQkFBWCxFQUFpQztBQUMvQixXQUFPOWtDLE9BQU9DLFlBQVAsQ0FBb0J6YixLQUFwQixDQUEwQndiLE1BQTFCLEVBQWtDK2tDLFVBQWxDLENBQVAsQ0FEK0IsQ0FDc0I7QUFDdEQ7O0FBRUQ7QUFDQSxNQUFJVCxNQUFNLEVBQVY7QUFDQSxNQUFJeC9DLElBQUksQ0FBUjtBQUNBLFNBQU9BLElBQUlpZixHQUFYLEVBQWdCO0FBQ2R1Z0MsV0FBT3RrQyxPQUFPQyxZQUFQLENBQW9CemIsS0FBcEIsQ0FDTHdiLE1BREssRUFFTCtrQyxXQUFXOTBDLEtBQVgsQ0FBaUJuTCxDQUFqQixFQUFvQkEsS0FBS2dnRCxvQkFBekIsQ0FGSyxDQUFQO0FBSUQ7QUFDRCxTQUFPUixHQUFQO0FBQ0Q7O0FBRUQsU0FBU3JDLFVBQVQsQ0FBcUJSLEdBQXJCLEVBQTBCL2pDLEtBQTFCLEVBQWlDUCxHQUFqQyxFQUFzQztBQUNwQyxNQUFJNm5DLE1BQU0sRUFBVjtBQUNBN25DLFFBQU0yQyxLQUFLbkcsR0FBTCxDQUFTOG5DLElBQUl0OEMsTUFBYixFQUFxQmdZLEdBQXJCLENBQU47O0FBRUEsT0FBSyxJQUFJclksSUFBSTRZLEtBQWIsRUFBb0I1WSxJQUFJcVksR0FBeEIsRUFBNkIsRUFBRXJZLENBQS9CLEVBQWtDO0FBQ2hDa2dELFdBQU9obEMsT0FBT0MsWUFBUCxDQUFvQndoQyxJQUFJMzhDLENBQUosSUFBUyxJQUE3QixDQUFQO0FBQ0Q7QUFDRCxTQUFPa2dELEdBQVA7QUFDRDs7QUFFRCxTQUFTOUMsV0FBVCxDQUFzQlQsR0FBdEIsRUFBMkIvakMsS0FBM0IsRUFBa0NQLEdBQWxDLEVBQXVDO0FBQ3JDLE1BQUk2bkMsTUFBTSxFQUFWO0FBQ0E3bkMsUUFBTTJDLEtBQUtuRyxHQUFMLENBQVM4bkMsSUFBSXQ4QyxNQUFiLEVBQXFCZ1ksR0FBckIsQ0FBTjs7QUFFQSxPQUFLLElBQUlyWSxJQUFJNFksS0FBYixFQUFvQjVZLElBQUlxWSxHQUF4QixFQUE2QixFQUFFclksQ0FBL0IsRUFBa0M7QUFDaENrZ0QsV0FBT2hsQyxPQUFPQyxZQUFQLENBQW9Cd2hDLElBQUkzOEMsQ0FBSixDQUFwQixDQUFQO0FBQ0Q7QUFDRCxTQUFPa2dELEdBQVA7QUFDRDs7QUFFRCxTQUFTakQsUUFBVCxDQUFtQk4sR0FBbkIsRUFBd0IvakMsS0FBeEIsRUFBK0JQLEdBQS9CLEVBQW9DO0FBQ2xDLE1BQUk0RyxNQUFNMDlCLElBQUl0OEMsTUFBZDs7QUFFQSxNQUFJLENBQUN1WSxLQUFELElBQVVBLFFBQVEsQ0FBdEIsRUFBeUJBLFFBQVEsQ0FBUjtBQUN6QixNQUFJLENBQUNQLEdBQUQsSUFBUUEsTUFBTSxDQUFkLElBQW1CQSxNQUFNNEcsR0FBN0IsRUFBa0M1RyxNQUFNNEcsR0FBTjs7QUFFbEMsTUFBSXRDLE1BQU0sRUFBVjtBQUNBLE9BQUssSUFBSTNjLElBQUk0WSxLQUFiLEVBQW9CNVksSUFBSXFZLEdBQXhCLEVBQTZCLEVBQUVyWSxDQUEvQixFQUFrQztBQUNoQzJjLFdBQU93akMsTUFBTXhELElBQUkzOEMsQ0FBSixDQUFOLENBQVA7QUFDRDtBQUNELFNBQU8yYyxHQUFQO0FBQ0Q7O0FBRUQsU0FBUzJnQyxZQUFULENBQXVCWCxHQUF2QixFQUE0Qi9qQyxLQUE1QixFQUFtQ1AsR0FBbkMsRUFBd0M7QUFDdEMsTUFBSStuQyxRQUFRekQsSUFBSXh4QyxLQUFKLENBQVV5TixLQUFWLEVBQWlCUCxHQUFqQixDQUFaO0FBQ0EsTUFBSW1uQyxNQUFNLEVBQVY7QUFDQSxPQUFLLElBQUl4L0MsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb2dELE1BQU0vL0MsTUFBMUIsRUFBa0NMLEtBQUssQ0FBdkMsRUFBMEM7QUFDeEN3L0MsV0FBT3RrQyxPQUFPQyxZQUFQLENBQW9CaWxDLE1BQU1wZ0QsQ0FBTixJQUFXb2dELE1BQU1wZ0QsSUFBSSxDQUFWLElBQWUsR0FBOUMsQ0FBUDtBQUNEO0FBQ0QsU0FBT3cvQyxHQUFQO0FBQ0Q7O0FBRURySSxPQUFPejRCLFNBQVAsQ0FBaUJ2VCxLQUFqQixHQUF5QixTQUFTQSxLQUFULENBQWdCeU4sS0FBaEIsRUFBdUJQLEdBQXZCLEVBQTRCO0FBQ25ELE1BQUk0RyxNQUFNLEtBQUs1ZSxNQUFmO0FBQ0F1WSxVQUFRLENBQUMsQ0FBQ0EsS0FBVjtBQUNBUCxRQUFNQSxRQUFRclUsU0FBUixHQUFvQmliLEdBQXBCLEdBQTBCLENBQUMsQ0FBQzVHLEdBQWxDOztBQUVBLE1BQUlPLFFBQVEsQ0FBWixFQUFlO0FBQ2JBLGFBQVNxRyxHQUFUO0FBQ0EsUUFBSXJHLFFBQVEsQ0FBWixFQUFlQSxRQUFRLENBQVI7QUFDaEIsR0FIRCxNQUdPLElBQUlBLFFBQVFxRyxHQUFaLEVBQWlCO0FBQ3RCckcsWUFBUXFHLEdBQVI7QUFDRDs7QUFFRCxNQUFJNUcsTUFBTSxDQUFWLEVBQWE7QUFDWEEsV0FBTzRHLEdBQVA7QUFDQSxRQUFJNUcsTUFBTSxDQUFWLEVBQWFBLE1BQU0sQ0FBTjtBQUNkLEdBSEQsTUFHTyxJQUFJQSxNQUFNNEcsR0FBVixFQUFlO0FBQ3BCNUcsVUFBTTRHLEdBQU47QUFDRDs7QUFFRCxNQUFJNUcsTUFBTU8sS0FBVixFQUFpQlAsTUFBTU8sS0FBTjs7QUFFakIsTUFBSXluQyxNQUFKO0FBQ0EsTUFBSWxKLE9BQU8wRCxtQkFBWCxFQUFnQztBQUM5QndGLGFBQVMsS0FBS3BGLFFBQUwsQ0FBY3JpQyxLQUFkLEVBQXFCUCxHQUFyQixDQUFUO0FBQ0Fnb0MsV0FBTzluQixTQUFQLEdBQW1CNGUsT0FBT3o0QixTQUExQjtBQUNELEdBSEQsTUFHTztBQUNMLFFBQUk0aEMsV0FBV2pvQyxNQUFNTyxLQUFyQjtBQUNBeW5DLGFBQVMsSUFBSWxKLE1BQUosQ0FBV21KLFFBQVgsRUFBcUJ0OEMsU0FBckIsQ0FBVDtBQUNBLFNBQUssSUFBSWhFLElBQUksQ0FBYixFQUFnQkEsSUFBSXNnRCxRQUFwQixFQUE4QixFQUFFdGdELENBQWhDLEVBQW1DO0FBQ2pDcWdELGFBQU9yZ0QsQ0FBUCxJQUFZLEtBQUtBLElBQUk0WSxLQUFULENBQVo7QUFDRDtBQUNGOztBQUVELFNBQU95bkMsTUFBUDtBQUNELENBbENEOztBQW9DQTs7O0FBR0EsU0FBU0UsV0FBVCxDQUFzQnBMLE1BQXRCLEVBQThCcUwsR0FBOUIsRUFBbUNuZ0QsTUFBbkMsRUFBMkM7QUFDekMsTUFBSzgwQyxTQUFTLENBQVYsS0FBaUIsQ0FBakIsSUFBc0JBLFNBQVMsQ0FBbkMsRUFBc0MsTUFBTSxJQUFJLzVCLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ3RDLE1BQUkrNUIsU0FBU3FMLEdBQVQsR0FBZW5nRCxNQUFuQixFQUEyQixNQUFNLElBQUkrYSxVQUFKLENBQWUsdUNBQWYsQ0FBTjtBQUM1Qjs7QUFFRCs3QixPQUFPejRCLFNBQVAsQ0FBaUIraEMsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQnRMLE1BQXJCLEVBQTZCK0QsVUFBN0IsRUFBeUN3SCxRQUF6QyxFQUFtRDtBQUMvRXZMLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQStELGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUN3SCxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CK0QsVUFBcEIsRUFBZ0MsS0FBSzc0QyxNQUFyQzs7QUFFZixNQUFJMi9CLE1BQU0sS0FBS21WLE1BQUwsQ0FBVjtBQUNBLE1BQUl3TCxNQUFNLENBQVY7QUFDQSxNQUFJM2dELElBQUksQ0FBUjtBQUNBLFNBQU8sRUFBRUEsQ0FBRixHQUFNazVDLFVBQU4sS0FBcUJ5SCxPQUFPLEtBQTVCLENBQVAsRUFBMkM7QUFDekMzZ0IsV0FBTyxLQUFLbVYsU0FBU24xQyxDQUFkLElBQW1CMmdELEdBQTFCO0FBQ0Q7O0FBRUQsU0FBTzNnQixHQUFQO0FBQ0QsQ0FiRDs7QUFlQW1YLE9BQU96NEIsU0FBUCxDQUFpQmtpQyxVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCekwsTUFBckIsRUFBNkIrRCxVQUE3QixFQUF5Q3dILFFBQXpDLEVBQW1EO0FBQy9FdkwsV0FBU0EsU0FBUyxDQUFsQjtBQUNBK0QsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ3dILFFBQUwsRUFBZTtBQUNiSCxnQkFBWXBMLE1BQVosRUFBb0IrRCxVQUFwQixFQUFnQyxLQUFLNzRDLE1BQXJDO0FBQ0Q7O0FBRUQsTUFBSTIvQixNQUFNLEtBQUttVixTQUFTLEVBQUUrRCxVQUFoQixDQUFWO0FBQ0EsTUFBSXlILE1BQU0sQ0FBVjtBQUNBLFNBQU96SCxhQUFhLENBQWIsS0FBbUJ5SCxPQUFPLEtBQTFCLENBQVAsRUFBeUM7QUFDdkMzZ0IsV0FBTyxLQUFLbVYsU0FBUyxFQUFFK0QsVUFBaEIsSUFBOEJ5SCxHQUFyQztBQUNEOztBQUVELFNBQU8zZ0IsR0FBUDtBQUNELENBZEQ7O0FBZ0JBbVgsT0FBT3o0QixTQUFQLENBQWlCbWlDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0IxTCxNQUFwQixFQUE0QnVMLFFBQTVCLEVBQXNDO0FBQ2pFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLOTBDLE1BQTVCO0FBQ2YsU0FBTyxLQUFLODBDLE1BQUwsQ0FBUDtBQUNELENBSEQ7O0FBS0FnQyxPQUFPejRCLFNBQVAsQ0FBaUJvaUMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QjNMLE1BQXZCLEVBQStCdUwsUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUs5MEMsTUFBNUI7QUFDZixTQUFPLEtBQUs4MEMsTUFBTCxJQUFnQixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FBM0M7QUFDRCxDQUhEOztBQUtBZ0MsT0FBT3o0QixTQUFQLENBQWlCOC9CLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJySixNQUF2QixFQUErQnVMLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLOTBDLE1BQTVCO0FBQ2YsU0FBUSxLQUFLODBDLE1BQUwsS0FBZ0IsQ0FBakIsR0FBc0IsS0FBS0EsU0FBUyxDQUFkLENBQTdCO0FBQ0QsQ0FIRDs7QUFLQWdDLE9BQU96NEIsU0FBUCxDQUFpQnFpQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCNUwsTUFBdkIsRUFBK0J1TCxRQUEvQixFQUF5QztBQUN2RSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBSzkwQyxNQUE1Qjs7QUFFZixTQUFPLENBQUUsS0FBSzgwQyxNQUFMLENBQUQsR0FDSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEakIsR0FFSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFGbEIsSUFHRixLQUFLQSxTQUFTLENBQWQsSUFBbUIsU0FIeEI7QUFJRCxDQVBEOztBQVNBZ0MsT0FBT3o0QixTQUFQLENBQWlCc2lDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUI3TCxNQUF2QixFQUErQnVMLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLOTBDLE1BQTVCOztBQUVmLFNBQVEsS0FBSzgwQyxNQUFMLElBQWUsU0FBaEIsSUFDSCxLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFBckIsR0FDQSxLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEcEIsR0FFRCxLQUFLQSxTQUFTLENBQWQsQ0FISyxDQUFQO0FBSUQsQ0FQRDs7QUFTQWdDLE9BQU96NEIsU0FBUCxDQUFpQnVpQyxTQUFqQixHQUE2QixTQUFTQSxTQUFULENBQW9COUwsTUFBcEIsRUFBNEIrRCxVQUE1QixFQUF3Q3dILFFBQXhDLEVBQWtEO0FBQzdFdkwsV0FBU0EsU0FBUyxDQUFsQjtBQUNBK0QsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ3dILFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IrRCxVQUFwQixFQUFnQyxLQUFLNzRDLE1BQXJDOztBQUVmLE1BQUkyL0IsTUFBTSxLQUFLbVYsTUFBTCxDQUFWO0FBQ0EsTUFBSXdMLE1BQU0sQ0FBVjtBQUNBLE1BQUkzZ0QsSUFBSSxDQUFSO0FBQ0EsU0FBTyxFQUFFQSxDQUFGLEdBQU1rNUMsVUFBTixLQUFxQnlILE9BQU8sS0FBNUIsQ0FBUCxFQUEyQztBQUN6QzNnQixXQUFPLEtBQUttVixTQUFTbjFDLENBQWQsSUFBbUIyZ0QsR0FBMUI7QUFDRDtBQUNEQSxTQUFPLElBQVA7O0FBRUEsTUFBSTNnQixPQUFPMmdCLEdBQVgsRUFBZ0IzZ0IsT0FBT2hsQixLQUFLdVcsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJMm5CLFVBQWhCLENBQVA7O0FBRWhCLFNBQU9sWixHQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JBbVgsT0FBT3o0QixTQUFQLENBQWlCd2lDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0IvTCxNQUFwQixFQUE0QitELFVBQTVCLEVBQXdDd0gsUUFBeEMsRUFBa0Q7QUFDN0V2TCxXQUFTQSxTQUFTLENBQWxCO0FBQ0ErRCxlQUFhQSxhQUFhLENBQTFCO0FBQ0EsTUFBSSxDQUFDd0gsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQitELFVBQXBCLEVBQWdDLEtBQUs3NEMsTUFBckM7O0FBRWYsTUFBSUwsSUFBSWs1QyxVQUFSO0FBQ0EsTUFBSXlILE1BQU0sQ0FBVjtBQUNBLE1BQUkzZ0IsTUFBTSxLQUFLbVYsU0FBUyxFQUFFbjFDLENBQWhCLENBQVY7QUFDQSxTQUFPQSxJQUFJLENBQUosS0FBVTJnRCxPQUFPLEtBQWpCLENBQVAsRUFBZ0M7QUFDOUIzZ0IsV0FBTyxLQUFLbVYsU0FBUyxFQUFFbjFDLENBQWhCLElBQXFCMmdELEdBQTVCO0FBQ0Q7QUFDREEsU0FBTyxJQUFQOztBQUVBLE1BQUkzZ0IsT0FBTzJnQixHQUFYLEVBQWdCM2dCLE9BQU9obEIsS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSTJuQixVQUFoQixDQUFQOztBQUVoQixTQUFPbFosR0FBUDtBQUNELENBaEJEOztBQWtCQW1YLE9BQU96NEIsU0FBUCxDQUFpQnlpQyxRQUFqQixHQUE0QixTQUFTQSxRQUFULENBQW1CaE0sTUFBbkIsRUFBMkJ1TCxRQUEzQixFQUFxQztBQUMvRCxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBSzkwQyxNQUE1QjtBQUNmLE1BQUksRUFBRSxLQUFLODBDLE1BQUwsSUFBZSxJQUFqQixDQUFKLEVBQTRCLE9BQVEsS0FBS0EsTUFBTCxDQUFSO0FBQzVCLFNBQVEsQ0FBQyxPQUFPLEtBQUtBLE1BQUwsQ0FBUCxHQUFzQixDQUF2QixJQUE0QixDQUFDLENBQXJDO0FBQ0QsQ0FKRDs7QUFNQWdDLE9BQU96NEIsU0FBUCxDQUFpQjBpQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCak0sTUFBdEIsRUFBOEJ1TCxRQUE5QixFQUF3QztBQUNyRSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBSzkwQyxNQUE1QjtBQUNmLE1BQUkyL0IsTUFBTSxLQUFLbVYsTUFBTCxJQUFnQixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FBOUM7QUFDQSxTQUFRblYsTUFBTSxNQUFQLEdBQWlCQSxNQUFNLFVBQXZCLEdBQW9DQSxHQUEzQztBQUNELENBSkQ7O0FBTUFtWCxPQUFPejRCLFNBQVAsQ0FBaUIyaUMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQmxNLE1BQXRCLEVBQThCdUwsUUFBOUIsRUFBd0M7QUFDckUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUs5MEMsTUFBNUI7QUFDZixNQUFJMi9CLE1BQU0sS0FBS21WLFNBQVMsQ0FBZCxJQUFvQixLQUFLQSxNQUFMLEtBQWdCLENBQTlDO0FBQ0EsU0FBUW5WLE1BQU0sTUFBUCxHQUFpQkEsTUFBTSxVQUF2QixHQUFvQ0EsR0FBM0M7QUFDRCxDQUpEOztBQU1BbVgsT0FBT3o0QixTQUFQLENBQWlCNGlDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JuTSxNQUF0QixFQUE4QnVMLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLOTBDLE1BQTVCOztBQUVmLFNBQVEsS0FBSzgwQyxNQUFMLENBQUQsR0FDSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsQ0FEaEIsR0FFSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFGaEIsR0FHSixLQUFLQSxTQUFTLENBQWQsS0FBb0IsRUFIdkI7QUFJRCxDQVBEOztBQVNBZ0MsT0FBT3o0QixTQUFQLENBQWlCNmlDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JwTSxNQUF0QixFQUE4QnVMLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLOTBDLE1BQTVCOztBQUVmLFNBQVEsS0FBSzgwQyxNQUFMLEtBQWdCLEVBQWpCLEdBQ0osS0FBS0EsU0FBUyxDQUFkLEtBQW9CLEVBRGhCLEdBRUosS0FBS0EsU0FBUyxDQUFkLEtBQW9CLENBRmhCLEdBR0osS0FBS0EsU0FBUyxDQUFkLENBSEg7QUFJRCxDQVBEOztBQVNBZ0MsT0FBT3o0QixTQUFQLENBQWlCOGlDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JyTSxNQUF0QixFQUE4QnVMLFFBQTlCLEVBQXdDO0FBQ3JFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLOTBDLE1BQTVCO0FBQ2YsU0FBT3E2QyxRQUFRNkQsSUFBUixDQUFhLElBQWIsRUFBbUJwSixNQUFuQixFQUEyQixJQUEzQixFQUFpQyxFQUFqQyxFQUFxQyxDQUFyQyxDQUFQO0FBQ0QsQ0FIRDs7QUFLQWdDLE9BQU96NEIsU0FBUCxDQUFpQitpQyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCdE0sTUFBdEIsRUFBOEJ1TCxRQUE5QixFQUF3QztBQUNyRSxNQUFJLENBQUNBLFFBQUwsRUFBZUgsWUFBWXBMLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUIsS0FBSzkwQyxNQUE1QjtBQUNmLFNBQU9xNkMsUUFBUTZELElBQVIsQ0FBYSxJQUFiLEVBQW1CcEosTUFBbkIsRUFBMkIsS0FBM0IsRUFBa0MsRUFBbEMsRUFBc0MsQ0FBdEMsQ0FBUDtBQUNELENBSEQ7O0FBS0FnQyxPQUFPejRCLFNBQVAsQ0FBaUJnakMsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnZNLE1BQXZCLEVBQStCdUwsUUFBL0IsRUFBeUM7QUFDdkUsTUFBSSxDQUFDQSxRQUFMLEVBQWVILFlBQVlwTCxNQUFaLEVBQW9CLENBQXBCLEVBQXVCLEtBQUs5MEMsTUFBNUI7QUFDZixTQUFPcTZDLFFBQVE2RCxJQUFSLENBQWEsSUFBYixFQUFtQnBKLE1BQW5CLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLEVBQXFDLENBQXJDLENBQVA7QUFDRCxDQUhEOztBQUtBZ0MsT0FBT3o0QixTQUFQLENBQWlCaWpDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJ4TSxNQUF2QixFQUErQnVMLFFBQS9CLEVBQXlDO0FBQ3ZFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlSCxZQUFZcEwsTUFBWixFQUFvQixDQUFwQixFQUF1QixLQUFLOTBDLE1BQTVCO0FBQ2YsU0FBT3E2QyxRQUFRNkQsSUFBUixDQUFhLElBQWIsRUFBbUJwSixNQUFuQixFQUEyQixLQUEzQixFQUFrQyxFQUFsQyxFQUFzQyxDQUF0QyxDQUFQO0FBQ0QsQ0FIRDs7QUFLQSxTQUFTeU0sUUFBVCxDQUFtQmpGLEdBQW5CLEVBQXdCendDLEtBQXhCLEVBQStCaXBDLE1BQS9CLEVBQXVDcUwsR0FBdkMsRUFBNEMxckMsR0FBNUMsRUFBaURELEdBQWpELEVBQXNEO0FBQ3BELE1BQUksQ0FBQ3NpQyxPQUFPbUYsUUFBUCxDQUFnQkssR0FBaEIsQ0FBTCxFQUEyQixNQUFNLElBQUk3NkIsU0FBSixDQUFjLDZDQUFkLENBQU47QUFDM0IsTUFBSTVWLFFBQVE0SSxHQUFSLElBQWU1SSxRQUFRMkksR0FBM0IsRUFBZ0MsTUFBTSxJQUFJdUcsVUFBSixDQUFlLG1DQUFmLENBQU47QUFDaEMsTUFBSSs1QixTQUFTcUwsR0FBVCxHQUFlN0QsSUFBSXQ4QyxNQUF2QixFQUErQixNQUFNLElBQUkrYSxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNoQzs7QUFFRCs3QixPQUFPejRCLFNBQVAsQ0FBaUJtakMsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQjMxQyxLQUF0QixFQUE2QmlwQyxNQUE3QixFQUFxQytELFVBQXJDLEVBQWlEd0gsUUFBakQsRUFBMkQ7QUFDeEZ4MEMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FpcEMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBK0QsZUFBYUEsYUFBYSxDQUExQjtBQUNBLE1BQUksQ0FBQ3dILFFBQUwsRUFBZTtBQUNiLFFBQUlvQixXQUFXOW1DLEtBQUt1VyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUkybkIsVUFBaEIsSUFBOEIsQ0FBN0M7QUFDQTBJLGFBQVMsSUFBVCxFQUFlMTFDLEtBQWYsRUFBc0JpcEMsTUFBdEIsRUFBOEIrRCxVQUE5QixFQUEwQzRJLFFBQTFDLEVBQW9ELENBQXBEO0FBQ0Q7O0FBRUQsTUFBSW5CLE1BQU0sQ0FBVjtBQUNBLE1BQUkzZ0QsSUFBSSxDQUFSO0FBQ0EsT0FBS20xQyxNQUFMLElBQWVqcEMsUUFBUSxJQUF2QjtBQUNBLFNBQU8sRUFBRWxNLENBQUYsR0FBTWs1QyxVQUFOLEtBQXFCeUgsT0FBTyxLQUE1QixDQUFQLEVBQTJDO0FBQ3pDLFNBQUt4TCxTQUFTbjFDLENBQWQsSUFBb0JrTSxRQUFReTBDLEdBQVQsR0FBZ0IsSUFBbkM7QUFDRDs7QUFFRCxTQUFPeEwsU0FBUytELFVBQWhCO0FBQ0QsQ0FqQkQ7O0FBbUJBL0IsT0FBT3o0QixTQUFQLENBQWlCcWpDLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0I3MUMsS0FBdEIsRUFBNkJpcEMsTUFBN0IsRUFBcUMrRCxVQUFyQyxFQUFpRHdILFFBQWpELEVBQTJEO0FBQ3hGeDBDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBaXBDLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQStELGVBQWFBLGFBQWEsQ0FBMUI7QUFDQSxNQUFJLENBQUN3SCxRQUFMLEVBQWU7QUFDYixRQUFJb0IsV0FBVzltQyxLQUFLdVcsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJMm5CLFVBQWhCLElBQThCLENBQTdDO0FBQ0EwSSxhQUFTLElBQVQsRUFBZTExQyxLQUFmLEVBQXNCaXBDLE1BQXRCLEVBQThCK0QsVUFBOUIsRUFBMEM0SSxRQUExQyxFQUFvRCxDQUFwRDtBQUNEOztBQUVELE1BQUk5aEQsSUFBSWs1QyxhQUFhLENBQXJCO0FBQ0EsTUFBSXlILE1BQU0sQ0FBVjtBQUNBLE9BQUt4TCxTQUFTbjFDLENBQWQsSUFBbUJrTSxRQUFRLElBQTNCO0FBQ0EsU0FBTyxFQUFFbE0sQ0FBRixJQUFPLENBQVAsS0FBYTJnRCxPQUFPLEtBQXBCLENBQVAsRUFBbUM7QUFDakMsU0FBS3hMLFNBQVNuMUMsQ0FBZCxJQUFvQmtNLFFBQVF5MEMsR0FBVCxHQUFnQixJQUFuQztBQUNEOztBQUVELFNBQU94TCxTQUFTK0QsVUFBaEI7QUFDRCxDQWpCRDs7QUFtQkEvQixPQUFPejRCLFNBQVAsQ0FBaUJzakMsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQjkxQyxLQUFyQixFQUE0QmlwQyxNQUE1QixFQUFvQ3VMLFFBQXBDLEVBQThDO0FBQzFFeDBDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBaXBDLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWVrQixTQUFTLElBQVQsRUFBZTExQyxLQUFmLEVBQXNCaXBDLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLElBQWpDLEVBQXVDLENBQXZDO0FBQ2YsTUFBSSxDQUFDZ0MsT0FBTzBELG1CQUFaLEVBQWlDM3VDLFFBQVE4TyxLQUFLL0YsS0FBTCxDQUFXL0ksS0FBWCxDQUFSO0FBQ2pDLE9BQUtpcEMsTUFBTCxJQUFnQmpwQyxRQUFRLElBQXhCO0FBQ0EsU0FBT2lwQyxTQUFTLENBQWhCO0FBQ0QsQ0FQRDs7QUFTQSxTQUFTOE0saUJBQVQsQ0FBNEJ0RixHQUE1QixFQUFpQ3p3QyxLQUFqQyxFQUF3Q2lwQyxNQUF4QyxFQUFnRCtNLFlBQWhELEVBQThEO0FBQzVELE1BQUloMkMsUUFBUSxDQUFaLEVBQWVBLFFBQVEsU0FBU0EsS0FBVCxHQUFpQixDQUF6QjtBQUNmLE9BQUssSUFBSWxNLElBQUksQ0FBUixFQUFXK2MsSUFBSS9CLEtBQUtuRyxHQUFMLENBQVM4bkMsSUFBSXQ4QyxNQUFKLEdBQWE4MEMsTUFBdEIsRUFBOEIsQ0FBOUIsQ0FBcEIsRUFBc0RuMUMsSUFBSStjLENBQTFELEVBQTZELEVBQUUvYyxDQUEvRCxFQUFrRTtBQUNoRTI4QyxRQUFJeEgsU0FBU24xQyxDQUFiLElBQWtCLENBQUNrTSxRQUFTLFFBQVMsS0FBS2cyQyxlQUFlbGlELENBQWYsR0FBbUIsSUFBSUEsQ0FBNUIsQ0FBbkIsTUFDaEIsQ0FBQ2tpRCxlQUFlbGlELENBQWYsR0FBbUIsSUFBSUEsQ0FBeEIsSUFBNkIsQ0FEL0I7QUFFRDtBQUNGOztBQUVEbTNDLE9BQU96NEIsU0FBUCxDQUFpQnlqQyxhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCajJDLEtBQXhCLEVBQStCaXBDLE1BQS9CLEVBQXVDdUwsUUFBdkMsRUFBaUQ7QUFDaEZ4MEMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FpcEMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3VMLFFBQUwsRUFBZWtCLFNBQVMsSUFBVCxFQUFlMTFDLEtBQWYsRUFBc0JpcEMsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsTUFBakMsRUFBeUMsQ0FBekM7QUFDZixNQUFJZ0MsT0FBTzBELG1CQUFYLEVBQWdDO0FBQzlCLFNBQUsxRixNQUFMLElBQWdCanBDLFFBQVEsSUFBeEI7QUFDQSxTQUFLaXBDLFNBQVMsQ0FBZCxJQUFvQmpwQyxVQUFVLENBQTlCO0FBQ0QsR0FIRCxNQUdPO0FBQ0wrMUMsc0JBQWtCLElBQWxCLEVBQXdCLzFDLEtBQXhCLEVBQStCaXBDLE1BQS9CLEVBQXVDLElBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FYRDs7QUFhQWdDLE9BQU96NEIsU0FBUCxDQUFpQjBqQyxhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCbDJDLEtBQXhCLEVBQStCaXBDLE1BQS9CLEVBQXVDdUwsUUFBdkMsRUFBaUQ7QUFDaEZ4MEMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FpcEMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3VMLFFBQUwsRUFBZWtCLFNBQVMsSUFBVCxFQUFlMTFDLEtBQWYsRUFBc0JpcEMsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsTUFBakMsRUFBeUMsQ0FBekM7QUFDZixNQUFJZ0MsT0FBTzBELG1CQUFYLEVBQWdDO0FBQzlCLFNBQUsxRixNQUFMLElBQWdCanBDLFVBQVUsQ0FBMUI7QUFDQSxTQUFLaXBDLFNBQVMsQ0FBZCxJQUFvQmpwQyxRQUFRLElBQTVCO0FBQ0QsR0FIRCxNQUdPO0FBQ0wrMUMsc0JBQWtCLElBQWxCLEVBQXdCLzFDLEtBQXhCLEVBQStCaXBDLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FYRDs7QUFhQSxTQUFTa04saUJBQVQsQ0FBNEIxRixHQUE1QixFQUFpQ3p3QyxLQUFqQyxFQUF3Q2lwQyxNQUF4QyxFQUFnRCtNLFlBQWhELEVBQThEO0FBQzVELE1BQUloMkMsUUFBUSxDQUFaLEVBQWVBLFFBQVEsYUFBYUEsS0FBYixHQUFxQixDQUE3QjtBQUNmLE9BQUssSUFBSWxNLElBQUksQ0FBUixFQUFXK2MsSUFBSS9CLEtBQUtuRyxHQUFMLENBQVM4bkMsSUFBSXQ4QyxNQUFKLEdBQWE4MEMsTUFBdEIsRUFBOEIsQ0FBOUIsQ0FBcEIsRUFBc0RuMUMsSUFBSStjLENBQTFELEVBQTZELEVBQUUvYyxDQUEvRCxFQUFrRTtBQUNoRTI4QyxRQUFJeEgsU0FBU24xQyxDQUFiLElBQW1Ca00sVUFBVSxDQUFDZzJDLGVBQWVsaUQsQ0FBZixHQUFtQixJQUFJQSxDQUF4QixJQUE2QixDQUF4QyxHQUE2QyxJQUEvRDtBQUNEO0FBQ0Y7O0FBRURtM0MsT0FBT3o0QixTQUFQLENBQWlCNGpDLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0JwMkMsS0FBeEIsRUFBK0JpcEMsTUFBL0IsRUFBdUN1TCxRQUF2QyxFQUFpRDtBQUNoRngwQyxVQUFRLENBQUNBLEtBQVQ7QUFDQWlwQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFla0IsU0FBUyxJQUFULEVBQWUxMUMsS0FBZixFQUFzQmlwQyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxVQUFqQyxFQUE2QyxDQUE3QztBQUNmLE1BQUlnQyxPQUFPMEQsbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzFGLFNBQVMsQ0FBZCxJQUFvQmpwQyxVQUFVLEVBQTlCO0FBQ0EsU0FBS2lwQyxTQUFTLENBQWQsSUFBb0JqcEMsVUFBVSxFQUE5QjtBQUNBLFNBQUtpcEMsU0FBUyxDQUFkLElBQW9CanBDLFVBQVUsQ0FBOUI7QUFDQSxTQUFLaXBDLE1BQUwsSUFBZ0JqcEMsUUFBUSxJQUF4QjtBQUNELEdBTEQsTUFLTztBQUNMbTJDLHNCQUFrQixJQUFsQixFQUF3Qm4yQyxLQUF4QixFQUErQmlwQyxNQUEvQixFQUF1QyxJQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBYkQ7O0FBZUFnQyxPQUFPejRCLFNBQVAsQ0FBaUI2akMsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QnIyQyxLQUF4QixFQUErQmlwQyxNQUEvQixFQUF1Q3VMLFFBQXZDLEVBQWlEO0FBQ2hGeDBDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBaXBDLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWVrQixTQUFTLElBQVQsRUFBZTExQyxLQUFmLEVBQXNCaXBDLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLFVBQWpDLEVBQTZDLENBQTdDO0FBQ2YsTUFBSWdDLE9BQU8wRCxtQkFBWCxFQUFnQztBQUM5QixTQUFLMUYsTUFBTCxJQUFnQmpwQyxVQUFVLEVBQTFCO0FBQ0EsU0FBS2lwQyxTQUFTLENBQWQsSUFBb0JqcEMsVUFBVSxFQUE5QjtBQUNBLFNBQUtpcEMsU0FBUyxDQUFkLElBQW9CanBDLFVBQVUsQ0FBOUI7QUFDQSxTQUFLaXBDLFNBQVMsQ0FBZCxJQUFvQmpwQyxRQUFRLElBQTVCO0FBQ0QsR0FMRCxNQUtPO0FBQ0xtMkMsc0JBQWtCLElBQWxCLEVBQXdCbjJDLEtBQXhCLEVBQStCaXBDLE1BQS9CLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRCxTQUFPQSxTQUFTLENBQWhCO0FBQ0QsQ0FiRDs7QUFlQWdDLE9BQU96NEIsU0FBUCxDQUFpQjhqQyxVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCdDJDLEtBQXJCLEVBQTRCaXBDLE1BQTVCLEVBQW9DK0QsVUFBcEMsRUFBZ0R3SCxRQUFoRCxFQUEwRDtBQUN0RngwQyxVQUFRLENBQUNBLEtBQVQ7QUFDQWlwQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFlO0FBQ2IsUUFBSStCLFFBQVF6bkMsS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSTJuQixVQUFKLEdBQWlCLENBQTdCLENBQVo7O0FBRUEwSSxhQUFTLElBQVQsRUFBZTExQyxLQUFmLEVBQXNCaXBDLE1BQXRCLEVBQThCK0QsVUFBOUIsRUFBMEN1SixRQUFRLENBQWxELEVBQXFELENBQUNBLEtBQXREO0FBQ0Q7O0FBRUQsTUFBSXppRCxJQUFJLENBQVI7QUFDQSxNQUFJMmdELE1BQU0sQ0FBVjtBQUNBLE1BQUkrQixNQUFNLENBQVY7QUFDQSxPQUFLdk4sTUFBTCxJQUFlanBDLFFBQVEsSUFBdkI7QUFDQSxTQUFPLEVBQUVsTSxDQUFGLEdBQU1rNUMsVUFBTixLQUFxQnlILE9BQU8sS0FBNUIsQ0FBUCxFQUEyQztBQUN6QyxRQUFJejBDLFFBQVEsQ0FBUixJQUFhdzJDLFFBQVEsQ0FBckIsSUFBMEIsS0FBS3ZOLFNBQVNuMUMsQ0FBVCxHQUFhLENBQWxCLE1BQXlCLENBQXZELEVBQTBEO0FBQ3hEMGlELFlBQU0sQ0FBTjtBQUNEO0FBQ0QsU0FBS3ZOLFNBQVNuMUMsQ0FBZCxJQUFtQixDQUFFa00sUUFBUXkwQyxHQUFULElBQWlCLENBQWxCLElBQXVCK0IsR0FBdkIsR0FBNkIsSUFBaEQ7QUFDRDs7QUFFRCxTQUFPdk4sU0FBUytELFVBQWhCO0FBQ0QsQ0FyQkQ7O0FBdUJBL0IsT0FBT3o0QixTQUFQLENBQWlCaWtDLFVBQWpCLEdBQThCLFNBQVNBLFVBQVQsQ0FBcUJ6MkMsS0FBckIsRUFBNEJpcEMsTUFBNUIsRUFBb0MrRCxVQUFwQyxFQUFnRHdILFFBQWhELEVBQTBEO0FBQ3RGeDBDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBaXBDLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWU7QUFDYixRQUFJK0IsUUFBUXpuQyxLQUFLdVcsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJMm5CLFVBQUosR0FBaUIsQ0FBN0IsQ0FBWjs7QUFFQTBJLGFBQVMsSUFBVCxFQUFlMTFDLEtBQWYsRUFBc0JpcEMsTUFBdEIsRUFBOEIrRCxVQUE5QixFQUEwQ3VKLFFBQVEsQ0FBbEQsRUFBcUQsQ0FBQ0EsS0FBdEQ7QUFDRDs7QUFFRCxNQUFJemlELElBQUlrNUMsYUFBYSxDQUFyQjtBQUNBLE1BQUl5SCxNQUFNLENBQVY7QUFDQSxNQUFJK0IsTUFBTSxDQUFWO0FBQ0EsT0FBS3ZOLFNBQVNuMUMsQ0FBZCxJQUFtQmtNLFFBQVEsSUFBM0I7QUFDQSxTQUFPLEVBQUVsTSxDQUFGLElBQU8sQ0FBUCxLQUFhMmdELE9BQU8sS0FBcEIsQ0FBUCxFQUFtQztBQUNqQyxRQUFJejBDLFFBQVEsQ0FBUixJQUFhdzJDLFFBQVEsQ0FBckIsSUFBMEIsS0FBS3ZOLFNBQVNuMUMsQ0FBVCxHQUFhLENBQWxCLE1BQXlCLENBQXZELEVBQTBEO0FBQ3hEMGlELFlBQU0sQ0FBTjtBQUNEO0FBQ0QsU0FBS3ZOLFNBQVNuMUMsQ0FBZCxJQUFtQixDQUFFa00sUUFBUXkwQyxHQUFULElBQWlCLENBQWxCLElBQXVCK0IsR0FBdkIsR0FBNkIsSUFBaEQ7QUFDRDs7QUFFRCxTQUFPdk4sU0FBUytELFVBQWhCO0FBQ0QsQ0FyQkQ7O0FBdUJBL0IsT0FBT3o0QixTQUFQLENBQWlCa2tDLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0IxMkMsS0FBcEIsRUFBMkJpcEMsTUFBM0IsRUFBbUN1TCxRQUFuQyxFQUE2QztBQUN4RXgwQyxVQUFRLENBQUNBLEtBQVQ7QUFDQWlwQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFla0IsU0FBUyxJQUFULEVBQWUxMUMsS0FBZixFQUFzQmlwQyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxJQUFqQyxFQUF1QyxDQUFDLElBQXhDO0FBQ2YsTUFBSSxDQUFDZ0MsT0FBTzBELG1CQUFaLEVBQWlDM3VDLFFBQVE4TyxLQUFLL0YsS0FBTCxDQUFXL0ksS0FBWCxDQUFSO0FBQ2pDLE1BQUlBLFFBQVEsQ0FBWixFQUFlQSxRQUFRLE9BQU9BLEtBQVAsR0FBZSxDQUF2QjtBQUNmLE9BQUtpcEMsTUFBTCxJQUFnQmpwQyxRQUFRLElBQXhCO0FBQ0EsU0FBT2lwQyxTQUFTLENBQWhCO0FBQ0QsQ0FSRDs7QUFVQWdDLE9BQU96NEIsU0FBUCxDQUFpQm1rQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCMzJDLEtBQXZCLEVBQThCaXBDLE1BQTlCLEVBQXNDdUwsUUFBdEMsRUFBZ0Q7QUFDOUV4MEMsVUFBUSxDQUFDQSxLQUFUO0FBQ0FpcEMsV0FBU0EsU0FBUyxDQUFsQjtBQUNBLE1BQUksQ0FBQ3VMLFFBQUwsRUFBZWtCLFNBQVMsSUFBVCxFQUFlMTFDLEtBQWYsRUFBc0JpcEMsTUFBdEIsRUFBOEIsQ0FBOUIsRUFBaUMsTUFBakMsRUFBeUMsQ0FBQyxNQUExQztBQUNmLE1BQUlnQyxPQUFPMEQsbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzFGLE1BQUwsSUFBZ0JqcEMsUUFBUSxJQUF4QjtBQUNBLFNBQUtpcEMsU0FBUyxDQUFkLElBQW9CanBDLFVBQVUsQ0FBOUI7QUFDRCxHQUhELE1BR087QUFDTCsxQyxzQkFBa0IsSUFBbEIsRUFBd0IvMUMsS0FBeEIsRUFBK0JpcEMsTUFBL0IsRUFBdUMsSUFBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQVhEOztBQWFBZ0MsT0FBT3o0QixTQUFQLENBQWlCb2tDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUI1MkMsS0FBdkIsRUFBOEJpcEMsTUFBOUIsRUFBc0N1TCxRQUF0QyxFQUFnRDtBQUM5RXgwQyxVQUFRLENBQUNBLEtBQVQ7QUFDQWlwQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFla0IsU0FBUyxJQUFULEVBQWUxMUMsS0FBZixFQUFzQmlwQyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxNQUFqQyxFQUF5QyxDQUFDLE1BQTFDO0FBQ2YsTUFBSWdDLE9BQU8wRCxtQkFBWCxFQUFnQztBQUM5QixTQUFLMUYsTUFBTCxJQUFnQmpwQyxVQUFVLENBQTFCO0FBQ0EsU0FBS2lwQyxTQUFTLENBQWQsSUFBb0JqcEMsUUFBUSxJQUE1QjtBQUNELEdBSEQsTUFHTztBQUNMKzFDLHNCQUFrQixJQUFsQixFQUF3Qi8xQyxLQUF4QixFQUErQmlwQyxNQUEvQixFQUF1QyxLQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBWEQ7O0FBYUFnQyxPQUFPejRCLFNBQVAsQ0FBaUJxa0MsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QjcyQyxLQUF2QixFQUE4QmlwQyxNQUE5QixFQUFzQ3VMLFFBQXRDLEVBQWdEO0FBQzlFeDBDLFVBQVEsQ0FBQ0EsS0FBVDtBQUNBaXBDLFdBQVNBLFNBQVMsQ0FBbEI7QUFDQSxNQUFJLENBQUN1TCxRQUFMLEVBQWVrQixTQUFTLElBQVQsRUFBZTExQyxLQUFmLEVBQXNCaXBDLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLFVBQWpDLEVBQTZDLENBQUMsVUFBOUM7QUFDZixNQUFJZ0MsT0FBTzBELG1CQUFYLEVBQWdDO0FBQzlCLFNBQUsxRixNQUFMLElBQWdCanBDLFFBQVEsSUFBeEI7QUFDQSxTQUFLaXBDLFNBQVMsQ0FBZCxJQUFvQmpwQyxVQUFVLENBQTlCO0FBQ0EsU0FBS2lwQyxTQUFTLENBQWQsSUFBb0JqcEMsVUFBVSxFQUE5QjtBQUNBLFNBQUtpcEMsU0FBUyxDQUFkLElBQW9CanBDLFVBQVUsRUFBOUI7QUFDRCxHQUxELE1BS087QUFDTG0yQyxzQkFBa0IsSUFBbEIsRUFBd0JuMkMsS0FBeEIsRUFBK0JpcEMsTUFBL0IsRUFBdUMsSUFBdkM7QUFDRDtBQUNELFNBQU9BLFNBQVMsQ0FBaEI7QUFDRCxDQWJEOztBQWVBZ0MsT0FBT3o0QixTQUFQLENBQWlCc2tDLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUI5MkMsS0FBdkIsRUFBOEJpcEMsTUFBOUIsRUFBc0N1TCxRQUF0QyxFQUFnRDtBQUM5RXgwQyxVQUFRLENBQUNBLEtBQVQ7QUFDQWlwQyxXQUFTQSxTQUFTLENBQWxCO0FBQ0EsTUFBSSxDQUFDdUwsUUFBTCxFQUFla0IsU0FBUyxJQUFULEVBQWUxMUMsS0FBZixFQUFzQmlwQyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxVQUFqQyxFQUE2QyxDQUFDLFVBQTlDO0FBQ2YsTUFBSWpwQyxRQUFRLENBQVosRUFBZUEsUUFBUSxhQUFhQSxLQUFiLEdBQXFCLENBQTdCO0FBQ2YsTUFBSWlyQyxPQUFPMEQsbUJBQVgsRUFBZ0M7QUFDOUIsU0FBSzFGLE1BQUwsSUFBZ0JqcEMsVUFBVSxFQUExQjtBQUNBLFNBQUtpcEMsU0FBUyxDQUFkLElBQW9CanBDLFVBQVUsRUFBOUI7QUFDQSxTQUFLaXBDLFNBQVMsQ0FBZCxJQUFvQmpwQyxVQUFVLENBQTlCO0FBQ0EsU0FBS2lwQyxTQUFTLENBQWQsSUFBb0JqcEMsUUFBUSxJQUE1QjtBQUNELEdBTEQsTUFLTztBQUNMbTJDLHNCQUFrQixJQUFsQixFQUF3Qm4yQyxLQUF4QixFQUErQmlwQyxNQUEvQixFQUF1QyxLQUF2QztBQUNEO0FBQ0QsU0FBT0EsU0FBUyxDQUFoQjtBQUNELENBZEQ7O0FBZ0JBLFNBQVM4TixZQUFULENBQXVCdEcsR0FBdkIsRUFBNEJ6d0MsS0FBNUIsRUFBbUNpcEMsTUFBbkMsRUFBMkNxTCxHQUEzQyxFQUFnRDFyQyxHQUFoRCxFQUFxREQsR0FBckQsRUFBMEQ7QUFDeEQsTUFBSXNnQyxTQUFTcUwsR0FBVCxHQUFlN0QsSUFBSXQ4QyxNQUF2QixFQUErQixNQUFNLElBQUkrYSxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUMvQixNQUFJKzVCLFNBQVMsQ0FBYixFQUFnQixNQUFNLElBQUkvNUIsVUFBSixDQUFlLG9CQUFmLENBQU47QUFDakI7O0FBRUQsU0FBUzhuQyxVQUFULENBQXFCdkcsR0FBckIsRUFBMEJ6d0MsS0FBMUIsRUFBaUNpcEMsTUFBakMsRUFBeUMrTSxZQUF6QyxFQUF1RHhCLFFBQXZELEVBQWlFO0FBQy9ELE1BQUksQ0FBQ0EsUUFBTCxFQUFlO0FBQ2J1QyxpQkFBYXRHLEdBQWIsRUFBa0J6d0MsS0FBbEIsRUFBeUJpcEMsTUFBekIsRUFBaUMsQ0FBakMsRUFBb0Msc0JBQXBDLEVBQTRELENBQUMsc0JBQTdEO0FBQ0Q7QUFDRHVGLFVBQVF5QixLQUFSLENBQWNRLEdBQWQsRUFBbUJ6d0MsS0FBbkIsRUFBMEJpcEMsTUFBMUIsRUFBa0MrTSxZQUFsQyxFQUFnRCxFQUFoRCxFQUFvRCxDQUFwRDtBQUNBLFNBQU8vTSxTQUFTLENBQWhCO0FBQ0Q7O0FBRURnQyxPQUFPejRCLFNBQVAsQ0FBaUJ5a0MsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QmozQyxLQUF2QixFQUE4QmlwQyxNQUE5QixFQUFzQ3VMLFFBQXRDLEVBQWdEO0FBQzlFLFNBQU93QyxXQUFXLElBQVgsRUFBaUJoM0MsS0FBakIsRUFBd0JpcEMsTUFBeEIsRUFBZ0MsSUFBaEMsRUFBc0N1TCxRQUF0QyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQXZKLE9BQU96NEIsU0FBUCxDQUFpQjBrQyxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCbDNDLEtBQXZCLEVBQThCaXBDLE1BQTlCLEVBQXNDdUwsUUFBdEMsRUFBZ0Q7QUFDOUUsU0FBT3dDLFdBQVcsSUFBWCxFQUFpQmgzQyxLQUFqQixFQUF3QmlwQyxNQUF4QixFQUFnQyxLQUFoQyxFQUF1Q3VMLFFBQXZDLENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVMyQyxXQUFULENBQXNCMUcsR0FBdEIsRUFBMkJ6d0MsS0FBM0IsRUFBa0NpcEMsTUFBbEMsRUFBMEMrTSxZQUExQyxFQUF3RHhCLFFBQXhELEVBQWtFO0FBQ2hFLE1BQUksQ0FBQ0EsUUFBTCxFQUFlO0FBQ2J1QyxpQkFBYXRHLEdBQWIsRUFBa0J6d0MsS0FBbEIsRUFBeUJpcEMsTUFBekIsRUFBaUMsQ0FBakMsRUFBb0MsdUJBQXBDLEVBQTZELENBQUMsdUJBQTlEO0FBQ0Q7QUFDRHVGLFVBQVF5QixLQUFSLENBQWNRLEdBQWQsRUFBbUJ6d0MsS0FBbkIsRUFBMEJpcEMsTUFBMUIsRUFBa0MrTSxZQUFsQyxFQUFnRCxFQUFoRCxFQUFvRCxDQUFwRDtBQUNBLFNBQU8vTSxTQUFTLENBQWhCO0FBQ0Q7O0FBRURnQyxPQUFPejRCLFNBQVAsQ0FBaUI0a0MsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QnAzQyxLQUF4QixFQUErQmlwQyxNQUEvQixFQUF1Q3VMLFFBQXZDLEVBQWlEO0FBQ2hGLFNBQU8yQyxZQUFZLElBQVosRUFBa0JuM0MsS0FBbEIsRUFBeUJpcEMsTUFBekIsRUFBaUMsSUFBakMsRUFBdUN1TCxRQUF2QyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQXZKLE9BQU96NEIsU0FBUCxDQUFpQjZrQyxhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCcjNDLEtBQXhCLEVBQStCaXBDLE1BQS9CLEVBQXVDdUwsUUFBdkMsRUFBaUQ7QUFDaEYsU0FBTzJDLFlBQVksSUFBWixFQUFrQm4zQyxLQUFsQixFQUF5QmlwQyxNQUF6QixFQUFpQyxLQUFqQyxFQUF3Q3VMLFFBQXhDLENBQVA7QUFDRCxDQUZEOztBQUlBO0FBQ0F2SixPQUFPejRCLFNBQVAsQ0FBaUI2OUIsSUFBakIsR0FBd0IsU0FBU0EsSUFBVCxDQUFldnhDLE1BQWYsRUFBdUJ3NEMsV0FBdkIsRUFBb0M1cUMsS0FBcEMsRUFBMkNQLEdBQTNDLEVBQWdEO0FBQ3RFLE1BQUksQ0FBQ08sS0FBTCxFQUFZQSxRQUFRLENBQVI7QUFDWixNQUFJLENBQUNQLEdBQUQsSUFBUUEsUUFBUSxDQUFwQixFQUF1QkEsTUFBTSxLQUFLaFksTUFBWDtBQUN2QixNQUFJbWpELGVBQWV4NEMsT0FBTzNLLE1BQTFCLEVBQWtDbWpELGNBQWN4NEMsT0FBTzNLLE1BQXJCO0FBQ2xDLE1BQUksQ0FBQ21qRCxXQUFMLEVBQWtCQSxjQUFjLENBQWQ7QUFDbEIsTUFBSW5yQyxNQUFNLENBQU4sSUFBV0EsTUFBTU8sS0FBckIsRUFBNEJQLE1BQU1PLEtBQU47O0FBRTVCO0FBQ0EsTUFBSVAsUUFBUU8sS0FBWixFQUFtQixPQUFPLENBQVA7QUFDbkIsTUFBSTVOLE9BQU8zSyxNQUFQLEtBQWtCLENBQWxCLElBQXVCLEtBQUtBLE1BQUwsS0FBZ0IsQ0FBM0MsRUFBOEMsT0FBTyxDQUFQOztBQUU5QztBQUNBLE1BQUltakQsY0FBYyxDQUFsQixFQUFxQjtBQUNuQixVQUFNLElBQUlwb0MsVUFBSixDQUFlLDJCQUFmLENBQU47QUFDRDtBQUNELE1BQUl4QyxRQUFRLENBQVIsSUFBYUEsU0FBUyxLQUFLdlksTUFBL0IsRUFBdUMsTUFBTSxJQUFJK2EsVUFBSixDQUFlLDJCQUFmLENBQU47QUFDdkMsTUFBSS9DLE1BQU0sQ0FBVixFQUFhLE1BQU0sSUFBSStDLFVBQUosQ0FBZSx5QkFBZixDQUFOOztBQUViO0FBQ0EsTUFBSS9DLE1BQU0sS0FBS2hZLE1BQWYsRUFBdUJnWSxNQUFNLEtBQUtoWSxNQUFYO0FBQ3ZCLE1BQUkySyxPQUFPM0ssTUFBUCxHQUFnQm1qRCxXQUFoQixHQUE4Qm5yQyxNQUFNTyxLQUF4QyxFQUErQztBQUM3Q1AsVUFBTXJOLE9BQU8zSyxNQUFQLEdBQWdCbWpELFdBQWhCLEdBQThCNXFDLEtBQXBDO0FBQ0Q7O0FBRUQsTUFBSXFHLE1BQU01RyxNQUFNTyxLQUFoQjtBQUNBLE1BQUk1WSxDQUFKOztBQUVBLE1BQUksU0FBU2dMLE1BQVQsSUFBbUI0TixRQUFRNHFDLFdBQTNCLElBQTBDQSxjQUFjbnJDLEdBQTVELEVBQWlFO0FBQy9EO0FBQ0EsU0FBS3JZLElBQUlpZixNQUFNLENBQWYsRUFBa0JqZixLQUFLLENBQXZCLEVBQTBCLEVBQUVBLENBQTVCLEVBQStCO0FBQzdCZ0wsYUFBT2hMLElBQUl3akQsV0FBWCxJQUEwQixLQUFLeGpELElBQUk0WSxLQUFULENBQTFCO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBSXFHLE1BQU0sSUFBTixJQUFjLENBQUNrNEIsT0FBTzBELG1CQUExQixFQUErQztBQUNwRDtBQUNBLFNBQUs3NkMsSUFBSSxDQUFULEVBQVlBLElBQUlpZixHQUFoQixFQUFxQixFQUFFamYsQ0FBdkIsRUFBMEI7QUFDeEJnTCxhQUFPaEwsSUFBSXdqRCxXQUFYLElBQTBCLEtBQUt4akQsSUFBSTRZLEtBQVQsQ0FBMUI7QUFDRDtBQUNGLEdBTE0sTUFLQTtBQUNMNGdDLGVBQVc5NkIsU0FBWCxDQUFxQjVULEdBQXJCLENBQXlCNlQsSUFBekIsQ0FDRTNULE1BREYsRUFFRSxLQUFLaXdDLFFBQUwsQ0FBY3JpQyxLQUFkLEVBQXFCQSxRQUFRcUcsR0FBN0IsQ0FGRixFQUdFdWtDLFdBSEY7QUFLRDs7QUFFRCxTQUFPdmtDLEdBQVA7QUFDRCxDQTlDRDs7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQWs0QixPQUFPejRCLFNBQVAsQ0FBaUJwUCxJQUFqQixHQUF3QixTQUFTQSxJQUFULENBQWUwd0IsR0FBZixFQUFvQnBuQixLQUFwQixFQUEyQlAsR0FBM0IsRUFBZ0NySyxRQUFoQyxFQUEwQztBQUNoRTtBQUNBLE1BQUksT0FBT2d5QixHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsUUFBSSxPQUFPcG5CLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0I1SyxpQkFBVzRLLEtBQVg7QUFDQUEsY0FBUSxDQUFSO0FBQ0FQLFlBQU0sS0FBS2hZLE1BQVg7QUFDRCxLQUpELE1BSU8sSUFBSSxPQUFPZ1ksR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2xDckssaUJBQVdxSyxHQUFYO0FBQ0FBLFlBQU0sS0FBS2hZLE1BQVg7QUFDRDtBQUNELFFBQUkyL0IsSUFBSTMvQixNQUFKLEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsVUFBSW81QyxPQUFPelosSUFBSXBrQixVQUFKLENBQWUsQ0FBZixDQUFYO0FBQ0EsVUFBSTY5QixPQUFPLEdBQVgsRUFBZ0I7QUFDZHpaLGNBQU15WixJQUFOO0FBQ0Q7QUFDRjtBQUNELFFBQUl6ckMsYUFBYWhLLFNBQWIsSUFBMEIsT0FBT2dLLFFBQVAsS0FBb0IsUUFBbEQsRUFBNEQ7QUFDMUQsWUFBTSxJQUFJOFQsU0FBSixDQUFjLDJCQUFkLENBQU47QUFDRDtBQUNELFFBQUksT0FBTzlULFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0MsQ0FBQ21wQyxPQUFPK0UsVUFBUCxDQUFrQmx1QyxRQUFsQixDQUFyQyxFQUFrRTtBQUNoRSxZQUFNLElBQUk4VCxTQUFKLENBQWMsdUJBQXVCOVQsUUFBckMsQ0FBTjtBQUNEO0FBQ0YsR0FyQkQsTUFxQk8sSUFBSSxPQUFPZ3lCLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQ0EsVUFBTUEsTUFBTSxHQUFaO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJcG5CLFFBQVEsQ0FBUixJQUFhLEtBQUt2WSxNQUFMLEdBQWN1WSxLQUEzQixJQUFvQyxLQUFLdlksTUFBTCxHQUFjZ1ksR0FBdEQsRUFBMkQ7QUFDekQsVUFBTSxJQUFJK0MsVUFBSixDQUFlLG9CQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJL0MsT0FBT08sS0FBWCxFQUFrQjtBQUNoQixXQUFPLElBQVA7QUFDRDs7QUFFREEsVUFBUUEsVUFBVSxDQUFsQjtBQUNBUCxRQUFNQSxRQUFRclUsU0FBUixHQUFvQixLQUFLM0QsTUFBekIsR0FBa0NnWSxRQUFRLENBQWhEOztBQUVBLE1BQUksQ0FBQzJuQixHQUFMLEVBQVVBLE1BQU0sQ0FBTjs7QUFFVixNQUFJaGdDLENBQUo7QUFDQSxNQUFJLE9BQU9nZ0MsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFNBQUtoZ0MsSUFBSTRZLEtBQVQsRUFBZ0I1WSxJQUFJcVksR0FBcEIsRUFBeUIsRUFBRXJZLENBQTNCLEVBQThCO0FBQzVCLFdBQUtBLENBQUwsSUFBVWdnQyxHQUFWO0FBQ0Q7QUFDRixHQUpELE1BSU87QUFDTCxRQUFJb2dCLFFBQVFqSixPQUFPbUYsUUFBUCxDQUFnQnRjLEdBQWhCLElBQ1JBLEdBRFEsR0FFUjhjLFlBQVksSUFBSTNGLE1BQUosQ0FBV25YLEdBQVgsRUFBZ0JoeUIsUUFBaEIsRUFBMEJ0SSxRQUExQixFQUFaLENBRko7QUFHQSxRQUFJdVosTUFBTW1oQyxNQUFNLy9DLE1BQWhCO0FBQ0EsU0FBS0wsSUFBSSxDQUFULEVBQVlBLElBQUlxWSxNQUFNTyxLQUF0QixFQUE2QixFQUFFNVksQ0FBL0IsRUFBa0M7QUFDaEMsV0FBS0EsSUFBSTRZLEtBQVQsSUFBa0J3bkMsTUFBTXBnRCxJQUFJaWYsR0FBVixDQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxJQUFQO0FBQ0QsQ0F6REQ7O0FBMkRBO0FBQ0E7O0FBRUEsSUFBSXdrQyxvQkFBb0Isb0JBQXhCOztBQUVBLFNBQVNDLFdBQVQsQ0FBc0J6NkIsR0FBdEIsRUFBMkI7QUFDekI7QUFDQUEsUUFBTTA2QixXQUFXMTZCLEdBQVgsRUFBZ0Jwb0IsT0FBaEIsQ0FBd0I0aUQsaUJBQXhCLEVBQTJDLEVBQTNDLENBQU47QUFDQTtBQUNBLE1BQUl4NkIsSUFBSTVvQixNQUFKLEdBQWEsQ0FBakIsRUFBb0IsT0FBTyxFQUFQO0FBQ3BCO0FBQ0EsU0FBTzRvQixJQUFJNW9CLE1BQUosR0FBYSxDQUFiLEtBQW1CLENBQTFCLEVBQTZCO0FBQzNCNG9CLFVBQU1BLE1BQU0sR0FBWjtBQUNEO0FBQ0QsU0FBT0EsR0FBUDtBQUNEOztBQUVELFNBQVMwNkIsVUFBVCxDQUFxQjE2QixHQUFyQixFQUEwQjtBQUN4QixNQUFJQSxJQUFJN0csSUFBUixFQUFjLE9BQU82RyxJQUFJN0csSUFBSixFQUFQO0FBQ2QsU0FBTzZHLElBQUlwb0IsT0FBSixDQUFZLFlBQVosRUFBMEIsRUFBMUIsQ0FBUDtBQUNEOztBQUVELFNBQVNzL0MsS0FBVCxDQUFnQnZqQyxDQUFoQixFQUFtQjtBQUNqQixNQUFJQSxJQUFJLEVBQVIsRUFBWSxPQUFPLE1BQU1BLEVBQUVsWCxRQUFGLENBQVcsRUFBWCxDQUFiO0FBQ1osU0FBT2tYLEVBQUVsWCxRQUFGLENBQVcsRUFBWCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU28zQyxXQUFULENBQXNCcHBDLE1BQXRCLEVBQThCckgsS0FBOUIsRUFBcUM7QUFDbkNBLFVBQVFBLFNBQVMyTCxRQUFqQjtBQUNBLE1BQUkrRCxTQUFKO0FBQ0EsTUFBSTFiLFNBQVNxVCxPQUFPclQsTUFBcEI7QUFDQSxNQUFJdWpELGdCQUFnQixJQUFwQjtBQUNBLE1BQUl4RCxRQUFRLEVBQVo7O0FBRUEsT0FBSyxJQUFJcGdELElBQUksQ0FBYixFQUFnQkEsSUFBSUssTUFBcEIsRUFBNEIsRUFBRUwsQ0FBOUIsRUFBaUM7QUFDL0IrYixnQkFBWXJJLE9BQU9rSSxVQUFQLENBQWtCNWIsQ0FBbEIsQ0FBWjs7QUFFQTtBQUNBLFFBQUkrYixZQUFZLE1BQVosSUFBc0JBLFlBQVksTUFBdEMsRUFBOEM7QUFDNUM7QUFDQSxVQUFJLENBQUM2bkMsYUFBTCxFQUFvQjtBQUNsQjtBQUNBLFlBQUk3bkMsWUFBWSxNQUFoQixFQUF3QjtBQUN0QjtBQUNBLGNBQUksQ0FBQzFQLFNBQVMsQ0FBVixJQUFlLENBQUMsQ0FBcEIsRUFBdUIrekMsTUFBTXAvQyxJQUFOLENBQVcsSUFBWCxFQUFpQixJQUFqQixFQUF1QixJQUF2QjtBQUN2QjtBQUNELFNBSkQsTUFJTyxJQUFJaEIsSUFBSSxDQUFKLEtBQVVLLE1BQWQsRUFBc0I7QUFDM0I7QUFDQSxjQUFJLENBQUNnTSxTQUFTLENBQVYsSUFBZSxDQUFDLENBQXBCLEVBQXVCK3pDLE1BQU1wL0MsSUFBTixDQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsSUFBdkI7QUFDdkI7QUFDRDs7QUFFRDtBQUNBNGlELHdCQUFnQjduQyxTQUFoQjs7QUFFQTtBQUNEOztBQUVEO0FBQ0EsVUFBSUEsWUFBWSxNQUFoQixFQUF3QjtBQUN0QixZQUFJLENBQUMxUCxTQUFTLENBQVYsSUFBZSxDQUFDLENBQXBCLEVBQXVCK3pDLE1BQU1wL0MsSUFBTixDQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsSUFBdkI7QUFDdkI0aUQsd0JBQWdCN25DLFNBQWhCO0FBQ0E7QUFDRDs7QUFFRDtBQUNBQSxrQkFBWSxDQUFDNm5DLGdCQUFnQixNQUFoQixJQUEwQixFQUExQixHQUErQjduQyxZQUFZLE1BQTVDLElBQXNELE9BQWxFO0FBQ0QsS0E3QkQsTUE2Qk8sSUFBSTZuQyxhQUFKLEVBQW1CO0FBQ3hCO0FBQ0EsVUFBSSxDQUFDdjNDLFNBQVMsQ0FBVixJQUFlLENBQUMsQ0FBcEIsRUFBdUIrekMsTUFBTXAvQyxJQUFOLENBQVcsSUFBWCxFQUFpQixJQUFqQixFQUF1QixJQUF2QjtBQUN4Qjs7QUFFRDRpRCxvQkFBZ0IsSUFBaEI7O0FBRUE7QUFDQSxRQUFJN25DLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsVUFBSSxDQUFDMVAsU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEIrekMsWUFBTXAvQyxJQUFOLENBQVcrYSxTQUFYO0FBQ0QsS0FIRCxNQUdPLElBQUlBLFlBQVksS0FBaEIsRUFBdUI7QUFDNUIsVUFBSSxDQUFDMVAsU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEIrekMsWUFBTXAvQyxJQUFOLENBQ0UrYSxhQUFhLEdBQWIsR0FBbUIsSUFEckIsRUFFRUEsWUFBWSxJQUFaLEdBQW1CLElBRnJCO0FBSUQsS0FOTSxNQU1BLElBQUlBLFlBQVksT0FBaEIsRUFBeUI7QUFDOUIsVUFBSSxDQUFDMVAsU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEIrekMsWUFBTXAvQyxJQUFOLENBQ0UrYSxhQUFhLEdBQWIsR0FBbUIsSUFEckIsRUFFRUEsYUFBYSxHQUFiLEdBQW1CLElBQW5CLEdBQTBCLElBRjVCLEVBR0VBLFlBQVksSUFBWixHQUFtQixJQUhyQjtBQUtELEtBUE0sTUFPQSxJQUFJQSxZQUFZLFFBQWhCLEVBQTBCO0FBQy9CLFVBQUksQ0FBQzFQLFNBQVMsQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCK3pDLFlBQU1wL0MsSUFBTixDQUNFK2EsYUFBYSxJQUFiLEdBQW9CLElBRHRCLEVBRUVBLGFBQWEsR0FBYixHQUFtQixJQUFuQixHQUEwQixJQUY1QixFQUdFQSxhQUFhLEdBQWIsR0FBbUIsSUFBbkIsR0FBMEIsSUFINUIsRUFJRUEsWUFBWSxJQUFaLEdBQW1CLElBSnJCO0FBTUQsS0FSTSxNQVFBO0FBQ0wsWUFBTSxJQUFJaFosS0FBSixDQUFVLG9CQUFWLENBQU47QUFDRDtBQUNGOztBQUVELFNBQU9xOUMsS0FBUDtBQUNEOztBQUVELFNBQVNsQixZQUFULENBQXVCajJCLEdBQXZCLEVBQTRCO0FBQzFCLE1BQUk0NkIsWUFBWSxFQUFoQjtBQUNBLE9BQUssSUFBSTdqRCxJQUFJLENBQWIsRUFBZ0JBLElBQUlpcEIsSUFBSTVvQixNQUF4QixFQUFnQyxFQUFFTCxDQUFsQyxFQUFxQztBQUNuQztBQUNBNmpELGNBQVU3aUQsSUFBVixDQUFlaW9CLElBQUlyTixVQUFKLENBQWU1YixDQUFmLElBQW9CLElBQW5DO0FBQ0Q7QUFDRCxTQUFPNmpELFNBQVA7QUFDRDs7QUFFRCxTQUFTdkUsY0FBVCxDQUF5QnIyQixHQUF6QixFQUE4QjVjLEtBQTlCLEVBQXFDO0FBQ25DLE1BQUkyaEIsQ0FBSixFQUFPODFCLEVBQVAsRUFBV0MsRUFBWDtBQUNBLE1BQUlGLFlBQVksRUFBaEI7QUFDQSxPQUFLLElBQUk3akQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaXBCLElBQUk1b0IsTUFBeEIsRUFBZ0MsRUFBRUwsQ0FBbEMsRUFBcUM7QUFDbkMsUUFBSSxDQUFDcU0sU0FBUyxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7O0FBRXRCMmhCLFFBQUkvRSxJQUFJck4sVUFBSixDQUFlNWIsQ0FBZixDQUFKO0FBQ0E4akQsU0FBSzkxQixLQUFLLENBQVY7QUFDQSsxQixTQUFLLzFCLElBQUksR0FBVDtBQUNBNjFCLGNBQVU3aUQsSUFBVixDQUFlK2lELEVBQWY7QUFDQUYsY0FBVTdpRCxJQUFWLENBQWU4aUQsRUFBZjtBQUNEOztBQUVELFNBQU9ELFNBQVA7QUFDRDs7QUFFRCxTQUFTOUcsYUFBVCxDQUF3Qjl6QixHQUF4QixFQUE2QjtBQUMzQixTQUFPdXhCLE9BQU9yQixXQUFQLENBQW1CdUssWUFBWXo2QixHQUFaLENBQW5CLENBQVA7QUFDRDs7QUFFRCxTQUFTKzFCLFVBQVQsQ0FBcUI5MEMsR0FBckIsRUFBMEI4NUMsR0FBMUIsRUFBK0I3TyxNQUEvQixFQUF1QzkwQyxNQUF2QyxFQUErQztBQUM3QyxPQUFLLElBQUlMLElBQUksQ0FBYixFQUFnQkEsSUFBSUssTUFBcEIsRUFBNEIsRUFBRUwsQ0FBOUIsRUFBaUM7QUFDL0IsUUFBS0EsSUFBSW0xQyxNQUFKLElBQWM2TyxJQUFJM2pELE1BQW5CLElBQStCTCxLQUFLa0ssSUFBSTdKLE1BQTVDLEVBQXFEO0FBQ3JEMmpELFFBQUloa0QsSUFBSW0xQyxNQUFSLElBQWtCanJDLElBQUlsSyxDQUFKLENBQWxCO0FBQ0Q7QUFDRCxTQUFPQSxDQUFQO0FBQ0Q7O0FBRUQsU0FBU3c4QyxLQUFULENBQWdCeGMsR0FBaEIsRUFBcUI7QUFDbkIsU0FBT0EsUUFBUUEsR0FBZixDQURtQixDQUNBO0FBQ3BCLEM7Ozs7Ozs7Ozs7Ozs7OztBQzV2REQ7QUFDQXJtQixRQUFRNGtDLElBQVIsR0FBZSxVQUFVbHdDLE1BQVYsRUFBa0I4bUMsTUFBbEIsRUFBMEI4TyxJQUExQixFQUFnQ0MsSUFBaEMsRUFBc0NDLE1BQXRDLEVBQThDO0FBQzNELE1BQUl2L0MsQ0FBSixFQUFPNlksQ0FBUDtBQUNBLE1BQUkybUMsT0FBUUQsU0FBUyxDQUFWLEdBQWVELElBQWYsR0FBc0IsQ0FBakM7QUFDQSxNQUFJRyxPQUFPLENBQUMsS0FBS0QsSUFBTixJQUFjLENBQXpCO0FBQ0EsTUFBSUUsUUFBUUQsUUFBUSxDQUFwQjtBQUNBLE1BQUlFLFFBQVEsQ0FBQyxDQUFiO0FBQ0EsTUFBSXZrRCxJQUFJaWtELE9BQVFFLFNBQVMsQ0FBakIsR0FBc0IsQ0FBOUI7QUFDQSxNQUFJaHhCLElBQUk4d0IsT0FBTyxDQUFDLENBQVIsR0FBWSxDQUFwQjtBQUNBLE1BQUl0Z0MsSUFBSXRWLE9BQU84bUMsU0FBU24xQyxDQUFoQixDQUFSOztBQUVBQSxPQUFLbXpCLENBQUw7O0FBRUF2dUIsTUFBSStlLElBQUssQ0FBQyxLQUFNLENBQUM0Z0MsS0FBUixJQUFrQixDQUEzQjtBQUNBNWdDLFFBQU8sQ0FBQzRnQyxLQUFSO0FBQ0FBLFdBQVNILElBQVQ7QUFDQSxTQUFPRyxRQUFRLENBQWYsRUFBa0IzL0MsSUFBS0EsSUFBSSxHQUFMLEdBQVl5SixPQUFPOG1DLFNBQVNuMUMsQ0FBaEIsQ0FBaEIsRUFBb0NBLEtBQUttekIsQ0FBekMsRUFBNENveEIsU0FBUyxDQUF2RSxFQUEwRSxDQUFFOztBQUU1RTltQyxNQUFJN1ksSUFBSyxDQUFDLEtBQU0sQ0FBQzIvQyxLQUFSLElBQWtCLENBQTNCO0FBQ0EzL0MsUUFBTyxDQUFDMi9DLEtBQVI7QUFDQUEsV0FBU0wsSUFBVDtBQUNBLFNBQU9LLFFBQVEsQ0FBZixFQUFrQjltQyxJQUFLQSxJQUFJLEdBQUwsR0FBWXBQLE9BQU84bUMsU0FBU24xQyxDQUFoQixDQUFoQixFQUFvQ0EsS0FBS216QixDQUF6QyxFQUE0Q294QixTQUFTLENBQXZFLEVBQTBFLENBQUU7O0FBRTVFLE1BQUkzL0MsTUFBTSxDQUFWLEVBQWE7QUFDWEEsUUFBSSxJQUFJMC9DLEtBQVI7QUFDRCxHQUZELE1BRU8sSUFBSTEvQyxNQUFNeS9DLElBQVYsRUFBZ0I7QUFDckIsV0FBTzVtQyxJQUFJK21DLEdBQUosR0FBVyxDQUFDN2dDLElBQUksQ0FBQyxDQUFMLEdBQVMsQ0FBVixJQUFlM0wsUUFBakM7QUFDRCxHQUZNLE1BRUE7QUFDTHlGLFFBQUlBLElBQUl6QyxLQUFLdVcsR0FBTCxDQUFTLENBQVQsRUFBWTJ5QixJQUFaLENBQVI7QUFDQXQvQyxRQUFJQSxJQUFJMC9DLEtBQVI7QUFDRDtBQUNELFNBQU8sQ0FBQzNnQyxJQUFJLENBQUMsQ0FBTCxHQUFTLENBQVYsSUFBZWxHLENBQWYsR0FBbUJ6QyxLQUFLdVcsR0FBTCxDQUFTLENBQVQsRUFBWTNzQixJQUFJcy9DLElBQWhCLENBQTFCO0FBQ0QsQ0EvQkQ7O0FBaUNBdnFDLFFBQVF3aUMsS0FBUixHQUFnQixVQUFVOXRDLE1BQVYsRUFBa0JuQyxLQUFsQixFQUF5QmlwQyxNQUF6QixFQUFpQzhPLElBQWpDLEVBQXVDQyxJQUF2QyxFQUE2Q0MsTUFBN0MsRUFBcUQ7QUFDbkUsTUFBSXYvQyxDQUFKLEVBQU82WSxDQUFQLEVBQVV1USxDQUFWO0FBQ0EsTUFBSW8yQixPQUFRRCxTQUFTLENBQVYsR0FBZUQsSUFBZixHQUFzQixDQUFqQztBQUNBLE1BQUlHLE9BQU8sQ0FBQyxLQUFLRCxJQUFOLElBQWMsQ0FBekI7QUFDQSxNQUFJRSxRQUFRRCxRQUFRLENBQXBCO0FBQ0EsTUFBSXhtQixLQUFNcW1CLFNBQVMsRUFBVCxHQUFjbHBDLEtBQUt1VyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixJQUFtQnZXLEtBQUt1VyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixDQUFqQyxHQUFvRCxDQUE5RDtBQUNBLE1BQUl2eEIsSUFBSWlrRCxPQUFPLENBQVAsR0FBWUUsU0FBUyxDQUE3QjtBQUNBLE1BQUloeEIsSUFBSTh3QixPQUFPLENBQVAsR0FBVyxDQUFDLENBQXBCO0FBQ0EsTUFBSXRnQyxJQUFJelgsUUFBUSxDQUFSLElBQWNBLFVBQVUsQ0FBVixJQUFlLElBQUlBLEtBQUosR0FBWSxDQUF6QyxHQUE4QyxDQUE5QyxHQUFrRCxDQUExRDs7QUFFQUEsVUFBUThPLEtBQUtqRyxHQUFMLENBQVM3SSxLQUFULENBQVI7O0FBRUEsTUFBSWtpQixNQUFNbGlCLEtBQU4sS0FBZ0JBLFVBQVU4TCxRQUE5QixFQUF3QztBQUN0Q3lGLFFBQUkyUSxNQUFNbGlCLEtBQU4sSUFBZSxDQUFmLEdBQW1CLENBQXZCO0FBQ0F0SCxRQUFJeS9DLElBQUo7QUFDRCxHQUhELE1BR087QUFDTHovQyxRQUFJb1csS0FBSy9GLEtBQUwsQ0FBVytGLEtBQUtpVyxHQUFMLENBQVMva0IsS0FBVCxJQUFrQjhPLEtBQUtva0IsR0FBbEMsQ0FBSjtBQUNBLFFBQUlsekIsU0FBUzhoQixJQUFJaFQsS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQzNzQixDQUFiLENBQWIsSUFBZ0MsQ0FBcEMsRUFBdUM7QUFDckNBO0FBQ0FvcEIsV0FBSyxDQUFMO0FBQ0Q7QUFDRCxRQUFJcHBCLElBQUkwL0MsS0FBSixJQUFhLENBQWpCLEVBQW9CO0FBQ2xCcDRDLGVBQVMyeEIsS0FBSzdQLENBQWQ7QUFDRCxLQUZELE1BRU87QUFDTDloQixlQUFTMnhCLEtBQUs3aUIsS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSSt5QixLQUFoQixDQUFkO0FBQ0Q7QUFDRCxRQUFJcDRDLFFBQVE4aEIsQ0FBUixJQUFhLENBQWpCLEVBQW9CO0FBQ2xCcHBCO0FBQ0FvcEIsV0FBSyxDQUFMO0FBQ0Q7O0FBRUQsUUFBSXBwQixJQUFJMC9DLEtBQUosSUFBYUQsSUFBakIsRUFBdUI7QUFDckI1bUMsVUFBSSxDQUFKO0FBQ0E3WSxVQUFJeS9DLElBQUo7QUFDRCxLQUhELE1BR08sSUFBSXovQyxJQUFJMC9DLEtBQUosSUFBYSxDQUFqQixFQUFvQjtBQUN6QjdtQyxVQUFJLENBQUV2UixRQUFROGhCLENBQVQsR0FBYyxDQUFmLElBQW9CaFQsS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVkyeUIsSUFBWixDQUF4QjtBQUNBdC9DLFVBQUlBLElBQUkwL0MsS0FBUjtBQUNELEtBSE0sTUFHQTtBQUNMN21DLFVBQUl2UixRQUFROE8sS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVkreUIsUUFBUSxDQUFwQixDQUFSLEdBQWlDdHBDLEtBQUt1VyxHQUFMLENBQVMsQ0FBVCxFQUFZMnlCLElBQVosQ0FBckM7QUFDQXQvQyxVQUFJLENBQUo7QUFDRDtBQUNGOztBQUVELFNBQU9zL0MsUUFBUSxDQUFmLEVBQWtCNzFDLE9BQU84bUMsU0FBU24xQyxDQUFoQixJQUFxQnlkLElBQUksSUFBekIsRUFBK0J6ZCxLQUFLbXpCLENBQXBDLEVBQXVDMVYsS0FBSyxHQUE1QyxFQUFpRHltQyxRQUFRLENBQTNFLEVBQThFLENBQUU7O0FBRWhGdC9DLE1BQUtBLEtBQUtzL0MsSUFBTixHQUFjem1DLENBQWxCO0FBQ0EybUMsVUFBUUYsSUFBUjtBQUNBLFNBQU9FLE9BQU8sQ0FBZCxFQUFpQi8xQyxPQUFPOG1DLFNBQVNuMUMsQ0FBaEIsSUFBcUI0RSxJQUFJLElBQXpCLEVBQStCNUUsS0FBS216QixDQUFwQyxFQUF1Q3Z1QixLQUFLLEdBQTVDLEVBQWlEdy9DLFFBQVEsQ0FBMUUsRUFBNkUsQ0FBRTs7QUFFL0UvMUMsU0FBTzhtQyxTQUFTbjFDLENBQVQsR0FBYW16QixDQUFwQixLQUEwQnhQLElBQUksR0FBOUI7QUFDRCxDQWxERCxDOzs7Ozs7Ozs7Ozs7OztBQ2xDQSxJQUFJamUsV0FBVyxHQUFHQSxRQUFsQjs7QUFFQWdVLE9BQU9DLE9BQVAsR0FBaUJ6WixNQUFNQyxPQUFOLElBQWlCLFVBQVU4NUMsR0FBVixFQUFlO0FBQy9DLFNBQU92MEMsU0FBU2laLElBQVQsQ0FBY3M3QixHQUFkLEtBQXNCLGdCQUE3QjtBQUNELENBRkQsQzs7Ozs7Ozs7Ozs7Ozs7QUNGQSxJQUFJd0ssY0FBYztBQUNoQkMsUUFBTSxHQURVO0FBRWhCQyxZQUFVLEdBRk07QUFHaEIsaUJBQWUsR0FIQztBQUloQixpQkFBZSxHQUpDO0FBS2hCcDRDLFNBQU8sR0FMUztBQU1oQnE0QyxRQUFNLEdBTlU7QUFPaEJDLFdBQVMsR0FQTztBQVFoQkMsVUFBUSxHQVJRO0FBU2hCQyxTQUFPLEdBVFM7QUFVaEJDLFNBQU8sR0FWUztBQVdoQkMsWUFBVSxHQVhNO0FBWWhCQyxVQUFRLEdBWlE7QUFhaEIsZUFBYSxHQWJHO0FBY2hCLGVBQWEsR0FkRztBQWVoQkMsUUFBTSxHQWZVO0FBZ0JoQkMsU0FBTyxHQWhCUztBQWlCaEJqN0IsU0FBTyxHQWpCUztBQWtCaEIsZ0JBQWMsR0FsQkU7QUFtQmhCLGlCQUFlLEdBbkJDO0FBb0JoQixpQkFBZSxHQXBCQztBQXFCaEIsZ0JBQWMsR0FyQkU7QUFzQmhCLGlCQUFlLEdBdEJDO0FBdUJoQms3QixPQUFLLEdBdkJXO0FBd0JoQkMsVUFBUTtBQXhCUSxDQUFsQjtBQTBCQSxJQUFJQyxLQUFLLEdBQVQ7QUFDQSxJQUFJQyxXQUFXLG9CQUFmOztBQUVBLElBQUlDLFlBQVksRUFBaEI7O0FBRUEvckMsT0FBT0MsT0FBUCxHQUFpQixVQUFTNVosS0FBVCxFQUFnQmtILElBQWhCLEVBQXNCeStDLFVBQXRCLEVBQWtDO0FBQ2pELE1BQUlDLFVBQVVGLFVBQVUxbEQsS0FBVixDQUFkO0FBQ0EsTUFBSSxDQUFDNGxELE9BQUwsRUFBYztBQUNaLFFBQUksQ0FBQ3psRCxNQUFNQyxPQUFOLENBQWNKLEtBQWQsQ0FBTCxFQUEyQjtBQUN6QkEsY0FBUSxDQUFDQSxLQUFELENBQVI7QUFDRDtBQUNELFFBQUk2bEQsU0FBUyxHQUFiO0FBQ0EsUUFBSXRoRCxRQUFRLFFBQVo7QUFDQSxRQUFJdWhELGVBQWUsRUFBbkI7QUFDQSxRQUFJQyxVQUFKLEVBQWdCQyxTQUFoQjtBQUNBLFNBQUssSUFBSS9sRCxJQUFJLENBQVIsRUFBV0MsS0FBS0YsTUFBTU0sTUFBM0IsRUFBbUNMLElBQUlDLEVBQXZDLEVBQTJDLEVBQUVELENBQTdDLEVBQWdEO0FBQzlDLFVBQUlXLE9BQU9aLE1BQU1DLENBQU4sQ0FBWDtBQUNBLFVBQUlvQyxRQUFRekIsS0FBS0MsS0FBTCxDQUFXLEdBQVgsQ0FBWjtBQUNBLFVBQUlvbEQsY0FBYzVqRCxNQUFNQSxNQUFNL0IsTUFBTixHQUFlLENBQXJCLEVBQXdCMmQsV0FBeEIsRUFBbEI7QUFDQSxVQUFJZ29DLGVBQWUsUUFBZixJQUEyQkEsZUFBZSxRQUExQyxJQUFzREEsZUFBZSxTQUF6RSxFQUFvRjtBQUNsRjFoRCxnQkFBUXloRCxZQUFZemhELEtBQVosR0FBb0IwaEQsV0FBNUI7QUFDQTVqRCxjQUFNd2lCLEdBQU47QUFDQW9oQyxzQkFBYzVqRCxNQUFNQSxNQUFNL0IsTUFBTixHQUFlLENBQXJCLEVBQXdCMmQsV0FBeEIsRUFBZDtBQUNELE9BSkQsTUFJTyxJQUFJd25DLFNBQVN6bkMsSUFBVCxDQUFjaW9DLFdBQWQsQ0FBSixFQUFnQztBQUNyQ0Esc0JBQWNBLFlBQVlubEQsT0FBWixDQUFvQjJrRCxRQUFwQixFQUE4QixFQUE5QixDQUFkO0FBQ0FsaEQsZ0JBQVF5aEQsWUFBWXpoRCxLQUFaLEdBQW9CbEMsTUFBTUEsTUFBTS9CLE1BQU4sR0FBZSxDQUFyQixFQUF3QlEsT0FBeEIsQ0FBZ0NtbEQsV0FBaEMsRUFBNkMsRUFBN0MsQ0FBNUI7QUFDRDtBQUNELFdBQUssSUFBSS9vQyxDQUFULElBQWN3bkMsV0FBZCxFQUEyQjtBQUN6QixZQUFJdUIsZUFBZS9vQyxDQUFmLElBQW9CK29DLGVBQWUvb0MsRUFBRXBjLE9BQUYsQ0FBVSxHQUFWLEVBQWUsRUFBZixDQUFuQyxJQUF5RG1sRCxlQUFlL29DLEVBQUVwYyxPQUFGLENBQVUsR0FBVixFQUFlMGtELEVBQWYsQ0FBNUUsRUFBZ0c7QUFDOUZLLG1CQUFTRSxhQUFhRixNQUFiLEdBQXNCbkIsWUFBWXhuQyxDQUFaLENBQS9CO0FBQ0E3YSxnQkFBTXdpQixHQUFOO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsVUFBSSxDQUFDa2hDLFVBQUQsSUFBZSxPQUFPRSxXQUFQLElBQXNCLFFBQXpDLEVBQW1EO0FBQ2pESixpQkFBU0ksV0FBVDtBQUNEO0FBQ0QsVUFBSUMsYUFBYTdqRCxNQUFNZ0osSUFBTixDQUFXbTZDLEVBQVgsRUFDZDFrRCxPQURjLENBQ04sc0JBRE0sRUFDa0IsV0FEbEIsQ0FBakI7QUFFQSxVQUFJb2xELFdBQVdsbEQsT0FBWCxDQUFtQndrRCxFQUFuQixNQUEyQixDQUFDLENBQWhDLEVBQW1DO0FBQ2pDVSxxQkFBYSxNQUFNQSxVQUFOLEdBQW1CLEdBQWhDO0FBQ0Q7QUFDREosbUJBQWE3a0QsSUFBYixDQUFrQmlsRCxVQUFsQjtBQUNEO0FBQ0Q7QUFDQU4sY0FBVUYsVUFBVTFsRCxLQUFWLElBQW1CLENBQUN1RSxLQUFELEVBQVFzaEQsTUFBUixFQUFnQkMsWUFBaEIsQ0FBN0I7QUFDRDtBQUNELFNBQU9GLFFBQVEsQ0FBUixJQUFhSixFQUFiLEdBQWtCSSxRQUFRLENBQVIsQ0FBbEIsR0FBK0JKLEVBQS9CLEdBQW9DdCtDLElBQXBDLEdBQTJDLElBQTNDLElBQW1EeStDLGFBQWEsTUFBTUEsVUFBbkIsR0FBZ0MsRUFBbkYsSUFBeUZILEVBQXpGLEdBQThGSSxRQUFRLENBQVIsQ0FBckc7QUFDRCxDQTNDRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QkE7O0FBRUE7Ozs7Ozs7O0FBUUEsSUFBTU8saUJBQWlCLFNBQWpCQSxjQUFpQixDQUFTek0sSUFBVCxFQUFlOztBQUVwQyxNQUFNeDNDLE9BQU9ra0QsaUJBQVVBLGVBQVF2bEQsS0FBUixDQUFjLEdBQWQsRUFBbUIsQ0FBbkIsQ0FBVixHQUFrQyxRQUEvQzs7QUFFQTs7O0FBR0EsT0FBS3FtQixPQUFMLEdBQWUscURBQXFEaGxCLElBQXJELEdBQ1gsZUFEVyxHQUNPdzNDLElBRFAsR0FDYyxlQUQ3Qjs7QUFHQTs7Ozs7Ozs7QUFRQSxPQUFLQSxJQUFMLEdBQVlBLElBQVo7O0FBRUEsT0FBS3p0QyxJQUFMLEdBQVksZ0JBQVo7QUFFRCxDQXRCRCxDLENBYkE7Ozs7O0FBcUNBLHFCQUFTazZDLGNBQVQsRUFBeUJuakQsS0FBekI7O2tCQUVlbWpELGM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDZjs7QUFFQTs7OztBQUlBLElBQU1FLGFBQWEsU0FBYkEsVUFBYSxHQUFXLENBQUUsQ0FBaEM7O0FBRUE7Ozs7O0FBWEE7OztBQWdCQUEsV0FBVzFuQyxTQUFYLENBQXFCMm5DLFNBQXJCLEdBQWlDLEtBQWpDOztBQUVBOzs7QUFHQUQsV0FBVzFuQyxTQUFYLENBQXFCNG5DLE9BQXJCLEdBQStCLFlBQVc7QUFDeEMsTUFBSSxDQUFDLEtBQUtELFNBQVYsRUFBcUI7QUFDbkIsU0FBS0EsU0FBTCxHQUFpQixJQUFqQjtBQUNBLFNBQUtFLGVBQUw7QUFDRDtBQUNGLENBTEQ7O0FBT0E7Ozs7QUFJQUgsV0FBVzFuQyxTQUFYLENBQXFCNm5DLGVBQXJCLEdBQXVDQyxvQkFBdkM7a0JBQ2VKLFU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCZjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7QUFNQTs7Ozs7Ozs7OztBQWhCQTs7O0FBMEJBLElBQU1LLFlBQVksU0FBWkEsU0FBWSxDQUFTQyxTQUFULEVBQW9CdlMsS0FBcEIsRUFBMkJqcUMsR0FBM0IsRUFBZ0NILFdBQWhDLEVBQTZDNDhDLGdCQUE3QyxFQUErREMsV0FBL0QsRUFBNEU7O0FBRTVGQyxpQkFBS2xvQyxJQUFMLENBQVUsSUFBVixFQUFnQituQyxTQUFoQixFQUEyQnZTLEtBQTNCLEVBQWtDeVMsV0FBbEM7O0FBRUE7Ozs7QUFJQSxPQUFLRSxZQUFMLEdBQW9CLzhDLFdBQXBCOztBQUVBOzs7Ozs7QUFNQSxPQUFLZzlDLElBQUwsR0FBWTc4QyxHQUFaOztBQUVBOzs7O0FBSUEsT0FBSzg4QyxNQUFMLEdBQWMsSUFBSUMsS0FBSixFQUFkO0FBQ0EsTUFBSWw5QyxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEIsU0FBS2k5QyxNQUFMLENBQVlqOUMsV0FBWixHQUEwQkEsV0FBMUI7QUFDRDs7QUFFRDs7OztBQUlBLE9BQUttOUMsa0JBQUwsR0FBMEIsSUFBMUI7O0FBRUE7Ozs7QUFJQSxPQUFLQyxpQkFBTCxHQUF5QlIsZ0JBQXpCO0FBRUQsQ0F2Q0Q7O0FBeUNBLHFCQUFTRixTQUFULEVBQW9CSSxjQUFwQjs7QUFHQTs7O0FBR0FKLFVBQVUvbkMsU0FBVixDQUFvQjZuQyxlQUFwQixHQUFzQyxZQUFXO0FBQy9DLE1BQUksS0FBS3BTLEtBQUwsSUFBY2lULG9CQUFVQyxPQUE1QixFQUFxQztBQUNuQyxTQUFLQyxjQUFMO0FBQ0EsU0FBS04sTUFBTCxHQUFjTyxlQUFkO0FBQ0Q7QUFDRCxNQUFJLEtBQUtDLFdBQVQsRUFBc0I7QUFDcEIsU0FBS0EsV0FBTCxDQUFpQmxCLE9BQWpCO0FBQ0Q7QUFDRCxPQUFLblMsS0FBTCxHQUFhaVQsb0JBQVVLLEtBQXZCO0FBQ0EsT0FBS0MsT0FBTDtBQUNBYixpQkFBS25vQyxTQUFMLENBQWU2bkMsZUFBZixDQUErQjVuQyxJQUEvQixDQUFvQyxJQUFwQztBQUNELENBWEQ7O0FBY0E7Ozs7O0FBS0E4bkMsVUFBVS9uQyxTQUFWLENBQW9CcFUsUUFBcEIsR0FBK0IsWUFBVztBQUN4QyxTQUFPLEtBQUswOEMsTUFBWjtBQUNELENBRkQ7O0FBS0E7OztBQUdBUCxVQUFVL25DLFNBQVYsQ0FBb0JpcEMsTUFBcEIsR0FBNkIsWUFBVztBQUN0QyxTQUFPLEtBQUtaLElBQVo7QUFDRCxDQUZEOztBQUtBOzs7OztBQUtBTixVQUFVL25DLFNBQVYsQ0FBb0JrcEMsaUJBQXBCLEdBQXdDLFlBQVc7QUFDakQsT0FBS3pULEtBQUwsR0FBYWlULG9CQUFVUyxLQUF2QjtBQUNBLE9BQUtQLGNBQUw7QUFDQSxPQUFLTixNQUFMLEdBQWNPLGVBQWQ7QUFDQSxPQUFLRyxPQUFMO0FBQ0QsQ0FMRDs7QUFRQTs7Ozs7QUFLQWpCLFVBQVUvbkMsU0FBVixDQUFvQm9wQyxnQkFBcEIsR0FBdUMsWUFBVztBQUNoRCxNQUFJLEtBQUtkLE1BQUwsQ0FBWWUsWUFBWixJQUE0QixLQUFLZixNQUFMLENBQVlnQixhQUE1QyxFQUEyRDtBQUN6RCxTQUFLN1QsS0FBTCxHQUFhaVQsb0JBQVVhLE1BQXZCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsU0FBSzlULEtBQUwsR0FBYWlULG9CQUFVYyxLQUF2QjtBQUNEO0FBQ0QsT0FBS1osY0FBTDtBQUNBLE9BQUtJLE9BQUw7QUFDRCxDQVJEOztBQVdBOzs7O0FBSUFqQixVQUFVL25DLFNBQVYsQ0FBb0J5cEMsSUFBcEIsR0FBMkIsWUFBVztBQUNwQyxNQUFJLEtBQUtoVSxLQUFMLElBQWNpVCxvQkFBVVMsS0FBNUIsRUFBbUM7QUFDakMsU0FBSzFULEtBQUwsR0FBYWlULG9CQUFVZ0IsSUFBdkI7QUFDQSxTQUFLcEIsTUFBTCxHQUFjLElBQUlDLEtBQUosRUFBZDtBQUNBLFFBQUksS0FBS0gsWUFBTCxLQUFzQixJQUExQixFQUFnQztBQUM5QixXQUFLRSxNQUFMLENBQVlqOUMsV0FBWixHQUEwQixLQUFLKzhDLFlBQS9CO0FBQ0Q7QUFDRjtBQUNELE1BQUksS0FBSzNTLEtBQUwsSUFBY2lULG9CQUFVZ0IsSUFBNUIsRUFBa0M7QUFDaEMsU0FBS2pVLEtBQUwsR0FBYWlULG9CQUFVQyxPQUF2QjtBQUNBLFNBQUtLLE9BQUw7QUFDQSxTQUFLUixrQkFBTCxHQUEwQixDQUN4Qix3QkFBVyxLQUFLRixNQUFoQixFQUF3QnFCLG9CQUFVUixLQUFsQyxFQUNFLEtBQUtELGlCQURQLEVBQzBCLElBRDFCLENBRHdCLEVBR3hCLHdCQUFXLEtBQUtaLE1BQWhCLEVBQXdCcUIsb0JBQVVDLElBQWxDLEVBQ0UsS0FBS1IsZ0JBRFAsRUFDeUIsSUFEekIsQ0FId0IsQ0FBMUI7QUFNQSxTQUFLWCxpQkFBTCxDQUF1QixJQUF2QixFQUE2QixLQUFLSixJQUFsQztBQUNEO0FBQ0YsQ0FuQkQ7O0FBc0JBOzs7OztBQUtBTixVQUFVL25DLFNBQVYsQ0FBb0I0b0MsY0FBcEIsR0FBcUMsWUFBVztBQUM5QyxPQUFLSixrQkFBTCxDQUF3QnhoQyxPQUF4QixDQUFnQzZpQyxxQkFBaEM7QUFDQSxPQUFLckIsa0JBQUwsR0FBMEIsSUFBMUI7QUFDRCxDQUhEOztBQU1BOzs7O0FBSUEsU0FBU0ssYUFBVCxHQUF5QjtBQUN2QixNQUFNejZCLE1BQU0sZ0NBQXNCLENBQXRCLEVBQXlCLENBQXpCLENBQVo7QUFDQUEsTUFBSTA3QixTQUFKLEdBQWdCLGVBQWhCO0FBQ0ExN0IsTUFBSTI3QixRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QjtBQUNBLFNBQU8zN0IsSUFBSTQ3QixNQUFYO0FBQ0Q7O2tCQUVjakMsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUM1RENrQyxrQixHQUFBQSxrQjs7QUF2SGhCOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBR0E7Ozs7Ozs7Ozs7O0FBV0EsSUFBTUMsY0FBYyxTQUFkQSxXQUFjLENBQVM1akQsSUFBVCxFQUFlcUUsR0FBZixFQUFvQncvQyxRQUFwQixFQUE4QjtBQUNoREMsa0JBQU1ucUMsSUFBTixDQUFXLElBQVgsRUFBaUIzWixJQUFqQjs7QUFFQTs7Ozs7QUFLQSxPQUFLcUUsR0FBTCxHQUFXQSxHQUFYOztBQUVBOzs7Ozs7QUFNQSxPQUFLdy9DLFFBQUwsR0FBZ0JBLFFBQWhCO0FBRUQsQ0FsQkQsQyxDQXJCQTs7OztBQXdDQSxxQkFBU0QsV0FBVCxFQUFzQkUsZUFBdEI7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0EsSUFBTUMsYUFBYSxTQUFiQSxVQUFhLENBQVNDLFVBQVQsRUFBcUI7QUFDdENDLHVCQUFXdHFDLElBQVgsQ0FBZ0IsSUFBaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBTyxJQUFQOztBQUVBOzs7O0FBSUEsT0FBS3VxQyxPQUFMLEdBQWUsRUFBZjs7QUFFQSxNQUFJRixlQUFlaGxELFNBQW5CLEVBQThCO0FBQzVCLFNBQUttbEQsYUFBTCxDQUFtQkgsVUFBbkI7QUFDRDtBQUNGLENBbEJEOztBQW9CQSxxQkFBU0QsVUFBVCxFQUFxQkUsb0JBQXJCOztBQUdBOzs7QUFHQSxJQUFNRyx1QkFBdUIsRUFBN0I7O0FBR0E7Ozs7QUFJTyxTQUFTVCxrQkFBVCxDQUE0QnQvQyxHQUE1QixFQUFpQztBQUN0QyxTQUFPKy9DLHFCQUFxQmxyQyxjQUFyQixDQUFvQzdVLEdBQXBDLElBQ0wrL0MscUJBQXFCLy9DLEdBQXJCLENBREssR0FFSisvQyxxQkFBcUIvL0MsR0FBckIsSUFBNEIsWUFBWUEsR0FGM0M7QUFHRDs7QUFHRDs7Ozs7O0FBTUEwL0MsV0FBV3JxQyxTQUFYLENBQXFCalQsR0FBckIsR0FBMkIsVUFBU3BDLEdBQVQsRUFBYztBQUN2QyxNQUFJNkMsY0FBSjtBQUNBLE1BQUksS0FBS2c5QyxPQUFMLENBQWFockMsY0FBYixDQUE0QjdVLEdBQTVCLENBQUosRUFBc0M7QUFDcEM2QyxZQUFRLEtBQUtnOUMsT0FBTCxDQUFhNy9DLEdBQWIsQ0FBUjtBQUNEO0FBQ0QsU0FBTzZDLEtBQVA7QUFDRCxDQU5EOztBQVNBOzs7OztBQUtBNjhDLFdBQVdycUMsU0FBWCxDQUFxQjJxQyxPQUFyQixHQUErQixZQUFXO0FBQ3hDLFNBQU90d0MsT0FBT04sSUFBUCxDQUFZLEtBQUt5d0MsT0FBakIsQ0FBUDtBQUNELENBRkQ7O0FBS0E7Ozs7O0FBS0FILFdBQVdycUMsU0FBWCxDQUFxQjRxQyxhQUFyQixHQUFxQyxZQUFXO0FBQzlDLFNBQU8saUJBQU8sRUFBUCxFQUFXLEtBQUtKLE9BQWhCLENBQVA7QUFDRCxDQUZEOztBQUtBOzs7O0FBSUFILFdBQVdycUMsU0FBWCxDQUFxQjZxQyxNQUFyQixHQUE4QixVQUFTbGdELEdBQVQsRUFBY3cvQyxRQUFkLEVBQXdCO0FBQ3BELE1BQUlXLGtCQUFKO0FBQ0FBLGNBQVliLG1CQUFtQnQvQyxHQUFuQixDQUFaO0FBQ0EsT0FBS29nRCxhQUFMLENBQW1CLElBQUliLFdBQUosQ0FBZ0JZLFNBQWhCLEVBQTJCbmdELEdBQTNCLEVBQWdDdy9DLFFBQWhDLENBQW5CO0FBQ0FXLGNBQVlFLDBCQUFnQkMsY0FBNUI7QUFDQSxPQUFLRixhQUFMLENBQW1CLElBQUliLFdBQUosQ0FBZ0JZLFNBQWhCLEVBQTJCbmdELEdBQTNCLEVBQWdDdy9DLFFBQWhDLENBQW5CO0FBQ0QsQ0FORDs7QUFTQTs7Ozs7OztBQU9BRSxXQUFXcnFDLFNBQVgsQ0FBcUI1VCxHQUFyQixHQUEyQixVQUFTekIsR0FBVCxFQUFjNkMsS0FBZCxFQUFxQjA5QyxVQUFyQixFQUFpQztBQUMxRCxNQUFJQSxVQUFKLEVBQWdCO0FBQ2QsU0FBS1YsT0FBTCxDQUFhNy9DLEdBQWIsSUFBb0I2QyxLQUFwQjtBQUNELEdBRkQsTUFFTztBQUNMLFFBQU0yOEMsV0FBVyxLQUFLSyxPQUFMLENBQWE3L0MsR0FBYixDQUFqQjtBQUNBLFNBQUs2L0MsT0FBTCxDQUFhNy9DLEdBQWIsSUFBb0I2QyxLQUFwQjtBQUNBLFFBQUkyOEMsYUFBYTM4QyxLQUFqQixFQUF3QjtBQUN0QixXQUFLcTlDLE1BQUwsQ0FBWWxnRCxHQUFaLEVBQWlCdy9DLFFBQWpCO0FBQ0Q7QUFDRjtBQUNGLENBVkQ7O0FBYUE7Ozs7Ozs7QUFPQUUsV0FBV3JxQyxTQUFYLENBQXFCeXFDLGFBQXJCLEdBQXFDLFVBQVN0OUMsTUFBVCxFQUFpQis5QyxVQUFqQixFQUE2QjtBQUNoRSxPQUFLLElBQU12Z0QsR0FBWCxJQUFrQndDLE1BQWxCLEVBQTBCO0FBQ3hCLFNBQUtmLEdBQUwsQ0FBU3pCLEdBQVQsRUFBY3dDLE9BQU94QyxHQUFQLENBQWQsRUFBMkJ1Z0QsVUFBM0I7QUFDRDtBQUNGLENBSkQ7O0FBT0E7Ozs7OztBQU1BYixXQUFXcnFDLFNBQVgsQ0FBcUJtckMsS0FBckIsR0FBNkIsVUFBU3hnRCxHQUFULEVBQWN1Z0QsVUFBZCxFQUEwQjtBQUNyRCxNQUFJdmdELE9BQU8sS0FBSzYvQyxPQUFoQixFQUF5QjtBQUN2QixRQUFNTCxXQUFXLEtBQUtLLE9BQUwsQ0FBYTcvQyxHQUFiLENBQWpCO0FBQ0EsV0FBTyxLQUFLNi9DLE9BQUwsQ0FBYTcvQyxHQUFiLENBQVA7QUFDQSxRQUFJLENBQUN1Z0QsVUFBTCxFQUFpQjtBQUNmLFdBQUtMLE1BQUwsQ0FBWWxnRCxHQUFaLEVBQWlCdy9DLFFBQWpCO0FBQ0Q7QUFDRjtBQUNGLENBUkQ7O2tCQVdlRSxVOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BPZjs7OztBQUlBOzs7a0JBR2U7QUFDYjs7Ozs7QUFLQVksa0JBQWdCO0FBTkgsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNvQ0NHLE8sR0FBQUEsTzs7QUF4Q2hCOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7OztBQVJBOzs7QUFzQkEsSUFBTWIsYUFBYSxTQUFiQSxVQUFhLEdBQVc7O0FBRTVCYyx3QkFBWXByQyxJQUFaLENBQWlCLElBQWpCOztBQUVBOzs7O0FBSUEsT0FBS3FyQyxTQUFMLEdBQWlCLENBQWpCO0FBRUQsQ0FWRDs7QUFZQSxxQkFBU2YsVUFBVCxFQUFxQmMscUJBQXJCOztBQUdBOzs7Ozs7QUFNTyxTQUFTRCxPQUFULENBQWlCemdELEdBQWpCLEVBQXNCO0FBQzNCLE1BQUluSixNQUFNQyxPQUFOLENBQWNrSixHQUFkLENBQUosRUFBd0I7QUFDdEIsU0FBSyxJQUFJckosSUFBSSxDQUFSLEVBQVdDLEtBQUtvSixJQUFJaEosTUFBekIsRUFBaUNMLElBQUlDLEVBQXJDLEVBQXlDLEVBQUVELENBQTNDLEVBQThDO0FBQzVDLGlDQUFjcUosSUFBSXJKLENBQUosQ0FBZDtBQUNEO0FBQ0YsR0FKRCxNQUlPO0FBQ0wsZ0NBQWMseUNBQTJDcUosR0FBekQ7QUFDRDtBQUNGOztBQUdEOzs7O0FBSUE0L0MsV0FBV3ZxQyxTQUFYLENBQXFCZ3BDLE9BQXJCLEdBQStCLFlBQVc7QUFDeEMsSUFBRSxLQUFLc0MsU0FBUDtBQUNBLE9BQUtQLGFBQUwsQ0FBbUJwQixvQkFBVTRCLE1BQTdCO0FBQ0QsQ0FIRDs7QUFNQTs7Ozs7Ozs7Ozs7QUFXQWhCLFdBQVd2cUMsU0FBWCxDQUFxQitxQyxhQUFyQjs7QUFHQTs7Ozs7O0FBTUFSLFdBQVd2cUMsU0FBWCxDQUFxQndyQyxXQUFyQixHQUFtQyxZQUFXO0FBQzVDLFNBQU8sS0FBS0YsU0FBWjtBQUNELENBRkQ7O0FBS0E7Ozs7Ozs7OztBQVNBZixXQUFXdnFDLFNBQVgsQ0FBcUI1WSxFQUFyQixHQUEwQixVQUFTZCxJQUFULEVBQWVtbEQsUUFBZixFQUF5QjtBQUNqRCxNQUFJanFELE1BQU1DLE9BQU4sQ0FBYzZFLElBQWQsQ0FBSixFQUF5QjtBQUN2QixRQUFNaWEsTUFBTWphLEtBQUszRSxNQUFqQjtBQUNBLFFBQU1vWSxPQUFPLElBQUl2WSxLQUFKLENBQVUrZSxHQUFWLENBQWI7QUFDQSxTQUFLLElBQUlqZixJQUFJLENBQWIsRUFBZ0JBLElBQUlpZixHQUFwQixFQUF5QixFQUFFamYsQ0FBM0IsRUFBOEI7QUFDNUJ5WSxXQUFLelksQ0FBTCxJQUFVLG9CQUFPLElBQVAsRUFBYWdGLEtBQUtoRixDQUFMLENBQWIsRUFBc0JtcUQsUUFBdEIsQ0FBVjtBQUNEO0FBQ0QsV0FBTzF4QyxJQUFQO0FBQ0QsR0FQRCxNQU9PO0FBQ0wsV0FBTyxvQkFBTyxJQUFQLEVBQWEscUJBQXVCelQsSUFBcEMsRUFBMkNtbEQsUUFBM0MsQ0FBUDtBQUNEO0FBQ0YsQ0FYRDs7QUFjQTs7Ozs7Ozs7O0FBU0FsQixXQUFXdnFDLFNBQVgsQ0FBcUJoWCxJQUFyQixHQUE0QixVQUFTMUMsSUFBVCxFQUFlbWxELFFBQWYsRUFBeUI7QUFDbkQsTUFBSWpxRCxNQUFNQyxPQUFOLENBQWM2RSxJQUFkLENBQUosRUFBeUI7QUFDdkIsUUFBTWlhLE1BQU1qYSxLQUFLM0UsTUFBakI7QUFDQSxRQUFNb1ksT0FBTyxJQUFJdlksS0FBSixDQUFVK2UsR0FBVixDQUFiO0FBQ0EsU0FBSyxJQUFJamYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaWYsR0FBcEIsRUFBeUIsRUFBRWpmLENBQTNCLEVBQThCO0FBQzVCeVksV0FBS3pZLENBQUwsSUFBVSx3QkFBVyxJQUFYLEVBQWlCZ0YsS0FBS2hGLENBQUwsQ0FBakIsRUFBMEJtcUQsUUFBMUIsQ0FBVjtBQUNEO0FBQ0QsV0FBTzF4QyxJQUFQO0FBQ0QsR0FQRCxNQU9PO0FBQ0wsV0FBTyx3QkFBVyxJQUFYLEVBQWlCLHFCQUF1QnpULElBQXhDLEVBQStDbWxELFFBQS9DLENBQVA7QUFDRDtBQUNGLENBWEQ7O0FBY0E7Ozs7OztBQU1BbEIsV0FBV3ZxQyxTQUFYLENBQXFCMHJDLEVBQXJCLEdBQTBCLFVBQVNwbEQsSUFBVCxFQUFlbWxELFFBQWYsRUFBeUI7QUFDakQsTUFBSWpxRCxNQUFNQyxPQUFOLENBQWM2RSxJQUFkLENBQUosRUFBeUI7QUFDdkIsU0FBSyxJQUFJaEYsSUFBSSxDQUFSLEVBQVdDLEtBQUsrRSxLQUFLM0UsTUFBMUIsRUFBa0NMLElBQUlDLEVBQXRDLEVBQTBDLEVBQUVELENBQTVDLEVBQStDO0FBQzdDLDRCQUFTLElBQVQsRUFBZWdGLEtBQUtoRixDQUFMLENBQWYsRUFBd0JtcUQsUUFBeEI7QUFDRDtBQUNEO0FBQ0QsR0FMRCxNQUtPO0FBQ0wsMEJBQVMsSUFBVCxFQUFlLHFCQUF1Qm5sRCxJQUF0QyxFQUE2Q21sRCxRQUE3QztBQUNEO0FBQ0YsQ0FURDtrQkFVZWxCLFU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BKZjs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUdBOzs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7QUFXQSxJQUFNcEMsT0FBTyxTQUFQQSxJQUFPLENBQVNILFNBQVQsRUFBb0J2UyxLQUFwQixFQUEyQnlTLFdBQTNCLEVBQXdDO0FBQ25EbUQsd0JBQVlwckMsSUFBWixDQUFpQixJQUFqQjs7QUFFQSxNQUFNL0csVUFBVWd2QyxjQUFjQSxXQUFkLEdBQTRCLEVBQTVDOztBQUVBOzs7QUFHQSxPQUFLRixTQUFMLEdBQWlCQSxTQUFqQjs7QUFFQTs7OztBQUlBLE9BQUt2UyxLQUFMLEdBQWFBLEtBQWI7O0FBRUE7Ozs7OztBQU1BLE9BQUtxVCxXQUFMLEdBQW1CLElBQW5COztBQUVBOzs7Ozs7QUFNQSxPQUFLbitDLEdBQUwsR0FBVyxFQUFYOztBQUVBOzs7O0FBSUEsT0FBS2doRCxXQUFMLEdBQW1CenlDLFFBQVE5SyxVQUFSLEtBQXVCOUksU0FBdkIsR0FBbUMsR0FBbkMsR0FBeUM0VCxRQUFROUssVUFBcEU7O0FBRUE7Ozs7O0FBS0EsT0FBS3c5QyxpQkFBTCxHQUF5QixFQUF6QjtBQUVELENBN0NELEMsQ0FyREE7Ozs7O0FBb0dBLHFCQUFTekQsSUFBVCxFQUFla0QscUJBQWY7O0FBR0E7OztBQUdBbEQsS0FBS25vQyxTQUFMLENBQWVncEMsT0FBZixHQUF5QixZQUFXO0FBQ2xDLE9BQUsrQixhQUFMLENBQW1CcEIsb0JBQVU0QixNQUE3QjtBQUNELENBRkQ7O0FBS0E7OztBQUdBcEQsS0FBS25vQyxTQUFMLENBQWVpcEMsTUFBZixHQUF3QixZQUFXO0FBQ2pDLFNBQU8sS0FBS3QrQyxHQUFMLEdBQVcsR0FBWCxHQUFpQixLQUFLcTlDLFNBQTdCO0FBQ0QsQ0FGRDs7QUFJQTs7Ozs7O0FBTUFHLEtBQUtub0MsU0FBTCxDQUFlNnJDLGNBQWYsR0FBZ0MsWUFBVztBQUN6QyxNQUFJLENBQUMsS0FBSy9DLFdBQVYsRUFBdUI7QUFDckI7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNELE1BQUkvOUMsT0FBTyxLQUFLKzlDLFdBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBRztBQUNELFFBQUkvOUMsS0FBS0gsUUFBTCxNQUFtQjg5QyxvQkFBVWEsTUFBakMsRUFBeUM7QUFDdkMsYUFBT3grQyxJQUFQO0FBQ0Q7QUFDREEsV0FBT0EsS0FBSys5QyxXQUFaO0FBQ0QsR0FMRCxRQUtTLzlDLElBTFQ7O0FBT0E7QUFDQSxTQUFPLElBQVA7QUFDRCxDQXBCRDs7QUFzQkE7Ozs7QUFJQW85QyxLQUFLbm9DLFNBQUwsQ0FBZThyQyxtQkFBZixHQUFxQyxZQUFXO0FBQzlDLE1BQUksQ0FBQyxLQUFLaEQsV0FBVixFQUF1QjtBQUNyQjtBQUNEOztBQUVELE1BQUkvOUMsT0FBTyxLQUFLKzlDLFdBQWhCO0FBQ0EsTUFBSWlELE9BQU8sSUFBWDs7QUFFQSxLQUFHO0FBQ0QsUUFBSWhoRCxLQUFLSCxRQUFMLE1BQW1CODlDLG9CQUFVYSxNQUFqQyxFQUF5QztBQUN2QztBQUNBO0FBQ0E7QUFDQXgrQyxXQUFLKzlDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQTtBQUNELEtBTkQsTUFNTyxJQUFJLzlDLEtBQUtILFFBQUwsTUFBbUI4OUMsb0JBQVVDLE9BQWpDLEVBQTBDO0FBQy9DO0FBQ0E7QUFDQW9ELGFBQU9oaEQsSUFBUDtBQUNELEtBSk0sTUFJQSxJQUFJQSxLQUFLSCxRQUFMLE1BQW1CODlDLG9CQUFVZ0IsSUFBakMsRUFBdUM7QUFDNUM7QUFDQTtBQUNBcUMsV0FBS2pELFdBQUwsR0FBbUIvOUMsS0FBSys5QyxXQUF4QjtBQUNELEtBSk0sTUFJQTtBQUNMaUQsYUFBT2hoRCxJQUFQO0FBQ0Q7QUFDREEsV0FBT2doRCxLQUFLakQsV0FBWjtBQUNELEdBbkJELFFBbUJTLzlDLElBbkJUO0FBb0JELENBNUJEOztBQThCQTs7Ozs7QUFLQW85QyxLQUFLbm9DLFNBQUwsQ0FBZXJVLFlBQWYsR0FBOEIsWUFBVztBQUN2QyxTQUFPLEtBQUtxOEMsU0FBWjtBQUNELENBRkQ7O0FBS0E7OztBQUdBRyxLQUFLbm9DLFNBQUwsQ0FBZXBWLFFBQWYsR0FBMEIsWUFBVztBQUNuQyxTQUFPLEtBQUs2cUMsS0FBWjtBQUNELENBRkQ7O0FBSUE7OztBQUdBMFMsS0FBS25vQyxTQUFMLENBQWVnc0MsUUFBZixHQUEwQixVQUFTdlcsS0FBVCxFQUFnQjtBQUN4QyxPQUFLQSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxPQUFLdVQsT0FBTDtBQUNELENBSEQ7O0FBS0E7Ozs7Ozs7QUFPQWIsS0FBS25vQyxTQUFMLENBQWV5cEMsSUFBZixHQUFzQixZQUFXLENBQUUsQ0FBbkM7O0FBRUE7Ozs7OztBQU1BdEIsS0FBS25vQyxTQUFMLENBQWVpc0MsUUFBZixHQUEwQixVQUFTaG1ELEVBQVQsRUFBYWltRCxJQUFiLEVBQW1CO0FBQzNDLE1BQUksQ0FBQyxLQUFLUCxXQUFWLEVBQXVCO0FBQ3JCLFdBQU8sQ0FBUDtBQUNEOztBQUVELE1BQUl6eEMsUUFBUSxLQUFLMHhDLGlCQUFMLENBQXVCM2xELEVBQXZCLENBQVo7QUFDQSxNQUFJLENBQUNpVSxLQUFMLEVBQVk7QUFDVkEsWUFBUWd5QyxJQUFSO0FBQ0EsU0FBS04saUJBQUwsQ0FBdUIzbEQsRUFBdkIsSUFBNkJpVSxLQUE3QjtBQUNELEdBSEQsTUFHTyxJQUFJQSxVQUFVLENBQUMsQ0FBZixFQUFrQjtBQUN2QixXQUFPLENBQVA7QUFDRDs7QUFFRCxNQUFNd0QsUUFBUXd1QyxPQUFPaHlDLEtBQVAsR0FBZ0IsT0FBTyxFQUFyQyxDQWIyQyxDQWFEO0FBQzFDLE1BQUl3RCxTQUFTLEtBQUtpdUMsV0FBbEIsRUFBK0I7QUFDN0IsV0FBTyxDQUFQO0FBQ0Q7QUFDRCxTQUFPLG9CQUFPanVDLFFBQVEsS0FBS2l1QyxXQUFwQixDQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBOzs7Ozs7O0FBT0F4RCxLQUFLbm9DLFNBQUwsQ0FBZW1zQyxZQUFmLEdBQThCLFVBQVNsbUQsRUFBVCxFQUFhO0FBQ3pDLE1BQUksQ0FBQyxLQUFLMGxELFdBQVYsRUFBdUI7QUFDckIsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFPLEtBQUtDLGlCQUFMLENBQXVCM2xELEVBQXZCLE1BQStCLENBQUMsQ0FBdkM7QUFDRCxDQUxEOztBQU9BOzs7O0FBSUFraUQsS0FBS25vQyxTQUFMLENBQWVvc0MsYUFBZixHQUErQixVQUFTbm1ELEVBQVQsRUFBYTtBQUMxQyxNQUFJLEtBQUswbEQsV0FBVCxFQUFzQjtBQUNwQixTQUFLQyxpQkFBTCxDQUF1QjNsRCxFQUF2QixJQUE2QixDQUFDLENBQTlCO0FBQ0Q7QUFDRixDQUpEO2tCQUtla2lELEk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BRZjs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQU1BLElBQU1rRSxZQUFZLFNBQVpBLFNBQVksQ0FBU0MsaUJBQVQsRUFBNEI7O0FBRTVDQyxxQkFBU3RzQyxJQUFULENBQWMsSUFBZCxFQUFvQnFzQyxpQkFBcEI7QUFFRCxDQUpELEMsQ0FiQTs7Ozs7QUFtQkEscUJBQVNELFNBQVQsRUFBb0JFLGtCQUFwQjs7QUFHQTs7O0FBR0FGLFVBQVVyc0MsU0FBVixDQUFvQndzQyxXQUFwQixHQUFrQyxVQUFTQyxTQUFULEVBQW9CO0FBQ3BELFNBQU8sS0FBS0MsY0FBTCxFQUFQLEVBQThCO0FBQzVCLFFBQU0zaEQsT0FBTyxLQUFLNGhELFFBQUwsRUFBYjtBQUNBLFFBQU1DLE9BQU83aEQsS0FBS2k5QyxTQUFMLENBQWUsQ0FBZixFQUFrQmhoRCxRQUFsQixFQUFiO0FBQ0EsUUFBSTRsRCxRQUFRSCxTQUFSLElBQXFCQSxVQUFVRyxJQUFWLEVBQWdCQyxRQUFoQixDQUF5QjloRCxLQUFLaTlDLFNBQTlCLENBQXpCLEVBQW1FO0FBQ2pFO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBSzloQyxHQUFMLEdBQVcwaEMsT0FBWDtBQUNEO0FBQ0Y7QUFDRixDQVZEOztBQWFBOzs7QUFHQXlFLFVBQVVyc0MsU0FBVixDQUFvQjhzQyxrQkFBcEIsR0FBeUMsWUFBVztBQUNsRCxNQUFJLEtBQUtDLFFBQUwsT0FBb0IsQ0FBeEIsRUFBMkI7QUFDekI7QUFDRDtBQUNELE1BQU1waUQsTUFBTSxLQUFLcWlELFlBQUwsRUFBWjtBQUNBLE1BQU1oRixZQUFZLHdCQUFRcjlDLEdBQVIsQ0FBbEI7QUFDQSxNQUFNbW9CLElBQUlrMUIsVUFBVSxDQUFWLENBQVY7QUFDQSxPQUFLaGhDLE9BQUwsQ0FBYSxVQUFTamMsSUFBVCxFQUFlO0FBQzFCLFFBQUlBLEtBQUtpOUMsU0FBTCxDQUFlLENBQWYsTUFBc0JsMUIsQ0FBMUIsRUFBNkI7QUFDM0IsV0FBS202QixNQUFMLENBQVksdUJBQU9saUQsS0FBS2k5QyxTQUFaLENBQVo7QUFDQWo5QyxXQUFLNjhDLE9BQUw7QUFDRDtBQUNGLEdBTEQsRUFLRyxJQUxIO0FBTUQsQ0FiRDtrQkFjZXlFLFM7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDUkNhLGMsR0FBQUEsYztBQS9DaEI7OztBQUdBOzs7Ozs7Ozs7OztBQVdBLElBQU1DLFlBQVksU0FBWkEsU0FBWSxDQUFTQyxJQUFULEVBQWVDLElBQWYsRUFBcUJDLElBQXJCLEVBQTJCQyxJQUEzQixFQUFpQzs7QUFFakQ7OztBQUdBLE9BQUtILElBQUwsR0FBWUEsSUFBWjs7QUFFQTs7O0FBR0EsT0FBS0MsSUFBTCxHQUFZQSxJQUFaOztBQUVBOzs7QUFHQSxPQUFLQyxJQUFMLEdBQVlBLElBQVo7O0FBRUE7OztBQUdBLE9BQUtDLElBQUwsR0FBWUEsSUFBWjtBQUVELENBdEJEOztBQXlCQTs7Ozs7Ozs7QUFRTyxTQUFTTCxjQUFULENBQXdCRSxJQUF4QixFQUE4QkMsSUFBOUIsRUFBb0NDLElBQXBDLEVBQTBDQyxJQUExQyxFQUFnREMsU0FBaEQsRUFBMkQ7QUFDaEUsTUFBSUEsY0FBY2xvRCxTQUFsQixFQUE2QjtBQUMzQmtvRCxjQUFVSixJQUFWLEdBQWlCQSxJQUFqQjtBQUNBSSxjQUFVSCxJQUFWLEdBQWlCQSxJQUFqQjtBQUNBRyxjQUFVRixJQUFWLEdBQWlCQSxJQUFqQjtBQUNBRSxjQUFVRCxJQUFWLEdBQWlCQSxJQUFqQjtBQUNBLFdBQU9DLFNBQVA7QUFDRCxHQU5ELE1BTU87QUFDTCxXQUFPLElBQUlMLFNBQUosQ0FBY0MsSUFBZCxFQUFvQkMsSUFBcEIsRUFBMEJDLElBQTFCLEVBQWdDQyxJQUFoQyxDQUFQO0FBQ0Q7QUFDRjs7QUFHRDs7OztBQUlBSixVQUFVbnRDLFNBQVYsQ0FBb0I2c0MsUUFBcEIsR0FBK0IsVUFBUzdFLFNBQVQsRUFBb0I7QUFDakQsU0FBTyxLQUFLeUYsVUFBTCxDQUFnQnpGLFVBQVUsQ0FBVixDQUFoQixFQUE4QkEsVUFBVSxDQUFWLENBQTlCLENBQVA7QUFDRCxDQUZEOztBQUtBOzs7O0FBSUFtRixVQUFVbnRDLFNBQVYsQ0FBb0IwdEMsaUJBQXBCLEdBQXdDLFVBQVNGLFNBQVQsRUFBb0I7QUFDMUQsU0FBTyxLQUFLSixJQUFMLElBQWFJLFVBQVVKLElBQXZCLElBQStCSSxVQUFVSCxJQUFWLElBQWtCLEtBQUtBLElBQXRELElBQ0gsS0FBS0MsSUFBTCxJQUFhRSxVQUFVRixJQURwQixJQUM0QkUsVUFBVUQsSUFBVixJQUFrQixLQUFLQSxJQUQxRDtBQUVELENBSEQ7O0FBTUE7Ozs7O0FBS0FKLFVBQVVudEMsU0FBVixDQUFvQnl0QyxVQUFwQixHQUFpQyxVQUFTanRDLENBQVQsRUFBWWdRLENBQVosRUFBZTtBQUM5QyxTQUFPLEtBQUs0OEIsSUFBTCxJQUFhNXNDLENBQWIsSUFBa0JBLEtBQUssS0FBSzZzQyxJQUE1QixJQUFvQyxLQUFLQyxJQUFMLElBQWE5OEIsQ0FBakQsSUFBc0RBLEtBQUssS0FBSys4QixJQUF2RTtBQUNELENBRkQ7O0FBS0E7Ozs7QUFJQUosVUFBVW50QyxTQUFWLENBQW9CaS9CLE1BQXBCLEdBQTZCLFVBQVN1TyxTQUFULEVBQW9CO0FBQy9DLFNBQU8sS0FBS0osSUFBTCxJQUFhSSxVQUFVSixJQUF2QixJQUErQixLQUFLRSxJQUFMLElBQWFFLFVBQVVGLElBQXRELElBQ0gsS0FBS0QsSUFBTCxJQUFhRyxVQUFVSCxJQURwQixJQUM0QixLQUFLRSxJQUFMLElBQWFDLFVBQVVELElBRDFEO0FBRUQsQ0FIRDs7QUFNQTs7O0FBR0FKLFVBQVVudEMsU0FBVixDQUFvQm9JLE1BQXBCLEdBQTZCLFVBQVNvbEMsU0FBVCxFQUFvQjtBQUMvQyxNQUFJQSxVQUFVSixJQUFWLEdBQWlCLEtBQUtBLElBQTFCLEVBQWdDO0FBQzlCLFNBQUtBLElBQUwsR0FBWUksVUFBVUosSUFBdEI7QUFDRDtBQUNELE1BQUlJLFVBQVVILElBQVYsR0FBaUIsS0FBS0EsSUFBMUIsRUFBZ0M7QUFDOUIsU0FBS0EsSUFBTCxHQUFZRyxVQUFVSCxJQUF0QjtBQUNEO0FBQ0QsTUFBSUcsVUFBVUYsSUFBVixHQUFpQixLQUFLQSxJQUExQixFQUFnQztBQUM5QixTQUFLQSxJQUFMLEdBQVlFLFVBQVVGLElBQXRCO0FBQ0Q7QUFDRCxNQUFJRSxVQUFVRCxJQUFWLEdBQWlCLEtBQUtBLElBQTFCLEVBQWdDO0FBQzlCLFNBQUtBLElBQUwsR0FBWUMsVUFBVUQsSUFBdEI7QUFDRDtBQUNGLENBYkQ7O0FBZ0JBOzs7QUFHQUosVUFBVW50QyxTQUFWLENBQW9CMnRDLFNBQXBCLEdBQWdDLFlBQVc7QUFDekMsU0FBTyxLQUFLSixJQUFMLEdBQVksS0FBS0QsSUFBakIsR0FBd0IsQ0FBL0I7QUFDRCxDQUZEOztBQUtBOzs7QUFHQUgsVUFBVW50QyxTQUFWLENBQW9CeFgsT0FBcEIsR0FBOEIsWUFBVztBQUN2QyxTQUFPLENBQUMsS0FBS29sRCxRQUFMLEVBQUQsRUFBa0IsS0FBS0QsU0FBTCxFQUFsQixDQUFQO0FBQ0QsQ0FGRDs7QUFLQTs7O0FBR0FSLFVBQVVudEMsU0FBVixDQUFvQjR0QyxRQUFwQixHQUErQixZQUFXO0FBQ3hDLFNBQU8sS0FBS1AsSUFBTCxHQUFZLEtBQUtELElBQWpCLEdBQXdCLENBQS9CO0FBQ0QsQ0FGRDs7QUFLQTs7OztBQUlBRCxVQUFVbnRDLFNBQVYsQ0FBb0I2dEMsVUFBcEIsR0FBaUMsVUFBU0wsU0FBVCxFQUFvQjtBQUNuRCxTQUFPLEtBQUtKLElBQUwsSUFBYUksVUFBVUgsSUFBdkIsSUFDSCxLQUFLQSxJQUFMLElBQWFHLFVBQVVKLElBRHBCLElBRUgsS0FBS0UsSUFBTCxJQUFhRSxVQUFVRCxJQUZwQixJQUdILEtBQUtBLElBQUwsSUFBYUMsVUFBVUYsSUFIM0I7QUFJRCxDQUxEO2tCQU1lSCxTOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hKZjs7OztBQUlBOzs7a0JBR2U7QUFDYnpELFFBQU0sQ0FETztBQUViZixXQUFTLENBRkk7QUFHYlksVUFBUSxDQUhLO0FBSWJKLFNBQU8sQ0FKTTtBQUtiSyxTQUFPLENBTE07QUFNYlQsU0FBTztBQU5NLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDT0M1b0IsWSxHQUFBQSxZO1FBa0NBMnRCLHlCLEdBQUFBLHlCO1FBV0E3TixRLEdBQUFBLFE7UUFhQThOLGlCLEdBQUFBLGlCO1FBMkNBQyxlLEdBQUFBLGU7UUFnQkE1bEMsTSxHQUFBQSxNO1FBZUE2a0MsTSxHQUFBQSxNO1FBZ0JBZ0IsSSxHQUFBQSxJO1FBbUJBaFAsTSxHQUFBQSxNO1FBa0JBaVAsVSxHQUFBQSxVO1FBcUJBQyxTLEdBQUFBLFM7UUFnQkFDLFEsR0FBQUEsUTtBQTVPaEI7Ozs7QUFLQTs7Ozs7Ozs7O0FBU08sU0FBU2p1QixZQUFULENBQXNCdEQsUUFBdEIsRUFBZ0NELE1BQWhDLEVBQXdDeXhCLGNBQXhDLEVBQXdEO0FBQzdELE1BQUlDLFlBQUo7QUFBQSxNQUFTQyxZQUFUO0FBQ0EsTUFBTUMsYUFBYUgsa0JBQWtCUCx5QkFBckM7QUFDQSxNQUFJVyxNQUFNLENBQVY7QUFDQSxNQUFJQyxPQUFPN3hCLFNBQVNsN0IsTUFBcEI7QUFDQSxNQUFJcStDLFFBQVEsS0FBWjs7QUFFQSxTQUFPeU8sTUFBTUMsSUFBYixFQUFtQjtBQUNqQjs7QUFFQUosVUFBTUcsT0FBT0MsT0FBT0QsR0FBUCxJQUFjLENBQXJCLENBQU47QUFDQUYsVUFBTSxDQUFDQyxXQUFXM3hCLFNBQVN5eEIsR0FBVCxDQUFYLEVBQTBCMXhCLE1BQTFCLENBQVA7O0FBRUEsUUFBSTJ4QixNQUFNLEdBQVYsRUFBZTtBQUFFO0FBQ2ZFLFlBQU9ILE1BQU0sQ0FBYjtBQUVELEtBSEQsTUFHTztBQUFFO0FBQ1BJLGFBQU9KLEdBQVA7QUFDQXRPLGNBQVEsQ0FBQ3VPLEdBQVQ7QUFDRDtBQUNGOztBQUVEO0FBQ0EsU0FBT3ZPLFFBQVF5TyxHQUFSLEdBQWMsQ0FBQ0EsR0FBdEI7QUFDRDs7QUFHRDs7Ozs7OztBQU9PLFNBQVNYLHlCQUFULENBQW1DdmhELENBQW5DLEVBQXNDZ2YsQ0FBdEMsRUFBeUM7QUFDOUMsU0FBT2hmLElBQUlnZixDQUFKLEdBQVEsQ0FBUixHQUFZaGYsSUFBSWdmLENBQUosR0FBUSxDQUFDLENBQVQsR0FBYSxDQUFoQztBQUNEOztBQUdEOzs7Ozs7QUFNTyxTQUFTMDBCLFFBQVQsQ0FBa0IxRSxHQUFsQixFQUF1Qi9oQyxHQUF2QixFQUE0QjtBQUNqQyxTQUFPK2hDLElBQUlsNUMsT0FBSixDQUFZbVgsR0FBWixLQUFvQixDQUEzQjtBQUNEOztBQUdEOzs7Ozs7OztBQVFPLFNBQVN1MEMsaUJBQVQsQ0FBMkJ4UyxHQUEzQixFQUFnQ2p2QyxNQUFoQyxFQUF3Q3FpRCxTQUF4QyxFQUFtRDtBQUN4RCxNQUFNendDLElBQUlxOUIsSUFBSTU1QyxNQUFkO0FBQ0EsTUFBSTQ1QyxJQUFJLENBQUosS0FBVWp2QyxNQUFkLEVBQXNCO0FBQ3BCLFdBQU8sQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJQSxVQUFVaXZDLElBQUlyOUIsSUFBSSxDQUFSLENBQWQsRUFBMEI7QUFDL0IsV0FBT0EsSUFBSSxDQUFYO0FBQ0QsR0FGTSxNQUVBO0FBQ0wsUUFBSTVjLFVBQUo7QUFDQSxRQUFJcXRELFlBQVksQ0FBaEIsRUFBbUI7QUFDakIsV0FBS3J0RCxJQUFJLENBQVQsRUFBWUEsSUFBSTRjLENBQWhCLEVBQW1CLEVBQUU1YyxDQUFyQixFQUF3QjtBQUN0QixZQUFJaTZDLElBQUlqNkMsQ0FBSixJQUFTZ0wsTUFBYixFQUFxQjtBQUNuQixpQkFBT2hMLElBQUksQ0FBWDtBQUNEO0FBQ0Y7QUFDRixLQU5ELE1BTU8sSUFBSXF0RCxZQUFZLENBQWhCLEVBQW1CO0FBQ3hCLFdBQUtydEQsSUFBSSxDQUFULEVBQVlBLElBQUk0YyxDQUFoQixFQUFtQixFQUFFNWMsQ0FBckIsRUFBd0I7QUFDdEIsWUFBSWk2QyxJQUFJajZDLENBQUosS0FBVWdMLE1BQWQsRUFBc0I7QUFDcEIsaUJBQU9oTCxDQUFQO0FBQ0Q7QUFDRjtBQUNGLEtBTk0sTUFNQTtBQUNMLFdBQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJNGMsQ0FBaEIsRUFBbUIsRUFBRTVjLENBQXJCLEVBQXdCO0FBQ3RCLFlBQUlpNkMsSUFBSWo2QyxDQUFKLEtBQVVnTCxNQUFkLEVBQXNCO0FBQ3BCLGlCQUFPaEwsQ0FBUDtBQUNELFNBRkQsTUFFTyxJQUFJaTZDLElBQUlqNkMsQ0FBSixJQUFTZ0wsTUFBYixFQUFxQjtBQUMxQixjQUFJaXZDLElBQUlqNkMsSUFBSSxDQUFSLElBQWFnTCxNQUFiLEdBQXNCQSxTQUFTaXZDLElBQUlqNkMsQ0FBSixDQUFuQyxFQUEyQztBQUN6QyxtQkFBT0EsSUFBSSxDQUFYO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsbUJBQU9BLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNELFdBQU80YyxJQUFJLENBQVg7QUFDRDtBQUNGOztBQUdEOzs7OztBQUtPLFNBQVM4dkMsZUFBVCxDQUF5QnpTLEdBQXpCLEVBQThCekQsS0FBOUIsRUFBcUNuK0IsR0FBckMsRUFBMEM7QUFDL0MsU0FBT20rQixRQUFRbitCLEdBQWYsRUFBb0I7QUFDbEIsUUFBTTJoQyxNQUFNQyxJQUFJekQsS0FBSixDQUFaO0FBQ0F5RCxRQUFJekQsS0FBSixJQUFheUQsSUFBSTVoQyxHQUFKLENBQWI7QUFDQTRoQyxRQUFJNWhDLEdBQUosSUFBVzJoQyxHQUFYO0FBQ0EsTUFBRXhELEtBQUY7QUFDQSxNQUFFbitCLEdBQUY7QUFDRDtBQUNGOztBQUdEOzs7OztBQUtPLFNBQVN5TyxNQUFULENBQWdCbXpCLEdBQWhCLEVBQXFCenZDLElBQXJCLEVBQTJCO0FBQ2hDLE1BQU1ySSxZQUFZakMsTUFBTUMsT0FBTixDQUFjcUssSUFBZCxJQUFzQkEsSUFBdEIsR0FBNkIsQ0FBQ0EsSUFBRCxDQUEvQztBQUNBLE1BQU1uSyxTQUFTOEIsVUFBVTlCLE1BQXpCO0FBQ0EsT0FBSyxJQUFJTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCTCxHQUE1QixFQUFpQztBQUMvQmk2QyxRQUFJQSxJQUFJNTVDLE1BQVIsSUFBa0I4QixVQUFVbkMsQ0FBVixDQUFsQjtBQUNEO0FBQ0Y7O0FBR0Q7Ozs7OztBQU1PLFNBQVMyckQsTUFBVCxDQUFnQjFSLEdBQWhCLEVBQXFCL2hDLEdBQXJCLEVBQTBCO0FBQy9CLE1BQU1sWSxJQUFJaTZDLElBQUlsNUMsT0FBSixDQUFZbVgsR0FBWixDQUFWO0FBQ0EsTUFBTXdtQyxRQUFRMStDLElBQUksQ0FBQyxDQUFuQjtBQUNBLE1BQUkwK0MsS0FBSixFQUFXO0FBQ1R6RSxRQUFJNThCLE1BQUosQ0FBV3JkLENBQVgsRUFBYyxDQUFkO0FBQ0Q7QUFDRCxTQUFPMCtDLEtBQVA7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU2lPLElBQVQsQ0FBYzFTLEdBQWQsRUFBbUJxVCxJQUFuQixFQUF5QjtBQUM5QixNQUFNanRELFNBQVM0NUMsSUFBSTU1QyxNQUFKLEtBQWUsQ0FBOUI7QUFDQSxNQUFJNkwsY0FBSjs7QUFFQSxPQUFLLElBQUlsTSxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCTCxHQUE1QixFQUFpQztBQUMvQmtNLFlBQVErdEMsSUFBSWo2QyxDQUFKLENBQVI7QUFDQSxRQUFJc3RELEtBQUtwaEQsS0FBTCxFQUFZbE0sQ0FBWixFQUFlaTZDLEdBQWYsQ0FBSixFQUF5QjtBQUN2QixhQUFPL3RDLEtBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBR0Q7Ozs7O0FBS08sU0FBU3l4QyxNQUFULENBQWdCNFAsSUFBaEIsRUFBc0JDLElBQXRCLEVBQTRCO0FBQ2pDLE1BQU1DLE9BQU9GLEtBQUtsdEQsTUFBbEI7QUFDQSxNQUFJb3RELFNBQVNELEtBQUtudEQsTUFBbEIsRUFBMEI7QUFDeEIsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxPQUFLLElBQUlMLElBQUksQ0FBYixFQUFnQkEsSUFBSXl0RCxJQUFwQixFQUEwQnp0RCxHQUExQixFQUErQjtBQUM3QixRQUFJdXRELEtBQUt2dEQsQ0FBTCxNQUFZd3RELEtBQUt4dEQsQ0FBTCxDQUFoQixFQUF5QjtBQUN2QixhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBR0Q7Ozs7QUFJTyxTQUFTNHNELFVBQVQsQ0FBb0IzUyxHQUFwQixFQUF5QnlULFVBQXpCLEVBQXFDO0FBQzFDLE1BQU1ydEQsU0FBUzQ1QyxJQUFJNTVDLE1BQW5CO0FBQ0EsTUFBTTI1QyxNQUFNOTVDLE1BQU0rNUMsSUFBSTU1QyxNQUFWLENBQVo7QUFDQSxNQUFJTCxVQUFKO0FBQ0EsT0FBS0EsSUFBSSxDQUFULEVBQVlBLElBQUlLLE1BQWhCLEVBQXdCTCxHQUF4QixFQUE2QjtBQUMzQmc2QyxRQUFJaDZDLENBQUosSUFBUyxFQUFDc1ksT0FBT3RZLENBQVIsRUFBV2tNLE9BQU8rdEMsSUFBSWo2QyxDQUFKLENBQWxCLEVBQVQ7QUFDRDtBQUNEZzZDLE1BQUlqZSxJQUFKLENBQVMsVUFBUzl3QixDQUFULEVBQVlnZixDQUFaLEVBQWU7QUFDdEIsV0FBT3lqQyxXQUFXemlELEVBQUVpQixLQUFiLEVBQW9CK2QsRUFBRS9kLEtBQXRCLEtBQWdDakIsRUFBRXFOLEtBQUYsR0FBVTJSLEVBQUUzUixLQUFuRDtBQUNELEdBRkQ7QUFHQSxPQUFLdFksSUFBSSxDQUFULEVBQVlBLElBQUlpNkMsSUFBSTU1QyxNQUFwQixFQUE0QkwsR0FBNUIsRUFBaUM7QUFDL0JpNkMsUUFBSWo2QyxDQUFKLElBQVNnNkMsSUFBSWg2QyxDQUFKLEVBQU9rTSxLQUFoQjtBQUNEO0FBQ0Y7O0FBR0Q7Ozs7O0FBS08sU0FBUzJnRCxTQUFULENBQW1CNVMsR0FBbkIsRUFBd0JxVCxJQUF4QixFQUE4QjtBQUNuQyxNQUFJaDFDLGNBQUo7QUFDQSxNQUFNb21DLFFBQVEsQ0FBQ3pFLElBQUlqdEIsS0FBSixDQUFVLFVBQVMyZ0MsRUFBVCxFQUFheHVDLEdBQWIsRUFBa0I7QUFDekM3RyxZQUFRNkcsR0FBUjtBQUNBLFdBQU8sQ0FBQ211QyxLQUFLSyxFQUFMLEVBQVN4dUMsR0FBVCxFQUFjODZCLEdBQWQsQ0FBUjtBQUNELEdBSGMsQ0FBZjtBQUlBLFNBQU95RSxRQUFRcG1DLEtBQVIsR0FBZ0IsQ0FBQyxDQUF4QjtBQUNEOztBQUdEOzs7Ozs7QUFNTyxTQUFTdzBDLFFBQVQsQ0FBa0I3UyxHQUFsQixFQUF1QjJULFFBQXZCLEVBQWlDQyxVQUFqQyxFQUE2QztBQUNsRCxNQUFNNWlDLFVBQVUyaUMsWUFBWXBCLHlCQUE1QjtBQUNBLFNBQU92UyxJQUFJanRCLEtBQUosQ0FBVSxVQUFTOGdDLFVBQVQsRUFBcUJ4MUMsS0FBckIsRUFBNEI7QUFDM0MsUUFBSUEsVUFBVSxDQUFkLEVBQWlCO0FBQ2YsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxRQUFNa25DLE1BQU12MEIsUUFBUWd2QixJQUFJM2hDLFFBQVEsQ0FBWixDQUFSLEVBQXdCdzFDLFVBQXhCLENBQVo7QUFDQSxXQUFPLEVBQUV0TyxNQUFNLENBQU4sSUFBV3FPLGNBQWNyTyxRQUFRLENBQW5DLENBQVA7QUFDRCxHQU5NLENBQVA7QUFPRCxDOzs7Ozs7Ozs7Ozs7Ozs7OztRQzVPZXVPLE0sR0FBQUEsTTs7QUFOaEI7Ozs7OztBQUVBOzs7O0FBSU8sU0FBU0EsTUFBVCxDQUFnQkMsU0FBaEIsRUFBMkJDLFNBQTNCLEVBQXNDO0FBQzNDLE1BQUksQ0FBQ0QsU0FBTCxFQUFnQjtBQUNkLFVBQU0sSUFBSTlILHdCQUFKLENBQW1CK0gsU0FBbkIsQ0FBTjtBQUNEO0FBQ0YsQyxDQWJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDV2dCQyxxQixHQUFBQSxxQjtRQW1CQUMsVSxHQUFBQSxVO1FBZ0JBQyxXLEdBQUFBLFc7UUFZQUMsVyxHQUFBQSxXO1FBV0FDLFUsR0FBQUEsVTtRQU9BQyxjLEdBQUFBLGM7QUE1RWhCOzs7O0FBS0E7Ozs7OztBQU1PLFNBQVNMLHFCQUFULENBQStCTSxTQUEvQixFQUEwQ0MsVUFBMUMsRUFBc0Q7QUFDM0QsTUFBTS9GLFNBQVMsZ0NBQWtDeG5ELFNBQVNHLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBakQ7QUFDQSxNQUFJbXRELFNBQUosRUFBZTtBQUNiOUYsV0FBT3YzQyxLQUFQLEdBQWVxOUMsU0FBZjtBQUNEO0FBQ0QsTUFBSUMsVUFBSixFQUFnQjtBQUNkL0YsV0FBT3QzQyxNQUFQLEdBQWdCcTlDLFVBQWhCO0FBQ0Q7QUFDRCxTQUFPLHdDQUF5Qy9GLE9BQU9nRyxVQUFQLENBQWtCLElBQWxCO0FBQWhEO0FBQ0Q7O0FBR0Q7Ozs7Ozs7QUFPTyxTQUFTUCxVQUFULENBQW9CanBELE9BQXBCLEVBQTZCO0FBQ2xDLE1BQUlpTSxRQUFRak0sUUFBUXlwRCxXQUFwQjtBQUNBLE1BQU1ycUQsUUFBUXNxRCxpQkFBaUIxcEQsT0FBakIsQ0FBZDtBQUNBaU0sV0FBU2dZLFNBQVM3a0IsTUFBTXVxRCxVQUFmLEVBQTJCLEVBQTNCLElBQWlDMWxDLFNBQVM3a0IsTUFBTXdxRCxXQUFmLEVBQTRCLEVBQTVCLENBQTFDOztBQUVBLFNBQU8zOUMsS0FBUDtBQUNEOztBQUdEOzs7Ozs7O0FBT08sU0FBU2k5QyxXQUFULENBQXFCbHBELE9BQXJCLEVBQThCO0FBQ25DLE1BQUlrTSxTQUFTbE0sUUFBUTZwRCxZQUFyQjtBQUNBLE1BQU16cUQsUUFBUXNxRCxpQkFBaUIxcEQsT0FBakIsQ0FBZDtBQUNBa00sWUFBVStYLFNBQVM3a0IsTUFBTTBxRCxTQUFmLEVBQTBCLEVBQTFCLElBQWdDN2xDLFNBQVM3a0IsTUFBTTJxRCxZQUFmLEVBQTZCLEVBQTdCLENBQTFDOztBQUVBLFNBQU83OUMsTUFBUDtBQUNEOztBQUVEOzs7O0FBSU8sU0FBU2k5QyxXQUFULENBQXFCYSxPQUFyQixFQUE4QkMsT0FBOUIsRUFBdUM7QUFDNUMsTUFBTWhvQyxTQUFTZ29DLFFBQVFDLFVBQXZCO0FBQ0EsTUFBSWpvQyxNQUFKLEVBQVk7QUFDVkEsV0FBT2tvQyxZQUFQLENBQW9CSCxPQUFwQixFQUE2QkMsT0FBN0I7QUFDRDtBQUNGOztBQUVEOzs7O0FBSU8sU0FBU2IsVUFBVCxDQUFvQmdCLElBQXBCLEVBQTBCO0FBQy9CLFNBQU9BLFFBQVFBLEtBQUtGLFVBQWIsR0FBMEJFLEtBQUtGLFVBQUwsQ0FBZ0JHLFdBQWhCLENBQTRCRCxJQUE1QixDQUExQixHQUE4RCxJQUFyRTtBQUNEOztBQUVEOzs7QUFHTyxTQUFTZixjQUFULENBQXdCZSxJQUF4QixFQUE4QjtBQUNuQyxTQUFPQSxLQUFLRSxTQUFaLEVBQXVCO0FBQ3JCRixTQUFLQyxXQUFMLENBQWlCRCxLQUFLRSxTQUF0QjtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNyRWVDLE0sR0FBQUEsTTtRQVdBQyxPLEdBQUFBLE87UUFXQUMsUSxHQUFBQSxRO1FBV0FwNUMsTSxHQUFBQSxNO1FBYUFxNUMsUyxHQUFBQSxTO0FBekRoQjs7OztBQUtBOzs7Ozs7QUFNTyxTQUFTSCxNQUFULENBQWdCdnlDLENBQWhCLEVBQW1CO0FBQ3hCLFNBQU9sQyxLQUFLdVcsR0FBTCxDQUFTclUsQ0FBVCxFQUFZLENBQVosQ0FBUDtBQUNEOztBQUdEOzs7Ozs7QUFNTyxTQUFTd3lDLE9BQVQsQ0FBaUJ4eUMsQ0FBakIsRUFBb0I7QUFDekIsU0FBTyxJQUFJdXlDLE9BQU8sSUFBSXZ5QyxDQUFYLENBQVg7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU3l5QyxRQUFULENBQWtCenlDLENBQWxCLEVBQXFCO0FBQzFCLFNBQU8sSUFBSUEsQ0FBSixHQUFRQSxDQUFSLEdBQVksSUFBSUEsQ0FBSixHQUFRQSxDQUFSLEdBQVlBLENBQS9CO0FBQ0Q7O0FBR0Q7Ozs7OztBQU1PLFNBQVMzRyxNQUFULENBQWdCMkcsQ0FBaEIsRUFBbUI7QUFDeEIsU0FBT0EsQ0FBUDtBQUNEOztBQUdEOzs7Ozs7OztBQVFPLFNBQVMweUMsU0FBVCxDQUFtQjF5QyxDQUFuQixFQUFzQjtBQUMzQixNQUFJQSxJQUFJLEdBQVIsRUFBYTtBQUNYLFdBQU95eUMsU0FBUyxJQUFJenlDLENBQWIsQ0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8sSUFBSXl5QyxTQUFTLEtBQUt6eUMsSUFBSSxHQUFULENBQVQsQ0FBWDtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUM5QmUyeUMsWSxHQUFBQSxZO1FBeUJBQyxZLEdBQUFBLFk7UUFxQkFDLFksR0FBQUEsWTtRQStEQUMsTSxHQUFBQSxNO1FBZ0RBQyxVLEdBQUFBLFU7UUFrQkFDLFEsR0FBQUEsUTtRQW9CQTNILGEsR0FBQUEsYTtRQXdCQTRILFcsR0FBQUEsVzs7QUF6UGhCOztBQUdBOzs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7O0FBU0E7Ozs7QUFJTyxTQUFTTixZQUFULENBQXNCTyxXQUF0QixFQUFtQztBQUN4QyxNQUFNQyxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQVNDLEdBQVQsRUFBYztBQUNsQyxRQUFNbkcsV0FBV2lHLFlBQVlqRyxRQUE3QjtBQUNBLFFBQU1vRyxTQUFTSCxZQUFZRyxNQUFaLElBQXNCSCxZQUFZcGxELE1BQWpEO0FBQ0EsUUFBSW9sRCxZQUFZSSxRQUFoQixFQUEwQjtBQUN4QmpJLG9CQUFjNkgsV0FBZDtBQUNEO0FBQ0QsV0FBT2pHLFNBQVN4ckMsSUFBVCxDQUFjNHhDLE1BQWQsRUFBc0JELEdBQXRCLENBQVA7QUFDRCxHQVBEO0FBUUFGLGNBQVlDLGFBQVosR0FBNEJBLGFBQTVCO0FBQ0EsU0FBT0EsYUFBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7OztBQS9DQTs7O0FBMERPLFNBQVNQLFlBQVQsQ0FBc0JXLFNBQXRCLEVBQWlDdEcsUUFBakMsRUFBMkN1RyxRQUEzQyxFQUFxREMsa0JBQXJELEVBQXlFO0FBQzlFLE1BQUlQLG9CQUFKO0FBQ0EsT0FBSyxJQUFJcHdELElBQUksQ0FBUixFQUFXQyxLQUFLd3dELFVBQVVwd0QsTUFBL0IsRUFBdUNMLElBQUlDLEVBQTNDLEVBQStDLEVBQUVELENBQWpELEVBQW9EO0FBQ2xEb3dELGtCQUFjSyxVQUFVendELENBQVYsQ0FBZDtBQUNBLFFBQUlvd0QsWUFBWWpHLFFBQVosS0FBeUJBLFFBQXpCLElBQ0FpRyxZQUFZRyxNQUFaLEtBQXVCRyxRQUQzQixFQUNxQztBQUNuQyxVQUFJQyxrQkFBSixFQUF3QjtBQUN0QlAsb0JBQVlRLFdBQVosR0FBMEI1d0QsQ0FBMUI7QUFDRDtBQUNELGFBQU9vd0QsV0FBUDtBQUNEO0FBQ0Y7QUFDRCxTQUFPcHNELFNBQVA7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTK3JELFlBQVQsQ0FBc0Iva0QsTUFBdEIsRUFBOEJoRyxJQUE5QixFQUFvQztBQUN6QyxNQUFNNnJELGNBQWM3bEQsT0FBTzhsRCxLQUEzQjtBQUNBLFNBQU9ELGNBQWNBLFlBQVk3ckQsSUFBWixDQUFkLEdBQWtDaEIsU0FBekM7QUFDRDs7QUFHRDs7Ozs7OztBQU9BLFNBQVMrc0QsY0FBVCxDQUF3Qi9sRCxNQUF4QixFQUFnQztBQUM5QixNQUFJNmxELGNBQWM3bEQsT0FBTzhsRCxLQUF6QjtBQUNBLE1BQUksQ0FBQ0QsV0FBTCxFQUFrQjtBQUNoQkEsa0JBQWM3bEQsT0FBTzhsRCxLQUFQLEdBQWUsRUFBN0I7QUFDRDtBQUNELFNBQU9ELFdBQVA7QUFDRDs7QUFHRDs7Ozs7OztBQU9BLFNBQVNHLGVBQVQsQ0FBeUJobUQsTUFBekIsRUFBaUNoRyxJQUFqQyxFQUF1QztBQUNyQyxNQUFNeXJELFlBQVlWLGFBQWEva0QsTUFBYixFQUFxQmhHLElBQXJCLENBQWxCO0FBQ0EsTUFBSXlyRCxTQUFKLEVBQWU7QUFDYixTQUFLLElBQUl6d0QsSUFBSSxDQUFSLEVBQVdDLEtBQUt3d0QsVUFBVXB3RCxNQUEvQixFQUF1Q0wsSUFBSUMsRUFBM0MsRUFBK0MsRUFBRUQsQ0FBakQsRUFBb0Q7QUFDbERnTCxhQUFPaW1ELG1CQUFQLENBQTJCanNELElBQTNCLEVBQWlDeXJELFVBQVV6d0QsQ0FBVixFQUFhcXdELGFBQTlDO0FBQ0Esc0JBQU1JLFVBQVV6d0QsQ0FBVixDQUFOO0FBQ0Q7QUFDRHl3RCxjQUFVcHdELE1BQVYsR0FBbUIsQ0FBbkI7QUFDQSxRQUFNd3dELGNBQWM3bEQsT0FBTzhsRCxLQUEzQjtBQUNBLFFBQUlELFdBQUosRUFBaUI7QUFDZixhQUFPQSxZQUFZN3JELElBQVosQ0FBUDtBQUNBLFVBQUkrVCxPQUFPTixJQUFQLENBQVlvNEMsV0FBWixFQUF5Qnh3RCxNQUF6QixLQUFvQyxDQUF4QyxFQUEyQztBQUN6QyxlQUFPMkssT0FBTzhsRCxLQUFkO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBR0Q7Ozs7Ozs7Ozs7Ozs7OztBQWVPLFNBQVNkLE1BQVQsQ0FBZ0JobEQsTUFBaEIsRUFBd0JoRyxJQUF4QixFQUE4Qm1sRCxRQUE5QixFQUF3Q3VHLFFBQXhDLEVBQWtEUSxRQUFsRCxFQUE0RDtBQUNqRSxNQUFNTCxjQUFjRSxlQUFlL2xELE1BQWYsQ0FBcEI7QUFDQSxNQUFJeWxELFlBQVlJLFlBQVk3ckQsSUFBWixDQUFoQjtBQUNBLE1BQUksQ0FBQ3lyRCxTQUFMLEVBQWdCO0FBQ2RBLGdCQUFZSSxZQUFZN3JELElBQVosSUFBb0IsRUFBaEM7QUFDRDtBQUNELE1BQUlvckQsY0FBY04sYUFBYVcsU0FBYixFQUF3QnRHLFFBQXhCLEVBQWtDdUcsUUFBbEMsRUFBNEMsS0FBNUMsQ0FBbEI7QUFDQSxNQUFJTixXQUFKLEVBQWlCO0FBQ2YsUUFBSSxDQUFDYyxRQUFMLEVBQWU7QUFDYjtBQUNBZCxrQkFBWUksUUFBWixHQUF1QixLQUF2QjtBQUNEO0FBQ0YsR0FMRCxNQUtPO0FBQ0xKLGtCQUFjLHlDQUEyQztBQUN2REcsY0FBUUcsUUFEK0M7QUFFdkRGLGdCQUFVLENBQUMsQ0FBQ1UsUUFGMkM7QUFHdkQvRyxnQkFBVUEsUUFINkM7QUFJdkRuL0MsY0FBUUEsTUFKK0M7QUFLdkRoRyxZQUFNQTtBQUxpRCxLQUF6RDtBQU9BZ0csV0FBT21tRCxnQkFBUCxDQUF3Qm5zRCxJQUF4QixFQUE4QjZxRCxhQUFhTyxXQUFiLENBQTlCO0FBQ0FLLGNBQVV6dkQsSUFBVixDQUFlb3ZELFdBQWY7QUFDRDs7QUFFRCxTQUFPQSxXQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JPLFNBQVNILFVBQVQsQ0FBb0JqbEQsTUFBcEIsRUFBNEJoRyxJQUE1QixFQUFrQ21sRCxRQUFsQyxFQUE0Q3VHLFFBQTVDLEVBQXNEO0FBQzNELFNBQU9WLE9BQU9obEQsTUFBUCxFQUFlaEcsSUFBZixFQUFxQm1sRCxRQUFyQixFQUErQnVHLFFBQS9CLEVBQXlDLElBQXpDLENBQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7Ozs7OztBQWFPLFNBQVNSLFFBQVQsQ0FBa0JsbEQsTUFBbEIsRUFBMEJoRyxJQUExQixFQUFnQ21sRCxRQUFoQyxFQUEwQ3VHLFFBQTFDLEVBQW9EO0FBQ3pELE1BQU1ELFlBQVlWLGFBQWEva0QsTUFBYixFQUFxQmhHLElBQXJCLENBQWxCO0FBQ0EsTUFBSXlyRCxTQUFKLEVBQWU7QUFDYixRQUFNTCxjQUFjTixhQUFhVyxTQUFiLEVBQXdCdEcsUUFBeEIsRUFBa0N1RyxRQUFsQyxFQUE0QyxJQUE1QyxDQUFwQjtBQUNBLFFBQUlOLFdBQUosRUFBaUI7QUFDZjdILG9CQUFjNkgsV0FBZDtBQUNEO0FBQ0Y7QUFDRjs7QUFHRDs7Ozs7Ozs7O0FBU08sU0FBUzdILGFBQVQsQ0FBdUJsL0MsR0FBdkIsRUFBNEI7QUFDakMsTUFBSUEsT0FBT0EsSUFBSTJCLE1BQWYsRUFBdUI7QUFDckIzQixRQUFJMkIsTUFBSixDQUFXaW1ELG1CQUFYLENBQStCNW5ELElBQUlyRSxJQUFuQyxFQUF5Q3FFLElBQUlnbkQsYUFBN0M7QUFDQSxRQUFNSSxZQUFZVixhQUFhMW1ELElBQUkyQixNQUFqQixFQUF5QjNCLElBQUlyRSxJQUE3QixDQUFsQjtBQUNBLFFBQUl5ckQsU0FBSixFQUFlO0FBQ2IsVUFBTXp3RCxJQUFJLGlCQUFpQnFKLEdBQWpCLEdBQXVCQSxJQUFJdW5ELFdBQTNCLEdBQXlDSCxVQUFVMXZELE9BQVYsQ0FBa0JzSSxHQUFsQixDQUFuRDtBQUNBLFVBQUlySixNQUFNLENBQUMsQ0FBWCxFQUFjO0FBQ1p5d0Qsa0JBQVVwekMsTUFBVixDQUFpQnJkLENBQWpCLEVBQW9CLENBQXBCO0FBQ0Q7QUFDRCxVQUFJeXdELFVBQVVwd0QsTUFBVixLQUFxQixDQUF6QixFQUE0QjtBQUMxQjJ3RCx3QkFBZ0IzbkQsSUFBSTJCLE1BQXBCLEVBQTRCM0IsSUFBSXJFLElBQWhDO0FBQ0Q7QUFDRjtBQUNELG9CQUFNcUUsR0FBTjtBQUNEO0FBQ0Y7O0FBR0Q7Ozs7OztBQU1PLFNBQVM4bUQsV0FBVCxDQUFxQm5sRCxNQUFyQixFQUE2QjtBQUNsQyxNQUFNNmxELGNBQWNFLGVBQWUvbEQsTUFBZixDQUFwQjtBQUNBLE9BQUssSUFBTWhHLElBQVgsSUFBbUI2ckQsV0FBbkIsRUFBZ0M7QUFDOUJHLG9CQUFnQmhtRCxNQUFoQixFQUF3QmhHLElBQXhCO0FBQ0Q7QUFDRixDOzs7Ozs7Ozs7Ozs7Ozs7OztRQ3JNZW9zRCxlLEdBQUFBLGU7UUFRQUMsYyxHQUFBQSxjO0FBcEVoQjs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7QUFhQSxJQUFNdkksUUFBUSxTQUFSQSxLQUFRLENBQVM5akQsSUFBVCxFQUFlOztBQUUzQjs7O0FBR0EsT0FBS3NzRCxrQkFBTDs7QUFFQTs7Ozs7QUFLQSxPQUFLdHNELElBQUwsR0FBWUEsSUFBWjs7QUFFQTs7Ozs7QUFLQSxPQUFLZ0csTUFBTCxHQUFjLElBQWQ7QUFFRCxDQXJCRDs7QUF3QkE7Ozs7O0FBS0E4OUMsTUFBTXBxQyxTQUFOLENBQWdCMnlDLGNBQWhCOztBQUVFOzs7OztBQUtBdkksTUFBTXBxQyxTQUFOLENBQWdCMHlDLGVBQWhCLEdBQWtDLFlBQVc7QUFDM0MsT0FBS0Usa0JBQUwsR0FBMEIsSUFBMUI7QUFDRCxDQVRIOztBQVlBOzs7QUFHTyxTQUFTRixlQUFULENBQXlCZCxHQUF6QixFQUE4QjtBQUNuQ0EsTUFBSWMsZUFBSjtBQUNEOztBQUdEOzs7QUFHTyxTQUFTQyxjQUFULENBQXdCZixHQUF4QixFQUE2QjtBQUNsQ0EsTUFBSWUsY0FBSjtBQUNEOztrQkFFY3ZJLEs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JFZjs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFHQTs7OztBQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsSUFBTWlCLGNBQWMsU0FBZEEsV0FBYyxHQUFXOztBQUU3QjNELHVCQUFXem5DLElBQVgsQ0FBZ0IsSUFBaEI7O0FBRUE7Ozs7QUFJQSxPQUFLNHlDLGdCQUFMLEdBQXdCLEVBQXhCOztBQUVBOzs7O0FBSUEsT0FBS0MsWUFBTCxHQUFvQixFQUFwQjs7QUFFQTs7OztBQUlBLE9BQUtDLFVBQUwsR0FBa0IsRUFBbEI7QUFFRCxDQXRCRCxDLENBakNBOzs7OztBQXlEQSxxQkFBUzFILFdBQVQsRUFBc0IzRCxvQkFBdEI7O0FBR0E7Ozs7QUFJQTJELFlBQVlyckMsU0FBWixDQUFzQnl5QyxnQkFBdEIsR0FBeUMsVUFBU25zRCxJQUFULEVBQWVtbEQsUUFBZixFQUF5QjtBQUNoRSxNQUFJc0csWUFBWSxLQUFLZ0IsVUFBTCxDQUFnQnpzRCxJQUFoQixDQUFoQjtBQUNBLE1BQUksQ0FBQ3lyRCxTQUFMLEVBQWdCO0FBQ2RBLGdCQUFZLEtBQUtnQixVQUFMLENBQWdCenNELElBQWhCLElBQXdCLEVBQXBDO0FBQ0Q7QUFDRCxNQUFJeXJELFVBQVUxdkQsT0FBVixDQUFrQm9wRCxRQUFsQixNQUFnQyxDQUFDLENBQXJDLEVBQXdDO0FBQ3RDc0csY0FBVXp2RCxJQUFWLENBQWVtcEQsUUFBZjtBQUNEO0FBQ0YsQ0FSRDs7QUFXQTs7Ozs7OztBQU9BSixZQUFZcnJDLFNBQVosQ0FBc0IrcUMsYUFBdEIsR0FBc0MsVUFBU2lJLEtBQVQsRUFBZ0I7QUFDcEQsTUFBTXBCLE1BQU0sT0FBT29CLEtBQVAsS0FBaUIsUUFBakIsR0FBNEIsSUFBSTVJLGVBQUosQ0FBVTRJLEtBQVYsQ0FBNUIsR0FBK0NBLEtBQTNEO0FBQ0EsTUFBTTFzRCxPQUFPc3JELElBQUl0ckQsSUFBakI7QUFDQXNyRCxNQUFJdGxELE1BQUosR0FBYSxJQUFiO0FBQ0EsTUFBTXlsRCxZQUFZLEtBQUtnQixVQUFMLENBQWdCenNELElBQWhCLENBQWxCO0FBQ0EsTUFBSTJzRCxrQkFBSjtBQUNBLE1BQUlsQixTQUFKLEVBQWU7QUFDYixRQUFJLEVBQUV6ckQsUUFBUSxLQUFLd3NELFlBQWYsQ0FBSixFQUFrQztBQUNoQyxXQUFLQSxZQUFMLENBQWtCeHNELElBQWxCLElBQTBCLENBQTFCO0FBQ0EsV0FBS3VzRCxnQkFBTCxDQUFzQnZzRCxJQUF0QixJQUE4QixDQUE5QjtBQUNEO0FBQ0QsTUFBRSxLQUFLd3NELFlBQUwsQ0FBa0J4c0QsSUFBbEIsQ0FBRjtBQUNBLFNBQUssSUFBSWhGLElBQUksQ0FBUixFQUFXQyxLQUFLd3dELFVBQVVwd0QsTUFBL0IsRUFBdUNMLElBQUlDLEVBQTNDLEVBQStDLEVBQUVELENBQWpELEVBQW9EO0FBQ2xELFVBQUl5d0QsVUFBVXp3RCxDQUFWLEVBQWEyZSxJQUFiLENBQWtCLElBQWxCLEVBQXdCMnhDLEdBQXhCLE1BQWlDLEtBQWpDLElBQTBDQSxJQUFJZ0Isa0JBQWxELEVBQXNFO0FBQ3BFSyxvQkFBWSxLQUFaO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsTUFBRSxLQUFLSCxZQUFMLENBQWtCeHNELElBQWxCLENBQUY7QUFDQSxRQUFJLEtBQUt3c0QsWUFBTCxDQUFrQnhzRCxJQUFsQixNQUE0QixDQUFoQyxFQUFtQztBQUNqQyxVQUFJNHNELGtCQUFrQixLQUFLTCxnQkFBTCxDQUFzQnZzRCxJQUF0QixDQUF0QjtBQUNBLGFBQU8sS0FBS3VzRCxnQkFBTCxDQUFzQnZzRCxJQUF0QixDQUFQO0FBQ0EsYUFBTzRzRCxpQkFBUCxFQUEwQjtBQUN4QixhQUFLWCxtQkFBTCxDQUF5QmpzRCxJQUF6QixFQUErQndoRCxvQkFBL0I7QUFDRDtBQUNELGFBQU8sS0FBS2dMLFlBQUwsQ0FBa0J4c0QsSUFBbEIsQ0FBUDtBQUNEO0FBQ0QsV0FBTzJzRCxTQUFQO0FBQ0Q7QUFDRixDQTdCRDs7QUFnQ0E7OztBQUdBNUgsWUFBWXJyQyxTQUFaLENBQXNCNm5DLGVBQXRCLEdBQXdDLFlBQVc7QUFDakQsMkJBQVksSUFBWjtBQUNELENBRkQ7O0FBS0E7Ozs7Ozs7QUFPQXdELFlBQVlyckMsU0FBWixDQUFzQnF4QyxZQUF0QixHQUFxQyxVQUFTL3FELElBQVQsRUFBZTtBQUNsRCxTQUFPLEtBQUt5c0QsVUFBTCxDQUFnQnpzRCxJQUFoQixDQUFQO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7QUFLQStrRCxZQUFZcnJDLFNBQVosQ0FBc0JtekMsV0FBdEIsR0FBb0MsVUFBU0MsUUFBVCxFQUFtQjtBQUNyRCxTQUFPQSxXQUNMQSxZQUFZLEtBQUtMLFVBRFosR0FFTDE0QyxPQUFPTixJQUFQLENBQVksS0FBS2c1QyxVQUFqQixFQUE2QnB4RCxNQUE3QixHQUFzQyxDQUZ4QztBQUdELENBSkQ7O0FBT0E7Ozs7QUFJQTBwRCxZQUFZcnJDLFNBQVosQ0FBc0J1eUMsbUJBQXRCLEdBQTRDLFVBQVNqc0QsSUFBVCxFQUFlbWxELFFBQWYsRUFBeUI7QUFDbkUsTUFBTXNHLFlBQVksS0FBS2dCLFVBQUwsQ0FBZ0J6c0QsSUFBaEIsQ0FBbEI7QUFDQSxNQUFJeXJELFNBQUosRUFBZTtBQUNiLFFBQU1uNEMsUUFBUW00QyxVQUFVMXZELE9BQVYsQ0FBa0JvcEQsUUFBbEIsQ0FBZDtBQUNBLFFBQUlubEQsUUFBUSxLQUFLdXNELGdCQUFqQixFQUFtQztBQUNqQztBQUNBZCxnQkFBVW40QyxLQUFWLElBQW1Ca3VDLG9CQUFuQjtBQUNBLFFBQUUsS0FBSytLLGdCQUFMLENBQXNCdnNELElBQXRCLENBQUY7QUFDRCxLQUpELE1BSU87QUFDTHlyRCxnQkFBVXB6QyxNQUFWLENBQWlCL0UsS0FBakIsRUFBd0IsQ0FBeEI7QUFDQSxVQUFJbTRDLFVBQVVwd0QsTUFBVixLQUFxQixDQUF6QixFQUE0QjtBQUMxQixlQUFPLEtBQUtveEQsVUFBTCxDQUFnQnpzRCxJQUFoQixDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsQ0FmRDtrQkFnQmUra0QsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0S2Y7Ozs7QUFJQTs7OztrQkFJZTtBQUNiOzs7OztBQUtBRSxVQUFRLFFBTks7O0FBUWI4SCxTQUFPLE9BUk07QUFTYkMsZUFBYSxhQVRBO0FBVWJDLFNBQU8sT0FWTTtBQVdiQyxZQUFVLFVBWEc7QUFZYkMsYUFBVyxXQVpFO0FBYWJDLFlBQVUsVUFiRztBQWNiQyxRQUFNLE1BZE87QUFlYnhLLFNBQU8sT0FmTTtBQWdCYnlLLFdBQVMsU0FoQkk7QUFpQmJDLFlBQVUsVUFqQkc7QUFrQmJqSyxRQUFNLE1BbEJPO0FBbUJia0ssYUFBVyxXQW5CRTtBQW9CYkMsYUFBVyxXQXBCRTtBQXFCYkMsWUFBVSxVQXJCRztBQXNCYkMsV0FBUyxTQXRCSTtBQXVCYkMsY0FBWSxZQXZCQztBQXdCYkMsaUJBQWUsZUF4QkY7QUF5QmJDLFVBQVEsUUF6Qks7QUEwQmJDLGNBQVksWUExQkM7QUEyQmJDLGFBQVcsV0EzQkU7QUE0QmJDLFlBQVUsVUE1Qkc7QUE2QmJDLFNBQU87QUE3Qk0sQzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNhQ0MsYyxHQUFBQSxjO1FBaUNBOWtELE0sR0FBQUEsTTtRQXlCQStrRCxLLEdBQUFBLEs7UUFtQkFDLHdCLEdBQUFBLHdCO1FBNEJBQyxrQixHQUFBQSxrQjtRQWlCQUMsYyxHQUFBQSxjO1FBZUFwSCxVLEdBQUFBLFU7UUFZQXFILHNCLEdBQUFBLHNCO1FBOEJBQyxXLEdBQUFBLFc7UUFjQTdILGMsR0FBQUEsYztRQWtCQThILG1CLEdBQUFBLG1CO1FBV0FDLDRCLEdBQUFBLDRCO1FBWUFDLDZCLEdBQUFBLDZCO1FBY0FDLGlDLEdBQUFBLGlDO1FBVUFDLHVCLEdBQUFBLHVCO1FBYUFuVyxNLEdBQUFBLE07UUFhQTcyQixNLEdBQUFBLE07UUFxQkFpdEMsZ0IsR0FBQUEsZ0I7UUFxQkFDLGlCLEdBQUFBLGlCO1FBZ0JBQyxxQixHQUFBQSxxQjtRQWFBQyxXLEdBQUFBLFc7UUFhQUMsUSxHQUFBQSxRO1FBa0JBQyxhLEdBQUFBLGE7UUE0QkFDLE8sR0FBQUEsTztRQWVBQyxhLEdBQUFBLGE7UUFXQUMsYyxHQUFBQSxjO1FBV0E5dEQsUyxHQUFBQSxTO1FBV0ErdEQsUyxHQUFBQSxTO1FBd0JBQyxlLEdBQUFBLGU7UUFpQkFDLGlCLEdBQUFBLGlCO1FBZ0NBckksUyxHQUFBQSxTO1FBVUFzSSxtQixHQUFBQSxtQjtRQWNBQyxlLEdBQUFBLGU7UUFrQ0FDLFMsR0FBQUEsUztRQVdBM3RELE8sR0FBQUEsTztRQVdBNHRELFUsR0FBQUEsVTtRQVdBQyxXLEdBQUFBLFc7UUFXQXpJLFEsR0FBQUEsUTtRQVlBQyxVLEdBQUFBLFU7UUFjQXlJLE8sR0FBQUEsTztRQVVBQyxjLEdBQUFBLGM7UUFpQkFDLGUsR0FBQUEsZTtRQWtCQUMsaUIsR0FBQUEsaUI7UUF5REFDLGMsR0FBQUEsYzs7QUEvd0JoQjs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPTyxTQUFTakMsY0FBVCxDQUF3QmhrRCxXQUF4QixFQUFxQztBQUMxQyxNQUFNa21ELFNBQVM1QixhQUFmO0FBQ0EsT0FBSyxJQUFJenpELElBQUksQ0FBUixFQUFXQyxLQUFLa1AsWUFBWTlPLE1BQWpDLEVBQXlDTCxJQUFJQyxFQUE3QyxFQUFpRCxFQUFFRCxDQUFuRCxFQUFzRDtBQUNwRCt6RCxxQkFBaUJzQixNQUFqQixFQUF5QmxtRCxZQUFZblAsQ0FBWixDQUF6QjtBQUNEO0FBQ0QsU0FBT3ExRCxNQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7QUE5QkE7OztBQXFDQSxTQUFTQyxrQkFBVCxDQUE0QkMsRUFBNUIsRUFBZ0NDLEVBQWhDLEVBQW9DQyxVQUFwQyxFQUFnRDtBQUM5QyxNQUFNM0osT0FBTzl3QyxLQUFLbkcsR0FBTCxDQUFTblYsS0FBVCxDQUFlLElBQWYsRUFBcUI2MUQsRUFBckIsQ0FBYjtBQUNBLE1BQU12SixPQUFPaHhDLEtBQUtuRyxHQUFMLENBQVNuVixLQUFULENBQWUsSUFBZixFQUFxQjgxRCxFQUFyQixDQUFiO0FBQ0EsTUFBTXpKLE9BQU8vd0MsS0FBS2xHLEdBQUwsQ0FBU3BWLEtBQVQsQ0FBZSxJQUFmLEVBQXFCNjFELEVBQXJCLENBQWI7QUFDQSxNQUFNdEosT0FBT2p4QyxLQUFLbEcsR0FBTCxDQUFTcFYsS0FBVCxDQUFlLElBQWYsRUFBcUI4MUQsRUFBckIsQ0FBYjtBQUNBLFNBQU81SixlQUFlRSxJQUFmLEVBQXFCRSxJQUFyQixFQUEyQkQsSUFBM0IsRUFBaUNFLElBQWpDLEVBQXVDd0osVUFBdkMsQ0FBUDtBQUNEOztBQUdEOzs7Ozs7OztBQVFPLFNBQVNwbkQsTUFBVCxDQUFnQmduRCxNQUFoQixFQUF3Qm5wRCxLQUF4QixFQUErQnVwRCxVQUEvQixFQUEyQztBQUNoRCxNQUFJQSxVQUFKLEVBQWdCO0FBQ2RBLGVBQVcsQ0FBWCxJQUFnQkosT0FBTyxDQUFQLElBQVlucEQsS0FBNUI7QUFDQXVwRCxlQUFXLENBQVgsSUFBZ0JKLE9BQU8sQ0FBUCxJQUFZbnBELEtBQTVCO0FBQ0F1cEQsZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsSUFBWW5wRCxLQUE1QjtBQUNBdXBELGVBQVcsQ0FBWCxJQUFnQkosT0FBTyxDQUFQLElBQVlucEQsS0FBNUI7QUFDQSxXQUFPdXBELFVBQVA7QUFDRCxHQU5ELE1BTU87QUFDTCxXQUFPLENBQ0xKLE9BQU8sQ0FBUCxJQUFZbnBELEtBRFAsRUFFTG1wRCxPQUFPLENBQVAsSUFBWW5wRCxLQUZQLEVBR0xtcEQsT0FBTyxDQUFQLElBQVlucEQsS0FIUCxFQUlMbXBELE9BQU8sQ0FBUCxJQUFZbnBELEtBSlAsQ0FBUDtBQU1EO0FBQ0Y7O0FBR0Q7Ozs7Ozs7QUFPTyxTQUFTa25ELEtBQVQsQ0FBZWlDLE1BQWYsRUFBdUJJLFVBQXZCLEVBQW1DO0FBQ3hDLE1BQUlBLFVBQUosRUFBZ0I7QUFDZEEsZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQUksZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQUksZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQUksZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQSxXQUFPSSxVQUFQO0FBQ0QsR0FORCxNQU1PO0FBQ0wsV0FBT0osT0FBT2xxRCxLQUFQLEVBQVA7QUFDRDtBQUNGOztBQUdEOzs7Ozs7QUFNTyxTQUFTa29ELHdCQUFULENBQWtDZ0MsTUFBbEMsRUFBMENuMkMsQ0FBMUMsRUFBNkNnUSxDQUE3QyxFQUFnRDtBQUNyRCxNQUFJd21DLFdBQUo7QUFBQSxNQUFRQyxXQUFSO0FBQ0EsTUFBSXoyQyxJQUFJbTJDLE9BQU8sQ0FBUCxDQUFSLEVBQW1CO0FBQ2pCSyxTQUFLTCxPQUFPLENBQVAsSUFBWW4yQyxDQUFqQjtBQUNELEdBRkQsTUFFTyxJQUFJbTJDLE9BQU8sQ0FBUCxJQUFZbjJDLENBQWhCLEVBQW1CO0FBQ3hCdzJDLFNBQUt4MkMsSUFBSW0yQyxPQUFPLENBQVAsQ0FBVDtBQUNELEdBRk0sTUFFQTtBQUNMSyxTQUFLLENBQUw7QUFDRDtBQUNELE1BQUl4bUMsSUFBSW1tQyxPQUFPLENBQVAsQ0FBUixFQUFtQjtBQUNqQk0sU0FBS04sT0FBTyxDQUFQLElBQVlubUMsQ0FBakI7QUFDRCxHQUZELE1BRU8sSUFBSW1tQyxPQUFPLENBQVAsSUFBWW5tQyxDQUFoQixFQUFtQjtBQUN4QnltQyxTQUFLem1DLElBQUltbUMsT0FBTyxDQUFQLENBQVQ7QUFDRCxHQUZNLE1BRUE7QUFDTE0sU0FBSyxDQUFMO0FBQ0Q7QUFDRCxTQUFPRCxLQUFLQSxFQUFMLEdBQVVDLEtBQUtBLEVBQXRCO0FBQ0Q7O0FBR0Q7Ozs7Ozs7O0FBUU8sU0FBU3JDLGtCQUFULENBQTRCK0IsTUFBNUIsRUFBb0NPLFVBQXBDLEVBQWdEO0FBQ3JELFNBQU96SixXQUFXa0osTUFBWCxFQUFtQk8sV0FBVyxDQUFYLENBQW5CLEVBQWtDQSxXQUFXLENBQVgsQ0FBbEMsQ0FBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7Ozs7QUFZTyxTQUFTckMsY0FBVCxDQUF3QnNDLE9BQXhCLEVBQWlDQyxPQUFqQyxFQUEwQztBQUMvQyxTQUFPRCxRQUFRLENBQVIsS0FBY0MsUUFBUSxDQUFSLENBQWQsSUFBNEJBLFFBQVEsQ0FBUixLQUFjRCxRQUFRLENBQVIsQ0FBMUMsSUFDSEEsUUFBUSxDQUFSLEtBQWNDLFFBQVEsQ0FBUixDQURYLElBQ3lCQSxRQUFRLENBQVIsS0FBY0QsUUFBUSxDQUFSLENBRDlDO0FBRUQ7O0FBR0Q7Ozs7Ozs7OztBQVNPLFNBQVMxSixVQUFULENBQW9Ca0osTUFBcEIsRUFBNEJuMkMsQ0FBNUIsRUFBK0JnUSxDQUEvQixFQUFrQztBQUN2QyxTQUFPbW1DLE9BQU8sQ0FBUCxLQUFhbjJDLENBQWIsSUFBa0JBLEtBQUttMkMsT0FBTyxDQUFQLENBQXZCLElBQW9DQSxPQUFPLENBQVAsS0FBYW5tQyxDQUFqRCxJQUFzREEsS0FBS21tQyxPQUFPLENBQVAsQ0FBbEU7QUFDRDs7QUFHRDs7Ozs7OztBQU9PLFNBQVM3QixzQkFBVCxDQUFnQzZCLE1BQWhDLEVBQXdDTyxVQUF4QyxFQUFvRDtBQUN6RCxNQUFNOUosT0FBT3VKLE9BQU8sQ0FBUCxDQUFiO0FBQ0EsTUFBTXJKLE9BQU9xSixPQUFPLENBQVAsQ0FBYjtBQUNBLE1BQU10SixPQUFPc0osT0FBTyxDQUFQLENBQWI7QUFDQSxNQUFNcEosT0FBT29KLE9BQU8sQ0FBUCxDQUFiO0FBQ0EsTUFBTW4yQyxJQUFJMDJDLFdBQVcsQ0FBWCxDQUFWO0FBQ0EsTUFBTTFtQyxJQUFJMG1DLFdBQVcsQ0FBWCxDQUFWO0FBQ0EsTUFBSUcsZUFBZUMsdUJBQWFDLE9BQWhDO0FBQ0EsTUFBSS8yQyxJQUFJNHNDLElBQVIsRUFBYztBQUNaaUssbUJBQWVBLGVBQWVDLHVCQUFhRSxJQUEzQztBQUNELEdBRkQsTUFFTyxJQUFJaDNDLElBQUk2c0MsSUFBUixFQUFjO0FBQ25CZ0ssbUJBQWVBLGVBQWVDLHVCQUFhRyxLQUEzQztBQUNEO0FBQ0QsTUFBSWpuQyxJQUFJODhCLElBQVIsRUFBYztBQUNaK0osbUJBQWVBLGVBQWVDLHVCQUFhSSxLQUEzQztBQUNELEdBRkQsTUFFTyxJQUFJbG5DLElBQUkrOEIsSUFBUixFQUFjO0FBQ25COEosbUJBQWVBLGVBQWVDLHVCQUFhSyxLQUEzQztBQUNEO0FBQ0QsTUFBSU4saUJBQWlCQyx1QkFBYUMsT0FBbEMsRUFBMkM7QUFDekNGLG1CQUFlQyx1QkFBYU0sWUFBNUI7QUFDRDtBQUNELFNBQU9QLFlBQVA7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTdEMsV0FBVCxHQUF1QjtBQUM1QixTQUFPLENBQUN6N0MsUUFBRCxFQUFXQSxRQUFYLEVBQXFCLENBQUNBLFFBQXRCLEVBQWdDLENBQUNBLFFBQWpDLENBQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7O0FBU08sU0FBUzR6QyxjQUFULENBQXdCRSxJQUF4QixFQUE4QkUsSUFBOUIsRUFBb0NELElBQXBDLEVBQTBDRSxJQUExQyxFQUFnRHdKLFVBQWhELEVBQTREO0FBQ2pFLE1BQUlBLFVBQUosRUFBZ0I7QUFDZEEsZUFBVyxDQUFYLElBQWdCM0osSUFBaEI7QUFDQTJKLGVBQVcsQ0FBWCxJQUFnQnpKLElBQWhCO0FBQ0F5SixlQUFXLENBQVgsSUFBZ0IxSixJQUFoQjtBQUNBMEosZUFBVyxDQUFYLElBQWdCeEosSUFBaEI7QUFDQSxXQUFPd0osVUFBUDtBQUNELEdBTkQsTUFNTztBQUNMLFdBQU8sQ0FBQzNKLElBQUQsRUFBT0UsSUFBUCxFQUFhRCxJQUFiLEVBQW1CRSxJQUFuQixDQUFQO0FBQ0Q7QUFDRjs7QUFHRDs7Ozs7QUFLTyxTQUFTeUgsbUJBQVQsQ0FBNkIrQixVQUE3QixFQUF5QztBQUM5QyxTQUFPN0osZUFDTDV6QyxRQURLLEVBQ0tBLFFBREwsRUFDZSxDQUFDQSxRQURoQixFQUMwQixDQUFDQSxRQUQzQixFQUNxQ3k5QyxVQURyQyxDQUFQO0FBRUQ7O0FBR0Q7Ozs7O0FBS08sU0FBUzlCLDRCQUFULENBQXNDaUMsVUFBdEMsRUFBa0RILFVBQWxELEVBQThEO0FBQ25FLE1BQU12MkMsSUFBSTAyQyxXQUFXLENBQVgsQ0FBVjtBQUNBLE1BQU0xbUMsSUFBSTBtQyxXQUFXLENBQVgsQ0FBVjtBQUNBLFNBQU9oSyxlQUFlMXNDLENBQWYsRUFBa0JnUSxDQUFsQixFQUFxQmhRLENBQXJCLEVBQXdCZ1EsQ0FBeEIsRUFBMkJ1bUMsVUFBM0IsQ0FBUDtBQUNEOztBQUdEOzs7OztBQUtPLFNBQVM3Qiw2QkFBVCxDQUF1Q3prRCxXQUF2QyxFQUFvRHNtRCxVQUFwRCxFQUFnRTtBQUNyRSxNQUFNSixTQUFTM0Isb0JBQW9CK0IsVUFBcEIsQ0FBZjtBQUNBLFNBQU96QixrQkFBa0JxQixNQUFsQixFQUEwQmxtRCxXQUExQixDQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7O0FBUU8sU0FBUzBrRCxpQ0FBVCxDQUEyQzBDLGVBQTNDLEVBQTREcGhCLE1BQTVELEVBQW9FOThCLEdBQXBFLEVBQXlFbStDLE1BQXpFLEVBQWlGZixVQUFqRixFQUE2RjtBQUNsRyxNQUFNSixTQUFTM0Isb0JBQW9CK0IsVUFBcEIsQ0FBZjtBQUNBLFNBQU94QixzQkFBc0JvQixNQUF0QixFQUE4QmtCLGVBQTlCLEVBQStDcGhCLE1BQS9DLEVBQXVEOThCLEdBQXZELEVBQTREbStDLE1BQTVELENBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLTyxTQUFTMUMsdUJBQVQsQ0FBaUM1aEMsS0FBakMsRUFBd0N1akMsVUFBeEMsRUFBb0Q7QUFDekQsTUFBTUosU0FBUzNCLG9CQUFvQitCLFVBQXBCLENBQWY7QUFDQSxTQUFPdkIsWUFBWW1CLE1BQVosRUFBb0JuakMsS0FBcEIsQ0FBUDtBQUNEOztBQUdEOzs7Ozs7O0FBT08sU0FBU3lyQixNQUFULENBQWdCa1ksT0FBaEIsRUFBeUJDLE9BQXpCLEVBQWtDO0FBQ3ZDLFNBQU9ELFFBQVEsQ0FBUixLQUFjQyxRQUFRLENBQVIsQ0FBZCxJQUE0QkQsUUFBUSxDQUFSLEtBQWNDLFFBQVEsQ0FBUixDQUExQyxJQUNIRCxRQUFRLENBQVIsS0FBY0MsUUFBUSxDQUFSLENBRFgsSUFDeUJELFFBQVEsQ0FBUixLQUFjQyxRQUFRLENBQVIsQ0FEOUM7QUFFRDs7QUFHRDs7Ozs7OztBQU9PLFNBQVNodkMsTUFBVCxDQUFnQit1QyxPQUFoQixFQUF5QkMsT0FBekIsRUFBa0M7QUFDdkMsTUFBSUEsUUFBUSxDQUFSLElBQWFELFFBQVEsQ0FBUixDQUFqQixFQUE2QjtBQUMzQkEsWUFBUSxDQUFSLElBQWFDLFFBQVEsQ0FBUixDQUFiO0FBQ0Q7QUFDRCxNQUFJQSxRQUFRLENBQVIsSUFBYUQsUUFBUSxDQUFSLENBQWpCLEVBQTZCO0FBQzNCQSxZQUFRLENBQVIsSUFBYUMsUUFBUSxDQUFSLENBQWI7QUFDRDtBQUNELE1BQUlBLFFBQVEsQ0FBUixJQUFhRCxRQUFRLENBQVIsQ0FBakIsRUFBNkI7QUFDM0JBLFlBQVEsQ0FBUixJQUFhQyxRQUFRLENBQVIsQ0FBYjtBQUNEO0FBQ0QsTUFBSUEsUUFBUSxDQUFSLElBQWFELFFBQVEsQ0FBUixDQUFqQixFQUE2QjtBQUMzQkEsWUFBUSxDQUFSLElBQWFDLFFBQVEsQ0FBUixDQUFiO0FBQ0Q7QUFDRCxTQUFPRCxPQUFQO0FBQ0Q7O0FBR0Q7Ozs7QUFJTyxTQUFTOUIsZ0JBQVQsQ0FBMEJzQixNQUExQixFQUFrQ08sVUFBbEMsRUFBOEM7QUFDbkQsTUFBSUEsV0FBVyxDQUFYLElBQWdCUCxPQUFPLENBQVAsQ0FBcEIsRUFBK0I7QUFDN0JBLFdBQU8sQ0FBUCxJQUFZTyxXQUFXLENBQVgsQ0FBWjtBQUNEO0FBQ0QsTUFBSUEsV0FBVyxDQUFYLElBQWdCUCxPQUFPLENBQVAsQ0FBcEIsRUFBK0I7QUFDN0JBLFdBQU8sQ0FBUCxJQUFZTyxXQUFXLENBQVgsQ0FBWjtBQUNEO0FBQ0QsTUFBSUEsV0FBVyxDQUFYLElBQWdCUCxPQUFPLENBQVAsQ0FBcEIsRUFBK0I7QUFDN0JBLFdBQU8sQ0FBUCxJQUFZTyxXQUFXLENBQVgsQ0FBWjtBQUNEO0FBQ0QsTUFBSUEsV0FBVyxDQUFYLElBQWdCUCxPQUFPLENBQVAsQ0FBcEIsRUFBK0I7QUFDN0JBLFdBQU8sQ0FBUCxJQUFZTyxXQUFXLENBQVgsQ0FBWjtBQUNEO0FBQ0Y7O0FBR0Q7Ozs7O0FBS08sU0FBUzVCLGlCQUFULENBQTJCcUIsTUFBM0IsRUFBbUNsbUQsV0FBbkMsRUFBZ0Q7QUFDckQsT0FBSyxJQUFJblAsSUFBSSxDQUFSLEVBQVdDLEtBQUtrUCxZQUFZOU8sTUFBakMsRUFBeUNMLElBQUlDLEVBQTdDLEVBQWlELEVBQUVELENBQW5ELEVBQXNEO0FBQ3BEK3pELHFCQUFpQnNCLE1BQWpCLEVBQXlCbG1ELFlBQVluUCxDQUFaLENBQXpCO0FBQ0Q7QUFDRCxTQUFPcTFELE1BQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7QUFRTyxTQUFTcEIscUJBQVQsQ0FBK0JvQixNQUEvQixFQUF1Q2tCLGVBQXZDLEVBQXdEcGhCLE1BQXhELEVBQWdFOThCLEdBQWhFLEVBQXFFbStDLE1BQXJFLEVBQTZFO0FBQ2xGLFNBQU9yaEIsU0FBUzk4QixHQUFoQixFQUFxQjg4QixVQUFVcWhCLE1BQS9CLEVBQXVDO0FBQ3JDckMsYUFBU2tCLE1BQVQsRUFBaUJrQixnQkFBZ0JwaEIsTUFBaEIsQ0FBakIsRUFBMENvaEIsZ0JBQWdCcGhCLFNBQVMsQ0FBekIsQ0FBMUM7QUFDRDtBQUNELFNBQU9rZ0IsTUFBUDtBQUNEOztBQUdEOzs7OztBQUtPLFNBQVNuQixXQUFULENBQXFCbUIsTUFBckIsRUFBNkJuakMsS0FBN0IsRUFBb0M7QUFDekMsT0FBSyxJQUFJbHlCLElBQUksQ0FBUixFQUFXQyxLQUFLaXlCLE1BQU03eEIsTUFBM0IsRUFBbUNMLElBQUlDLEVBQXZDLEVBQTJDLEVBQUVELENBQTdDLEVBQWdEO0FBQzlDZzBELHNCQUFrQnFCLE1BQWxCLEVBQTBCbmpDLE1BQU1seUIsQ0FBTixDQUExQjtBQUNEO0FBQ0QsU0FBT3ExRCxNQUFQO0FBQ0Q7O0FBR0Q7Ozs7O0FBS08sU0FBU2xCLFFBQVQsQ0FBa0JrQixNQUFsQixFQUEwQm4yQyxDQUExQixFQUE2QmdRLENBQTdCLEVBQWdDO0FBQ3JDbW1DLFNBQU8sQ0FBUCxJQUFZcjZDLEtBQUtuRyxHQUFMLENBQVN3Z0QsT0FBTyxDQUFQLENBQVQsRUFBb0JuMkMsQ0FBcEIsQ0FBWjtBQUNBbTJDLFNBQU8sQ0FBUCxJQUFZcjZDLEtBQUtuRyxHQUFMLENBQVN3Z0QsT0FBTyxDQUFQLENBQVQsRUFBb0JubUMsQ0FBcEIsQ0FBWjtBQUNBbW1DLFNBQU8sQ0FBUCxJQUFZcjZDLEtBQUtsRyxHQUFMLENBQVN1Z0QsT0FBTyxDQUFQLENBQVQsRUFBb0JuMkMsQ0FBcEIsQ0FBWjtBQUNBbTJDLFNBQU8sQ0FBUCxJQUFZcjZDLEtBQUtsRyxHQUFMLENBQVN1Z0QsT0FBTyxDQUFQLENBQVQsRUFBb0JubUMsQ0FBcEIsQ0FBWjtBQUNEOztBQUdEOzs7Ozs7Ozs7O0FBVU8sU0FBU2tsQyxhQUFULENBQXVCaUIsTUFBdkIsRUFBK0Jod0MsUUFBL0IsRUFBeUNxckMsUUFBekMsRUFBbUQ7QUFDeEQsTUFBSTF3QixZQUFKO0FBQ0FBLFFBQU0zYSxTQUFTMUcsSUFBVCxDQUFjK3hDLFFBQWQsRUFBd0I0RCxjQUFjZSxNQUFkLENBQXhCLENBQU47QUFDQSxNQUFJcjFCLEdBQUosRUFBUztBQUNQLFdBQU9BLEdBQVA7QUFDRDtBQUNEQSxRQUFNM2EsU0FBUzFHLElBQVQsQ0FBYyt4QyxRQUFkLEVBQXdCNkQsZUFBZWMsTUFBZixDQUF4QixDQUFOO0FBQ0EsTUFBSXIxQixHQUFKLEVBQVM7QUFDUCxXQUFPQSxHQUFQO0FBQ0Q7QUFDREEsUUFBTTNhLFNBQVMxRyxJQUFULENBQWMreEMsUUFBZCxFQUF3QnFFLFlBQVlNLE1BQVosQ0FBeEIsQ0FBTjtBQUNBLE1BQUlyMUIsR0FBSixFQUFTO0FBQ1AsV0FBT0EsR0FBUDtBQUNEO0FBQ0RBLFFBQU0zYSxTQUFTMUcsSUFBVCxDQUFjK3hDLFFBQWQsRUFBd0JvRSxXQUFXTyxNQUFYLENBQXhCLENBQU47QUFDQSxNQUFJcjFCLEdBQUosRUFBUztBQUNQLFdBQU9BLEdBQVA7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNEOztBQUdEOzs7Ozs7QUFNTyxTQUFTcTBCLE9BQVQsQ0FBaUJnQixNQUFqQixFQUF5QjtBQUM5QixNQUFJb0IsT0FBTyxDQUFYO0FBQ0EsTUFBSSxDQUFDekIsUUFBUUssTUFBUixDQUFMLEVBQXNCO0FBQ3BCb0IsV0FBT25LLFNBQVMrSSxNQUFULElBQW1CaEosVUFBVWdKLE1BQVYsQ0FBMUI7QUFDRDtBQUNELFNBQU9vQixJQUFQO0FBQ0Q7O0FBR0Q7Ozs7OztBQU1PLFNBQVNuQyxhQUFULENBQXVCZSxNQUF2QixFQUErQjtBQUNwQyxTQUFPLENBQUNBLE9BQU8sQ0FBUCxDQUFELEVBQVlBLE9BQU8sQ0FBUCxDQUFaLENBQVA7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU2QsY0FBVCxDQUF3QmMsTUFBeEIsRUFBZ0M7QUFDckMsU0FBTyxDQUFDQSxPQUFPLENBQVAsQ0FBRCxFQUFZQSxPQUFPLENBQVAsQ0FBWixDQUFQO0FBQ0Q7O0FBR0Q7Ozs7OztBQU1PLFNBQVM1dUQsU0FBVCxDQUFtQjR1RCxNQUFuQixFQUEyQjtBQUNoQyxTQUFPLENBQUMsQ0FBQ0EsT0FBTyxDQUFQLElBQVlBLE9BQU8sQ0FBUCxDQUFiLElBQTBCLENBQTNCLEVBQThCLENBQUNBLE9BQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsQ0FBYixJQUEwQixDQUF4RCxDQUFQO0FBQ0Q7O0FBR0Q7Ozs7OztBQU1PLFNBQVNiLFNBQVQsQ0FBbUJhLE1BQW5CLEVBQTJCcUIsTUFBM0IsRUFBbUM7QUFDeEMsTUFBSWQsbUJBQUo7QUFDQSxNQUFJYyxXQUFXQyxpQkFBT0MsV0FBdEIsRUFBbUM7QUFDakNoQixpQkFBYXRCLGNBQWNlLE1BQWQsQ0FBYjtBQUNELEdBRkQsTUFFTyxJQUFJcUIsV0FBV0MsaUJBQU9FLFlBQXRCLEVBQW9DO0FBQ3pDakIsaUJBQWFyQixlQUFlYyxNQUFmLENBQWI7QUFDRCxHQUZNLE1BRUEsSUFBSXFCLFdBQVdDLGlCQUFPRyxRQUF0QixFQUFnQztBQUNyQ2xCLGlCQUFhZCxXQUFXTyxNQUFYLENBQWI7QUFDRCxHQUZNLE1BRUEsSUFBSXFCLFdBQVdDLGlCQUFPSSxTQUF0QixFQUFpQztBQUN0Q25CLGlCQUFhYixZQUFZTSxNQUFaLENBQWI7QUFDRCxHQUZNLE1BRUE7QUFDTCx5QkFBTyxLQUFQLEVBQWMsRUFBZCxFQURLLENBQ2M7QUFDcEI7QUFDRDtBQUNFLG1EQUFpRE87QUFEbkQ7QUFHRDs7QUFHRDs7Ozs7QUFLTyxTQUFTbkIsZUFBVCxDQUF5Qm9CLE9BQXpCLEVBQWtDQyxPQUFsQyxFQUEyQztBQUNoRCxNQUFNaEssT0FBTzl3QyxLQUFLbkcsR0FBTCxDQUFTZ2hELFFBQVEsQ0FBUixDQUFULEVBQXFCQyxRQUFRLENBQVIsQ0FBckIsQ0FBYjtBQUNBLE1BQU05SixPQUFPaHhDLEtBQUtuRyxHQUFMLENBQVNnaEQsUUFBUSxDQUFSLENBQVQsRUFBcUJDLFFBQVEsQ0FBUixDQUFyQixDQUFiO0FBQ0EsTUFBTS9KLE9BQU8vd0MsS0FBS2xHLEdBQUwsQ0FBUytnRCxRQUFRLENBQVIsQ0FBVCxFQUFxQkMsUUFBUSxDQUFSLENBQXJCLENBQWI7QUFDQSxNQUFNN0osT0FBT2p4QyxLQUFLbEcsR0FBTCxDQUFTK2dELFFBQVEsQ0FBUixDQUFULEVBQXFCQyxRQUFRLENBQVIsQ0FBckIsQ0FBYjtBQUNBLFNBQU8sQ0FBQy9KLE9BQU9ELElBQVIsS0FBaUJHLE9BQU9ELElBQXhCLENBQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7QUFRTyxTQUFTMEksaUJBQVQsQ0FBMkIvdEQsTUFBM0IsRUFBbUNxd0QsVUFBbkMsRUFBK0NDLFFBQS9DLEVBQXlEaHdELElBQXpELEVBQStEd3VELFVBQS9ELEVBQTJFO0FBQ2hGLE1BQU1DLEtBQUtzQixhQUFhL3ZELEtBQUssQ0FBTCxDQUFiLEdBQXVCLENBQWxDO0FBQ0EsTUFBTTB1RCxLQUFLcUIsYUFBYS92RCxLQUFLLENBQUwsQ0FBYixHQUF1QixDQUFsQztBQUNBLE1BQU1pd0QsY0FBY2w4QyxLQUFLeEcsR0FBTCxDQUFTeWlELFFBQVQsQ0FBcEI7QUFDQSxNQUFNRSxjQUFjbjhDLEtBQUt6RyxHQUFMLENBQVMwaUQsUUFBVCxDQUFwQjtBQUNBLE1BQU1HLE9BQU8xQixLQUFLd0IsV0FBbEI7QUFDQSxNQUFNRyxPQUFPM0IsS0FBS3lCLFdBQWxCO0FBQ0EsTUFBTUcsT0FBTzNCLEtBQUt1QixXQUFsQjtBQUNBLE1BQU1LLE9BQU81QixLQUFLd0IsV0FBbEI7QUFDQSxNQUFNajRDLElBQUl2WSxPQUFPLENBQVAsQ0FBVjtBQUNBLE1BQU11b0IsSUFBSXZvQixPQUFPLENBQVAsQ0FBVjtBQUNBLE1BQU02d0QsS0FBS3Q0QyxJQUFJazRDLElBQUosR0FBV0csSUFBdEI7QUFDQSxNQUFNM2xDLEtBQUsxUyxJQUFJazRDLElBQUosR0FBV0csSUFBdEI7QUFDQSxNQUFNemxDLEtBQUs1UyxJQUFJazRDLElBQUosR0FBV0csSUFBdEI7QUFDQSxNQUFNemtDLEtBQUs1VCxJQUFJazRDLElBQUosR0FBV0csSUFBdEI7QUFDQSxNQUFNRSxLQUFLdm9DLElBQUltb0MsSUFBSixHQUFXQyxJQUF0QjtBQUNBLE1BQU16bEMsS0FBSzNDLElBQUltb0MsSUFBSixHQUFXQyxJQUF0QjtBQUNBLE1BQU12bEMsS0FBSzdDLElBQUltb0MsSUFBSixHQUFXQyxJQUF0QjtBQUNBLE1BQU12a0MsS0FBSzdELElBQUltb0MsSUFBSixHQUFXQyxJQUF0QjtBQUNBLFNBQU8xTCxlQUNMNXdDLEtBQUtuRyxHQUFMLENBQVMyaUQsRUFBVCxFQUFhNWxDLEVBQWIsRUFBaUJFLEVBQWpCLEVBQXFCZ0IsRUFBckIsQ0FESyxFQUNxQjlYLEtBQUtuRyxHQUFMLENBQVM0aUQsRUFBVCxFQUFhNWxDLEVBQWIsRUFBaUJFLEVBQWpCLEVBQXFCZ0IsRUFBckIsQ0FEckIsRUFFTC9YLEtBQUtsRyxHQUFMLENBQVMwaUQsRUFBVCxFQUFhNWxDLEVBQWIsRUFBaUJFLEVBQWpCLEVBQXFCZ0IsRUFBckIsQ0FGSyxFQUVxQjlYLEtBQUtsRyxHQUFMLENBQVMyaUQsRUFBVCxFQUFhNWxDLEVBQWIsRUFBaUJFLEVBQWpCLEVBQXFCZ0IsRUFBckIsQ0FGckIsRUFHTDBpQyxVQUhLLENBQVA7QUFJRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU3BKLFNBQVQsQ0FBbUJnSixNQUFuQixFQUEyQjtBQUNoQyxTQUFPQSxPQUFPLENBQVAsSUFBWUEsT0FBTyxDQUFQLENBQW5CO0FBQ0Q7O0FBR0Q7Ozs7O0FBS08sU0FBU1YsbUJBQVQsQ0FBNkJrQixPQUE3QixFQUFzQ0MsT0FBdEMsRUFBK0M7QUFDcEQsTUFBTTRCLGVBQWU5QyxnQkFBZ0JpQixPQUFoQixFQUF5QkMsT0FBekIsQ0FBckI7QUFDQSxTQUFPekIsUUFBUXFELFlBQVIsQ0FBUDtBQUNEOztBQUdEOzs7Ozs7OztBQVFPLFNBQVM5QyxlQUFULENBQXlCaUIsT0FBekIsRUFBa0NDLE9BQWxDLEVBQTJDTCxVQUEzQyxFQUF1RDtBQUM1RCxNQUFNaUMsZUFBZWpDLGFBQWFBLFVBQWIsR0FBMEJoQyxhQUEvQztBQUNBLE1BQUlsSCxXQUFXc0osT0FBWCxFQUFvQkMsT0FBcEIsQ0FBSixFQUFrQztBQUNoQyxRQUFJRCxRQUFRLENBQVIsSUFBYUMsUUFBUSxDQUFSLENBQWpCLEVBQTZCO0FBQzNCNEIsbUJBQWEsQ0FBYixJQUFrQjdCLFFBQVEsQ0FBUixDQUFsQjtBQUNELEtBRkQsTUFFTztBQUNMNkIsbUJBQWEsQ0FBYixJQUFrQjVCLFFBQVEsQ0FBUixDQUFsQjtBQUNEO0FBQ0QsUUFBSUQsUUFBUSxDQUFSLElBQWFDLFFBQVEsQ0FBUixDQUFqQixFQUE2QjtBQUMzQjRCLG1CQUFhLENBQWIsSUFBa0I3QixRQUFRLENBQVIsQ0FBbEI7QUFDRCxLQUZELE1BRU87QUFDTDZCLG1CQUFhLENBQWIsSUFBa0I1QixRQUFRLENBQVIsQ0FBbEI7QUFDRDtBQUNELFFBQUlELFFBQVEsQ0FBUixJQUFhQyxRQUFRLENBQVIsQ0FBakIsRUFBNkI7QUFDM0I0QixtQkFBYSxDQUFiLElBQWtCN0IsUUFBUSxDQUFSLENBQWxCO0FBQ0QsS0FGRCxNQUVPO0FBQ0w2QixtQkFBYSxDQUFiLElBQWtCNUIsUUFBUSxDQUFSLENBQWxCO0FBQ0Q7QUFDRCxRQUFJRCxRQUFRLENBQVIsSUFBYUMsUUFBUSxDQUFSLENBQWpCLEVBQTZCO0FBQzNCNEIsbUJBQWEsQ0FBYixJQUFrQjdCLFFBQVEsQ0FBUixDQUFsQjtBQUNELEtBRkQsTUFFTztBQUNMNkIsbUJBQWEsQ0FBYixJQUFrQjVCLFFBQVEsQ0FBUixDQUFsQjtBQUNEO0FBQ0YsR0FyQkQsTUFxQk87QUFDTHBDLHdCQUFvQmdFLFlBQXBCO0FBQ0Q7QUFDRCxTQUFPQSxZQUFQO0FBQ0Q7O0FBR0Q7Ozs7QUFJTyxTQUFTN0MsU0FBVCxDQUFtQlEsTUFBbkIsRUFBMkI7QUFDaEMsU0FBTy9JLFNBQVMrSSxNQUFULElBQW1CaEosVUFBVWdKLE1BQVYsQ0FBMUI7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU251RCxPQUFULENBQWlCbXVELE1BQWpCLEVBQXlCO0FBQzlCLFNBQU8sQ0FBQ0EsT0FBTyxDQUFQLElBQVlBLE9BQU8sQ0FBUCxDQUFiLEVBQXdCQSxPQUFPLENBQVAsSUFBWUEsT0FBTyxDQUFQLENBQXBDLENBQVA7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU1AsVUFBVCxDQUFvQk8sTUFBcEIsRUFBNEI7QUFDakMsU0FBTyxDQUFDQSxPQUFPLENBQVAsQ0FBRCxFQUFZQSxPQUFPLENBQVAsQ0FBWixDQUFQO0FBQ0Q7O0FBR0Q7Ozs7OztBQU1PLFNBQVNOLFdBQVQsQ0FBcUJNLE1BQXJCLEVBQTZCO0FBQ2xDLFNBQU8sQ0FBQ0EsT0FBTyxDQUFQLENBQUQsRUFBWUEsT0FBTyxDQUFQLENBQVosQ0FBUDtBQUNEOztBQUdEOzs7Ozs7QUFNTyxTQUFTL0ksUUFBVCxDQUFrQitJLE1BQWxCLEVBQTBCO0FBQy9CLFNBQU9BLE9BQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsQ0FBbkI7QUFDRDs7QUFHRDs7Ozs7OztBQU9PLFNBQVM5SSxVQUFULENBQW9Cc0osT0FBcEIsRUFBNkJDLE9BQTdCLEVBQXNDO0FBQzNDLFNBQU9ELFFBQVEsQ0FBUixLQUFjQyxRQUFRLENBQVIsQ0FBZCxJQUNIRCxRQUFRLENBQVIsS0FBY0MsUUFBUSxDQUFSLENBRFgsSUFFSEQsUUFBUSxDQUFSLEtBQWNDLFFBQVEsQ0FBUixDQUZYLElBR0hELFFBQVEsQ0FBUixLQUFjQyxRQUFRLENBQVIsQ0FIbEI7QUFJRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU2QsT0FBVCxDQUFpQkssTUFBakIsRUFBeUI7QUFDOUIsU0FBT0EsT0FBTyxDQUFQLElBQVlBLE9BQU8sQ0FBUCxDQUFaLElBQXlCQSxPQUFPLENBQVAsSUFBWUEsT0FBTyxDQUFQLENBQTVDO0FBQ0Q7O0FBR0Q7Ozs7O0FBS08sU0FBU0osY0FBVCxDQUF3QkksTUFBeEIsRUFBZ0NJLFVBQWhDLEVBQTRDO0FBQ2pELE1BQUlBLFVBQUosRUFBZ0I7QUFDZEEsZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQUksZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQUksZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQUksZUFBVyxDQUFYLElBQWdCSixPQUFPLENBQVAsQ0FBaEI7QUFDQSxXQUFPSSxVQUFQO0FBQ0QsR0FORCxNQU1PO0FBQ0wsV0FBT0osTUFBUDtBQUNEO0FBQ0Y7O0FBR0Q7Ozs7QUFJTyxTQUFTSCxlQUFULENBQXlCRyxNQUF6QixFQUFpQ25wRCxLQUFqQyxFQUF3QztBQUM3QyxNQUFNeXJELFNBQVUsQ0FBQ3RDLE9BQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsQ0FBYixJQUEwQixDQUEzQixJQUFpQ25wRCxRQUFRLENBQXpDLENBQWY7QUFDQSxNQUFNMHJELFNBQVUsQ0FBQ3ZDLE9BQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsQ0FBYixJQUEwQixDQUEzQixJQUFpQ25wRCxRQUFRLENBQXpDLENBQWY7QUFDQW1wRCxTQUFPLENBQVAsS0FBYXNDLE1BQWI7QUFDQXRDLFNBQU8sQ0FBUCxLQUFhc0MsTUFBYjtBQUNBdEMsU0FBTyxDQUFQLEtBQWF1QyxNQUFiO0FBQ0F2QyxTQUFPLENBQVAsS0FBYXVDLE1BQWI7QUFDRDs7QUFHRDs7Ozs7Ozs7QUFRTyxTQUFTekMsaUJBQVQsQ0FBMkJFLE1BQTNCLEVBQW1DejhDLEtBQW5DLEVBQTBDUCxHQUExQyxFQUErQztBQUNwRCxNQUFJazBDLGFBQWEsS0FBakI7QUFDQSxNQUFNc0wsV0FBV3JFLHVCQUF1QjZCLE1BQXZCLEVBQStCejhDLEtBQS9CLENBQWpCO0FBQ0EsTUFBTWsvQyxTQUFTdEUsdUJBQXVCNkIsTUFBdkIsRUFBK0JoOUMsR0FBL0IsQ0FBZjtBQUNBLE1BQUl3L0MsYUFBYTdCLHVCQUFhTSxZQUExQixJQUNBd0IsV0FBVzlCLHVCQUFhTSxZQUQ1QixFQUMwQztBQUN4Qy9KLGlCQUFhLElBQWI7QUFDRCxHQUhELE1BR087QUFDTCxRQUFNVCxPQUFPdUosT0FBTyxDQUFQLENBQWI7QUFDQSxRQUFNckosT0FBT3FKLE9BQU8sQ0FBUCxDQUFiO0FBQ0EsUUFBTXRKLE9BQU9zSixPQUFPLENBQVAsQ0FBYjtBQUNBLFFBQU1wSixPQUFPb0osT0FBTyxDQUFQLENBQWI7QUFDQSxRQUFNMEMsU0FBU24vQyxNQUFNLENBQU4sQ0FBZjtBQUNBLFFBQU1vL0MsU0FBU3AvQyxNQUFNLENBQU4sQ0FBZjtBQUNBLFFBQU1xL0MsT0FBTzUvQyxJQUFJLENBQUosQ0FBYjtBQUNBLFFBQU02L0MsT0FBTzcvQyxJQUFJLENBQUosQ0FBYjtBQUNBLFFBQU04L0MsUUFBUSxDQUFDRCxPQUFPRixNQUFSLEtBQW1CQyxPQUFPRixNQUExQixDQUFkO0FBQ0EsUUFBSTc0QyxVQUFKO0FBQUEsUUFBT2dRLFVBQVA7QUFDQSxRQUFJLENBQUMsRUFBRTRvQyxTQUFTOUIsdUJBQWFLLEtBQXhCLENBQUQsSUFDQSxFQUFFd0IsV0FBVzdCLHVCQUFhSyxLQUExQixDQURKLEVBQ3NDO0FBQ3BDO0FBQ0FuM0MsVUFBSSs0QyxPQUFRLENBQUNDLE9BQU9qTSxJQUFSLElBQWdCa00sS0FBNUI7QUFDQTVMLG1CQUFhcnRDLEtBQUs0c0MsSUFBTCxJQUFhNXNDLEtBQUs2c0MsSUFBL0I7QUFDRDtBQUNELFFBQUksQ0FBQ1EsVUFBRCxJQUFlLENBQUMsRUFBRXVMLFNBQVM5Qix1QkFBYUcsS0FBeEIsQ0FBaEIsSUFDQSxFQUFFMEIsV0FBVzdCLHVCQUFhRyxLQUExQixDQURKLEVBQ3NDO0FBQ3BDO0FBQ0FqbkMsVUFBSWdwQyxPQUFRLENBQUNELE9BQU9sTSxJQUFSLElBQWdCb00sS0FBNUI7QUFDQTVMLG1CQUFhcjlCLEtBQUs4OEIsSUFBTCxJQUFhOThCLEtBQUsrOEIsSUFBL0I7QUFDRDtBQUNELFFBQUksQ0FBQ00sVUFBRCxJQUFlLENBQUMsRUFBRXVMLFNBQVM5Qix1QkFBYUksS0FBeEIsQ0FBaEIsSUFDQSxFQUFFeUIsV0FBVzdCLHVCQUFhSSxLQUExQixDQURKLEVBQ3NDO0FBQ3BDO0FBQ0FsM0MsVUFBSSs0QyxPQUFRLENBQUNDLE9BQU9sTSxJQUFSLElBQWdCbU0sS0FBNUI7QUFDQTVMLG1CQUFhcnRDLEtBQUs0c0MsSUFBTCxJQUFhNXNDLEtBQUs2c0MsSUFBL0I7QUFDRDtBQUNELFFBQUksQ0FBQ1EsVUFBRCxJQUFlLENBQUMsRUFBRXVMLFNBQVM5Qix1QkFBYUUsSUFBeEIsQ0FBaEIsSUFDQSxFQUFFMkIsV0FBVzdCLHVCQUFhRSxJQUExQixDQURKLEVBQ3FDO0FBQ25DO0FBQ0FobkMsVUFBSWdwQyxPQUFRLENBQUNELE9BQU9uTSxJQUFSLElBQWdCcU0sS0FBNUI7QUFDQTVMLG1CQUFhcjlCLEtBQUs4OEIsSUFBTCxJQUFhOThCLEtBQUsrOEIsSUFBL0I7QUFDRDtBQUVGO0FBQ0QsU0FBT00sVUFBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7QUFTTyxTQUFTNkksY0FBVCxDQUF3QkMsTUFBeEIsRUFBZ0MrQyxXQUFoQyxFQUE2QzNDLFVBQTdDLEVBQXlEO0FBQzlELE1BQU10bUQsY0FBYyxDQUNsQmttRCxPQUFPLENBQVAsQ0FEa0IsRUFDUEEsT0FBTyxDQUFQLENBRE8sRUFFbEJBLE9BQU8sQ0FBUCxDQUZrQixFQUVQQSxPQUFPLENBQVAsQ0FGTyxFQUdsQkEsT0FBTyxDQUFQLENBSGtCLEVBR1BBLE9BQU8sQ0FBUCxDQUhPLEVBSWxCQSxPQUFPLENBQVAsQ0FKa0IsRUFJUEEsT0FBTyxDQUFQLENBSk8sQ0FBcEI7QUFNQStDLGNBQVlqcEQsV0FBWixFQUF5QkEsV0FBekIsRUFBc0MsQ0FBdEM7QUFDQSxNQUFNb21ELEtBQUssQ0FBQ3BtRCxZQUFZLENBQVosQ0FBRCxFQUFpQkEsWUFBWSxDQUFaLENBQWpCLEVBQWlDQSxZQUFZLENBQVosQ0FBakMsRUFBaURBLFlBQVksQ0FBWixDQUFqRCxDQUFYO0FBQ0EsTUFBTXFtRCxLQUFLLENBQUNybUQsWUFBWSxDQUFaLENBQUQsRUFBaUJBLFlBQVksQ0FBWixDQUFqQixFQUFpQ0EsWUFBWSxDQUFaLENBQWpDLEVBQWlEQSxZQUFZLENBQVosQ0FBakQsQ0FBWDtBQUNBLFNBQU9tbUQsbUJBQW1CQyxFQUFuQixFQUF1QkMsRUFBdkIsRUFBMkJDLFVBQTNCLENBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzd4QkQ7Ozs7QUFJQTs7OztrQkFJZTtBQUNibUIsZUFBYSxhQURBO0FBRWJDLGdCQUFjLGNBRkQ7QUFHYkMsWUFBVSxVQUhHO0FBSWJDLGFBQVc7QUFKRSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1JmOzs7O0FBSUE7Ozs7a0JBSWU7QUFDYmQsV0FBUyxDQURJO0FBRWJLLGdCQUFjLENBRkQ7QUFHYkQsU0FBTyxDQUhNO0FBSWJGLFNBQU8sQ0FKTTtBQUtiQyxTQUFPLENBTE07QUFNYkYsUUFBTTtBQU5PLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDQUNtQyxJLEdBQUFBLEk7UUFRQUMsSyxHQUFBQSxLO1FBU0E5UixTLEdBQUFBLFM7QUF6QmhCOzs7O0FBSUE7Ozs7QUFJTyxTQUFTNlIsSUFBVCxHQUFnQjtBQUNyQixTQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQUlPLFNBQVNDLEtBQVQsR0FBaUI7QUFDdEIsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS08sU0FBUzlSLFNBQVQsR0FBcUIsQ0FBRSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCOUI7Ozs7QUFJQTs7Ozs7O2tCQU1lO0FBQ2IrUixTQUFPLE9BRE07QUFFYkMsZUFBYSxZQUZBO0FBR2JDLGVBQWEsWUFIQTtBQUliQyxXQUFTLFNBSkk7QUFLYkMsZUFBYSxZQUxBO0FBTWJDLHFCQUFtQixpQkFOTjtBQU9iQyxpQkFBZSxjQVBGO0FBUWJDLHVCQUFxQixvQkFSUjtBQVNiQyxVQUFRO0FBVEssQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDcUZDQyxRLEdBQUFBLFE7UUFxQkFDLE0sR0FBQUEsTTs7QUFoSGhCOztBQUdBOzs7Ozs7O0FBUUE7Ozs7OztBQU1PLElBQU1DLG9DQUFjLElBQXBCOztBQUdQOzs7Ozs7QUF4QkE7Ozs7QUE4QkEsSUFBSUMsK0JBQUosQyxDQUE0Qjs7O0FBRzVCOzs7OztBQUtBLElBQUlDLHlCQUFKLEMsQ0FBc0I7OztBQUd0Qjs7Ozs7QUFLQSxJQUFJQyxZQUFZLEtBQWhCOztBQUdBLElBQUksT0FBT2oyRCxNQUFQLEtBQWtCLFdBQWxCLElBQWlDLDJCQUEyQkEsTUFBaEUsRUFBd0U7QUFDdEUsTUFBSTtBQUNGLFFBQU1zbEQsU0FBUyxnQ0FBa0N4bkQsU0FBU0csYUFBVCxDQUF1QixRQUF2QixDQUFqRDtBQUNBLFFBQU1pNEQsS0FBSyx1QkFBVzVRLE1BQVgsRUFBbUIsRUFBQzZRLDhCQUE4QixJQUEvQixFQUFuQixDQUFYO0FBQ0EsUUFBSUQsRUFBSixFQUFRO0FBQ04sY0FTRUQsU0FURixlQUFZLElBQVo7QUFDQSxjQVFhRixzQkFSYiw0QkFBeUIscUJBQXVCRyxHQUFHRSxZQUFILENBQWdCRixHQUFHRyxnQkFBbkIsQ0FBaEQ7QUFDQSxjQU9xQ0wsZ0JBUHJDLHNCQUFtQkUsR0FBR0ksc0JBQUgsRUFBbkI7QUFDRDtBQUNGLEdBUkQsQ0FRRSxPQUFPOTBELENBQVAsRUFBVTtBQUNWO0FBQ0Q7QUFDRjs7UUFFT3kwRCxTLEdBQUFBLFM7UUFBV0Ysc0IsR0FBQUEsc0I7UUFBd0JDLGdCLEdBQUFBLGdCOztBQUczQzs7Ozs7QUFJTyxJQUFNalQsNEJBQVUsUUFBaEI7O0FBR1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQk8sU0FBUzZTLFFBQVQsQ0FBa0JXLFNBQWxCLEVBQTZCQyxVQUE3QixFQUF5QztBQUM5Q0QsWUFBVWo3QyxTQUFWLEdBQXNCM0YsT0FBT2lvQixNQUFQLENBQWM0NEIsV0FBV2w3QyxTQUF6QixDQUF0QjtBQUNBaTdDLFlBQVVqN0MsU0FBVixDQUFvQm03QyxXQUFwQixHQUFrQ0YsU0FBbEM7QUFDRDs7QUFHRDs7Ozs7QUFLQSxJQUFJRyxjQUFjLENBQWxCOztBQUVBOzs7Ozs7OztBQVFPLFNBQVNiLE1BQVQsQ0FBZ0IvZ0QsR0FBaEIsRUFBcUI7QUFDMUIsU0FBT0EsSUFBSTZoRCxNQUFKLEtBQWU3aEQsSUFBSTZoRCxNQUFKLEdBQWEsRUFBRUQsV0FBOUIsQ0FBUDtBQUNELEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQ3pHZUUsSyxHQUFBQSxLO1FBb0NBQyxtQixHQUFBQSxtQjtRQWlCQUMsc0IsR0FBQUEsc0I7UUF5QkFDLGUsR0FBQUEsZTtRQWNBQyxpQixHQUFBQSxpQjtRQXVEQUMsUyxHQUFBQSxTO1FBV0FDLFMsR0FBQUEsUztRQVdBQyxNLEdBQUFBLE07UUFhQUMsSSxHQUFBQSxJOztBQWhNaEI7O0FBRUE7Ozs7Ozs7O0FBUU8sU0FBU1IsS0FBVCxDQUFlOXRELEtBQWYsRUFBc0IySSxHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7QUFDckMsU0FBT2tHLEtBQUtuRyxHQUFMLENBQVNtRyxLQUFLbEcsR0FBTCxDQUFTNUksS0FBVCxFQUFnQjJJLEdBQWhCLENBQVQsRUFBK0JDLEdBQS9CLENBQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7O0FBbEJBOzs7QUEyQk8sSUFBTTJsRCxzQkFBUyxZQUFXO0FBQy9CO0FBQ0E7QUFDQSxNQUFJQSxhQUFKO0FBQ0EsTUFBSSxVQUFVei9DLElBQWQsRUFBb0I7QUFDbEI7QUFDQXkvQyxXQUFPei9DLEtBQUt5L0MsSUFBWjtBQUNELEdBSEQsTUFHTztBQUNMO0FBQ0FBLFdBQU8sY0FBU3Y3QyxDQUFULEVBQVk7QUFDakIsVUFBTWdRLElBQUlsVSxLQUFLMC9DLEdBQUwsQ0FBU3g3QyxDQUFULENBQVY7QUFDQSxhQUFPLENBQUNnUSxJQUFJLElBQUlBLENBQVQsSUFBYyxDQUFyQjtBQUNELEtBSEQ7QUFJRDtBQUNELFNBQU91ckMsSUFBUDtBQUNELENBZnFCLEVBQWY7O0FBa0JQOzs7O0FBSU8sU0FBU1IsbUJBQVQsQ0FBNkIvNkMsQ0FBN0IsRUFBZ0M7QUFDckMsdUJBQU8sSUFBSUEsQ0FBWCxFQUFjLEVBQWQsRUFEcUMsQ0FDbEI7QUFDbkIsU0FBT2xFLEtBQUt1VyxHQUFMLENBQVMsQ0FBVCxFQUFZdlcsS0FBS2hHLElBQUwsQ0FBVWdHLEtBQUtpVyxHQUFMLENBQVMvUixDQUFULElBQWNsRSxLQUFLb2tCLEdBQTdCLENBQVosQ0FBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7OztBQVdPLFNBQVM4NkIsc0JBQVQsQ0FBZ0NoN0MsQ0FBaEMsRUFBbUNnUSxDQUFuQyxFQUFzQzBDLEVBQXRDLEVBQTBDQyxFQUExQyxFQUE4Q0MsRUFBOUMsRUFBa0RDLEVBQWxELEVBQXNEO0FBQzNELE1BQU0yakMsS0FBSzVqQyxLQUFLRixFQUFoQjtBQUNBLE1BQU0rakMsS0FBSzVqQyxLQUFLRixFQUFoQjtBQUNBLE1BQUk2akMsT0FBTyxDQUFQLElBQVlDLE9BQU8sQ0FBdkIsRUFBMEI7QUFDeEIsUUFBTXo0QyxJQUFJLENBQUMsQ0FBQ2dDLElBQUkwUyxFQUFMLElBQVc4akMsRUFBWCxHQUFnQixDQUFDeG1DLElBQUkyQyxFQUFMLElBQVc4akMsRUFBNUIsS0FBbUNELEtBQUtBLEVBQUwsR0FBVUMsS0FBS0EsRUFBbEQsQ0FBVjtBQUNBLFFBQUl6NEMsSUFBSSxDQUFSLEVBQVc7QUFDVDBVLFdBQUtFLEVBQUw7QUFDQUQsV0FBS0UsRUFBTDtBQUNELEtBSEQsTUFHTyxJQUFJN1UsSUFBSSxDQUFSLEVBQVc7QUFDaEIwVSxZQUFNOGpDLEtBQUt4NEMsQ0FBWDtBQUNBMlUsWUFBTThqQyxLQUFLejRDLENBQVg7QUFDRDtBQUNGO0FBQ0QsU0FBT2k5QyxnQkFBZ0JqN0MsQ0FBaEIsRUFBbUJnUSxDQUFuQixFQUFzQjBDLEVBQXRCLEVBQTBCQyxFQUExQixDQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7O0FBUU8sU0FBU3NvQyxlQUFULENBQXlCdm9DLEVBQXpCLEVBQTZCQyxFQUE3QixFQUFpQ0MsRUFBakMsRUFBcUNDLEVBQXJDLEVBQXlDO0FBQzlDLE1BQU0yakMsS0FBSzVqQyxLQUFLRixFQUFoQjtBQUNBLE1BQU0rakMsS0FBSzVqQyxLQUFLRixFQUFoQjtBQUNBLFNBQU82akMsS0FBS0EsRUFBTCxHQUFVQyxLQUFLQSxFQUF0QjtBQUNEOztBQUdEOzs7Ozs7O0FBT08sU0FBU3lFLGlCQUFULENBQTJCTyxHQUEzQixFQUFnQztBQUNyQyxNQUFNLzlDLElBQUkrOUMsSUFBSXQ2RCxNQUFkOztBQUVBLE9BQUssSUFBSUwsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNGMsQ0FBcEIsRUFBdUI1YyxHQUF2QixFQUE0QjtBQUMxQjtBQUNBLFFBQUk0NkQsU0FBUzU2RCxDQUFiO0FBQ0EsUUFBSTY2RCxRQUFRNy9DLEtBQUtqRyxHQUFMLENBQVM0bEQsSUFBSTM2RCxDQUFKLEVBQU9BLENBQVAsQ0FBVCxDQUFaO0FBQ0EsU0FBSyxJQUFJOEQsSUFBSTlELElBQUksQ0FBakIsRUFBb0I4RCxJQUFJOFksQ0FBeEIsRUFBMkI5WSxHQUEzQixFQUFnQztBQUM5QixVQUFNZzNELFdBQVc5L0MsS0FBS2pHLEdBQUwsQ0FBUzRsRCxJQUFJNzJELENBQUosRUFBTzlELENBQVAsQ0FBVCxDQUFqQjtBQUNBLFVBQUk4NkQsV0FBV0QsS0FBZixFQUFzQjtBQUNwQkEsZ0JBQVFDLFFBQVI7QUFDQUYsaUJBQVM5MkQsQ0FBVDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSSsyRCxVQUFVLENBQWQsRUFBaUI7QUFDZixhQUFPLElBQVAsQ0FEZSxDQUNGO0FBQ2Q7O0FBRUQ7QUFDQSxRQUFNN2dCLE1BQU0yZ0IsSUFBSUMsTUFBSixDQUFaO0FBQ0FELFFBQUlDLE1BQUosSUFBY0QsSUFBSTM2RCxDQUFKLENBQWQ7QUFDQTI2RCxRQUFJMzZELENBQUosSUFBU2c2QyxHQUFUOztBQUVBO0FBQ0EsU0FBSyxJQUFJajlCLElBQUkvYyxJQUFJLENBQWpCLEVBQW9CK2MsSUFBSUgsQ0FBeEIsRUFBMkJHLEdBQTNCLEVBQWdDO0FBQzlCLFVBQU1nK0MsT0FBTyxDQUFDSixJQUFJNTlDLENBQUosRUFBTy9jLENBQVAsQ0FBRCxHQUFhMjZELElBQUkzNkQsQ0FBSixFQUFPQSxDQUFQLENBQTFCO0FBQ0EsV0FBSyxJQUFJdWMsSUFBSXZjLENBQWIsRUFBZ0J1YyxJQUFJSyxJQUFJLENBQXhCLEVBQTJCTCxHQUEzQixFQUFnQztBQUM5QixZQUFJdmMsS0FBS3VjLENBQVQsRUFBWTtBQUNWbytDLGNBQUk1OUMsQ0FBSixFQUFPUixDQUFQLElBQVksQ0FBWjtBQUNELFNBRkQsTUFFTztBQUNMbytDLGNBQUk1OUMsQ0FBSixFQUFPUixDQUFQLEtBQWF3K0MsT0FBT0osSUFBSTM2RCxDQUFKLEVBQU91YyxDQUFQLENBQXBCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQSxNQUFNMkMsSUFBSSxJQUFJaGYsS0FBSixDQUFVMGMsQ0FBVixDQUFWO0FBQ0EsT0FBSyxJQUFJNVcsSUFBSTRXLElBQUksQ0FBakIsRUFBb0I1VyxLQUFLLENBQXpCLEVBQTRCQSxHQUE1QixFQUFpQztBQUMvQmtaLE1BQUVsWixDQUFGLElBQU8yMEQsSUFBSTMwRCxDQUFKLEVBQU80VyxDQUFQLElBQVkrOUMsSUFBSTMwRCxDQUFKLEVBQU9BLENBQVAsQ0FBbkI7QUFDQSxTQUFLLElBQUl5WCxJQUFJelgsSUFBSSxDQUFqQixFQUFvQnlYLEtBQUssQ0FBekIsRUFBNEJBLEdBQTVCLEVBQWlDO0FBQy9CazlDLFVBQUlsOUMsQ0FBSixFQUFPYixDQUFQLEtBQWErOUMsSUFBSWw5QyxDQUFKLEVBQU96WCxDQUFQLElBQVlrWixFQUFFbFosQ0FBRixDQUF6QjtBQUNEO0FBQ0Y7QUFDRCxTQUFPa1osQ0FBUDtBQUNEOztBQUdEOzs7Ozs7QUFNTyxTQUFTbTdDLFNBQVQsQ0FBbUJXLGNBQW5CLEVBQW1DO0FBQ3hDLFNBQU9BLGlCQUFpQixHQUFqQixHQUF1QmhnRCxLQUFLZ1csRUFBbkM7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU3NwQyxTQUFULENBQW1CVyxjQUFuQixFQUFtQztBQUN4QyxTQUFPQSxpQkFBaUJqZ0QsS0FBS2dXLEVBQXRCLEdBQTJCLEdBQWxDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTdXBDLE1BQVQsQ0FBZ0J0dkQsQ0FBaEIsRUFBbUJnZixDQUFuQixFQUFzQjtBQUMzQixNQUFNbm1CLElBQUltSCxJQUFJZ2YsQ0FBZDtBQUNBLFNBQU9ubUIsSUFBSW1tQixDQUFKLEdBQVEsQ0FBUixHQUFZbm1CLElBQUltbUIsQ0FBaEIsR0FBb0JubUIsQ0FBM0I7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRTyxTQUFTMDJELElBQVQsQ0FBY3Z2RCxDQUFkLEVBQWlCZ2YsQ0FBakIsRUFBb0IvSyxDQUFwQixFQUF1QjtBQUM1QixTQUFPalUsSUFBSWlVLEtBQUsrSyxJQUFJaGYsQ0FBVCxDQUFYO0FBQ0QsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUMvSmVpd0QsSyxHQUFBQSxLO1FBYUFDLFMsR0FBQUEsUztRQWNBbkcsTyxHQUFBQSxPO0FBakVoQjs7OztBQUtBOzs7Ozs7Ozs7QUFTTyxJQUFNb0csMEJBQVUsT0FBT3JpRCxPQUFPcWlELE1BQWQsS0FBeUIsVUFBMUIsR0FBd0NyaUQsT0FBT3FpRCxNQUEvQyxHQUF3RCxVQUFTcHdELE1BQVQsRUFBaUJxd0QsV0FBakIsRUFBOEI7QUFDMUcsTUFBSXJ3RCxXQUFXaEgsU0FBWCxJQUF3QmdILFdBQVcsSUFBdkMsRUFBNkM7QUFDM0MsVUFBTSxJQUFJOFcsU0FBSixDQUFjLDRDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFNckcsU0FBUzFDLE9BQU8vTixNQUFQLENBQWY7QUFDQSxPQUFLLElBQUloTCxJQUFJLENBQVIsRUFBV0MsS0FBS3d6QyxVQUFVcHpDLE1BQS9CLEVBQXVDTCxJQUFJQyxFQUEzQyxFQUErQyxFQUFFRCxDQUFqRCxFQUFvRDtBQUNsRCxRQUFNdUMsU0FBU2t4QyxVQUFVenpDLENBQVYsQ0FBZjtBQUNBLFFBQUl1QyxXQUFXeUIsU0FBWCxJQUF3QnpCLFdBQVcsSUFBdkMsRUFBNkM7QUFDM0MsV0FBSyxJQUFNOEcsR0FBWCxJQUFrQjlHLE1BQWxCLEVBQTBCO0FBQ3hCLFlBQUlBLE9BQU8yYixjQUFQLENBQXNCN1UsR0FBdEIsQ0FBSixFQUFnQztBQUM5Qm9TLGlCQUFPcFMsR0FBUCxJQUFjOUcsT0FBTzhHLEdBQVAsQ0FBZDtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsU0FBT29TLE1BQVA7QUFDRCxDQWpCTTs7QUFvQlA7Ozs7QUFJTyxTQUFTeS9DLEtBQVQsQ0FBZXJuRCxNQUFmLEVBQXVCO0FBQzVCLE9BQUssSUFBTWtELFFBQVgsSUFBdUJsRCxNQUF2QixFQUErQjtBQUM3QixXQUFPQSxPQUFPa0QsUUFBUCxDQUFQO0FBQ0Q7QUFDRjs7QUFHRDs7Ozs7O0FBTU8sU0FBU29rRCxTQUFULENBQW1CdG5ELE1BQW5CLEVBQTJCO0FBQ2hDLE1BQU1oSSxTQUFTLEVBQWY7QUFDQSxPQUFLLElBQU1rTCxRQUFYLElBQXVCbEQsTUFBdkIsRUFBK0I7QUFDN0JoSSxXQUFPN0ssSUFBUCxDQUFZNlMsT0FBT2tELFFBQVAsQ0FBWjtBQUNEO0FBQ0QsU0FBT2xMLE1BQVA7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTbXBELE9BQVQsQ0FBaUJuaEQsTUFBakIsRUFBeUI7QUFDOUIsTUFBSWtELGlCQUFKO0FBQ0EsT0FBS0EsUUFBTCxJQUFpQmxELE1BQWpCLEVBQXlCO0FBQ3ZCLFdBQU8sS0FBUDtBQUNEO0FBQ0QsU0FBTyxDQUFDa0QsUUFBUjtBQUNELEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQ3dCZXVrRCxjLEdBQUFBLGM7UUFvQkFDLGlCLEdBQUFBLGlCO1FBa0JBQyxhLEdBQUFBLGE7UUFTQUMsYyxHQUFBQSxjO1FBY0Fod0QsRyxHQUFBQSxHO1FBZ0NBaXdELGtCLEdBQUFBLGtCO1FBNENBQyx3QixHQUFBQSx3QjtRQXlCQUMsdUIsR0FBQUEsdUI7UUFhQUMsbUIsR0FBQUEsbUI7UUFXQUMsZ0IsR0FBQUEsZ0I7UUFvQkFDLHNDLEdBQUFBLHNDO1FBNENBQyx1QixHQUFBQSx1QjtRQWlCQUMsVSxHQUFBQSxVO1FBZUFDLFEsR0FBQUEsUTtRQXFCQUMsVSxHQUFBQSxVO1FBdUJBQywyQixHQUFBQSwyQjtRQXFCQUMsWSxHQUFBQSxZO1FBcUJBQyxTLEdBQUFBLFM7UUFnQkFDLGUsR0FBQUEsZTtRQWNBQyx3QixHQUFBQSx3QjtRQVVBQyxTLEdBQUFBLFM7O0FBaGNoQjs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0lBQVlDLFc7O0FBQ1o7Ozs7OztBQUdBOzs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7UUFXUUMsZSxHQUFBQSxzQjs7QUFHUjs7Ozs7OztBQXhGQTs7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkZPLFNBQVNyQixjQUFULENBQXdCNytDLEtBQXhCLEVBQStCbWdELFVBQS9CLEVBQTJDQyxhQUEzQyxFQUEwRDtBQUMvRCxNQUFJcGhELGVBQUo7QUFDQSxNQUFJbWhELGVBQWU1NEQsU0FBbkIsRUFBOEI7QUFDNUIsU0FBSyxJQUFJaEUsSUFBSSxDQUFSLEVBQVdDLEtBQUt3YyxNQUFNcGMsTUFBM0IsRUFBbUNMLElBQUlDLEVBQXZDLEVBQTJDLEVBQUVELENBQTdDLEVBQWdEO0FBQzlDNDhELGlCQUFXNThELENBQVgsSUFBZ0J5YyxNQUFNemMsQ0FBTixDQUFoQjtBQUNEO0FBQ0R5YixhQUFTbWhELFVBQVQ7QUFDRCxHQUxELE1BS087QUFDTG5oRCxhQUFTZ0IsTUFBTXRSLEtBQU4sRUFBVDtBQUNEO0FBQ0QsU0FBT3NRLE1BQVA7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBUzgvQyxpQkFBVCxDQUEyQjkrQyxLQUEzQixFQUFrQ21nRCxVQUFsQyxFQUE4Q0MsYUFBOUMsRUFBNkQ7QUFDbEUsTUFBSUQsZUFBZTU0RCxTQUFmLElBQTRCeVksVUFBVW1nRCxVQUExQyxFQUFzRDtBQUNwRCxTQUFLLElBQUk1OEQsSUFBSSxDQUFSLEVBQVdDLEtBQUt3YyxNQUFNcGMsTUFBM0IsRUFBbUNMLElBQUlDLEVBQXZDLEVBQTJDLEVBQUVELENBQTdDLEVBQWdEO0FBQzlDNDhELGlCQUFXNThELENBQVgsSUFBZ0J5YyxNQUFNemMsQ0FBTixDQUFoQjtBQUNEO0FBQ0R5YyxZQUFRbWdELFVBQVI7QUFDRDtBQUNELFNBQU9uZ0QsS0FBUDtBQUNEOztBQUdEOzs7Ozs7O0FBT08sU0FBUysrQyxhQUFULENBQXVCdnVELFVBQXZCLEVBQW1DO0FBQ3hDeXZELGNBQVlJLEdBQVosQ0FBZ0I3dkQsV0FBVzh2RCxPQUFYLEVBQWhCLEVBQXNDOXZELFVBQXRDO0FBQ0EsdUJBQWlCQSxVQUFqQixFQUE2QkEsVUFBN0IsRUFBeUNxdUQsY0FBekM7QUFDRDs7QUFHRDs7O0FBR08sU0FBU0csY0FBVCxDQUF3QmlCLFdBQXhCLEVBQXFDO0FBQzFDQSxjQUFZaDNDLE9BQVosQ0FBb0I4MUMsYUFBcEI7QUFDRDs7QUFHRDs7Ozs7Ozs7O0FBU08sU0FBUy92RCxHQUFULENBQWF1eEQsY0FBYixFQUE2QjtBQUNsQyxNQUFJL3ZELGFBQWEsSUFBakI7QUFDQSxNQUFJK3ZELDBCQUEwQkMsb0JBQTlCLEVBQTBDO0FBQ3hDaHdELGlCQUFhK3ZELGNBQWI7QUFDRCxHQUZELE1BRU8sSUFBSSxPQUFPQSxjQUFQLEtBQTBCLFFBQTlCLEVBQXdDO0FBQzdDLFFBQU12akIsT0FBT3VqQixjQUFiO0FBQ0EvdkQsaUJBQWF5dkQsWUFBWWp4RCxHQUFaLENBQWdCZ3VDLElBQWhCLENBQWI7QUFDRDtBQUNELFNBQU94c0MsVUFBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CTyxTQUFTeXVELGtCQUFULENBQTRCenVELFVBQTVCLEVBQXdDK3BELFVBQXhDLEVBQW9EaG1ELEtBQXBELEVBQTJEa3NELFNBQTNELEVBQXNFO0FBQzNFandELGVBQWF4QixJQUFJd0IsVUFBSixDQUFiO0FBQ0EsTUFBSWt3RCx3QkFBSjtBQUNBLE1BQU1DLFNBQVNud0QsV0FBV293RCxzQkFBWCxFQUFmO0FBQ0EsTUFBSUQsTUFBSixFQUFZO0FBQ1ZELHNCQUFrQkMsT0FBT3BHLFVBQVAsRUFBbUJobUQsS0FBbkIsQ0FBbEI7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFNM0UsUUFBUVksV0FBV3F3RCxRQUFYLEVBQWQ7QUFDQSxRQUFJanhELFNBQVNreEQsZ0JBQU1DLE9BQWYsSUFBMEIsQ0FBQ04sU0FBM0IsSUFBd0NBLGFBQWFLLGdCQUFNQyxPQUEvRCxFQUF3RTtBQUN0RUwsd0JBQWtCbkcsVUFBbEI7QUFDRCxLQUZELE1BRU87QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFNeUcsVUFBYXJCLDRCQUE0Qm52RCxVQUE1QixFQUF3Q3hCLElBQUksV0FBSixDQUF4QyxDQUFuQjtBQUNBLFVBQUlpeUQsV0FBVyxDQUNiMXNELE1BQU0sQ0FBTixJQUFXZ21ELGFBQWEsQ0FEWCxFQUNjaG1ELE1BQU0sQ0FBTixDQURkLEVBRWJBLE1BQU0sQ0FBTixJQUFXZ21ELGFBQWEsQ0FGWCxFQUVjaG1ELE1BQU0sQ0FBTixDQUZkLEVBR2JBLE1BQU0sQ0FBTixDQUhhLEVBR0hBLE1BQU0sQ0FBTixJQUFXZ21ELGFBQWEsQ0FIckIsRUFJYmhtRCxNQUFNLENBQU4sQ0FKYSxFQUlIQSxNQUFNLENBQU4sSUFBV2dtRCxhQUFhLENBSnJCLENBQWY7QUFNQTBHLGlCQUFXRCxRQUFXQyxRQUFYLEVBQXFCQSxRQUFyQixFQUErQixDQUEvQixDQUFYO0FBQ0EsVUFBTXZzRCxRQUFRLHlCQUFZdXNELFNBQVN2eUQsS0FBVCxDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBWixFQUFrQ3V5RCxTQUFTdnlELEtBQVQsQ0FBZSxDQUFmLEVBQWtCLENBQWxCLENBQWxDLENBQWQ7QUFDQSxVQUFNaUcsU0FBUyx5QkFBWXNzRCxTQUFTdnlELEtBQVQsQ0FBZSxDQUFmLEVBQWtCLENBQWxCLENBQVosRUFBa0N1eUQsU0FBU3Z5RCxLQUFULENBQWUsQ0FBZixFQUFrQixDQUFsQixDQUFsQyxDQUFmO0FBQ0FneUQsd0JBQWtCLENBQUNoc0QsUUFBUUMsTUFBVCxJQUFtQixDQUFyQztBQUNBLFVBQU11c0QsZ0JBQWdCVCxZQUNwQlAsdUJBQWdCTyxTQUFoQixDQURvQixHQUVwQmp3RCxXQUFXMndELGdCQUFYLEVBRkY7QUFHQSxVQUFJRCxrQkFBa0IzNUQsU0FBdEIsRUFBaUM7QUFDL0JtNUQsMkJBQW1CUSxhQUFuQjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU9SLGVBQVA7QUFDRDs7QUFHRDs7Ozs7OztBQU9PLFNBQVN4Qix3QkFBVCxDQUFrQ2UsV0FBbEMsRUFBK0M7QUFDcERqQixpQkFBZWlCLFdBQWY7QUFDQUEsY0FBWWgzQyxPQUFaLENBQW9CLFVBQVNuakIsTUFBVCxFQUFpQjtBQUNuQ202RCxnQkFBWWgzQyxPQUFaLENBQW9CLFVBQVNtNEMsV0FBVCxFQUFzQjtBQUN4QyxVQUFJdDdELFdBQVdzN0QsV0FBZixFQUE0QjtBQUMxQiw2QkFBaUJ0N0QsTUFBakIsRUFBeUJzN0QsV0FBekIsRUFBc0N2QyxjQUF0QztBQUNEO0FBQ0YsS0FKRDtBQUtELEdBTkQ7QUFPRDs7QUFHRDs7Ozs7Ozs7Ozs7OztBQWFPLFNBQVNNLHVCQUFULENBQWlDa0MsWUFBakMsRUFBK0NDLFlBQS9DLEVBQTZEQyxnQkFBN0QsRUFBK0VDLGdCQUEvRSxFQUFpRztBQUN0R0gsZUFBYXA0QyxPQUFiLENBQXFCLFVBQVN3NEMsV0FBVCxFQUFzQjtBQUN6Q0gsaUJBQWFyNEMsT0FBYixDQUFxQixVQUFTeTRDLFdBQVQsRUFBc0I7QUFDekMsMkJBQWlCRCxXQUFqQixFQUE4QkMsV0FBOUIsRUFBMkNILGdCQUEzQztBQUNBLDJCQUFpQkcsV0FBakIsRUFBOEJELFdBQTlCLEVBQTJDRCxnQkFBM0M7QUFDRCxLQUhEO0FBSUQsR0FMRDtBQU1EOztBQUdEOzs7QUFHTyxTQUFTcEMsbUJBQVQsR0FBK0I7QUFDcENhLGNBQVl4QixLQUFaO0FBQ0E7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTWSxnQkFBVCxDQUEwQjd1RCxVQUExQixFQUFzQ214RCxXQUF0QyxFQUFtRDtBQUN4RCxNQUFJLENBQUNueEQsVUFBTCxFQUFpQjtBQUNmLFdBQU94QixJQUFJMnlELFdBQUosQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJLE9BQU9ueEQsVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUN6QyxXQUFPeEIsSUFBSXdCLFVBQUosQ0FBUDtBQUNELEdBRk0sTUFFQTtBQUNMO0FBQ0UsOENBQTBDQTtBQUQ1QztBQUdEO0FBQ0Y7O0FBR0Q7Ozs7Ozs7QUFPTyxTQUFTOHVELHNDQUFULENBQWdEc0MsY0FBaEQsRUFBZ0U7QUFDckU7QUFDRTs7Ozs7O0FBTUEsY0FBUzVoRCxLQUFULEVBQWdCbWdELFVBQWhCLEVBQTRCQyxhQUE1QixFQUEyQztBQUN6QyxVQUFNeDhELFNBQVNvYyxNQUFNcGMsTUFBckI7QUFDQSxVQUFNaStELFlBQVl6QixrQkFBa0I3NEQsU0FBbEIsR0FBOEI2NEQsYUFBOUIsR0FBOEMsQ0FBaEU7QUFDQSxVQUFNcGhELFNBQVNtaEQsZUFBZTU0RCxTQUFmLEdBQTJCNDRELFVBQTNCLEdBQXdDLElBQUkxOEQsS0FBSixDQUFVRyxNQUFWLENBQXZEO0FBQ0EsV0FBSyxJQUFJTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCTCxLQUFLcytELFNBQWpDLEVBQTRDO0FBQzFDLFlBQU10dEQsUUFBUXF0RCxlQUFlLENBQUM1aEQsTUFBTXpjLENBQU4sQ0FBRCxFQUFXeWMsTUFBTXpjLElBQUksQ0FBVixDQUFYLENBQWYsQ0FBZDtBQUNBeWIsZUFBT3piLENBQVAsSUFBWWdSLE1BQU0sQ0FBTixDQUFaO0FBQ0F5SyxlQUFPemIsSUFBSSxDQUFYLElBQWdCZ1IsTUFBTSxDQUFOLENBQWhCO0FBQ0EsYUFBSyxJQUFJK0wsSUFBSXVoRCxZQUFZLENBQXpCLEVBQTRCdmhELEtBQUssQ0FBakMsRUFBb0MsRUFBRUEsQ0FBdEMsRUFBeUM7QUFDdkN0QixpQkFBT3piLElBQUkrYyxDQUFYLElBQWdCTixNQUFNemMsSUFBSStjLENBQVYsQ0FBaEI7QUFDRDtBQUNGO0FBQ0QsYUFBT3RCLE1BQVA7QUFDRDtBQXBCSDtBQXFCRDs7QUFHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CTyxTQUFTdWdELHVCQUFULENBQWlDejVELE1BQWpDLEVBQXlDczdELFdBQXpDLEVBQXNEaGtDLE9BQXRELEVBQStEMGtDLE9BQS9ELEVBQXdFO0FBQzdFLE1BQU1DLGFBQWEveUQsSUFBSWxKLE1BQUosQ0FBbkI7QUFDQSxNQUFNazhELFdBQVdoekQsSUFBSW95RCxXQUFKLENBQWpCO0FBQ0EsdUJBQWlCVyxVQUFqQixFQUE2QkMsUUFBN0IsRUFBdUMxQyx1Q0FBdUNsaUMsT0FBdkMsQ0FBdkM7QUFDQSx1QkFBaUI0a0MsUUFBakIsRUFBMkJELFVBQTNCLEVBQXVDekMsdUNBQXVDd0MsT0FBdkMsQ0FBdkM7QUFDRDs7QUFHRDs7Ozs7Ozs7O0FBU08sU0FBU3RDLFVBQVQsQ0FBb0JyRyxVQUFwQixFQUFnQzhJLGNBQWhDLEVBQWdEO0FBQ3JELFNBQU9wQyxVQUFVMUcsVUFBVixFQUFzQixXQUF0QixFQUNMOEksbUJBQW1CMTZELFNBQW5CLEdBQStCMDZELGNBQS9CLEdBQWdELFdBRDNDLENBQVA7QUFFRDs7QUFHRDs7Ozs7Ozs7O0FBU08sU0FBU3hDLFFBQVQsQ0FBa0J0RyxVQUFsQixFQUE4QjhJLGNBQTlCLEVBQThDO0FBQ25ELE1BQU1DLFNBQVNyQyxVQUFVMUcsVUFBVixFQUNiOEksbUJBQW1CMTZELFNBQW5CLEdBQStCMDZELGNBQS9CLEdBQWdELFdBRG5DLEVBQ2dELFdBRGhELENBQWY7QUFFQSxNQUFNRSxNQUFNRCxPQUFPLENBQVAsQ0FBWjtBQUNBLE1BQUlDLE1BQU0sQ0FBQyxHQUFQLElBQWNBLE1BQU0sR0FBeEIsRUFBNkI7QUFDM0JELFdBQU8sQ0FBUCxJQUFZLGtCQUFPQyxNQUFNLEdBQWIsRUFBa0IsR0FBbEIsSUFBeUIsR0FBckM7QUFDRDtBQUNELFNBQU9ELE1BQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7OztBQVVPLFNBQVN4QyxVQUFULENBQW9CK0IsV0FBcEIsRUFBaUNDLFdBQWpDLEVBQThDO0FBQ25ELE1BQUlELGdCQUFnQkMsV0FBcEIsRUFBaUM7QUFDL0IsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFNVSxhQUFhWCxZQUFZWixRQUFaLE9BQTJCYSxZQUFZYixRQUFaLEVBQTlDO0FBQ0EsTUFBSVksWUFBWW5CLE9BQVosT0FBMEJvQixZQUFZcEIsT0FBWixFQUE5QixFQUFxRDtBQUNuRCxXQUFPOEIsVUFBUDtBQUNELEdBRkQsTUFFTztBQUNMLFFBQU1DLGdCQUFnQjFDLDRCQUE0QjhCLFdBQTVCLEVBQXlDQyxXQUF6QyxDQUF0QjtBQUNBLFdBQU9XLGtCQUFrQnhELGNBQWxCLElBQW9DdUQsVUFBM0M7QUFDRDtBQUNGOztBQUdEOzs7Ozs7Ozs7QUFTTyxTQUFTekMsMkJBQVQsQ0FBcUMyQyxnQkFBckMsRUFBdURDLHFCQUF2RCxFQUE4RTtBQUNuRixNQUFNQyxhQUFhRixpQkFBaUJoQyxPQUFqQixFQUFuQjtBQUNBLE1BQU1tQyxrQkFBa0JGLHNCQUFzQmpDLE9BQXRCLEVBQXhCO0FBQ0EsTUFBSStCLGdCQUFnQixxQkFBaUJHLFVBQWpCLEVBQTZCQyxlQUE3QixDQUFwQjtBQUNBLE1BQUksQ0FBQ0osYUFBTCxFQUFvQjtBQUNsQkEsb0JBQWdCdkQsaUJBQWhCO0FBQ0Q7QUFDRCxTQUFPdUQsYUFBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7O0FBVU8sU0FBU3pDLFlBQVQsQ0FBc0I5NUQsTUFBdEIsRUFBOEJzN0QsV0FBOUIsRUFBMkM7QUFDaEQsTUFBTWtCLG1CQUFtQnR6RCxJQUFJbEosTUFBSixDQUF6QjtBQUNBLE1BQU15OEQsd0JBQXdCdnpELElBQUlveUQsV0FBSixDQUE5QjtBQUNBLFNBQU96Qiw0QkFBNEIyQyxnQkFBNUIsRUFBOENDLHFCQUE5QyxDQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7Ozs7Ozs7O0FBY08sU0FBUzFDLFNBQVQsQ0FBbUIxRyxVQUFuQixFQUErQnJ6RCxNQUEvQixFQUF1Q3M3RCxXQUF2QyxFQUFvRDtBQUN6RCxNQUFNaUIsZ0JBQWdCekMsYUFBYTk1RCxNQUFiLEVBQXFCczdELFdBQXJCLENBQXRCO0FBQ0EsU0FBT2lCLGNBQWNsSixVQUFkLEVBQTBCNXhELFNBQTFCLEVBQXFDNHhELFdBQVd2MUQsTUFBaEQsQ0FBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7O0FBVU8sU0FBU2s4RCxlQUFULENBQXlCbEgsTUFBekIsRUFBaUM5eUQsTUFBakMsRUFBeUNzN0QsV0FBekMsRUFBc0Q7QUFDM0QsTUFBTWlCLGdCQUFnQnpDLGFBQWE5NUQsTUFBYixFQUFxQnM3RCxXQUFyQixDQUF0QjtBQUNBLFNBQU8sNEJBQWV4SSxNQUFmLEVBQXVCeUosYUFBdkIsQ0FBUDtBQUNEOztBQUdEOzs7Ozs7OztBQVFPLFNBQVN0Qyx3QkFBVCxDQUFrQ3hyRCxLQUFsQyxFQUF5Qyt0RCxnQkFBekMsRUFBMkRDLHFCQUEzRCxFQUFrRjtBQUN2RixNQUFNRixnQkFBZ0IxQyw0QkFBNEIyQyxnQkFBNUIsRUFBOENDLHFCQUE5QyxDQUF0QjtBQUNBLFNBQU9GLGNBQWM5dEQsS0FBZCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS08sU0FBU3lyRCxTQUFULEdBQXFCO0FBQzFCO0FBQ0E7QUFDQWQsMkJBQXlCd0QsaUJBQXpCO0FBQ0F4RCwyQkFBeUJ5RCxrQkFBekI7QUFDQTtBQUNBO0FBQ0F4RCwwQkFBd0J3RCxrQkFBeEIsRUFBOENELGlCQUE5QyxFQUFvRUUsa0JBQXBFLEVBQWtGNUIsZ0JBQWxGO0FBQ0Q7O0FBRURoQixZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5ZkE7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQSxJQUFNUSxhQUFhLFNBQWJBLFVBQWEsQ0FBU3JsRCxPQUFULEVBQWtCO0FBQ25DOzs7O0FBSUEsT0FBSzBuRCxLQUFMLEdBQWExbkQsUUFBUTZoQyxJQUFyQjs7QUFFQTs7Ozs7OztBQU9BLE9BQUs4bEIsTUFBTCxHQUFjLG1DQUFxQzNuRCxRQUFRdkwsS0FBM0Q7O0FBRUE7Ozs7Ozs7QUFPQSxPQUFLbXpELE9BQUwsR0FBZTVuRCxRQUFReTlDLE1BQVIsS0FBbUJyeEQsU0FBbkIsR0FBK0I0VCxRQUFReTlDLE1BQXZDLEdBQWdELElBQS9EOztBQUVBOzs7Ozs7O0FBT0EsT0FBS29LLFlBQUwsR0FBb0I3bkQsUUFBUThuRCxXQUFSLEtBQXdCMTdELFNBQXhCLEdBQ2xCNFQsUUFBUThuRCxXQURVLEdBQ0ksSUFEeEI7O0FBR0E7Ozs7QUFJQSxPQUFLQyxnQkFBTCxHQUF3Qi9uRCxRQUFRZ29ELGVBQVIsS0FBNEI1N0QsU0FBNUIsR0FDdEI0VCxRQUFRZ29ELGVBRGMsR0FDSSxLQUQ1Qjs7QUFHQTs7OztBQUlBLE9BQUtDLE9BQUwsR0FBZWpvRCxRQUFRMEIsTUFBUixLQUFtQnRWLFNBQW5CLEdBQStCNFQsUUFBUTBCLE1BQXZDLEdBQWdELEtBQS9EOztBQUVBOzs7O0FBSUEsT0FBS3dtRCxTQUFMLEdBQWlCLENBQUMsRUFBRSxLQUFLRCxPQUFMLElBQWdCLEtBQUtMLE9BQXZCLENBQWxCOztBQUVBOzs7O0FBSUEsT0FBS08sdUJBQUwsR0FBK0Jub0QsUUFBUThqRCxrQkFBdkM7O0FBRUE7Ozs7QUFJQSxPQUFLc0UsZ0JBQUwsR0FBd0IsSUFBeEI7O0FBRUE7Ozs7QUFJQSxPQUFLQyxjQUFMLEdBQXNCcm9ELFFBQVErbEQsYUFBOUI7QUFDRCxDQXZFRDs7QUEwRUE7OztBQWxJQTs7O0FBcUlBVixXQUFXditDLFNBQVgsQ0FBcUJ3aEQsUUFBckIsR0FBZ0MsWUFBVztBQUN6QyxTQUFPLEtBQUtKLFNBQVo7QUFDRCxDQUZEOztBQUtBOzs7OztBQUtBN0MsV0FBV3YrQyxTQUFYLENBQXFCcStDLE9BQXJCLEdBQStCLFlBQVc7QUFDeEMsU0FBTyxLQUFLdUMsS0FBWjtBQUNELENBRkQ7O0FBS0E7Ozs7O0FBS0FyQyxXQUFXditDLFNBQVgsQ0FBcUIzWCxTQUFyQixHQUFpQyxZQUFXO0FBQzFDLFNBQU8sS0FBS3k0RCxPQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7QUFLQXZDLFdBQVd2K0MsU0FBWCxDQUFxQjQrQyxRQUFyQixHQUFnQyxZQUFXO0FBQ3pDLFNBQU8sS0FBS2lDLE1BQVo7QUFDRCxDQUZEOztBQUtBOzs7Ozs7O0FBT0F0QyxXQUFXditDLFNBQVgsQ0FBcUJrL0MsZ0JBQXJCLEdBQXdDLFlBQVc7QUFDakQsU0FBTyxLQUFLcUMsY0FBTCxJQUF1QnRELHVCQUFnQixLQUFLNEMsTUFBckIsQ0FBOUI7QUFDRCxDQUZEOztBQUtBOzs7OztBQUtBdEMsV0FBV3YrQyxTQUFYLENBQXFCeWhELGNBQXJCLEdBQXNDLFlBQVc7QUFDL0MsU0FBTyxLQUFLVixZQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7Ozs7Ozs7QUFXQXhDLFdBQVd2K0MsU0FBWCxDQUFxQjBoRCxrQkFBckIsR0FBMEMsWUFBVztBQUNuRCxTQUFPLEtBQUtULGdCQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7QUFLQTFDLFdBQVd2K0MsU0FBWCxDQUFxQjJoRCxRQUFyQixHQUFnQyxZQUFXO0FBQ3pDLFNBQU8sS0FBS1IsT0FBWjtBQUNELENBRkQ7O0FBS0E7Ozs7O0FBS0E1QyxXQUFXditDLFNBQVgsQ0FBcUI0aEQsU0FBckIsR0FBaUMsVUFBU2huRCxNQUFULEVBQWlCO0FBQ2hELE9BQUt1bUQsT0FBTCxHQUFldm1ELE1BQWY7QUFDQSxPQUFLd21ELFNBQUwsR0FBaUIsQ0FBQyxFQUFFeG1ELFVBQVUsS0FBS2ttRCxPQUFqQixDQUFsQjtBQUNELENBSEQ7O0FBTUE7OztBQUdBdkMsV0FBV3YrQyxTQUFYLENBQXFCNmhELGtCQUFyQixHQUEwQyxZQUFXO0FBQ25ELFNBQU8sS0FBS1AsZ0JBQVo7QUFDRCxDQUZEOztBQUtBOzs7QUFHQS9DLFdBQVd2K0MsU0FBWCxDQUFxQjhoRCxrQkFBckIsR0FBMEMsVUFBU3Y0RCxRQUFULEVBQW1CO0FBQzNELE9BQUsrM0QsZ0JBQUwsR0FBd0IvM0QsUUFBeEI7QUFDRCxDQUZEOztBQUtBOzs7OztBQUtBZzFELFdBQVd2K0MsU0FBWCxDQUFxQitoRCxTQUFyQixHQUFpQyxVQUFTcEwsTUFBVCxFQUFpQjtBQUNoRCxPQUFLbUssT0FBTCxHQUFlbkssTUFBZjtBQUNBLE9BQUt5SyxTQUFMLEdBQWlCLENBQUMsRUFBRSxLQUFLRCxPQUFMLElBQWdCeEssTUFBbEIsQ0FBbEI7QUFDRCxDQUhEOztBQU1BOzs7Ozs7QUFNQTRILFdBQVd2K0MsU0FBWCxDQUFxQmdpRCxjQUFyQixHQUFzQyxVQUFTaEIsV0FBVCxFQUFzQjtBQUMxRCxPQUFLRCxZQUFMLEdBQW9CQyxXQUFwQjtBQUNELENBRkQ7O0FBS0E7Ozs7OztBQU1BekMsV0FBV3YrQyxTQUFYLENBQXFCaWlELHFCQUFyQixHQUE2QyxVQUFTclQsSUFBVCxFQUFlO0FBQzFELE9BQUt5Uyx1QkFBTCxHQUErQnpTLElBQS9CO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7QUFLQTJQLFdBQVd2K0MsU0FBWCxDQUFxQjIrQyxzQkFBckIsR0FBOEMsWUFBVztBQUN2RCxTQUFPLEtBQUswQyx1QkFBWjtBQUNELENBRkQ7a0JBR2U5QyxVOzs7Ozs7Ozs7Ozs7Ozs7OztBQzVSZjs7OztBQUlBOzs7OztBQUtBLElBQU1NLFFBQVE7QUFDWkMsV0FBUyxTQURHO0FBRVpvRCxRQUFNLElBRk07QUFHWkMsVUFBUSxHQUhJO0FBSVpDLFVBQVEsUUFKSTtBQUtaQyxlQUFhLGFBTEQ7QUFNWkMsVUFBUTtBQU5JLENBQWQ7O0FBVUE7Ozs7OztBQU1PLElBQU1yRSw0Q0FBa0IsRUFBeEI7QUFDUDtBQUNBQSxnQkFBZ0JZLE1BQU1DLE9BQXRCLElBQWlDLElBQUl4aUQsS0FBS2dXLEVBQVQsR0FBYyxPQUFkLEdBQXdCLEdBQXpEO0FBQ0EyckMsZ0JBQWdCWSxNQUFNcUQsSUFBdEIsSUFBOEIsTUFBOUI7QUFDQWpFLGdCQUFnQlksTUFBTXNELE1BQXRCLElBQWdDLENBQWhDO0FBQ0FsRSxnQkFBZ0JZLE1BQU15RCxNQUF0QixJQUFnQyxPQUFPLElBQXZDOztrQkFFZXpELEs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQzBEQzhCLFksR0FBQUEsWTtRQW9DQTVCLFUsR0FBQUEsVTs7QUEzSGhCOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUdBOzs7Ozs7QUFUQTs7O0FBZU8sSUFBTXdELDBCQUFTLE9BQWY7O0FBR1A7Ozs7QUFJTyxJQUFNQyxnQ0FBWWxtRCxLQUFLZ1csRUFBTCxHQUFVaXdDLE1BQTVCOztBQUdQOzs7O0FBSU8sSUFBTXZ3QywwQkFBUyxDQUNwQixDQUFDd3dDLFNBRG1CLEVBQ1IsQ0FBQ0EsU0FETyxFQUVwQkEsU0FGb0IsRUFFVEEsU0FGUyxDQUFmOztBQU1QOzs7O0FBSU8sSUFBTUMsc0NBQWUsQ0FBQyxDQUFDLEdBQUYsRUFBTyxDQUFDLEVBQVIsRUFBWSxHQUFaLEVBQWlCLEVBQWpCLENBQXJCOztBQUdQOzs7Ozs7OztBQVFBLFNBQVNDLGtCQUFULENBQTRCM25CLElBQTVCLEVBQWtDO0FBQ2hDd2pCLHVCQUFXdCtDLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0I7QUFDcEI4NkIsVUFBTUEsSUFEYztBQUVwQnB0QyxXQUFPa3hELGdCQUFNc0QsTUFGTztBQUdwQnhMLFlBQVEza0MsTUFIWTtBQUlwQnBYLFlBQVEsSUFKWTtBQUtwQm9tRCxpQkFBYXlCLFlBTE87QUFNcEJ6Rix3QkFBb0IsNEJBQVMxRSxVQUFULEVBQXFCaG1ELEtBQXJCLEVBQTRCO0FBQzlDLGFBQU9nbUQsYUFBYSxnQkFBS2htRCxNQUFNLENBQU4sSUFBV2l3RCxNQUFoQixDQUFwQjtBQUNEO0FBUm1CLEdBQXRCO0FBVUQ7QUFDRCxxQkFBU0csa0JBQVQsRUFBNkJuRSxvQkFBN0I7O0FBR0E7Ozs7OztBQU1PLElBQU1vRSxvQ0FBYyxDQUN6QixJQUFJRCxrQkFBSixDQUF1QixXQUF2QixDQUR5QixFQUV6QixJQUFJQSxrQkFBSixDQUF1QixhQUF2QixDQUZ5QixFQUd6QixJQUFJQSxrQkFBSixDQUF1QixhQUF2QixDQUh5QixFQUl6QixJQUFJQSxrQkFBSixDQUF1QixhQUF2QixDQUp5QixFQUt6QixJQUFJQSxrQkFBSixDQUF1QixrQ0FBdkIsQ0FMeUIsRUFNekIsSUFBSUEsa0JBQUosQ0FBdUIsNEJBQXZCLENBTnlCLEVBT3pCLElBQUlBLGtCQUFKLENBQXVCLDhDQUF2QixDQVB5QixDQUFwQjs7QUFXUDs7Ozs7Ozs7QUFRTyxTQUFTL0IsWUFBVCxDQUFzQjVpRCxLQUF0QixFQUE2Qm1nRCxVQUE3QixFQUF5Q0MsYUFBekMsRUFBd0Q7QUFDN0QsTUFBTXg4RCxTQUFTb2MsTUFBTXBjLE1BQXJCO0FBQ0EsTUFBTWkrRCxZQUFZekIsZ0JBQWdCLENBQWhCLEdBQW9CQSxhQUFwQixHQUFvQyxDQUF0RDtBQUNBLE1BQUlwaEQsU0FBU21oRCxVQUFiO0FBQ0EsTUFBSW5oRCxXQUFXelgsU0FBZixFQUEwQjtBQUN4QixRQUFJczZELFlBQVksQ0FBaEIsRUFBbUI7QUFDakI7QUFDQTdpRCxlQUFTZ0IsTUFBTXRSLEtBQU4sRUFBVDtBQUNELEtBSEQsTUFHTztBQUNMc1EsZUFBUyxJQUFJdmIsS0FBSixDQUFVRyxNQUFWLENBQVQ7QUFDRDtBQUNGO0FBQ0QsTUFBTWloRSxXQUFXSixTQUFqQjtBQUNBLE9BQUssSUFBSWxoRSxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCTCxLQUFLcytELFNBQWpDLEVBQTRDO0FBQzFDN2lELFdBQU96YixDQUFQLElBQVlzaEUsV0FBVzdrRCxNQUFNemMsQ0FBTixDQUFYLEdBQXNCLEdBQWxDO0FBQ0EsUUFBSWt2QixJQUFJK3hDLFNBQ0pqbUQsS0FBS2lXLEdBQUwsQ0FBU2pXLEtBQUt2RyxHQUFMLENBQVN1RyxLQUFLZ1csRUFBTCxJQUFXdlUsTUFBTXpjLElBQUksQ0FBVixJQUFlLEVBQTFCLElBQWdDLEdBQXpDLENBQVQsQ0FESjtBQUVBLFFBQUlrdkIsSUFBSW95QyxRQUFSLEVBQWtCO0FBQ2hCcHlDLFVBQUlveUMsUUFBSjtBQUNELEtBRkQsTUFFTyxJQUFJcHlDLElBQUksQ0FBQ295QyxRQUFULEVBQW1CO0FBQ3hCcHlDLFVBQUksQ0FBQ295QyxRQUFMO0FBQ0Q7QUFDRDdsRCxXQUFPemIsSUFBSSxDQUFYLElBQWdCa3ZCLENBQWhCO0FBQ0Q7QUFDRCxTQUFPelQsTUFBUDtBQUNEOztBQUdEOzs7Ozs7OztBQVFPLFNBQVNnaUQsVUFBVCxDQUFvQmhoRCxLQUFwQixFQUEyQm1nRCxVQUEzQixFQUF1Q0MsYUFBdkMsRUFBc0Q7QUFDM0QsTUFBTXg4RCxTQUFTb2MsTUFBTXBjLE1BQXJCO0FBQ0EsTUFBTWkrRCxZQUFZekIsZ0JBQWdCLENBQWhCLEdBQW9CQSxhQUFwQixHQUFvQyxDQUF0RDtBQUNBLE1BQUlwaEQsU0FBU21oRCxVQUFiO0FBQ0EsTUFBSW5oRCxXQUFXelgsU0FBZixFQUEwQjtBQUN4QixRQUFJczZELFlBQVksQ0FBaEIsRUFBbUI7QUFDakI7QUFDQTdpRCxlQUFTZ0IsTUFBTXRSLEtBQU4sRUFBVDtBQUNELEtBSEQsTUFHTztBQUNMc1EsZUFBUyxJQUFJdmIsS0FBSixDQUFVRyxNQUFWLENBQVQ7QUFDRDtBQUNGO0FBQ0QsT0FBSyxJQUFJTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlLLE1BQXBCLEVBQTRCTCxLQUFLcytELFNBQWpDLEVBQTRDO0FBQzFDN2lELFdBQU96YixDQUFQLElBQVksTUFBTXljLE1BQU16YyxDQUFOLENBQU4sR0FBaUJraEUsU0FBN0I7QUFDQXpsRCxXQUFPemIsSUFBSSxDQUFYLElBQWdCLE1BQU1nYixLQUFLcEcsSUFBTCxDQUNwQm9HLEtBQUswL0MsR0FBTCxDQUFTaitDLE1BQU16YyxJQUFJLENBQVYsSUFBZWloRSxNQUF4QixDQURvQixDQUFOLEdBQ3FCam1ELEtBQUtnVyxFQUQxQixHQUMrQixFQUQvQztBQUVEO0FBQ0QsU0FBT3ZWLE1BQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0lEOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUdBOzs7Ozs7QUFNTyxJQUFNd2xELDBCQUFTLE9BQWY7O0FBR1A7Ozs7OztBQWpCQTs7O0FBdUJPLElBQU12d0MsMEJBQVMsQ0FBQyxDQUFDLEdBQUYsRUFBTyxDQUFDLEVBQVIsRUFBWSxHQUFaLEVBQWlCLEVBQWpCLENBQWY7O0FBR1A7Ozs7QUFJTyxJQUFNaXNDLDRDQUFrQjNoRCxLQUFLZ1csRUFBTCxHQUFVaXdDLE1BQVYsR0FBbUIsR0FBM0M7O0FBR1A7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFTTSxrQkFBVCxDQUE0QjluQixJQUE1QixFQUFrQytuQixtQkFBbEMsRUFBdUQ7QUFDckR2RSx1QkFBV3QrQyxJQUFYLENBQWdCLElBQWhCLEVBQXNCO0FBQ3BCODZCLFVBQU1BLElBRGM7QUFFcEJwdEMsV0FBT2t4RCxnQkFBTUMsT0FGTztBQUdwQm5JLFlBQVEza0MsTUFIWTtBQUlwQmt2QyxxQkFBaUI0QixtQkFKRztBQUtwQmxvRCxZQUFRLElBTFk7QUFNcEJxa0QsbUJBQWVoQixlQU5LO0FBT3BCK0MsaUJBQWFodkM7QUFQTyxHQUF0QjtBQVNEO0FBQ0QscUJBQVM2d0Msa0JBQVQsRUFBNkJ0RSxvQkFBN0I7O0FBR0E7Ozs7OztBQU1PLElBQU1vRSxvQ0FBYyxDQUN6QixJQUFJRSxrQkFBSixDQUF1QixRQUF2QixDQUR5QixFQUV6QixJQUFJQSxrQkFBSixDQUF1QixXQUF2QixFQUFvQyxLQUFwQyxDQUZ5QixFQUd6QixJQUFJQSxrQkFBSixDQUF1Qiw0QkFBdkIsRUFBcUQsS0FBckQsQ0FIeUIsRUFJekIsSUFBSUEsa0JBQUosQ0FBdUIsK0JBQXZCLEVBQXdELEtBQXhELENBSnlCLEVBS3pCLElBQUlBLGtCQUFKLENBQXVCLCtCQUF2QixDQUx5QixFQU16QixJQUFJQSxrQkFBSixDQUF1QiwwQkFBdkIsQ0FOeUIsRUFPekIsSUFBSUEsa0JBQUosQ0FBdUIsOENBQXZCLEVBQXVFLEtBQXZFLENBUHlCLEVBUXpCLElBQUlBLGtCQUFKLENBQXVCLDZCQUF2QixFQUFzRCxLQUF0RCxDQVJ5QixDQUFwQixDOzs7Ozs7Ozs7Ozs7Ozs7OztRQ3BEU3JHLEssR0FBQUEsSztRQVVBenZELEcsR0FBQUEsRztRQVVBcXhELEcsR0FBQUEsRztBQWxDaEI7Ozs7QUFLQTs7O0FBR0EsSUFBSTJFLFFBQVEsRUFBWjs7QUFHQTs7O0FBR08sU0FBU3ZHLEtBQVQsR0FBaUI7QUFDdEJ1RyxVQUFRLEVBQVI7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTaDJELEdBQVQsQ0FBYWd1QyxJQUFiLEVBQW1CO0FBQ3hCLFNBQU9nb0IsTUFBTWhvQixJQUFOLEtBQWUsSUFBdEI7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTcWpCLEdBQVQsQ0FBYXJqQixJQUFiLEVBQW1CeHNDLFVBQW5CLEVBQStCO0FBQ3BDdzBELFFBQU1ob0IsSUFBTixJQUFjeHNDLFVBQWQ7QUFDRCxDOzs7Ozs7Ozs7Ozs7Ozs7OztRQ3BCZWl1RCxLLEdBQUFBLEs7UUFhQTRCLEcsR0FBQUEsRztRQW1CQW5SLE0sR0FBQUEsTTtRQWtCQWxnRCxHLEdBQUFBLEc7O0FBL0RoQjs7QUFHQTs7OztBQUlBLElBQUlpMkQsYUFBYSxFQUFqQjs7QUFHQTs7O0FBYkE7OztBQWdCTyxTQUFTeEcsS0FBVCxHQUFpQjtBQUN0QndHLGVBQWEsRUFBYjtBQUNEOztBQUdEOzs7Ozs7OztBQVFPLFNBQVM1RSxHQUFULENBQWF2NkQsTUFBYixFQUFxQnM3RCxXQUFyQixFQUFrQ3pGLFdBQWxDLEVBQStDO0FBQ3BELE1BQU02RyxhQUFhMThELE9BQU93NkQsT0FBUCxFQUFuQjtBQUNBLE1BQU1tQyxrQkFBa0JyQixZQUFZZCxPQUFaLEVBQXhCO0FBQ0EsTUFBSSxFQUFFa0MsY0FBY3lDLFVBQWhCLENBQUosRUFBaUM7QUFDL0JBLGVBQVd6QyxVQUFYLElBQXlCLEVBQXpCO0FBQ0Q7QUFDRHlDLGFBQVd6QyxVQUFYLEVBQXVCQyxlQUF2QixJQUEwQzlHLFdBQTFDO0FBQ0Q7O0FBR0Q7Ozs7Ozs7OztBQVNPLFNBQVN6TSxNQUFULENBQWdCcHBELE1BQWhCLEVBQXdCczdELFdBQXhCLEVBQXFDO0FBQzFDLE1BQU1vQixhQUFhMThELE9BQU93NkQsT0FBUCxFQUFuQjtBQUNBLE1BQU1tQyxrQkFBa0JyQixZQUFZZCxPQUFaLEVBQXhCO0FBQ0EsTUFBTVQsWUFBWW9GLFdBQVd6QyxVQUFYLEVBQXVCQyxlQUF2QixDQUFsQjtBQUNBLFNBQU93QyxXQUFXekMsVUFBWCxFQUF1QkMsZUFBdkIsQ0FBUDtBQUNBLE1BQUksa0JBQVF3QyxXQUFXekMsVUFBWCxDQUFSLENBQUosRUFBcUM7QUFDbkMsV0FBT3lDLFdBQVd6QyxVQUFYLENBQVA7QUFDRDtBQUNELFNBQU8zQyxTQUFQO0FBQ0Q7O0FBR0Q7Ozs7OztBQU1PLFNBQVM3d0QsR0FBVCxDQUFhd3pELFVBQWIsRUFBeUJDLGVBQXpCLEVBQTBDO0FBQy9DLE1BQUk1QyxrQkFBSjtBQUNBLE1BQUkyQyxjQUFjeUMsVUFBZCxJQUE0QnhDLG1CQUFtQndDLFdBQVd6QyxVQUFYLENBQW5ELEVBQTJFO0FBQ3pFM0MsZ0JBQVlvRixXQUFXekMsVUFBWCxFQUF1QkMsZUFBdkIsQ0FBWjtBQUNEO0FBQ0QsU0FBTzVDLFNBQVA7QUFDRCxDOzs7Ozs7Ozs7Ozs7Ozs7OztRQ25EZXFGLHlCLEdBQUFBLHlCO1FBdUVBQyxNLEdBQUFBLE07O0FBekZoQjs7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQTs7Ozs7Ozs7Ozs7O0FBVEE7OztBQXFCTyxTQUFTRCx5QkFBVCxDQUFtQ25ELFVBQW5DLEVBQStDcUQsVUFBL0MsRUFDTEMsWUFESyxFQUNTQyxnQkFEVCxFQUMyQjs7QUFFaEMsTUFBTUMsZUFBZSxxQkFBVUYsWUFBVixFQUF3QkQsVUFBeEIsRUFBb0NyRCxVQUFwQyxDQUFyQjs7QUFFQTtBQUNBLE1BQUl5RCxtQkFBbUIsOEJBQW1CSixVQUFuQixFQUErQkUsZ0JBQS9CLEVBQWlERCxZQUFqRCxDQUF2Qjs7QUFFQSxNQUFNSSxzQkFBc0JMLFdBQVdqRSxnQkFBWCxFQUE1QjtBQUNBLE1BQUlzRSx3QkFBd0JsK0QsU0FBNUIsRUFBdUM7QUFDckNpK0Qsd0JBQW9CQyxtQkFBcEI7QUFDRDtBQUNELE1BQU1DLHNCQUFzQjNELFdBQVdaLGdCQUFYLEVBQTVCO0FBQ0EsTUFBSXVFLHdCQUF3Qm4rRCxTQUE1QixFQUF1QztBQUNyQ2krRCx3QkFBb0JFLG1CQUFwQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQyxlQUFlNUQsV0FBV3ozRCxTQUFYLEVBQXJCO0FBQ0EsTUFBSSxDQUFDcTdELFlBQUQsSUFBaUIsZ0NBQW1CQSxZQUFuQixFQUFpQ0osWUFBakMsQ0FBckIsRUFBcUU7QUFDbkUsUUFBTUsscUJBQXFCLDhCQUFtQjdELFVBQW5CLEVBQStCeUQsZ0JBQS9CLEVBQWlERCxZQUFqRCxJQUN2QkMsZ0JBREo7QUFFQSxRQUFJeGlELFNBQVM0aUQsa0JBQVQsS0FBZ0NBLHFCQUFxQixDQUF6RCxFQUE0RDtBQUMxREosMEJBQW9CSSxrQkFBcEI7QUFDRDtBQUNGOztBQUVELFNBQU9KLGdCQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7Ozs7QUFVQSxTQUFTSyxnQkFBVCxDQUEwQkMsU0FBMUIsRUFBcUNDLFNBQXJDLEVBQWdEdGpELENBQWhELEVBQW1EZ1EsQ0FBbkQsRUFBc0Q7QUFDcEQsTUFBTUMsS0FBS2pRLElBQUlxakQsU0FBZjtBQUNBLE1BQU1uekMsS0FBS0YsSUFBSXN6QyxTQUFmO0FBQ0EsTUFBTXR0RCxXQUFXOEYsS0FBSzdHLElBQUwsQ0FBVWdiLEtBQUtBLEVBQUwsR0FBVUMsS0FBS0EsRUFBekIsQ0FBakI7QUFDQSxTQUFPLENBQUNwVSxLQUFLdEssS0FBTCxDQUFXd08sSUFBSWlRLEtBQUtqYSxRQUFwQixDQUFELEVBQWdDOEYsS0FBS3RLLEtBQUwsQ0FBV3dlLElBQUlFLEtBQUtsYSxRQUFwQixDQUFoQyxDQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQk8sU0FBUzBzRCxNQUFULENBQWdCendELEtBQWhCLEVBQXVCQyxNQUF2QixFQUErQnF4RCxVQUEvQixFQUNMUixnQkFESyxFQUNhRyxZQURiLEVBQzJCTCxnQkFEM0IsRUFDNkNXLFlBRDdDLEVBRUxDLGFBRkssRUFFVTU2RCxPQUZWLEVBRW1CNjZELE1BRm5CLEVBRTJCQyxlQUYzQixFQUU0Qzs7QUFFakQsTUFBTXAyQyxVQUFVLGdDQUFzQnpSLEtBQUt0SyxLQUFMLENBQVcreEQsYUFBYXR4RCxLQUF4QixDQUF0QixFQUNkNkosS0FBS3RLLEtBQUwsQ0FBVyt4RCxhQUFhcnhELE1BQXhCLENBRGMsQ0FBaEI7O0FBR0EsTUFBSXJKLFFBQVExSCxNQUFSLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLFdBQU9vc0IsUUFBUWk4QixNQUFmO0FBQ0Q7O0FBRURqOEIsVUFBUXBCLEtBQVIsQ0FBY28zQyxVQUFkLEVBQTBCQSxVQUExQjs7QUFFQSxNQUFNSyxtQkFBbUIsMEJBQXpCO0FBQ0EvNkQsVUFBUTJkLE9BQVIsQ0FBZ0IsVUFBU3hiLEdBQVQsRUFBY2xLLENBQWQsRUFBaUJpNkMsR0FBakIsRUFBc0I7QUFDcEMsd0JBQU82b0IsZ0JBQVAsRUFBeUI1NEQsSUFBSW1yRCxNQUE3QjtBQUNELEdBRkQ7O0FBSUEsTUFBTTBOLHFCQUFxQixzQkFBU0QsZ0JBQVQsQ0FBM0I7QUFDQSxNQUFNRSxzQkFBc0IsdUJBQVVGLGdCQUFWLENBQTVCO0FBQ0EsTUFBTUcsZ0JBQWdCLGdDQUNwQmpvRCxLQUFLdEssS0FBTCxDQUFXK3hELGFBQWFNLGtCQUFiLEdBQWtDZCxnQkFBN0MsQ0FEb0IsRUFFcEJqbkQsS0FBS3RLLEtBQUwsQ0FBVyt4RCxhQUFhTyxtQkFBYixHQUFtQ2YsZ0JBQTlDLENBRm9CLENBQXRCOztBQUlBLE1BQU1pQixjQUFjVCxhQUFhUixnQkFBakM7O0FBRUFsNkQsVUFBUTJkLE9BQVIsQ0FBZ0IsVUFBU3hiLEdBQVQsRUFBY2xLLENBQWQsRUFBaUJpNkMsR0FBakIsRUFBc0I7QUFDcEMsUUFBTWtwQixPQUFPajVELElBQUltckQsTUFBSixDQUFXLENBQVgsSUFBZ0J5TixpQkFBaUIsQ0FBakIsQ0FBN0I7QUFDQSxRQUFNTSxPQUFPLEVBQUVsNUQsSUFBSW1yRCxNQUFKLENBQVcsQ0FBWCxJQUFnQnlOLGlCQUFpQixDQUFqQixDQUFsQixDQUFiO0FBQ0EsUUFBTU8sV0FBVyxzQkFBU241RCxJQUFJbXJELE1BQWIsQ0FBakI7QUFDQSxRQUFNaU8sWUFBWSx1QkFBVXA1RCxJQUFJbXJELE1BQWQsQ0FBbEI7O0FBRUE0TixrQkFBY00sU0FBZCxDQUNFcjVELElBQUltRixLQUROLEVBRUV1ekQsTUFGRixFQUVVQSxNQUZWLEVBR0UxNEQsSUFBSW1GLEtBQUosQ0FBVThCLEtBQVYsR0FBa0IsSUFBSXl4RCxNQUh4QixFQUdnQzE0RCxJQUFJbUYsS0FBSixDQUFVK0IsTUFBVixHQUFtQixJQUFJd3hELE1BSHZELEVBSUVPLE9BQU9ELFdBSlQsRUFJc0JFLE9BQU9GLFdBSjdCLEVBS0VHLFdBQVdILFdBTGIsRUFLMEJJLFlBQVlKLFdBTHRDO0FBTUQsR0FaRDs7QUFjQSxNQUFNTSxnQkFBZ0Isd0JBQVdkLFlBQVgsQ0FBdEI7O0FBRUFDLGdCQUFjYyxZQUFkLEdBQTZCLzlDLE9BQTdCLENBQXFDLFVBQVNnK0MsUUFBVCxFQUFtQjFqRSxDQUFuQixFQUFzQmk2QyxHQUF0QixFQUEyQjtBQUM5RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEsUUFBTTEzQyxTQUFTbWhFLFNBQVNuaEUsTUFBeEI7QUFDQSxRQUFNeUksU0FBUzA0RCxTQUFTMTRELE1BQXhCO0FBQ0EsUUFBSXdzRCxLQUFLajFELE9BQU8sQ0FBUCxFQUFVLENBQVYsQ0FBVDtBQUFBLFFBQXVCazFELEtBQUtsMUQsT0FBTyxDQUFQLEVBQVUsQ0FBVixDQUE1QjtBQUNBLFFBQUlxdkIsS0FBS3J2QixPQUFPLENBQVAsRUFBVSxDQUFWLENBQVQ7QUFBQSxRQUF1QnN2QixLQUFLdHZCLE9BQU8sQ0FBUCxFQUFVLENBQVYsQ0FBNUI7QUFDQSxRQUFJdXZCLEtBQUt2dkIsT0FBTyxDQUFQLEVBQVUsQ0FBVixDQUFUO0FBQUEsUUFBdUJ3dkIsS0FBS3h2QixPQUFPLENBQVAsRUFBVSxDQUFWLENBQTVCO0FBQ0EsUUFBTW9oRSxLQUFLLENBQUMzNEQsT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFldzRELGNBQWMsQ0FBZCxDQUFoQixJQUFvQ3pCLGdCQUEvQztBQUNBLFFBQU02QixLQUFLLEVBQUU1NEQsT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFldzRELGNBQWMsQ0FBZCxDQUFqQixJQUFxQ3pCLGdCQUFoRDtBQUNBLFFBQU04QixLQUFLLENBQUM3NEQsT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFldzRELGNBQWMsQ0FBZCxDQUFoQixJQUFvQ3pCLGdCQUEvQztBQUNBLFFBQU10dkMsS0FBSyxFQUFFem5CLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBZXc0RCxjQUFjLENBQWQsQ0FBakIsSUFBcUN6QixnQkFBaEQ7QUFDQSxRQUFNK0IsS0FBSyxDQUFDOTRELE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBZXc0RCxjQUFjLENBQWQsQ0FBaEIsSUFBb0N6QixnQkFBL0M7QUFDQSxRQUFNcnZDLEtBQUssRUFBRTFuQixPQUFPLENBQVAsRUFBVSxDQUFWLElBQWV3NEQsY0FBYyxDQUFkLENBQWpCLElBQXFDekIsZ0JBQWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU1nQyx3QkFBd0J2TSxFQUE5QjtBQUNBLFFBQU13TSx3QkFBd0J2TSxFQUE5QjtBQUNBRCxTQUFLLENBQUw7QUFDQUMsU0FBSyxDQUFMO0FBQ0E3bEMsVUFBTW15QyxxQkFBTjtBQUNBbHlDLFVBQU1teUMscUJBQU47QUFDQWx5QyxVQUFNaXlDLHFCQUFOO0FBQ0FoeUMsVUFBTWl5QyxxQkFBTjs7QUFFQSxRQUFNQyxrQkFBa0IsQ0FDdEIsQ0FBQ3J5QyxFQUFELEVBQUtDLEVBQUwsRUFBUyxDQUFULEVBQVksQ0FBWixFQUFlZ3lDLEtBQUtGLEVBQXBCLENBRHNCLEVBRXRCLENBQUM3eEMsRUFBRCxFQUFLQyxFQUFMLEVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSt4QyxLQUFLSCxFQUFwQixDQUZzQixFQUd0QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8veEMsRUFBUCxFQUFXQyxFQUFYLEVBQWVZLEtBQUtteEMsRUFBcEIsQ0FIc0IsRUFJdEIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPOXhDLEVBQVAsRUFBV0MsRUFBWCxFQUFlVyxLQUFLa3hDLEVBQXBCLENBSnNCLENBQXhCO0FBTUEsUUFBTU0sY0FBYyw2QkFBa0JELGVBQWxCLENBQXBCO0FBQ0EsUUFBSSxDQUFDQyxXQUFMLEVBQWtCO0FBQ2hCO0FBQ0Q7O0FBRUR6M0MsWUFBUTAzQyxJQUFSO0FBQ0ExM0MsWUFBUTIzQyxTQUFSO0FBQ0EsUUFBTTdCLFlBQVksQ0FBQ29CLEtBQUtFLEVBQUwsR0FBVUMsRUFBWCxJQUFpQixDQUFuQztBQUNBLFFBQU10QixZQUFZLENBQUNvQixLQUFLbnhDLEVBQUwsR0FBVUMsRUFBWCxJQUFpQixDQUFuQztBQUNBLFFBQU0yeEMsS0FBSy9CLGlCQUFpQkMsU0FBakIsRUFBNEJDLFNBQTVCLEVBQXVDbUIsRUFBdkMsRUFBMkNDLEVBQTNDLENBQVg7QUFDQSxRQUFNbHlDLEtBQUs0d0MsaUJBQWlCQyxTQUFqQixFQUE0QkMsU0FBNUIsRUFBdUNxQixFQUF2QyxFQUEyQ3B4QyxFQUEzQyxDQUFYO0FBQ0EsUUFBTWQsS0FBSzJ3QyxpQkFBaUJDLFNBQWpCLEVBQTRCQyxTQUE1QixFQUF1Q3NCLEVBQXZDLEVBQTJDcHhDLEVBQTNDLENBQVg7O0FBRUFqRyxZQUFRNjNDLE1BQVIsQ0FBZTV5QyxHQUFHLENBQUgsQ0FBZixFQUFzQkEsR0FBRyxDQUFILENBQXRCO0FBQ0FqRixZQUFRODNDLE1BQVIsQ0FBZUYsR0FBRyxDQUFILENBQWYsRUFBc0JBLEdBQUcsQ0FBSCxDQUF0QjtBQUNBNTNDLFlBQVE4M0MsTUFBUixDQUFlNXlDLEdBQUcsQ0FBSCxDQUFmLEVBQXNCQSxHQUFHLENBQUgsQ0FBdEI7QUFDQWxGLFlBQVErM0MsSUFBUjs7QUFFQS8zQyxZQUFRNnZDLFNBQVIsQ0FDRTRILFlBQVksQ0FBWixDQURGLEVBQ2tCQSxZQUFZLENBQVosQ0FEbEIsRUFDa0NBLFlBQVksQ0FBWixDQURsQyxFQUNrREEsWUFBWSxDQUFaLENBRGxELEVBQ2tFUCxFQURsRSxFQUNzRUMsRUFEdEU7O0FBR0FuM0MsWUFBUWc0QyxTQUFSLENBQWtCM0IsaUJBQWlCLENBQWpCLElBQXNCaUIscUJBQXhDLEVBQ0VqQixpQkFBaUIsQ0FBakIsSUFBc0JrQixxQkFEeEI7O0FBR0F2M0MsWUFBUXBCLEtBQVIsQ0FBYzQyQyxtQkFBbUJRLFVBQWpDLEVBQ0UsQ0FBQ1IsZ0JBQUQsR0FBb0JRLFVBRHRCOztBQUdBaDJDLFlBQVE4MkMsU0FBUixDQUFrQk4sY0FBY3ZhLE1BQWhDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDO0FBQ0FqOEIsWUFBUWk0QyxPQUFSO0FBQ0QsR0FoRkQ7O0FBa0ZBLE1BQUk3QixlQUFKLEVBQXFCO0FBQ25CcDJDLFlBQVEwM0MsSUFBUjs7QUFFQTEzQyxZQUFRazRDLFdBQVIsR0FBc0IsT0FBdEI7QUFDQWw0QyxZQUFRbTRDLFNBQVIsR0FBb0IsQ0FBcEI7O0FBRUFqQyxrQkFBY2MsWUFBZCxHQUE2Qi85QyxPQUE3QixDQUFxQyxVQUFTZytDLFFBQVQsRUFBbUIxakUsQ0FBbkIsRUFBc0JpNkMsR0FBdEIsRUFBMkI7QUFDOUQsVUFBTWp2QyxTQUFTMDRELFNBQVMxNEQsTUFBeEI7QUFDQSxVQUFNMjRELEtBQUssQ0FBQzM0RCxPQUFPLENBQVAsRUFBVSxDQUFWLElBQWV3NEQsY0FBYyxDQUFkLENBQWhCLElBQW9DekIsZ0JBQS9DO0FBQ0EsVUFBTTZCLEtBQUssRUFBRTU0RCxPQUFPLENBQVAsRUFBVSxDQUFWLElBQWV3NEQsY0FBYyxDQUFkLENBQWpCLElBQXFDekIsZ0JBQWhEO0FBQ0EsVUFBTThCLEtBQUssQ0FBQzc0RCxPQUFPLENBQVAsRUFBVSxDQUFWLElBQWV3NEQsY0FBYyxDQUFkLENBQWhCLElBQW9DekIsZ0JBQS9DO0FBQ0EsVUFBTXR2QyxLQUFLLEVBQUV6bkIsT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFldzRELGNBQWMsQ0FBZCxDQUFqQixJQUFxQ3pCLGdCQUFoRDtBQUNBLFVBQU0rQixLQUFLLENBQUM5NEQsT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFldzRELGNBQWMsQ0FBZCxDQUFoQixJQUFvQ3pCLGdCQUEvQztBQUNBLFVBQU1ydkMsS0FBSyxFQUFFMW5CLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBZXc0RCxjQUFjLENBQWQsQ0FBakIsSUFBcUN6QixnQkFBaEQ7O0FBRUF0MUMsY0FBUTIzQyxTQUFSO0FBQ0EzM0MsY0FBUTYzQyxNQUFSLENBQWVULEVBQWYsRUFBbUJweEMsRUFBbkI7QUFDQWhHLGNBQVE4M0MsTUFBUixDQUFlWixFQUFmLEVBQW1CQyxFQUFuQjtBQUNBbjNDLGNBQVE4M0MsTUFBUixDQUFlVCxFQUFmLEVBQW1CcHhDLEVBQW5CO0FBQ0FqRyxjQUFRbzRDLFNBQVI7QUFDQXA0QyxjQUFRcTRDLE1BQVI7QUFDRCxLQWZEOztBQWlCQXI0QyxZQUFRaTRDLE9BQVI7QUFDRDtBQUNELFNBQU9qNEMsUUFBUWk4QixNQUFmO0FBQ0QsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL09EOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFHQTs7OztBQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXBCQTs7O0FBd0NBLElBQU1xYyxhQUFhLFNBQWJBLFVBQWEsQ0FBU3ZHLFVBQVQsRUFBcUJ3RyxjQUFyQixFQUNqQm5ELFVBRGlCLEVBQ0xvRCxjQURLLEVBQ1d2ZSxTQURYLEVBQ3NCd2UsZ0JBRHRCLEVBRWpCekMsVUFGaUIsRUFFTEcsTUFGSyxFQUVHdUMsZUFGSCxFQUdqQkMsa0JBSGlCLEVBR0d2QyxlQUhILEVBR29CO0FBQ3JDaGMsaUJBQUtsb0MsSUFBTCxDQUFVLElBQVYsRUFBZ0IrbkMsU0FBaEIsRUFBMkJVLG9CQUFVZ0IsSUFBckM7O0FBRUE7Ozs7QUFJQSxPQUFLaWQsWUFBTCxHQUFvQnhDLG9CQUFvQjcrRCxTQUFwQixHQUFnQzYrRCxlQUFoQyxHQUFrRCxLQUF0RTs7QUFFQTs7OztBQUlBLE9BQUt5QyxXQUFMLEdBQW1CN0MsVUFBbkI7O0FBRUE7Ozs7QUFJQSxPQUFLOEMsT0FBTCxHQUFlM0MsTUFBZjs7QUFFQTs7OztBQUlBLE9BQUs0QyxPQUFMLEdBQWUsSUFBZjs7QUFFQTs7OztBQUlBLE9BQUtDLGVBQUwsR0FBdUJULGNBQXZCOztBQUVBOzs7O0FBSUEsT0FBS1UsZUFBTCxHQUF1QlQsY0FBdkI7O0FBRUE7Ozs7QUFJQSxPQUFLVSxpQkFBTCxHQUF5QlQsbUJBQW1CQSxnQkFBbkIsR0FBc0N4ZSxTQUEvRDs7QUFFQTs7OztBQUlBLE9BQUtrZixZQUFMLEdBQW9CLEVBQXBCOztBQUVBOzs7O0FBSUEsT0FBS0Msb0JBQUwsR0FBNEIsSUFBNUI7O0FBRUE7Ozs7QUFJQSxPQUFLQyxRQUFMLEdBQWdCLENBQWhCOztBQUVBLE1BQU1wRCxlQUFldUMsZUFBZTc2RCxrQkFBZixDQUFrQyxLQUFLdTdELGlCQUF2QyxDQUFyQjtBQUNBLE1BQU1JLGtCQUFrQixLQUFLTCxlQUFMLENBQXFCMytELFNBQXJCLEVBQXhCO0FBQ0EsTUFBSWkvRCxrQkFBa0IsS0FBS1AsZUFBTCxDQUFxQjErRCxTQUFyQixFQUF0Qjs7QUFFQSxNQUFNay9ELHNCQUFzQkYsa0JBQzFCLDZCQUFnQnJELFlBQWhCLEVBQThCcUQsZUFBOUIsQ0FEMEIsR0FDdUJyRCxZQURuRDs7QUFHQSxNQUFJLHFCQUFRdUQsbUJBQVIsTUFBaUMsQ0FBckMsRUFBd0M7QUFDdEM7QUFDQTtBQUNBLFNBQUs5eEIsS0FBTCxHQUFhaVQsb0JBQVVjLEtBQXZCO0FBQ0E7QUFDRDs7QUFFRCxNQUFNZ2UsbUJBQW1CMUgsV0FBV3ozRCxTQUFYLEVBQXpCO0FBQ0EsTUFBSW0vRCxnQkFBSixFQUFzQjtBQUNwQixRQUFJLENBQUNGLGVBQUwsRUFBc0I7QUFDcEJBLHdCQUFrQkUsZ0JBQWxCO0FBQ0QsS0FGRCxNQUVPO0FBQ0xGLHdCQUFrQiw2QkFBZ0JBLGVBQWhCLEVBQWlDRSxnQkFBakMsQ0FBbEI7QUFDRDtBQUNGOztBQUVELE1BQU1uRSxtQkFBbUJrRCxlQUFldjhELGFBQWYsQ0FDdkIsS0FBS2k5RCxpQkFBTCxDQUF1QixDQUF2QixDQUR1QixDQUF6Qjs7QUFHQSxNQUFNN0QsZUFBZSx1QkFBVW1FLG1CQUFWLENBQXJCO0FBQ0EsTUFBTWhFLG1CQUFtQix1Q0FDdkJ6RCxVQUR1QixFQUNYcUQsVUFEVyxFQUNDQyxZQURELEVBQ2VDLGdCQURmLENBQXpCOztBQUdBLE1BQUksQ0FBQ3RpRCxTQUFTd2lELGdCQUFULENBQUQsSUFBK0JBLG9CQUFvQixDQUF2RCxFQUEwRDtBQUN4RDtBQUNBO0FBQ0EsU0FBSzl0QixLQUFMLEdBQWFpVCxvQkFBVWMsS0FBdkI7QUFDQTtBQUNEOztBQUVELE1BQU1pZSx5QkFBeUJmLHVCQUF1QnBoRSxTQUF2QixHQUM3Qm9oRSxrQkFENkIsR0FDUmdCLHVCQUR2Qjs7QUFHQTs7OztBQUlBLE9BQUtDLGNBQUwsR0FBc0IsSUFBSUMsdUJBQUosQ0FDcEI5SCxVQURvQixFQUNScUQsVUFEUSxFQUNJb0UsbUJBREosRUFDeUJELGVBRHpCLEVBRXBCL0QsbUJBQW1Ca0Usc0JBRkMsQ0FBdEI7O0FBSUEsTUFBSSxLQUFLRSxjQUFMLENBQW9CNUMsWUFBcEIsR0FBbUNwakUsTUFBbkMsS0FBOEMsQ0FBbEQsRUFBcUQ7QUFDbkQ7QUFDQSxTQUFLOHpDLEtBQUwsR0FBYWlULG9CQUFVYyxLQUF2QjtBQUNBO0FBQ0Q7O0FBRUQsT0FBSzRkLFFBQUwsR0FBZ0JkLGVBQWV1QixpQkFBZixDQUFpQ3RFLGdCQUFqQyxDQUFoQjtBQUNBLE1BQUlHLGVBQWUsS0FBS2lFLGNBQUwsQ0FBb0JHLHFCQUFwQixFQUFuQjs7QUFFQSxNQUFJUixlQUFKLEVBQXFCO0FBQ25CLFFBQUl4SCxXQUFXMEIsUUFBWCxFQUFKLEVBQTJCO0FBQ3pCa0MsbUJBQWEsQ0FBYixJQUFrQixpQkFDaEJBLGFBQWEsQ0FBYixDQURnQixFQUNDNEQsZ0JBQWdCLENBQWhCLENBREQsRUFDcUJBLGdCQUFnQixDQUFoQixDQURyQixDQUFsQjtBQUVBNUQsbUJBQWEsQ0FBYixJQUFrQixpQkFDaEJBLGFBQWEsQ0FBYixDQURnQixFQUNDNEQsZ0JBQWdCLENBQWhCLENBREQsRUFDcUJBLGdCQUFnQixDQUFoQixDQURyQixDQUFsQjtBQUVELEtBTEQsTUFLTztBQUNMNUQscUJBQWUsNkJBQWdCQSxZQUFoQixFQUE4QjRELGVBQTlCLENBQWY7QUFDRDtBQUNGOztBQUVELE1BQUksQ0FBQyxxQkFBUTVELFlBQVIsQ0FBTCxFQUE0QjtBQUMxQixTQUFLanVCLEtBQUwsR0FBYWlULG9CQUFVYyxLQUF2QjtBQUNELEdBRkQsTUFFTztBQUNMLFFBQU11ZSxjQUFjekIsZUFBZTBCLHlCQUFmLENBQ2xCdEUsWUFEa0IsRUFDSixLQUFLMEQsUUFERCxDQUFwQjs7QUFHQSxTQUFLLElBQUlhLE9BQU9GLFlBQVkzYSxJQUE1QixFQUFrQzZhLFFBQVFGLFlBQVkxYSxJQUF0RCxFQUE0RDRhLE1BQTVELEVBQW9FO0FBQ2xFLFdBQUssSUFBSUMsT0FBT0gsWUFBWXphLElBQTVCLEVBQWtDNGEsUUFBUUgsWUFBWXhhLElBQXRELEVBQTREMmEsTUFBNUQsRUFBb0U7QUFDbEUsWUFBTW45RCxPQUFPMDdELGdCQUFnQixLQUFLVyxRQUFyQixFQUErQmEsSUFBL0IsRUFBcUNDLElBQXJDLEVBQTJDbkUsVUFBM0MsQ0FBYjtBQUNBLFlBQUloNUQsSUFBSixFQUFVO0FBQ1IsZUFBS204RCxZQUFMLENBQWtCNWtFLElBQWxCLENBQXVCeUksSUFBdkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsUUFBSSxLQUFLbThELFlBQUwsQ0FBa0J2bEUsTUFBbEIsS0FBNkIsQ0FBakMsRUFBb0M7QUFDbEMsV0FBSzh6QyxLQUFMLEdBQWFpVCxvQkFBVWMsS0FBdkI7QUFDRDtBQUNGO0FBQ0YsQ0F6SkQ7O0FBMkpBLHFCQUFTNmMsVUFBVCxFQUFxQmxlLGNBQXJCOztBQUdBOzs7QUFHQWtlLFdBQVdybUQsU0FBWCxDQUFxQjZuQyxlQUFyQixHQUF1QyxZQUFXO0FBQ2hELE1BQUksS0FBS3BTLEtBQUwsSUFBY2lULG9CQUFVQyxPQUE1QixFQUFxQztBQUNuQyxTQUFLd2YsZ0JBQUw7QUFDRDtBQUNEaGdCLGlCQUFLbm9DLFNBQUwsQ0FBZTZuQyxlQUFmLENBQStCNW5DLElBQS9CLENBQW9DLElBQXBDO0FBQ0QsQ0FMRDs7QUFRQTs7OztBQUlBb21ELFdBQVdybUQsU0FBWCxDQUFxQnBVLFFBQXJCLEdBQWdDLFlBQVc7QUFDekMsU0FBTyxLQUFLazdELE9BQVo7QUFDRCxDQUZEOztBQUtBOzs7QUFHQVQsV0FBV3JtRCxTQUFYLENBQXFCb29ELFVBQXJCLEdBQWtDLFlBQVc7QUFDM0MsTUFBTS8rRCxVQUFVLEVBQWhCO0FBQ0EsT0FBSzY5RCxZQUFMLENBQWtCbGdELE9BQWxCLENBQTBCLFVBQVNqYyxJQUFULEVBQWV6SixDQUFmLEVBQWtCaTZDLEdBQWxCLEVBQXVCO0FBQy9DLFFBQUl4d0MsUUFBUUEsS0FBS0gsUUFBTCxNQUFtQjg5QyxvQkFBVWEsTUFBekMsRUFBaUQ7QUFDL0NsZ0QsY0FBUS9HLElBQVIsQ0FBYTtBQUNYcTBELGdCQUFRLEtBQUtvUSxlQUFMLENBQXFCcjdELGtCQUFyQixDQUF3Q1gsS0FBS2k5QyxTQUE3QyxDQURHO0FBRVhyM0MsZUFBTzVGLEtBQUthLFFBQUw7QUFGSSxPQUFiO0FBSUQ7QUFDRixHQVB5QixDQU94QmczQixJQVB3QixDQU9uQixJQVBtQixDQUExQjtBQVFBLE9BQUtza0MsWUFBTCxDQUFrQnZsRSxNQUFsQixHQUEyQixDQUEzQjs7QUFFQSxNQUFJMEgsUUFBUTFILE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsU0FBSzh6QyxLQUFMLEdBQWFpVCxvQkFBVVMsS0FBdkI7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFNcjJCLElBQUksS0FBS20wQyxpQkFBTCxDQUF1QixDQUF2QixDQUFWO0FBQ0EsUUFBTTErRCxPQUFPLEtBQUt5K0QsZUFBTCxDQUFxQnFCLFdBQXJCLENBQWlDdjFDLENBQWpDLENBQWI7QUFDQSxRQUFNcmdCLFFBQVEsT0FBT2xLLElBQVAsS0FBZ0IsUUFBaEIsR0FBMkJBLElBQTNCLEdBQWtDQSxLQUFLLENBQUwsQ0FBaEQ7QUFDQSxRQUFNbUssU0FBUyxPQUFPbkssSUFBUCxLQUFnQixRQUFoQixHQUEyQkEsSUFBM0IsR0FBa0NBLEtBQUssQ0FBTCxDQUFqRDtBQUNBLFFBQU04NkQsbUJBQW1CLEtBQUsyRCxlQUFMLENBQXFCaDlELGFBQXJCLENBQW1DOG9CLENBQW5DLENBQXpCO0FBQ0EsUUFBTXl3QyxtQkFBbUIsS0FBS3dELGVBQUwsQ0FBcUIvOEQsYUFBckIsQ0FBbUMsS0FBS285RCxRQUF4QyxDQUF6Qjs7QUFFQSxRQUFNcEQsZUFBZSxLQUFLZ0QsZUFBTCxDQUFxQnQ3RCxrQkFBckIsQ0FDbkIsS0FBS3U3RCxpQkFEYyxDQUFyQjtBQUVBLFNBQUtILE9BQUwsR0FBZSxvQkFBa0JyMEQsS0FBbEIsRUFBeUJDLE1BQXpCLEVBQWlDLEtBQUtrMEQsV0FBdEMsRUFDYnJELGdCQURhLEVBQ0ssS0FBS3dELGVBQUwsQ0FBcUIxK0QsU0FBckIsRUFETCxFQUViZzdELGdCQUZhLEVBRUtXLFlBRkwsRUFFbUIsS0FBSzJELGNBRnhCLEVBRXdDdCtELE9BRnhDLEVBR2IsS0FBS3c5RCxPQUhRLEVBR0MsS0FBS0YsWUFITixDQUFmOztBQUtBLFNBQUtseEIsS0FBTCxHQUFhaVQsb0JBQVVhLE1BQXZCO0FBQ0Q7QUFDRCxPQUFLUCxPQUFMO0FBQ0QsQ0FoQ0Q7O0FBbUNBOzs7QUFHQXFkLFdBQVdybUQsU0FBWCxDQUFxQnlwQyxJQUFyQixHQUE0QixZQUFXO0FBQ3JDLE1BQUksS0FBS2hVLEtBQUwsSUFBY2lULG9CQUFVZ0IsSUFBNUIsRUFBa0M7QUFDaEMsU0FBS2pVLEtBQUwsR0FBYWlULG9CQUFVQyxPQUF2QjtBQUNBLFNBQUtLLE9BQUw7O0FBRUEsUUFBSXNmLGFBQWEsQ0FBakI7O0FBRUEsU0FBS25CLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0EsU0FBS0QsWUFBTCxDQUFrQmxnRCxPQUFsQixDQUEwQixVQUFTamMsSUFBVCxFQUFlekosQ0FBZixFQUFrQmk2QyxHQUFsQixFQUF1QjtBQUMvQyxVQUFNOUYsUUFBUTFxQyxLQUFLSCxRQUFMLEVBQWQ7QUFDQSxVQUFJNnFDLFNBQVNpVCxvQkFBVWdCLElBQW5CLElBQTJCalUsU0FBU2lULG9CQUFVQyxPQUFsRCxFQUEyRDtBQUN6RDJmOztBQUVBLFlBQU1DLGtCQUFrQixvQkFBT3g5RCxJQUFQLEVBQWE0K0Msb0JBQVU0QixNQUF2QixFQUN0QixVQUFTcmxELENBQVQsRUFBWTtBQUNWLGNBQU11dkMsUUFBUTFxQyxLQUFLSCxRQUFMLEVBQWQ7QUFDQSxjQUFJNnFDLFNBQVNpVCxvQkFBVWEsTUFBbkIsSUFDRTlULFNBQVNpVCxvQkFBVVMsS0FEckIsSUFFRTFULFNBQVNpVCxvQkFBVWMsS0FGekIsRUFFZ0M7QUFDOUIsdUNBQWMrZSxlQUFkO0FBQ0FEO0FBQ0EsZ0JBQUlBLGVBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsbUJBQUtILGdCQUFMO0FBQ0EsbUJBQUtDLFVBQUw7QUFDRDtBQUNGO0FBQ0YsU0FicUIsRUFhbkIsSUFibUIsQ0FBeEI7QUFjQSxhQUFLakIsb0JBQUwsQ0FBMEI3a0UsSUFBMUIsQ0FBK0JpbUUsZUFBL0I7QUFDRDtBQUNGLEtBckJ5QixDQXFCeEIzbEMsSUFyQndCLENBcUJuQixJQXJCbUIsQ0FBMUI7O0FBdUJBLFNBQUtza0MsWUFBTCxDQUFrQmxnRCxPQUFsQixDQUEwQixVQUFTamMsSUFBVCxFQUFlekosQ0FBZixFQUFrQmk2QyxHQUFsQixFQUF1QjtBQUMvQyxVQUFNOUYsUUFBUTFxQyxLQUFLSCxRQUFMLEVBQWQ7QUFDQSxVQUFJNnFDLFNBQVNpVCxvQkFBVWdCLElBQXZCLEVBQTZCO0FBQzNCMytDLGFBQUswK0MsSUFBTDtBQUNEO0FBQ0YsS0FMRDs7QUFPQSxRQUFJNmUsZUFBZSxDQUFuQixFQUFzQjtBQUNwQm5pRSxpQkFBVyxLQUFLaWlFLFVBQUwsQ0FBZ0J4bEMsSUFBaEIsQ0FBcUIsSUFBckIsQ0FBWCxFQUF1QyxDQUF2QztBQUNEO0FBQ0Y7QUFDRixDQTFDRDs7QUE2Q0E7OztBQUdBeWpDLFdBQVdybUQsU0FBWCxDQUFxQm1vRCxnQkFBckIsR0FBd0MsWUFBVztBQUNqRCxPQUFLaEIsb0JBQUwsQ0FBMEJuZ0QsT0FBMUIsQ0FBa0M2aUMscUJBQWxDO0FBQ0EsT0FBS3NkLG9CQUFMLEdBQTRCLElBQTVCO0FBQ0QsQ0FIRDtrQkFJZWQsVTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcFRmOztBQUVBOztBQUNBOztBQUdBOzs7Ozs7O0FBUUE7Ozs7Ozs7QUFPQSxJQUFNbUMsa0JBQWtCLEVBQXhCOztBQUdBOzs7Ozs7OztBQTNCQTs7O0FBbUNBLElBQU1DLHFCQUFxQixJQUEzQjs7QUFHQTs7Ozs7Ozs7Ozs7O0FBWUEsSUFBTWIsZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFTOUgsVUFBVCxFQUFxQnFELFVBQXJCLEVBQWlDYSxZQUFqQyxFQUNwQnNELGVBRG9CLEVBQ0hvQixjQURHLEVBQ2E7O0FBRWpDOzs7O0FBSUEsT0FBS0MsV0FBTCxHQUFtQjdJLFVBQW5COztBQUVBOzs7O0FBSUEsT0FBSzhJLFdBQUwsR0FBbUJ6RixVQUFuQjs7QUFFQTtBQUNBLE1BQUkwRixvQkFBb0IsRUFBeEI7QUFDQSxNQUFNQyxlQUFlLHdCQUFhLEtBQUtGLFdBQWxCLEVBQStCLEtBQUtELFdBQXBDLENBQXJCOztBQUVBOzs7OztBQUtBLE9BQUtJLGFBQUwsR0FBcUIsVUFBU3o1QyxDQUFULEVBQVk7QUFDL0IsUUFBTTNrQixNQUFNMmtCLEVBQUUsQ0FBRixJQUFPLEdBQVAsR0FBYUEsRUFBRSxDQUFGLENBQXpCO0FBQ0EsUUFBSSxDQUFDdTVDLGtCQUFrQmwrRCxHQUFsQixDQUFMLEVBQTZCO0FBQzNCaytELHdCQUFrQmwrRCxHQUFsQixJQUF5Qm0rRCxhQUFheDVDLENBQWIsQ0FBekI7QUFDRDtBQUNELFdBQU91NUMsa0JBQWtCbCtELEdBQWxCLENBQVA7QUFDRCxHQU5EOztBQVFBOzs7O0FBSUEsT0FBS3ErRCxnQkFBTCxHQUF3QjFCLGVBQXhCOztBQUVBOzs7O0FBSUEsT0FBSzJCLHNCQUFMLEdBQThCUCxpQkFBaUJBLGNBQS9DOztBQUVBOzs7O0FBSUEsT0FBS1EsVUFBTCxHQUFrQixFQUFsQjs7QUFFQTs7Ozs7QUFLQSxPQUFLQyxlQUFMLEdBQXVCLEtBQXZCOztBQUVBOzs7O0FBSUEsT0FBS0MsaUJBQUwsR0FBeUIsS0FBS1QsV0FBTCxDQUFpQm5ILFFBQWpCLE1BQ3JCLENBQUMsQ0FBQzhGLGVBRG1CLElBRXJCLENBQUMsQ0FBQyxLQUFLcUIsV0FBTCxDQUFpQnRnRSxTQUFqQixFQUZtQixJQUdwQixzQkFBU2kvRCxlQUFULEtBQTZCLHNCQUFTLEtBQUtxQixXQUFMLENBQWlCdGdFLFNBQWpCLEVBQVQsQ0FIbEM7O0FBS0E7Ozs7QUFJQSxPQUFLZ2hFLGlCQUFMLEdBQXlCLEtBQUtWLFdBQUwsQ0FBaUJ0Z0UsU0FBakIsS0FDdkIsc0JBQVMsS0FBS3NnRSxXQUFMLENBQWlCdGdFLFNBQWpCLEVBQVQsQ0FEdUIsR0FDa0IsSUFEM0M7O0FBR0E7Ozs7QUFJQSxPQUFLaWhFLGlCQUFMLEdBQXlCLEtBQUtWLFdBQUwsQ0FBaUJ2Z0UsU0FBakIsS0FDdkIsc0JBQVMsS0FBS3VnRSxXQUFMLENBQWlCdmdFLFNBQWpCLEVBQVQsQ0FEdUIsR0FDa0IsSUFEM0M7O0FBR0EsTUFBTWtoRSxxQkFBcUIsd0JBQVd2RixZQUFYLENBQTNCO0FBQ0EsTUFBTXdGLHNCQUFzQix5QkFBWXhGLFlBQVosQ0FBNUI7QUFDQSxNQUFNeUYseUJBQXlCLDRCQUFlekYsWUFBZixDQUEvQjtBQUNBLE1BQU0wRix3QkFBd0IsMkJBQWMxRixZQUFkLENBQTlCO0FBQ0EsTUFBTTJGLGdCQUFnQixLQUFLWixhQUFMLENBQW1CUSxrQkFBbkIsQ0FBdEI7QUFDQSxNQUFNSyxpQkFBaUIsS0FBS2IsYUFBTCxDQUFtQlMsbUJBQW5CLENBQXZCO0FBQ0EsTUFBTUssb0JBQW9CLEtBQUtkLGFBQUwsQ0FBbUJVLHNCQUFuQixDQUExQjtBQUNBLE1BQU1LLG1CQUFtQixLQUFLZixhQUFMLENBQW1CVyxxQkFBbkIsQ0FBekI7O0FBRUEsT0FBS0ssUUFBTCxDQUNFUixrQkFERixFQUNzQkMsbUJBRHRCLEVBRUVDLHNCQUZGLEVBRTBCQyxxQkFGMUIsRUFHRUMsYUFIRixFQUdpQkMsY0FIakIsRUFHaUNDLGlCQUhqQyxFQUdvREMsZ0JBSHBELEVBSUV0QixlQUpGOztBQU1BLE1BQUksS0FBS1csZUFBVCxFQUEwQjtBQUN4QixRQUFJYSxZQUFZMXdELFFBQWhCO0FBQ0EsU0FBSzR2RCxVQUFMLENBQWdCbGlELE9BQWhCLENBQXdCLFVBQVNnK0MsUUFBVCxFQUFtQjFqRSxDQUFuQixFQUFzQmk2QyxHQUF0QixFQUEyQjtBQUNqRHl1QixrQkFBWTF0RCxLQUFLbkcsR0FBTCxDQUFTNnpELFNBQVQsRUFDVmhGLFNBQVNuaEUsTUFBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQURVLEVBQ2FtaEUsU0FBU25oRSxNQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBRGIsRUFDb0NtaEUsU0FBU25oRSxNQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBRHBDLENBQVo7QUFFRCxLQUhEOztBQUtBO0FBQ0E7QUFDQSxTQUFLcWxFLFVBQUwsQ0FBZ0JsaUQsT0FBaEIsQ0FBd0IsVUFBU2crQyxRQUFULEVBQW1CO0FBQ3pDLFVBQUkxb0QsS0FBS2xHLEdBQUwsQ0FBUzR1RCxTQUFTbmhFLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBVCxFQUFnQ21oRSxTQUFTbmhFLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBaEMsRUFDRm1oRSxTQUFTbmhFLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FERSxJQUN1Qm1tRSxTQUR2QixHQUNtQyxLQUFLWCxpQkFBTCxHQUF5QixDQURoRSxFQUNtRTtBQUNqRSxZQUFNWSxjQUFjLENBQUMsQ0FBQ2pGLFNBQVNuaEUsTUFBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFELEVBQXdCbWhFLFNBQVNuaEUsTUFBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUF4QixDQUFELEVBQ2xCLENBQUNtaEUsU0FBU25oRSxNQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQUQsRUFBd0JtaEUsU0FBU25oRSxNQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQXhCLENBRGtCLEVBRWxCLENBQUNtaEUsU0FBU25oRSxNQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQUQsRUFBd0JtaEUsU0FBU25oRSxNQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQXhCLENBRmtCLENBQXBCO0FBR0EsWUFBS29tRSxZQUFZLENBQVosRUFBZSxDQUFmLElBQW9CRCxTQUFyQixHQUFrQyxLQUFLWCxpQkFBTCxHQUF5QixDQUEvRCxFQUFrRTtBQUNoRVksc0JBQVksQ0FBWixFQUFlLENBQWYsS0FBcUIsS0FBS1osaUJBQTFCO0FBQ0Q7QUFDRCxZQUFLWSxZQUFZLENBQVosRUFBZSxDQUFmLElBQW9CRCxTQUFyQixHQUFrQyxLQUFLWCxpQkFBTCxHQUF5QixDQUEvRCxFQUFrRTtBQUNoRVksc0JBQVksQ0FBWixFQUFlLENBQWYsS0FBcUIsS0FBS1osaUJBQTFCO0FBQ0Q7QUFDRCxZQUFLWSxZQUFZLENBQVosRUFBZSxDQUFmLElBQW9CRCxTQUFyQixHQUFrQyxLQUFLWCxpQkFBTCxHQUF5QixDQUEvRCxFQUFrRTtBQUNoRVksc0JBQVksQ0FBWixFQUFlLENBQWYsS0FBcUIsS0FBS1osaUJBQTFCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBTWpjLE9BQU85d0MsS0FBS25HLEdBQUwsQ0FDWDh6RCxZQUFZLENBQVosRUFBZSxDQUFmLENBRFcsRUFDUUEsWUFBWSxDQUFaLEVBQWUsQ0FBZixDQURSLEVBQzJCQSxZQUFZLENBQVosRUFBZSxDQUFmLENBRDNCLENBQWI7QUFFQSxZQUFNNWMsT0FBTy93QyxLQUFLbEcsR0FBTCxDQUNYNnpELFlBQVksQ0FBWixFQUFlLENBQWYsQ0FEVyxFQUNRQSxZQUFZLENBQVosRUFBZSxDQUFmLENBRFIsRUFDMkJBLFlBQVksQ0FBWixFQUFlLENBQWYsQ0FEM0IsQ0FBYjtBQUVBLFlBQUs1YyxPQUFPRCxJQUFSLEdBQWdCLEtBQUtpYyxpQkFBTCxHQUF5QixDQUE3QyxFQUFnRDtBQUM5Q3JFLG1CQUFTbmhFLE1BQVQsR0FBa0JvbUUsV0FBbEI7QUFDRDtBQUNGO0FBQ0YsS0EzQnVCLENBMkJ0QnJuQyxJQTNCc0IsQ0EyQmpCLElBM0JpQixDQUF4QjtBQTRCRDs7QUFFRGltQyxzQkFBb0IsRUFBcEI7QUFDRCxDQXZJRDs7QUEwSUE7Ozs7Ozs7Ozs7QUFVQWpCLGNBQWM1bkQsU0FBZCxDQUF3QmtxRCxZQUF4QixHQUF1QyxVQUFTMzlELENBQVQsRUFBWWdmLENBQVosRUFBZStELENBQWYsRUFDckM2NkMsSUFEcUMsRUFDL0JDLElBRCtCLEVBQ3pCQyxJQUR5QixFQUNuQjtBQUNsQixPQUFLbkIsVUFBTCxDQUFnQjVtRSxJQUFoQixDQUFxQjtBQUNuQnVCLFlBQVEsQ0FBQ3NtRSxJQUFELEVBQU9DLElBQVAsRUFBYUMsSUFBYixDQURXO0FBRW5CLzlELFlBQVEsQ0FBQ0MsQ0FBRCxFQUFJZ2YsQ0FBSixFQUFPK0QsQ0FBUDtBQUZXLEdBQXJCO0FBSUQsQ0FORDs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQXM0QyxjQUFjNW5ELFNBQWQsQ0FBd0IrcEQsUUFBeEIsR0FBbUMsVUFBU3g5RCxDQUFULEVBQVlnZixDQUFaLEVBQWUrRCxDQUFmLEVBQWtCbUYsQ0FBbEIsRUFDakMwMUMsSUFEaUMsRUFDM0JDLElBRDJCLEVBQ3JCQyxJQURxQixFQUNmQyxJQURlLEVBQ1RDLGNBRFMsRUFDTzs7QUFFeEMsTUFBTUMsbUJBQW1CLDRCQUFlLENBQUNMLElBQUQsRUFBT0MsSUFBUCxFQUFhQyxJQUFiLEVBQW1CQyxJQUFuQixDQUFmLENBQXpCO0FBQ0EsTUFBTUcsa0JBQWtCLEtBQUtwQixpQkFBTCxHQUN0QixzQkFBU21CLGdCQUFULElBQTZCLEtBQUtuQixpQkFEWixHQUNnQyxJQUR4RDtBQUVBLE1BQU1xQixtQkFBbUIscUJBQXVCLEtBQUtyQixpQkFBckQ7O0FBRUE7QUFDQTtBQUNBLE1BQU1zQixTQUFTLEtBQUtoQyxXQUFMLENBQWlCbkgsUUFBakIsTUFDRmlKLGtCQUFrQixHQURoQixJQUN1QkEsa0JBQWtCLENBRHhEOztBQUdBLE1BQUlHLG1CQUFtQixLQUF2Qjs7QUFFQSxNQUFJTCxpQkFBaUIsQ0FBckIsRUFBd0I7QUFDdEIsUUFBSSxLQUFLM0IsV0FBTCxDQUFpQmpILFFBQWpCLE1BQStCLEtBQUsySCxpQkFBeEMsRUFBMkQ7QUFDekQsVUFBTXVCLG1CQUFtQiw0QkFBZSxDQUFDdCtELENBQUQsRUFBSWdmLENBQUosRUFBTytELENBQVAsRUFBVW1GLENBQVYsQ0FBZixDQUF6QjtBQUNBLFVBQU1xMkMsa0JBQWtCLHNCQUFTRCxnQkFBVCxJQUE2QixLQUFLdkIsaUJBQTFEO0FBQ0FzQiwwQkFDSUUsa0JBQWtCckMsa0JBRHRCO0FBRUQ7QUFDRCxRQUFJLENBQUNrQyxNQUFELElBQVcsS0FBS2hDLFdBQUwsQ0FBaUJoSCxRQUFqQixFQUFYLElBQTBDOEksZUFBOUMsRUFBK0Q7QUFDN0RHLDBCQUNJSCxrQkFBa0JoQyxrQkFEdEI7QUFFRDtBQUNGOztBQUVELE1BQUksQ0FBQ21DLGdCQUFELElBQXFCLEtBQUs1QixnQkFBOUIsRUFBZ0Q7QUFDOUMsUUFBSSxDQUFDLHdCQUFXd0IsZ0JBQVgsRUFBNkIsS0FBS3hCLGdCQUFsQyxDQUFMLEVBQTBEO0FBQ3hEO0FBQ0E7QUFDRDtBQUNGOztBQUVELE1BQUksQ0FBQzRCLGdCQUFMLEVBQXVCO0FBQ3JCLFFBQUksQ0FBQzdwRCxTQUFTb3BELEtBQUssQ0FBTCxDQUFULENBQUQsSUFBc0IsQ0FBQ3BwRCxTQUFTb3BELEtBQUssQ0FBTCxDQUFULENBQXZCLElBQ0EsQ0FBQ3BwRCxTQUFTcXBELEtBQUssQ0FBTCxDQUFULENBREQsSUFDc0IsQ0FBQ3JwRCxTQUFTcXBELEtBQUssQ0FBTCxDQUFULENBRHZCLElBRUEsQ0FBQ3JwRCxTQUFTc3BELEtBQUssQ0FBTCxDQUFULENBRkQsSUFFc0IsQ0FBQ3RwRCxTQUFTc3BELEtBQUssQ0FBTCxDQUFULENBRnZCLElBR0EsQ0FBQ3RwRCxTQUFTdXBELEtBQUssQ0FBTCxDQUFULENBSEQsSUFHc0IsQ0FBQ3ZwRCxTQUFTdXBELEtBQUssQ0FBTCxDQUFULENBSDNCLEVBRzhDO0FBQzVDLFVBQUlDLGlCQUFpQixDQUFyQixFQUF3QjtBQUN0QkssMkJBQW1CLElBQW5CO0FBQ0QsT0FGRCxNQUVPO0FBQ0w7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSUwsaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLFFBQUksQ0FBQ0ssZ0JBQUwsRUFBdUI7QUFDckIsVUFBTTNpRSxTQUFTLENBQUMsQ0FBQ3NFLEVBQUUsQ0FBRixJQUFPK2lCLEVBQUUsQ0FBRixDQUFSLElBQWdCLENBQWpCLEVBQW9CLENBQUMvaUIsRUFBRSxDQUFGLElBQU8raUIsRUFBRSxDQUFGLENBQVIsSUFBZ0IsQ0FBcEMsQ0FBZjtBQUNBLFVBQU15N0MsWUFBWSxLQUFLaEMsYUFBTCxDQUFtQjlnRSxNQUFuQixDQUFsQjs7QUFFQSxVQUFJK3VELFdBQUo7QUFDQSxVQUFJMlQsTUFBSixFQUFZO0FBQ1YsWUFBTUssa0JBQ0YsQ0FBQyxrQkFBT2IsS0FBSyxDQUFMLENBQVAsRUFBZ0JPLGdCQUFoQixJQUNBLGtCQUFPTCxLQUFLLENBQUwsQ0FBUCxFQUFnQkssZ0JBQWhCLENBREQsSUFDc0MsQ0FGMUM7QUFHQTFULGFBQUtnVSxrQkFDRCxrQkFBT0QsVUFBVSxDQUFWLENBQVAsRUFBcUJMLGdCQUFyQixDQURKO0FBRUQsT0FORCxNQU1PO0FBQ0wxVCxhQUFLLENBQUNtVCxLQUFLLENBQUwsSUFBVUUsS0FBSyxDQUFMLENBQVgsSUFBc0IsQ0FBdEIsR0FBMEJVLFVBQVUsQ0FBVixDQUEvQjtBQUNEO0FBQ0QsVUFBTTlULEtBQUssQ0FBQ2tULEtBQUssQ0FBTCxJQUFVRSxLQUFLLENBQUwsQ0FBWCxJQUFzQixDQUF0QixHQUEwQlUsVUFBVSxDQUFWLENBQXJDO0FBQ0EsVUFBTUUsd0JBQXdCalUsS0FBS0EsRUFBTCxHQUFVQyxLQUFLQSxFQUE3QztBQUNBMlQseUJBQW1CSyx3QkFBd0IsS0FBS2hDLHNCQUFoRDtBQUNEO0FBQ0QsUUFBSTJCLGdCQUFKLEVBQXNCO0FBQ3BCLFVBQUl0dUQsS0FBS2pHLEdBQUwsQ0FBUzlKLEVBQUUsQ0FBRixJQUFPK2lCLEVBQUUsQ0FBRixDQUFoQixLQUF5QmhULEtBQUtqRyxHQUFMLENBQVM5SixFQUFFLENBQUYsSUFBTytpQixFQUFFLENBQUYsQ0FBaEIsQ0FBN0IsRUFBb0Q7QUFDbEQ7QUFDQSxZQUFNNDdDLEtBQUssQ0FBQyxDQUFDMy9DLEVBQUUsQ0FBRixJQUFPK0QsRUFBRSxDQUFGLENBQVIsSUFBZ0IsQ0FBakIsRUFBb0IsQ0FBQy9ELEVBQUUsQ0FBRixJQUFPK0QsRUFBRSxDQUFGLENBQVIsSUFBZ0IsQ0FBcEMsQ0FBWDtBQUNBLFlBQU02N0MsUUFBUSxLQUFLcEMsYUFBTCxDQUFtQm1DLEVBQW5CLENBQWQ7QUFDQSxZQUFNRSxLQUFLLENBQUMsQ0FBQzMyQyxFQUFFLENBQUYsSUFBT2xvQixFQUFFLENBQUYsQ0FBUixJQUFnQixDQUFqQixFQUFvQixDQUFDa29CLEVBQUUsQ0FBRixJQUFPbG9CLEVBQUUsQ0FBRixDQUFSLElBQWdCLENBQXBDLENBQVg7QUFDQSxZQUFNOCtELFFBQVEsS0FBS3RDLGFBQUwsQ0FBbUJxQyxFQUFuQixDQUFkOztBQUVBLGFBQUtyQixRQUFMLENBQ0V4OUQsQ0FERixFQUNLZ2YsQ0FETCxFQUNRMi9DLEVBRFIsRUFDWUUsRUFEWixFQUNnQmpCLElBRGhCLEVBQ3NCQyxJQUR0QixFQUM0QmUsS0FENUIsRUFDbUNFLEtBRG5DLEVBQzBDZCxpQkFBaUIsQ0FEM0Q7QUFFQSxhQUFLUixRQUFMLENBQ0VxQixFQURGLEVBQ01GLEVBRE4sRUFDVTU3QyxDQURWLEVBQ2FtRixDQURiLEVBQ2dCNDJDLEtBRGhCLEVBQ3VCRixLQUR2QixFQUM4QmQsSUFEOUIsRUFDb0NDLElBRHBDLEVBQzBDQyxpQkFBaUIsQ0FEM0Q7QUFFRCxPQVhELE1BV087QUFDTDtBQUNBLFlBQU1lLEtBQUssQ0FBQyxDQUFDLytELEVBQUUsQ0FBRixJQUFPZ2YsRUFBRSxDQUFGLENBQVIsSUFBZ0IsQ0FBakIsRUFBb0IsQ0FBQ2hmLEVBQUUsQ0FBRixJQUFPZ2YsRUFBRSxDQUFGLENBQVIsSUFBZ0IsQ0FBcEMsQ0FBWDtBQUNBLFlBQU1nZ0QsUUFBUSxLQUFLeEMsYUFBTCxDQUFtQnVDLEVBQW5CLENBQWQ7QUFDQSxZQUFNRSxLQUFLLENBQUMsQ0FBQ2w4QyxFQUFFLENBQUYsSUFBT21GLEVBQUUsQ0FBRixDQUFSLElBQWdCLENBQWpCLEVBQW9CLENBQUNuRixFQUFFLENBQUYsSUFBT21GLEVBQUUsQ0FBRixDQUFSLElBQWdCLENBQXBDLENBQVg7QUFDQSxZQUFNZzNDLFFBQVEsS0FBSzFDLGFBQUwsQ0FBbUJ5QyxFQUFuQixDQUFkOztBQUVBLGFBQUt6QixRQUFMLENBQ0V4OUQsQ0FERixFQUNLKytELEVBREwsRUFDU0UsRUFEVCxFQUNhLzJDLENBRGIsRUFDZ0IwMUMsSUFEaEIsRUFDc0JvQixLQUR0QixFQUM2QkUsS0FEN0IsRUFDb0NuQixJQURwQyxFQUMwQ0MsaUJBQWlCLENBRDNEO0FBRUEsYUFBS1IsUUFBTCxDQUNFdUIsRUFERixFQUNNLy9DLENBRE4sRUFDUytELENBRFQsRUFDWWs4QyxFQURaLEVBQ2dCRCxLQURoQixFQUN1Qm5CLElBRHZCLEVBQzZCQyxJQUQ3QixFQUNtQ29CLEtBRG5DLEVBQzBDbEIsaUJBQWlCLENBRDNEO0FBRUQ7QUFDRDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUksTUFBSixFQUFZO0FBQ1YsUUFBSSxDQUFDLEtBQUt2QixpQkFBVixFQUE2QjtBQUMzQjtBQUNEO0FBQ0QsU0FBS0QsZUFBTCxHQUF1QixJQUF2QjtBQUNEOztBQUVELE9BQUtlLFlBQUwsQ0FBa0IzOUQsQ0FBbEIsRUFBcUIraUIsQ0FBckIsRUFBd0JtRixDQUF4QixFQUEyQjAxQyxJQUEzQixFQUFpQ0UsSUFBakMsRUFBdUNDLElBQXZDO0FBQ0EsT0FBS0osWUFBTCxDQUFrQjM5RCxDQUFsQixFQUFxQmdmLENBQXJCLEVBQXdCK0QsQ0FBeEIsRUFBMkI2NkMsSUFBM0IsRUFBaUNDLElBQWpDLEVBQXVDQyxJQUF2QztBQUNELENBeEdEOztBQTJHQTs7Ozs7QUFLQXpDLGNBQWM1bkQsU0FBZCxDQUF3QjhuRCxxQkFBeEIsR0FBZ0QsWUFBVztBQUN6RCxNQUFNblIsU0FBUywwQkFBZjs7QUFFQSxPQUFLdVMsVUFBTCxDQUFnQmxpRCxPQUFoQixDQUF3QixVQUFTZytDLFFBQVQsRUFBbUIxakUsQ0FBbkIsRUFBc0JpNkMsR0FBdEIsRUFBMkI7QUFDakQsUUFBTS92QyxNQUFNdzVELFNBQVNuaEUsTUFBckI7QUFDQSxrQ0FBaUI4eUQsTUFBakIsRUFBeUJuckQsSUFBSSxDQUFKLENBQXpCO0FBQ0Esa0NBQWlCbXJELE1BQWpCLEVBQXlCbnJELElBQUksQ0FBSixDQUF6QjtBQUNBLGtDQUFpQm1yRCxNQUFqQixFQUF5Qm5yRCxJQUFJLENBQUosQ0FBekI7QUFDRCxHQUxEOztBQU9BLFNBQU9tckQsTUFBUDtBQUNELENBWEQ7O0FBY0E7OztBQUdBaVIsY0FBYzVuRCxTQUFkLENBQXdCK2tELFlBQXhCLEdBQXVDLFlBQVc7QUFDaEQsU0FBTyxLQUFLbUUsVUFBWjtBQUNELENBRkQ7a0JBR2V0QixhOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25XZjs7Ozs7QUFLTyxJQUFNRiw0Q0FBa0IsR0FBeEI7O0FBRVA7Ozs7O0FBS08sSUFBTWdFLGtFQUE2QixJQUFuQyxDOzs7Ozs7Ozs7Ozs7Ozs7OztRQ09TLzdELE0sR0FBQUEsTTtRQWVBZzhELE8sR0FBQUEsTztRQVlBaC9DLEssR0FBQUEsSztRQW1CQWkvQyxNLEdBQUFBLE07QUFqRWhCOzs7O0FBS0E7Ozs7OztBQU9BOzs7Ozs7O0FBT08sU0FBU2o4RCxNQUFULENBQWdCcEgsSUFBaEIsRUFBc0JpbkIsR0FBdEIsRUFBMkJxOEMsUUFBM0IsRUFBcUM7QUFDMUMsTUFBSUEsYUFBYXZtRSxTQUFqQixFQUE0QjtBQUMxQnVtRSxlQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWDtBQUNEO0FBQ0RBLFdBQVMsQ0FBVCxJQUFjdGpFLEtBQUssQ0FBTCxJQUFVLElBQUlpbkIsR0FBNUI7QUFDQXE4QyxXQUFTLENBQVQsSUFBY3RqRSxLQUFLLENBQUwsSUFBVSxJQUFJaW5CLEdBQTVCO0FBQ0EsU0FBT3E4QyxRQUFQO0FBQ0Q7O0FBR0Q7Ozs7O0FBS08sU0FBU0YsT0FBVCxDQUFpQnBqRSxJQUFqQixFQUF1QjtBQUM1QixTQUFPQSxLQUFLLENBQUwsSUFBVSxDQUFWLElBQWVBLEtBQUssQ0FBTCxJQUFVLENBQWhDO0FBQ0Q7O0FBR0Q7Ozs7Ozs7QUFPTyxTQUFTb2tCLEtBQVQsQ0FBZXBrQixJQUFmLEVBQXFCdWpFLEtBQXJCLEVBQTRCRCxRQUE1QixFQUFzQztBQUMzQyxNQUFJQSxhQUFhdm1FLFNBQWpCLEVBQTRCO0FBQzFCdW1FLGVBQVcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFYO0FBQ0Q7QUFDREEsV0FBUyxDQUFULElBQWV0akUsS0FBSyxDQUFMLElBQVV1akUsS0FBVixHQUFrQixHQUFuQixHQUEwQixDQUF4QztBQUNBRCxXQUFTLENBQVQsSUFBZXRqRSxLQUFLLENBQUwsSUFBVXVqRSxLQUFWLEdBQWtCLEdBQW5CLEdBQTBCLENBQXhDO0FBQ0EsU0FBT0QsUUFBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7QUFTTyxTQUFTRCxNQUFULENBQWdCcmpFLElBQWhCLEVBQXNCc2pFLFFBQXRCLEVBQWdDO0FBQ3JDLE1BQUlycUUsTUFBTUMsT0FBTixDQUFjOEcsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLFdBQU9BLElBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJc2pFLGFBQWF2bUUsU0FBakIsRUFBNEI7QUFDMUJ1bUUsaUJBQVcsQ0FBQ3RqRSxJQUFELEVBQU9BLElBQVAsQ0FBWDtBQUNELEtBRkQsTUFFTztBQUNMc2pFLGVBQVMsQ0FBVCxJQUFjQSxTQUFTLENBQVQsSUFBYyxxQkFBdUJ0akUsSUFBbkQ7QUFDRDtBQUNELFdBQU9zakUsUUFBUDtBQUNEO0FBQ0YsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekVEOztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBOzs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBTUUsU0FBUyxTQUFUQSxNQUFTLENBQVM3eUQsT0FBVCxFQUFrQjs7QUFFL0JteEMsbUJBQVdwcUMsSUFBWCxDQUFnQixJQUFoQjs7QUFFQTs7OztBQUlBLE9BQUsrckQsV0FBTCxHQUFtQixlQUFjOXlELFFBQVEzSyxVQUF0QixDQUFuQjs7QUFFQTs7OztBQUlBLE9BQUswOUQsYUFBTCxHQUFxQixLQUFLQyxrQkFBTCxDQUF3Qmh6RCxRQUFRaFAsWUFBaEMsQ0FBckI7O0FBRUE7Ozs7QUFJQSxPQUFLaWlFLE1BQUwsR0FBY2p6RCxRQUFRdThCLEtBQVIsS0FBa0Jud0MsU0FBbEIsR0FDWjRULFFBQVF1OEIsS0FESSxHQUNJMjJCLGdCQUFZQyxLQUQ5Qjs7QUFHQTs7OztBQUlBLE9BQUtDLE1BQUwsR0FBY3B6RCxRQUFRcXpELEtBQVIsS0FBa0JqbkUsU0FBbEIsR0FBOEI0VCxRQUFRcXpELEtBQXRDLEdBQThDLEtBQTVEO0FBRUQsQ0E3QkQsQyxDQXJEQTs7Ozs7QUFvRkEscUJBQVNSLE1BQVQsRUFBaUIxaEIsZ0JBQWpCOztBQUVBOzs7OztBQUtBMGhCLE9BQU8vckQsU0FBUCxDQUFpQmtzRCxrQkFBakIsR0FBc0MsVUFBU00sZUFBVCxFQUEwQjtBQUM5RCxNQUFJLENBQUNBLGVBQUwsRUFBc0I7QUFDcEIsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFJaHJFLE1BQU1DLE9BQU4sQ0FBYytxRSxlQUFkLENBQUosRUFBb0M7QUFDbEMsV0FBTyxVQUFTQyxVQUFULEVBQXFCO0FBQzFCLGFBQU9ELGVBQVA7QUFDRCxLQUZEO0FBR0Q7O0FBRUQsTUFBSSxPQUFPQSxlQUFQLEtBQTJCLFVBQS9CLEVBQTJDO0FBQ3pDLFdBQU9BLGVBQVA7QUFDRDs7QUFFRCxTQUFPLFVBQVNDLFVBQVQsRUFBcUI7QUFDMUIsV0FBTyxDQUFDRCxlQUFELENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FqQkQ7O0FBbUJBOzs7Ozs7Ozs7O0FBVUFULE9BQU8vckQsU0FBUCxDQUFpQjBzRCwwQkFBakIsR0FBOEM1a0Isb0JBQTlDOztBQUdBOzs7O0FBSUFpa0IsT0FBTy9yRCxTQUFQLENBQWlCOVUsZUFBakIsR0FBbUMsWUFBVztBQUM1QyxTQUFPLEtBQUsrZ0UsYUFBWjtBQUNELENBRkQ7O0FBS0E7Ozs7O0FBS0FGLE9BQU8vckQsU0FBUCxDQUFpQjVYLGFBQWpCLEdBQWlDLFlBQVc7QUFDMUMsU0FBTyxLQUFLNGpFLFdBQVo7QUFDRCxDQUZEOztBQUtBOzs7O0FBSUFELE9BQU8vckQsU0FBUCxDQUFpQjJzRCxjQUFqQixHQUFrQyxZQUFXLENBQUUsQ0FBL0M7O0FBR0E7Ozs7O0FBS0FaLE9BQU8vckQsU0FBUCxDQUFpQnBWLFFBQWpCLEdBQTRCLFlBQVc7QUFDckMsU0FBTyxLQUFLdWhFLE1BQVo7QUFDRCxDQUZEOztBQUtBOzs7QUFHQUosT0FBTy9yRCxTQUFQLENBQWlCNHNELFFBQWpCLEdBQTRCLFlBQVc7QUFDckMsU0FBTyxLQUFLTixNQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7OztBQUlBUCxPQUFPL3JELFNBQVAsQ0FBaUI2c0QsT0FBakIsR0FBMkIsWUFBVztBQUNwQyxPQUFLN2pCLE9BQUw7QUFDRCxDQUZEOztBQUtBOzs7Ozs7O0FBT0EraUIsT0FBTy9yRCxTQUFQLENBQWlCOHNELGVBQWpCLEdBQW1DLFVBQVM1aUUsWUFBVCxFQUF1QjtBQUN4RCxPQUFLK2hFLGFBQUwsR0FBcUIsS0FBS0Msa0JBQUwsQ0FBd0JoaUUsWUFBeEIsQ0FBckI7QUFDQSxPQUFLOCtDLE9BQUw7QUFDRCxDQUhEOztBQU1BOzs7OztBQUtBK2lCLE9BQU8vckQsU0FBUCxDQUFpQmdzQyxRQUFqQixHQUE0QixVQUFTdlcsS0FBVCxFQUFnQjtBQUMxQyxPQUFLMDJCLE1BQUwsR0FBYzEyQixLQUFkO0FBQ0EsT0FBS3VULE9BQUw7QUFDRCxDQUhEO2tCQUllK2lCLE07Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdE1mOzs7O0FBSUE7Ozs7a0JBSWU7QUFDYmprQixhQUFXLFdBREU7QUFFYmEsV0FBUyxTQUZJO0FBR2IwakIsU0FBTyxPQUhNO0FBSWJsakIsU0FBTztBQUpNLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMZjs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7OztBQTdCQTs7O0FBeUNBLElBQU00akIsYUFBYSxTQUFiQSxVQUFhLENBQVM3ekQsT0FBVCxFQUFrQjs7QUFFbkM2eUQsbUJBQU85ckQsSUFBUCxDQUFZLElBQVosRUFBa0I7QUFDaEIvVixrQkFBY2dQLFFBQVFoUCxZQUROO0FBRWhCeXNELFlBQVF6OUMsUUFBUXk5QyxNQUZBO0FBR2hCcG9ELGdCQUFZMkssUUFBUTNLLFVBSEo7QUFJaEJrbkMsV0FBT3Y4QixRQUFRdThCLEtBSkM7QUFLaEI4MkIsV0FBT3J6RCxRQUFRcXpEO0FBTEMsR0FBbEI7O0FBUUE7Ozs7QUFJQSxPQUFLUyxPQUFMLEdBQWU5ekQsUUFBUSt6RCxNQUFSLEtBQW1CM25FLFNBQW5CLEdBQStCNFQsUUFBUSt6RCxNQUF2QyxHQUFnRCxLQUEvRDs7QUFFQTs7OztBQUlBLE9BQUtDLGVBQUwsR0FBdUJoMEQsUUFBUWkwRCxjQUFSLEtBQTJCN25FLFNBQTNCLEdBQ3JCNFQsUUFBUWkwRCxjQURhLEdBQ0ksQ0FEM0I7O0FBR0E7Ozs7QUFJQSxPQUFLNWpFLFFBQUwsR0FBZ0IyUCxRQUFRM1AsUUFBUixLQUFxQmpFLFNBQXJCLEdBQWlDNFQsUUFBUTNQLFFBQXpDLEdBQW9ELElBQXBFOztBQUVBOzs7O0FBSUEsT0FBSzZqRSxTQUFMLEdBQWlCLElBQUkvZ0IsbUJBQUosQ0FBY256QyxRQUFRbTBELFNBQXRCLENBQWpCOztBQUVBOzs7O0FBSUEsT0FBS0MsT0FBTCxHQUFlLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZjs7QUFFQTs7OztBQUlBLE9BQUtDLElBQUwsR0FBWSxFQUFaOztBQUVBOzs7O0FBSUEsT0FBS0MsV0FBTCxHQUFtQixFQUFDcC9ELFlBQVk4SyxRQUFROUssVUFBckIsRUFBbkI7QUFFRCxDQXJERDs7QUF1REEscUJBQVMyK0QsVUFBVCxFQUFxQmhCLGdCQUFyQjs7QUFHQTs7O0FBR0FnQixXQUFXL3NELFNBQVgsQ0FBcUIwc0MsY0FBckIsR0FBc0MsWUFBVztBQUMvQyxTQUFPLEtBQUswZ0IsU0FBTCxDQUFlMWdCLGNBQWYsRUFBUDtBQUNELENBRkQ7O0FBS0E7Ozs7QUFJQXFnQixXQUFXL3NELFNBQVgsQ0FBcUJ3c0MsV0FBckIsR0FBbUMsVUFBU2orQyxVQUFULEVBQXFCaytDLFNBQXJCLEVBQWdDO0FBQ2pFLE1BQU0yZ0IsWUFBWSxLQUFLSyx5QkFBTCxDQUErQmwvRCxVQUEvQixDQUFsQjtBQUNBLE1BQUk2K0QsU0FBSixFQUFlO0FBQ2JBLGNBQVU1Z0IsV0FBVixDQUFzQkMsU0FBdEI7QUFDRDtBQUNGLENBTEQ7O0FBUUE7Ozs7Ozs7OztBQVNBc2dCLFdBQVcvc0QsU0FBWCxDQUFxQjB0RCxpQkFBckIsR0FBeUMsVUFBU24vRCxVQUFULEVBQXFCdWtCLENBQXJCLEVBQXdCMDZCLFNBQXhCLEVBQW1DN21DLFFBQW5DLEVBQTZDO0FBQ3BGLE1BQU15bUQsWUFBWSxLQUFLSyx5QkFBTCxDQUErQmwvRCxVQUEvQixDQUFsQjtBQUNBLE1BQUksQ0FBQzYrRCxTQUFMLEVBQWdCO0FBQ2QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSU8sVUFBVSxJQUFkO0FBQ0EsTUFBSTVpRSxhQUFKO0FBQUEsTUFBVTZpRSxxQkFBVjtBQUFBLE1BQXdCQyxlQUF4QjtBQUNBLE9BQUssSUFBSXJ0RCxJQUFJZ3RDLFVBQVVKLElBQXZCLEVBQTZCNXNDLEtBQUtndEMsVUFBVUgsSUFBNUMsRUFBa0QsRUFBRTdzQyxDQUFwRCxFQUF1RDtBQUNyRCxTQUFLLElBQUlnUSxJQUFJZzlCLFVBQVVGLElBQXZCLEVBQTZCOThCLEtBQUtnOUIsVUFBVUQsSUFBNUMsRUFBa0QsRUFBRS84QixDQUFwRCxFQUF1RDtBQUNyRG85QyxxQkFBZSwwQkFBVTk2QyxDQUFWLEVBQWF0UyxDQUFiLEVBQWdCZ1EsQ0FBaEIsQ0FBZjtBQUNBcTlDLGVBQVMsS0FBVDtBQUNBLFVBQUlULFVBQVVVLFdBQVYsQ0FBc0JGLFlBQXRCLENBQUosRUFBeUM7QUFDdkM3aUUsZUFBTyw4QkFBZ0NxaUUsVUFBVXJnRSxHQUFWLENBQWM2Z0UsWUFBZCxDQUF2QztBQUNBQyxpQkFBUzlpRSxLQUFLSCxRQUFMLE9BQW9CODlDLG9CQUFVYSxNQUF2QztBQUNBLFlBQUlza0IsTUFBSixFQUFZO0FBQ1ZBLG1CQUFVbG5ELFNBQVM1YixJQUFULE1BQW1CLEtBQTdCO0FBQ0Q7QUFDRjtBQUNELFVBQUksQ0FBQzhpRSxNQUFMLEVBQWE7QUFDWEYsa0JBQVUsS0FBVjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU9BLE9BQVA7QUFDRCxDQXpCRDs7QUE0QkE7Ozs7QUFJQVosV0FBVy9zRCxTQUFYLENBQXFCK3RELFNBQXJCLEdBQWlDLFVBQVN4L0QsVUFBVCxFQUFxQjtBQUNwRCxTQUFPLENBQVA7QUFDRCxDQUZEOztBQUtBOzs7OztBQUtBdytELFdBQVcvc0QsU0FBWCxDQUFxQmlwQyxNQUFyQixHQUE4QixZQUFXO0FBQ3ZDLFNBQU8sS0FBS3NrQixJQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7QUFLQVIsV0FBVy9zRCxTQUFYLENBQXFCZ3VELE1BQXJCLEdBQThCLFVBQVNyakUsR0FBVCxFQUFjO0FBQzFDLE1BQUksS0FBSzRpRSxJQUFMLEtBQWM1aUUsR0FBbEIsRUFBdUI7QUFDckIsU0FBSzRpRSxJQUFMLEdBQVk1aUUsR0FBWjtBQUNBLFNBQUtxK0MsT0FBTDtBQUNEO0FBQ0YsQ0FMRDs7QUFRQTs7OztBQUlBK2pCLFdBQVcvc0QsU0FBWCxDQUFxQml1RCxTQUFyQixHQUFpQyxVQUFTMS9ELFVBQVQsRUFBcUI7QUFDcEQsU0FBTyxLQUFLeStELE9BQVo7QUFDRCxDQUZEOztBQUtBOzs7QUFHQUQsV0FBVy9zRCxTQUFYLENBQXFCMnNELGNBQXJCLEdBQXNDLFlBQVc7QUFDL0MsU0FBTyxLQUFLcGpFLFFBQUwsQ0FBY29qRSxjQUFkLEVBQVA7QUFDRCxDQUZEOztBQUtBOzs7Ozs7Ozs7QUFTQUksV0FBVy9zRCxTQUFYLENBQXFCa3VELE9BQXJCLEdBQStCLFVBQVNwN0MsQ0FBVCxFQUFZdFMsQ0FBWixFQUFlZ1EsQ0FBZixFQUFrQnV6QyxVQUFsQixFQUE4QngxRCxVQUE5QixFQUEwQyxDQUFFLENBQTNFOztBQUdBOzs7OztBQUtBdytELFdBQVcvc0QsU0FBWCxDQUFxQmhWLFdBQXJCLEdBQW1DLFlBQVc7QUFDNUMsU0FBTyxLQUFLekIsUUFBWjtBQUNELENBRkQ7O0FBS0E7Ozs7QUFJQXdqRSxXQUFXL3NELFNBQVgsQ0FBcUJtdUQsd0JBQXJCLEdBQWdELFVBQVM1L0QsVUFBVCxFQUFxQjtBQUNuRSxNQUFJLENBQUMsS0FBS2hGLFFBQVYsRUFBb0I7QUFDbEIsV0FBTyxnQ0FBeUJnRixVQUF6QixDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBTyxLQUFLaEYsUUFBWjtBQUNEO0FBQ0YsQ0FORDs7QUFTQTs7Ozs7QUFLQXdqRSxXQUFXL3NELFNBQVgsQ0FBcUJ5dEQseUJBQXJCLEdBQWlELFVBQVNsL0QsVUFBVCxFQUFxQjtBQUNwRSxNQUFNNi9ELFdBQVcsS0FBS2htRSxhQUFMLEVBQWpCO0FBQ0EsTUFBSWdtRSxZQUFZLENBQUMsc0JBQVdBLFFBQVgsRUFBcUI3L0QsVUFBckIsQ0FBakIsRUFBbUQ7QUFDakQsV0FBTyxJQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBTyxLQUFLNitELFNBQVo7QUFDRDtBQUNGLENBUEQ7O0FBVUE7Ozs7Ozs7QUFPQUwsV0FBVy9zRCxTQUFYLENBQXFCcXVELGlCQUFyQixHQUF5QyxVQUFTdEssVUFBVCxFQUFxQjtBQUM1RCxTQUFPLEtBQUttSixlQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7O0FBTUFILFdBQVcvc0QsU0FBWCxDQUFxQnN1RCxnQkFBckIsR0FBd0MsVUFBU3g3QyxDQUFULEVBQVlpeEMsVUFBWixFQUF3QngxRCxVQUF4QixFQUFvQztBQUMxRSxNQUFNaEYsV0FBVyxLQUFLNGtFLHdCQUFMLENBQThCNS9ELFVBQTlCLENBQWpCO0FBQ0EsTUFBTTQrRCxpQkFBaUIsS0FBS2tCLGlCQUFMLENBQXVCdEssVUFBdkIsQ0FBdkI7QUFDQSxNQUFNdjZELFdBQVcsa0JBQU9ELFNBQVM4K0QsV0FBVCxDQUFxQnYxQyxDQUFyQixDQUFQLEVBQWdDLEtBQUt3NkMsT0FBckMsQ0FBakI7QUFDQSxNQUFJSCxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDdkIsV0FBTzNqRSxRQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBTyxpQkFBVUEsUUFBVixFQUFvQjJqRSxjQUFwQixFQUFvQyxLQUFLRyxPQUF6QyxDQUFQO0FBQ0Q7QUFDRixDQVREOztBQVlBOzs7Ozs7Ozs7QUFTQVAsV0FBVy9zRCxTQUFYLENBQXFCdXVELDhCQUFyQixHQUFzRCxVQUFTdm1CLFNBQVQsRUFBb0JnWSxjQUFwQixFQUFvQztBQUN4RixNQUFNenhELGFBQWF5eEQsbUJBQW1CMTZELFNBQW5CLEdBQ2pCMDZELGNBRGlCLEdBQ0EsS0FBSzUzRCxhQUFMLEVBRG5CO0FBRUEsTUFBTW1CLFdBQVcsS0FBSzRrRSx3QkFBTCxDQUE4QjUvRCxVQUE5QixDQUFqQjtBQUNBLE1BQUksS0FBS3ErRCxRQUFMLE1BQW1CcitELFdBQVdvekQsUUFBWCxFQUF2QixFQUE4QztBQUM1QzNaLGdCQUFZLHFCQUFNeitDLFFBQU4sRUFBZ0J5K0MsU0FBaEIsRUFBMkJ6NUMsVUFBM0IsQ0FBWjtBQUNEO0FBQ0QsU0FBTyxpQ0FBaUJ5NUMsU0FBakIsRUFBNEJ6K0MsUUFBNUIsSUFBd0N5K0MsU0FBeEMsR0FBb0QsSUFBM0Q7QUFDRCxDQVJEOztBQVdBOzs7QUFHQStrQixXQUFXL3NELFNBQVgsQ0FBcUI2c0QsT0FBckIsR0FBK0IsWUFBVztBQUN4QyxPQUFLTyxTQUFMLENBQWU1USxLQUFmO0FBQ0EsT0FBS3hULE9BQUw7QUFDRCxDQUhEOztBQU1BOzs7Ozs7O0FBT0ErakIsV0FBVy9zRCxTQUFYLENBQXFCd3VELE9BQXJCLEdBQStCMW1CLG9CQUEvQjs7QUFHQTs7Ozs7Ozs7OztBQVVPLElBQU0ybUIsNENBQWtCLFNBQWxCQSxlQUFrQixDQUFTbm9FLElBQVQsRUFBZXlFLElBQWYsRUFBcUI7O0FBRWxEcS9DLGtCQUFNbnFDLElBQU4sQ0FBVyxJQUFYLEVBQWlCM1osSUFBakI7O0FBRUE7Ozs7O0FBS0EsT0FBS3lFLElBQUwsR0FBWUEsSUFBWjtBQUVELENBWE07QUFZUCxxQkFBUzBqRSxlQUFULEVBQTBCcmtCLGVBQTFCOztrQkFFZTJpQixVOzs7Ozs7Ozs7Ozs7Ozs7OztBQzVWZjs7OztBQUlBOzs7a0JBR2U7O0FBRWI7Ozs7O0FBS0EyQixpQkFBZSxlQVBGOztBQVNiOzs7Ozs7QUFNQUMsZUFBYSxhQWZBOztBQWlCYjs7Ozs7QUFLQUMsaUJBQWU7O0FBdEJGLEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pmOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdDQTs7Ozs7Ozs7OztBQXhEQTs7O0FBa0VBLElBQU1DLFlBQVksU0FBWkEsU0FBWSxDQUFTMzFELE9BQVQsRUFBa0I7O0FBRWxDNDFELG9CQUFRN3VELElBQVIsQ0FBYSxJQUFiLEVBQW1CO0FBQ2pCL1Ysa0JBQWNnUCxRQUFRaFAsWUFETDtBQUVqQm1qRSxlQUFXbjBELFFBQVFtMEQsU0FGRjtBQUdqQjFXLFlBQVF6OUMsUUFBUXk5QyxNQUhDO0FBSWpCc1csWUFBUS96RCxRQUFRK3pELE1BSkM7QUFLakIxK0QsZ0JBQVkySyxRQUFRM0ssVUFMSDtBQU1qQmtuQyxXQUFPdjhCLFFBQVF1OEIsS0FORTtBQU9qQmxzQyxjQUFVMlAsUUFBUTNQLFFBUEQ7QUFRakIwK0Msc0JBQWtCL3VDLFFBQVErdUMsZ0JBQVIsR0FDaEIvdUMsUUFBUSt1QyxnQkFEUSxHQUNXOG1CLHVCQVRaO0FBVWpCNUIsb0JBQWdCajBELFFBQVFpMEQsY0FWUDtBQVdqQjZCLHFCQUFpQjkxRCxRQUFRODFELGVBWFI7QUFZakIxckUsU0FBSzRWLFFBQVE1VixHQVpJO0FBYWpCZ0gsVUFBTTRPLFFBQVE1TyxJQWJHO0FBY2pCaWlFLFdBQU9yekQsUUFBUXF6RCxLQWRFO0FBZWpCbitELGdCQUFZOEssUUFBUTlLO0FBZkgsR0FBbkI7O0FBa0JBOzs7O0FBSUEsT0FBSy9DLFdBQUwsR0FDSTZOLFFBQVE3TixXQUFSLEtBQXdCL0YsU0FBeEIsR0FBb0M0VCxRQUFRN04sV0FBNUMsR0FBMEQsSUFEOUQ7O0FBR0E7Ozs7O0FBS0EsT0FBSzRqRSxTQUFMLEdBQWlCLzFELFFBQVErMUQsU0FBUixLQUFzQjNwRSxTQUF0QixHQUNmNFQsUUFBUSsxRCxTQURPLEdBQ0tsbkIsbUJBRHRCOztBQUdBOzs7O0FBSUEsT0FBS21uQixzQkFBTCxHQUE4QixFQUE5Qjs7QUFFQTs7OztBQUlBLE9BQUtDLHFCQUFMLEdBQTZCLEVBQTdCOztBQUVBOzs7O0FBSUEsT0FBS0MsMkJBQUwsR0FBbUNsMkQsUUFBUW0yRCwwQkFBM0M7O0FBRUE7Ozs7QUFJQSxPQUFLQyx3QkFBTCxHQUFnQyxLQUFoQztBQUNELENBMUREOztBQTREQSxxQkFBU1QsU0FBVCxFQUFvQkMsaUJBQXBCOztBQUdBOzs7QUFHQUQsVUFBVTd1RCxTQUFWLENBQW9CMHNDLGNBQXBCLEdBQXFDLFlBQVc7QUFDOUMsTUFBSSxDQUFDZ2Ysa0NBQUwsRUFBaUM7QUFDL0IsV0FBT29ELGtCQUFROXVELFNBQVIsQ0FBa0Iwc0MsY0FBbEIsQ0FBaUN6c0MsSUFBakMsQ0FBc0MsSUFBdEMsQ0FBUDtBQUNEO0FBQ0QsTUFBSSxLQUFLbXRELFNBQUwsQ0FBZTFnQixjQUFmLEVBQUosRUFBcUM7QUFDbkMsV0FBTyxJQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsU0FBSyxJQUFNL2hELEdBQVgsSUFBa0IsS0FBS3VrRSxzQkFBdkIsRUFBK0M7QUFDN0MsVUFBSSxLQUFLQSxzQkFBTCxDQUE0QnZrRSxHQUE1QixFQUFpQytoRCxjQUFqQyxFQUFKLEVBQXVEO0FBQ3JELGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU8sS0FBUDtBQUNELENBZEQ7O0FBaUJBOzs7QUFHQW1pQixVQUFVN3VELFNBQVYsQ0FBb0J3c0MsV0FBcEIsR0FBa0MsVUFBU2orQyxVQUFULEVBQXFCaytDLFNBQXJCLEVBQWdDO0FBQ2hFLE1BQUksQ0FBQ2lmLGtDQUFMLEVBQWlDO0FBQy9Cb0Qsc0JBQVE5dUQsU0FBUixDQUFrQndzQyxXQUFsQixDQUE4QnZzQyxJQUE5QixDQUFtQyxJQUFuQyxFQUF5QzFSLFVBQXpDLEVBQXFEaytDLFNBQXJEO0FBQ0E7QUFDRDtBQUNELE1BQU04aUIsZ0JBQWdCLEtBQUs5Qix5QkFBTCxDQUErQmwvRCxVQUEvQixDQUF0Qjs7QUFFQSxPQUFLNitELFNBQUwsQ0FBZTVnQixXQUFmLENBQTJCLEtBQUs0Z0IsU0FBTCxJQUFrQm1DLGFBQWxCLEdBQWtDOWlCLFNBQWxDLEdBQThDLEVBQXpFO0FBQ0EsT0FBSyxJQUFNeG1ELEVBQVgsSUFBaUIsS0FBS2lwRSxzQkFBdEIsRUFBOEM7QUFDNUMsUUFBTTlCLFlBQVksS0FBSzhCLHNCQUFMLENBQTRCanBFLEVBQTVCLENBQWxCO0FBQ0FtbkUsY0FBVTVnQixXQUFWLENBQXNCNGdCLGFBQWFtQyxhQUFiLEdBQTZCOWlCLFNBQTdCLEdBQXlDLEVBQS9EO0FBQ0Q7QUFDRixDQVpEOztBQWVBOzs7QUFHQW9pQixVQUFVN3VELFNBQVYsQ0FBb0IrdEQsU0FBcEIsR0FBZ0MsVUFBU3gvRCxVQUFULEVBQXFCO0FBQ25ELE1BQUltOUQsc0NBQ0EsS0FBS3RqRSxhQUFMLEVBREEsSUFDd0JtRyxVQUR4QixJQUNzQyxDQUFDLHNCQUFXLEtBQUtuRyxhQUFMLEVBQVgsRUFBaUNtRyxVQUFqQyxDQUQzQyxFQUN5RjtBQUN2RixXQUFPLENBQVA7QUFDRCxHQUhELE1BR087QUFDTCxXQUFPLEtBQUtpaEUsaUJBQUwsRUFBUDtBQUNEO0FBQ0YsQ0FQRDs7QUFVQTs7OztBQUlBWCxVQUFVN3VELFNBQVYsQ0FBb0J3dkQsaUJBQXBCLEdBQXdDLFlBQVc7QUFDakQsU0FBTyxDQUFQO0FBQ0QsQ0FGRDs7QUFLQTs7O0FBR0FYLFVBQVU3dUQsU0FBVixDQUFvQml1RCxTQUFwQixHQUFnQyxVQUFTMS9ELFVBQVQsRUFBcUI7QUFDbkQsTUFBSW05RCxzQ0FDQSxLQUFLdGpFLGFBQUwsRUFEQSxJQUN3Qm1HLFVBRHhCLElBQ3NDLENBQUMsc0JBQVcsS0FBS25HLGFBQUwsRUFBWCxFQUFpQ21HLFVBQWpDLENBRDNDLEVBQ3lGO0FBQ3ZGLFdBQU8sS0FBUDtBQUNELEdBSEQsTUFHTztBQUNMLFdBQU91Z0Usa0JBQVE5dUQsU0FBUixDQUFrQml1RCxTQUFsQixDQUE0Qmh1RCxJQUE1QixDQUFpQyxJQUFqQyxFQUF1QzFSLFVBQXZDLENBQVA7QUFDRDtBQUNGLENBUEQ7O0FBVUE7OztBQUdBc2dFLFVBQVU3dUQsU0FBVixDQUFvQm11RCx3QkFBcEIsR0FBK0MsVUFBUzUvRCxVQUFULEVBQXFCO0FBQ2xFLE1BQUksQ0FBQ205RCxrQ0FBTCxFQUFpQztBQUMvQixXQUFPb0Qsa0JBQVE5dUQsU0FBUixDQUFrQm11RCx3QkFBbEIsQ0FBMkNsdUQsSUFBM0MsQ0FBZ0QsSUFBaEQsRUFBc0QxUixVQUF0RCxDQUFQO0FBQ0Q7QUFDRCxNQUFNNi9ELFdBQVcsS0FBS2htRSxhQUFMLEVBQWpCO0FBQ0EsTUFBSSxLQUFLbUIsUUFBTCxLQUFrQixDQUFDNmtFLFFBQUQsSUFBYSxzQkFBV0EsUUFBWCxFQUFxQjcvRCxVQUFyQixDQUEvQixDQUFKLEVBQXNFO0FBQ3BFLFdBQU8sS0FBS2hGLFFBQVo7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFNa21FLFVBQVUsbUJBQU9saEUsVUFBUCxFQUFtQnZILFFBQW5CLEVBQWhCO0FBQ0EsUUFBSSxFQUFFeW9FLFdBQVcsS0FBS04scUJBQWxCLENBQUosRUFBOEM7QUFDNUMsV0FBS0EscUJBQUwsQ0FBMkJNLE9BQTNCLElBQXNDLGdDQUF5QmxoRSxVQUF6QixDQUF0QztBQUNEO0FBQ0Q7QUFDRSxpREFBNkMsS0FBSzRnRSxxQkFBTCxDQUEyQk0sT0FBM0I7QUFEL0M7QUFHRDtBQUNGLENBaEJEOztBQW1CQTs7O0FBR0FaLFVBQVU3dUQsU0FBVixDQUFvQnl0RCx5QkFBcEIsR0FBZ0QsVUFBU2wvRCxVQUFULEVBQXFCO0FBQ25FLE1BQUksQ0FBQ205RCxrQ0FBTCxFQUFpQztBQUMvQixXQUFPb0Qsa0JBQVE5dUQsU0FBUixDQUFrQnl0RCx5QkFBbEIsQ0FBNEN4dEQsSUFBNUMsQ0FBaUQsSUFBakQsRUFBdUQxUixVQUF2RCxDQUFQO0FBQ0Q7QUFDRCxNQUFNNi9ELFdBQVcsS0FBS2htRSxhQUFMLEVBQWpCLENBQXVDLElBQUksQ0FBQ2dtRSxRQUFELElBQWEsc0JBQVdBLFFBQVgsRUFBcUI3L0QsVUFBckIsQ0FBakIsRUFBbUQ7QUFDeEYsV0FBTyxLQUFLNitELFNBQVo7QUFDRCxHQUZzQyxNQUVoQztBQUNMLFFBQU1xQyxVQUFVLG1CQUFPbGhFLFVBQVAsRUFBbUJ2SCxRQUFuQixFQUFoQjtBQUNBLFFBQUksRUFBRXlvRSxXQUFXLEtBQUtQLHNCQUFsQixDQUFKLEVBQStDO0FBQzdDLFdBQUtBLHNCQUFMLENBQTRCTyxPQUE1QixJQUF1QyxJQUFJcGpCLG1CQUFKLENBQWMsS0FBSytnQixTQUFMLENBQWVzQyxhQUE3QixDQUF2QztBQUNEO0FBQ0QsV0FBTyxLQUFLUixzQkFBTCxDQUE0Qk8sT0FBNUIsQ0FBUDtBQUNEO0FBQ0YsQ0FiRDs7QUFnQkE7Ozs7Ozs7Ozs7QUFVQVosVUFBVTd1RCxTQUFWLENBQW9CMnZELFdBQXBCLEdBQWtDLFVBQVM3OEMsQ0FBVCxFQUFZdFMsQ0FBWixFQUFlZ1EsQ0FBZixFQUFrQnV6QyxVQUFsQixFQUE4QngxRCxVQUE5QixFQUEwQzVELEdBQTFDLEVBQStDO0FBQy9FLE1BQU1xOUMsWUFBWSxDQUFDbDFCLENBQUQsRUFBSXRTLENBQUosRUFBT2dRLENBQVAsQ0FBbEI7QUFDQSxNQUFNby9DLGVBQWUsS0FBS3JCLDhCQUFMLENBQ25Cdm1CLFNBRG1CLEVBQ1J6NUMsVUFEUSxDQUFyQjtBQUVBLE1BQU1zaEUsVUFBVUQsZUFDZCxLQUFLWixlQUFMLENBQXFCWSxZQUFyQixFQUFtQzdMLFVBQW5DLEVBQStDeDFELFVBQS9DLENBRGMsR0FDK0NqSixTQUQvRDtBQUVBLE1BQU15RixPQUFPLElBQUksS0FBS2trRSxTQUFULENBQ1hqbkIsU0FEVyxFQUVYNm5CLFlBQVl2cUUsU0FBWixHQUF3Qm9qRCxvQkFBVWdCLElBQWxDLEdBQXlDaEIsb0JBQVVjLEtBRnhDLEVBR1hxbUIsWUFBWXZxRSxTQUFaLEdBQXdCdXFFLE9BQXhCLEdBQWtDLEVBSHZCLEVBSVgsS0FBS3hrRSxXQUpNLEVBS1gsS0FBSzQ4QyxnQkFMTSxFQU1YLEtBQUt1bEIsV0FOTSxDQUFiO0FBT0F6aUUsT0FBS0osR0FBTCxHQUFXQSxHQUFYO0FBQ0Esc0JBQU9JLElBQVAsRUFBYTQrQyxvQkFBVTRCLE1BQXZCLEVBQ0UsS0FBS3VrQixnQkFEUCxFQUN5QixJQUR6QjtBQUVBLFNBQU8va0UsSUFBUDtBQUNELENBakJEOztBQW9CQTs7O0FBR0E4akUsVUFBVTd1RCxTQUFWLENBQW9Ca3VELE9BQXBCLEdBQThCLFVBQVNwN0MsQ0FBVCxFQUFZdFMsQ0FBWixFQUFlZ1EsQ0FBZixFQUFrQnV6QyxVQUFsQixFQUE4QngxRCxVQUE5QixFQUEwQztBQUN0RSxNQUFNOHhELG1CQUFtQix5Q0FBMkMsS0FBS2o0RCxhQUFMLEVBQXBFO0FBQ0EsTUFBSSxDQUFDc2pFLGtDQUFELElBQ0EsQ0FBQ3JMLGdCQURELElBQ3FCLENBQUM5eEQsVUFEdEIsSUFDb0Msc0JBQVc4eEQsZ0JBQVgsRUFBNkI5eEQsVUFBN0IsQ0FEeEMsRUFDa0Y7QUFDaEYsV0FBTyxLQUFLd2hFLGVBQUwsQ0FBcUJqOUMsQ0FBckIsRUFBd0J0UyxDQUF4QixFQUEyQmdRLENBQTNCLEVBQThCdXpDLFVBQTlCLEVBQTBDMUQsb0JBQW9COXhELFVBQTlELENBQVA7QUFDRCxHQUhELE1BR087QUFDTCxRQUFNdzBELFFBQVEsS0FBSzBLLHlCQUFMLENBQStCbC9ELFVBQS9CLENBQWQ7QUFDQSxRQUFNeTVDLFlBQVksQ0FBQ2wxQixDQUFELEVBQUl0UyxDQUFKLEVBQU9nUSxDQUFQLENBQWxCO0FBQ0EsUUFBSXpsQixhQUFKO0FBQ0EsUUFBTTZpRSxlQUFlLHVCQUFPNWxCLFNBQVAsQ0FBckI7QUFDQSxRQUFJK2EsTUFBTStLLFdBQU4sQ0FBa0JGLFlBQWxCLENBQUosRUFBcUM7QUFDbkM3aUUsYUFBTyw4QkFBZ0NnNEQsTUFBTWgyRCxHQUFOLENBQVU2Z0UsWUFBVixDQUF2QztBQUNEO0FBQ0QsUUFBTWpqRSxNQUFNLEtBQUtzK0MsTUFBTCxFQUFaO0FBQ0EsUUFBSWwrQyxRQUFRQSxLQUFLSixHQUFMLElBQVlBLEdBQXhCLEVBQTZCO0FBQzNCLGFBQU9JLElBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFNdTdELGlCQUFpQixLQUFLNkgsd0JBQUwsQ0FBOEI5TixnQkFBOUIsQ0FBdkI7QUFDQSxVQUFNa0csaUJBQWlCLEtBQUs0SCx3QkFBTCxDQUE4QjUvRCxVQUE5QixDQUF2QjtBQUNBLFVBQU1pNEQsbUJBQ0YsS0FBSytILDhCQUFMLENBQW9Ddm1CLFNBQXBDLEVBQStDejVDLFVBQS9DLENBREo7QUFFQSxVQUFNeWhFLFVBQVUsSUFBSTNKLGNBQUosQ0FDZGhHLGdCQURjLEVBQ0lpRyxjQURKLEVBRWQvM0QsVUFGYyxFQUVGZzRELGNBRkUsRUFHZHZlLFNBSGMsRUFHSHdlLGdCQUhHLEVBR2UsS0FBSzZILGlCQUFMLENBQXVCdEssVUFBdkIsQ0FIZixFQUlkLEtBQUt5TCxpQkFBTCxFQUpjLEVBS2QsVUFBUzE4QyxDQUFULEVBQVl0UyxDQUFaLEVBQWVnUSxDQUFmLEVBQWtCdXpDLFVBQWxCLEVBQThCO0FBQzVCLGVBQU8sS0FBS2dNLGVBQUwsQ0FBcUJqOUMsQ0FBckIsRUFBd0J0UyxDQUF4QixFQUEyQmdRLENBQTNCLEVBQThCdXpDLFVBQTlCLEVBQTBDMUQsZ0JBQTFDLENBQVA7QUFDRCxPQUZELENBRUV6OUIsSUFGRixDQUVPLElBRlAsQ0FMYyxFQU9BLEtBQUt3c0MsMkJBUEwsRUFRZCxLQUFLRSx3QkFSUyxDQUFoQjtBQVNBVSxjQUFRcmxFLEdBQVIsR0FBY0EsR0FBZDs7QUFFQSxVQUFJSSxJQUFKLEVBQVU7QUFDUmlsRSxnQkFBUWxuQixXQUFSLEdBQXNCLzlDLElBQXRCO0FBQ0FpbEUsZ0JBQVFsa0IsbUJBQVI7QUFDQWlYLGNBQU01Z0UsT0FBTixDQUFjeXJFLFlBQWQsRUFBNEJvQyxPQUE1QjtBQUNELE9BSkQsTUFJTztBQUNMak4sY0FBTTMyRCxHQUFOLENBQVV3aEUsWUFBVixFQUF3Qm9DLE9BQXhCO0FBQ0Q7QUFDRCxhQUFPQSxPQUFQO0FBQ0Q7QUFDRjtBQUNGLENBMUNEOztBQTZDQTs7Ozs7Ozs7O0FBU0FuQixVQUFVN3VELFNBQVYsQ0FBb0IrdkQsZUFBcEIsR0FBc0MsVUFBU2o5QyxDQUFULEVBQVl0UyxDQUFaLEVBQWVnUSxDQUFmLEVBQWtCdXpDLFVBQWxCLEVBQThCeDFELFVBQTlCLEVBQTBDO0FBQzlFLE1BQUl4RCxPQUFPLElBQVg7QUFDQSxNQUFNNmlFLGVBQWUsMEJBQVU5NkMsQ0FBVixFQUFhdFMsQ0FBYixFQUFnQmdRLENBQWhCLENBQXJCO0FBQ0EsTUFBTTdsQixNQUFNLEtBQUtzK0MsTUFBTCxFQUFaO0FBQ0EsTUFBSSxDQUFDLEtBQUtta0IsU0FBTCxDQUFlVSxXQUFmLENBQTJCRixZQUEzQixDQUFMLEVBQStDO0FBQzdDN2lFLFdBQU8sS0FBSzRrRSxXQUFMLENBQWlCNzhDLENBQWpCLEVBQW9CdFMsQ0FBcEIsRUFBdUJnUSxDQUF2QixFQUEwQnV6QyxVQUExQixFQUFzQ3gxRCxVQUF0QyxFQUFrRDVELEdBQWxELENBQVA7QUFDQSxTQUFLeWlFLFNBQUwsQ0FBZWhoRSxHQUFmLENBQW1Cd2hFLFlBQW5CLEVBQWlDN2lFLElBQWpDO0FBQ0QsR0FIRCxNQUdPO0FBQ0xBLFdBQU8sS0FBS3FpRSxTQUFMLENBQWVyZ0UsR0FBZixDQUFtQjZnRSxZQUFuQixDQUFQO0FBQ0EsUUFBSTdpRSxLQUFLSixHQUFMLElBQVlBLEdBQWhCLEVBQXFCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQU1tK0MsY0FBYy85QyxJQUFwQjtBQUNBQSxhQUFPLEtBQUs0a0UsV0FBTCxDQUFpQjc4QyxDQUFqQixFQUFvQnRTLENBQXBCLEVBQXVCZ1EsQ0FBdkIsRUFBMEJ1ekMsVUFBMUIsRUFBc0N4MUQsVUFBdEMsRUFBa0Q1RCxHQUFsRCxDQUFQOztBQUVBO0FBQ0EsVUFBSW0rQyxZQUFZbCtDLFFBQVosTUFBMEI4OUMsb0JBQVVnQixJQUF4QyxFQUE4QztBQUM1QztBQUNBMytDLGFBQUsrOUMsV0FBTCxHQUFtQkEsWUFBWUEsV0FBL0I7QUFDRCxPQUhELE1BR087QUFDTC85QyxhQUFLKzlDLFdBQUwsR0FBbUJBLFdBQW5CO0FBQ0Q7QUFDRC85QyxXQUFLK2dELG1CQUFMO0FBQ0EsV0FBS3NoQixTQUFMLENBQWVqckUsT0FBZixDQUF1QnlyRSxZQUF2QixFQUFxQzdpRSxJQUFyQztBQUNEO0FBQ0Y7QUFDRCxTQUFPQSxJQUFQO0FBQ0QsQ0E1QkQ7O0FBK0JBOzs7OztBQUtBOGpFLFVBQVU3dUQsU0FBVixDQUFvQml3RCwwQkFBcEIsR0FBaUQsVUFBUy9NLE1BQVQsRUFBaUI7QUFDaEUsTUFBSSxDQUFDd0ksa0NBQUQsSUFDQSxLQUFLNEQsd0JBQUwsSUFBaUNwTSxNQURyQyxFQUM2QztBQUMzQztBQUNEO0FBQ0QsT0FBS29NLHdCQUFMLEdBQWdDcE0sTUFBaEM7QUFDQSxPQUFLLElBQU1qOUQsRUFBWCxJQUFpQixLQUFLaXBFLHNCQUF0QixFQUE4QztBQUM1QyxTQUFLQSxzQkFBTCxDQUE0QmpwRSxFQUE1QixFQUFnQ3UyRCxLQUFoQztBQUNEO0FBQ0QsT0FBS3hULE9BQUw7QUFDRCxDQVZEOztBQWFBOzs7Ozs7Ozs7Ozs7QUFZQTZsQixVQUFVN3VELFNBQVYsQ0FBb0Jrd0Qsd0JBQXBCLEdBQStDLFVBQVMzaEUsVUFBVCxFQUFxQjRoRSxRQUFyQixFQUErQjtBQUM1RSxNQUFJekUsa0NBQUosRUFBZ0M7QUFDOUIsUUFBTTBFLE9BQU8sZUFBYzdoRSxVQUFkLENBQWI7QUFDQSxRQUFJNmhFLElBQUosRUFBVTtBQUNSLFVBQU1YLFVBQVUsbUJBQU9XLElBQVAsRUFBYXBwRSxRQUFiLEVBQWhCO0FBQ0EsVUFBSSxFQUFFeW9FLFdBQVcsS0FBS04scUJBQWxCLENBQUosRUFBOEM7QUFDNUMsYUFBS0EscUJBQUwsQ0FBMkJNLE9BQTNCLElBQXNDVSxRQUF0QztBQUNEO0FBQ0Y7QUFDRjtBQUNGLENBVkQ7O0FBYUE7Ozs7QUFJQSxTQUFTcEIsdUJBQVQsQ0FBaUNzQixTQUFqQyxFQUE0QzdrRSxHQUE1QyxFQUFpRDtBQUMvQzZrRSxZQUFVemtFLFFBQVYsR0FBcUJKLEdBQXJCLEdBQTJCQSxHQUEzQjtBQUNEOztrQkFFY3FqRSxTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6WmY7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7O0FBN0JBOzs7QUF1Q0EsSUFBTUMsVUFBVSxTQUFWQSxPQUFVLENBQVM1MUQsT0FBVCxFQUFrQjs7QUFFaEM2ekQsaUJBQVc5c0QsSUFBWCxDQUFnQixJQUFoQixFQUFzQjtBQUNwQi9WLGtCQUFjZ1AsUUFBUWhQLFlBREY7QUFFcEJtakUsZUFBV24wRCxRQUFRbTBELFNBRkM7QUFHcEIxVyxZQUFRejlDLFFBQVF5OUMsTUFISTtBQUlwQnNXLFlBQVEvekQsUUFBUSt6RCxNQUpJO0FBS3BCMStELGdCQUFZMkssUUFBUTNLLFVBTEE7QUFNcEJrbkMsV0FBT3Y4QixRQUFRdThCLEtBTks7QUFPcEJsc0MsY0FBVTJQLFFBQVEzUCxRQVBFO0FBUXBCNGpFLG9CQUFnQmowRCxRQUFRaTBELGNBUko7QUFTcEJaLFdBQU9yekQsUUFBUXF6RCxLQVRLO0FBVXBCbitELGdCQUFZOEssUUFBUTlLO0FBVkEsR0FBdEI7O0FBYUE7Ozs7QUFJQSxPQUFLNjVDLGdCQUFMLEdBQXdCL3VDLFFBQVErdUMsZ0JBQWhDOztBQUVBOzs7O0FBSUEsT0FBSyttQixlQUFMLEdBQXVCLEtBQUtzQixvQkFBTCxHQUNyQixLQUFLQSxvQkFBTCxDQUEwQjF0QyxJQUExQixDQUErQixJQUEvQixDQURxQixHQUNrQjJ0QyxvQ0FEekM7O0FBR0E7Ozs7QUFJQSxPQUFLam1FLElBQUwsR0FBWSxJQUFaOztBQUVBLE1BQUk0TyxRQUFRNU8sSUFBWixFQUFrQjtBQUNoQixTQUFLa21FLE9BQUwsQ0FBYXQzRCxRQUFRNU8sSUFBckI7QUFDRCxHQUZELE1BRU8sSUFBSTRPLFFBQVE1VixHQUFaLEVBQWlCO0FBQ3RCLFNBQUttdEUsTUFBTCxDQUFZdjNELFFBQVE1VixHQUFwQjtBQUNEO0FBQ0QsTUFBSTRWLFFBQVE4MUQsZUFBWixFQUE2QjtBQUMzQixTQUFLMEIsa0JBQUwsQ0FBd0J4M0QsUUFBUTgxRCxlQUFoQztBQUNEOztBQUVEOzs7O0FBSUEsT0FBSzJCLGdCQUFMLEdBQXdCLEVBQXhCO0FBRUQsQ0FqREQ7O0FBbURBLHFCQUFTN0IsT0FBVCxFQUFrQi9CLGNBQWxCOztBQUdBOzs7O0FBSUErQixRQUFROXVELFNBQVIsQ0FBa0Jzd0Qsb0JBQWxCOztBQUVBOzs7OztBQUtBeEIsUUFBUTl1RCxTQUFSLENBQWtCNHdELG1CQUFsQixHQUF3QyxZQUFXO0FBQ2pELFNBQU8sS0FBSzNvQixnQkFBWjtBQUNELENBRkQ7O0FBS0E7Ozs7O0FBS0E2bUIsUUFBUTl1RCxTQUFSLENBQWtCNndELGtCQUFsQixHQUF1QyxZQUFXO0FBQ2hELFNBQU8sS0FBSzdCLGVBQVo7QUFDRCxDQUZEOztBQUtBOzs7Ozs7O0FBT0FGLFFBQVE5dUQsU0FBUixDQUFrQjh3RCxPQUFsQixHQUE0QixZQUFXO0FBQ3JDLFNBQU8sS0FBS3htRSxJQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7QUFLQXdrRSxRQUFROXVELFNBQVIsQ0FBa0I4dkQsZ0JBQWxCLEdBQXFDLFVBQVM5YyxLQUFULEVBQWdCO0FBQ25ELE1BQU1qb0QsT0FBTyw2QkFBK0Jpb0QsTUFBTTFtRCxNQUFsRDtBQUNBLE1BQU15a0UsTUFBTSxtQkFBT2htRSxJQUFQLENBQVo7QUFDQSxNQUFNaW1FLFlBQVlqbUUsS0FBS0gsUUFBTCxFQUFsQjtBQUNBLE1BQUl0RSxhQUFKO0FBQ0EsTUFBSTBxRSxhQUFhdG9CLG9CQUFVQyxPQUEzQixFQUFvQztBQUNsQyxTQUFLZ29CLGdCQUFMLENBQXNCSSxHQUF0QixJQUE2QixJQUE3QjtBQUNBenFFLFdBQU8ycUUsd0JBQWN2QyxhQUFyQjtBQUNELEdBSEQsTUFHTyxJQUFJcUMsT0FBTyxLQUFLSixnQkFBaEIsRUFBa0M7QUFDdkMsV0FBTyxLQUFLQSxnQkFBTCxDQUFzQkksR0FBdEIsQ0FBUDtBQUNBenFFLFdBQU8wcUUsYUFBYXRvQixvQkFBVVMsS0FBdkIsR0FBK0I4bkIsd0JBQWNyQyxhQUE3QyxHQUNKb0MsYUFBYXRvQixvQkFBVWEsTUFBdkIsSUFBaUN5bkIsYUFBYXRvQixvQkFBVUssS0FBekQsR0FDRWtvQix3QkFBY3RDLFdBRGhCLEdBQzhCcnBFLFNBRmhDO0FBR0Q7QUFDRCxNQUFJZ0IsUUFBUWhCLFNBQVosRUFBdUI7QUFDckIsU0FBS3lsRCxhQUFMLENBQW1CLElBQUkwakIscUJBQUosQ0FBb0Jub0UsSUFBcEIsRUFBMEJ5RSxJQUExQixDQUFuQjtBQUNEO0FBQ0YsQ0FqQkQ7O0FBb0JBOzs7OztBQUtBK2pFLFFBQVE5dUQsU0FBUixDQUFrQnpVLG1CQUFsQixHQUF3QyxVQUFTMDhDLGdCQUFULEVBQTJCO0FBQ2pFLE9BQUttbEIsU0FBTCxDQUFlNVEsS0FBZjtBQUNBLE9BQUt2VSxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBQ0EsT0FBS2UsT0FBTDtBQUNELENBSkQ7O0FBT0E7Ozs7OztBQU1BOGxCLFFBQVE5dUQsU0FBUixDQUFrQjB3RCxrQkFBbEIsR0FBdUMsVUFBUzFCLGVBQVQsRUFBMEJrQyxPQUExQixFQUFtQztBQUN4RSxPQUFLbEMsZUFBTCxHQUF1QkEsZUFBdkI7QUFDQSxPQUFLNUIsU0FBTCxDQUFldGdCLGtCQUFmO0FBQ0EsTUFBSSxPQUFPb2tCLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbEMsU0FBS2xELE1BQUwsQ0FBWWtELE9BQVo7QUFDRCxHQUZELE1BRU87QUFDTCxTQUFLbG9CLE9BQUw7QUFDRDtBQUNGLENBUkQ7O0FBV0E7Ozs7O0FBS0E4bEIsUUFBUTl1RCxTQUFSLENBQWtCeXdELE1BQWxCLEdBQTJCLFVBQVNudEUsR0FBVCxFQUFjO0FBQ3ZDLE1BQU1nSCxPQUFPLEtBQUtBLElBQUwsR0FBWSxnQ0FBVWhILEdBQVYsQ0FBekI7QUFDQSxPQUFLb3RFLGtCQUFMLENBQXdCLEtBQUtKLG9CQUFMLEdBQ3RCLEtBQUtBLG9CQUFMLENBQTBCMXRDLElBQTFCLENBQStCLElBQS9CLENBRHNCLEdBRXRCLDBDQUFvQnQ0QixJQUFwQixFQUEwQixLQUFLZixRQUEvQixDQUZGLEVBRTRDakcsR0FGNUM7QUFHRCxDQUxEOztBQVFBOzs7OztBQUtBd3JFLFFBQVE5dUQsU0FBUixDQUFrQnd3RCxPQUFsQixHQUE0QixVQUFTbG1FLElBQVQsRUFBZTtBQUN6QyxPQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDQSxNQUFNSyxNQUFNTCxLQUFLb0MsSUFBTCxDQUFVLElBQVYsQ0FBWjtBQUNBLE9BQUtna0Usa0JBQUwsQ0FBd0IsS0FBS0osb0JBQUwsR0FDdEIsS0FBS0Esb0JBQUwsQ0FBMEIxdEMsSUFBMUIsQ0FBK0IsSUFBL0IsQ0FEc0IsR0FFdEIsMENBQW9CdDRCLElBQXBCLEVBQTBCLEtBQUtmLFFBQS9CLENBRkYsRUFFNENvQixHQUY1QztBQUdELENBTkQ7O0FBU0E7OztBQUdBbWtFLFFBQVE5dUQsU0FBUixDQUFrQnd1RCxPQUFsQixHQUE0QixVQUFTMTdDLENBQVQsRUFBWXRTLENBQVosRUFBZWdRLENBQWYsRUFBa0I7QUFDNUMsTUFBTW85QyxlQUFlLDBCQUFVOTZDLENBQVYsRUFBYXRTLENBQWIsRUFBZ0JnUSxDQUFoQixDQUFyQjtBQUNBLE1BQUksS0FBSzQ4QyxTQUFMLENBQWVVLFdBQWYsQ0FBMkJGLFlBQTNCLENBQUosRUFBOEM7QUFDNUMsU0FBS1IsU0FBTCxDQUFlcmdFLEdBQWYsQ0FBbUI2Z0UsWUFBbkI7QUFDRDtBQUNGLENBTEQ7a0JBTWVrQixPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxTmY7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQSxJQUFNeGpFLE1BQU0sU0FBTkEsR0FBTSxDQUFTNDhDLFdBQVQsRUFBc0I7QUFDaEMsTUFBTWh2QyxVQUFVZ3ZDLGVBQWUsRUFBL0I7QUFDQSxNQUFNMzVDLGFBQWEySyxRQUFRM0ssVUFBUixLQUF1QmpKLFNBQXZCLEdBQ2pCNFQsUUFBUTNLLFVBRFMsR0FDSSxXQUR2Qjs7QUFHQSxNQUFNaEYsV0FBVzJQLFFBQVEzUCxRQUFSLEtBQXFCakUsU0FBckIsR0FBaUM0VCxRQUFRM1AsUUFBekMsR0FDZix5QkFBVTtBQUNSb3RELFlBQVEsb0NBQXFCcG9ELFVBQXJCLENBREE7QUFFUjlFLGFBQVN5UCxRQUFRelAsT0FGVDtBQUdSRSxhQUFTdVAsUUFBUXZQLE9BSFQ7QUFJUkgsY0FBVTBQLFFBQVExUDtBQUpWLEdBQVYsQ0FERjs7QUFRQXFsRSxzQkFBVTV1RCxJQUFWLENBQWUsSUFBZixFQUFxQjtBQUNuQi9WLGtCQUFjZ1AsUUFBUWhQLFlBREg7QUFFbkJtakUsZUFBV24wRCxRQUFRbTBELFNBRkE7QUFHbkJoaUUsaUJBQWE2TixRQUFRN04sV0FIRjtBQUluQjRoRSxZQUFRL3pELFFBQVErekQsTUFKRztBQUtuQjErRCxnQkFBWUEsVUFMTztBQU1uQjhnRSxnQ0FBNEJuMkQsUUFBUW0yRCwwQkFOakI7QUFPbkI5bEUsY0FBVUEsUUFQUztBQVFuQjArQyxzQkFBa0IvdUMsUUFBUSt1QyxnQkFSUDtBQVNuQmtsQixvQkFBZ0JqMEQsUUFBUWkwRCxjQVRMO0FBVW5CNkIscUJBQWlCOTFELFFBQVE4MUQsZUFWTjtBQVduQjFyRSxTQUFLNFYsUUFBUTVWLEdBWE07QUFZbkJnSCxVQUFNNE8sUUFBUTVPLElBWks7QUFhbkJpaUUsV0FBT3J6RCxRQUFRcXpELEtBQVIsS0FBa0JqbkUsU0FBbEIsR0FBOEI0VCxRQUFRcXpELEtBQXRDLEdBQThDLElBYmxDO0FBY25CbitELGdCQUFZOEssUUFBUTlLO0FBZEQsR0FBckI7QUFpQkQsQ0E5QkQsQyxDQXBFQTs7Ozs7QUFvR0EscUJBQVM5QyxHQUFULEVBQWN1akUsbUJBQWQ7a0JBQ2V2akUsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDMURDNmxFLFcsR0FBQUEsVztRQXdDQUMsUyxHQUFBQSxTO1FBZ0dBemIsTyxHQUFBQSxPO1FBK0RBbGYsTSxHQUFBQSxNOztBQXhPaEI7O0FBQ0E7Ozs7OztBQUdBOzs7Ozs7Ozs7OztBQVlBOzs7OztBQTFCQTs7Ozs7OztBQU9BOzs7QUF3Qk8sSUFBTTQ2QiwwQ0FBaUIsU0FBdkI7O0FBR1A7Ozs7Ozs7OztBQVNPLFNBQVNGLFdBQVQsQ0FBcUJHLEVBQXJCLEVBQXlCQyxFQUF6QixFQUE2QkMsVUFBN0IsRUFBeUM7QUFDOUMsTUFBTUMsU0FBU0QsY0FBY0gsY0FBN0I7QUFDQSxNQUFNSyxPQUFPLHFCQUFVSixHQUFHLENBQUgsQ0FBVixDQUFiO0FBQ0EsTUFBTUssT0FBTyxxQkFBVUosR0FBRyxDQUFILENBQVYsQ0FBYjtBQUNBLE1BQU1LLGNBQWMsQ0FBQ0QsT0FBT0QsSUFBUixJQUFnQixDQUFwQztBQUNBLE1BQU1HLGNBQWMscUJBQVVOLEdBQUcsQ0FBSCxJQUFRRCxHQUFHLENBQUgsQ0FBbEIsSUFBMkIsQ0FBL0M7QUFDQSxNQUFNL2tFLElBQUkrUCxLQUFLekcsR0FBTCxDQUFTKzdELFdBQVQsSUFBd0J0MUQsS0FBS3pHLEdBQUwsQ0FBUys3RCxXQUFULENBQXhCLEdBQ050MUQsS0FBS3pHLEdBQUwsQ0FBU2c4RCxXQUFULElBQXdCdjFELEtBQUt6RyxHQUFMLENBQVNnOEQsV0FBVCxDQUF4QixHQUNBdjFELEtBQUt4RyxHQUFMLENBQVM0N0QsSUFBVCxDQURBLEdBQ2lCcDFELEtBQUt4RyxHQUFMLENBQVM2N0QsSUFBVCxDQUZyQjtBQUdBLFNBQU8sSUFBSUYsTUFBSixHQUFhbjFELEtBQUt3ZSxLQUFMLENBQVd4ZSxLQUFLN0csSUFBTCxDQUFVbEosQ0FBVixDQUFYLEVBQXlCK1AsS0FBSzdHLElBQUwsQ0FBVSxJQUFJbEosQ0FBZCxDQUF6QixDQUFwQjtBQUNEOztBQUdEOzs7Ozs7QUFNQSxTQUFTdWxFLGlCQUFULENBQTJCcmhFLFdBQTNCLEVBQXdDZ2hFLE1BQXhDLEVBQWdEO0FBQzlDLE1BQUk5dkUsU0FBUyxDQUFiO0FBQ0EsT0FBSyxJQUFJTCxJQUFJLENBQVIsRUFBV0MsS0FBS2tQLFlBQVk5TyxNQUFqQyxFQUF5Q0wsSUFBSUMsS0FBSyxDQUFsRCxFQUFxRCxFQUFFRCxDQUF2RCxFQUEwRDtBQUN4REssY0FBVXd2RSxZQUFZMWdFLFlBQVluUCxDQUFaLENBQVosRUFBNEJtUCxZQUFZblAsSUFBSSxDQUFoQixDQUE1QixFQUFnRG13RSxNQUFoRCxDQUFWO0FBQ0Q7QUFDRCxTQUFPOXZFLE1BQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7Ozs7O0FBWU8sU0FBU3l2RSxTQUFULENBQW1CN2dELFFBQW5CLEVBQTZCMjNCLFdBQTdCLEVBQTBDO0FBQy9DLE1BQU1odkMsVUFBVWd2QyxlQUFlLEVBQS9CO0FBQ0EsTUFBTXVwQixTQUFTdjRELFFBQVF1NEQsTUFBUixJQUFrQkosY0FBakM7QUFDQSxNQUFNOWlFLGFBQWEySyxRQUFRM0ssVUFBUixJQUFzQixXQUF6QztBQUNBLE1BQU1qSSxPQUFPaXFCLFNBQVM4USxPQUFULEVBQWI7QUFDQSxNQUFJLzZCLFNBQVN5ckUsdUJBQWEzWCxtQkFBMUIsRUFBK0M7QUFDN0M3cEMsZUFBV0EsU0FBU21rQyxLQUFULEdBQWlCa0osU0FBakIsQ0FBMkJydkQsVUFBM0IsRUFBdUMsV0FBdkMsQ0FBWDtBQUNEO0FBQ0QsTUFBSTVNLFNBQVMsQ0FBYjtBQUNBLE1BQUk4TyxvQkFBSjtBQUFBLE1BQWlCdWhFLGVBQWpCO0FBQUEsTUFBeUIxd0UsVUFBekI7QUFBQSxNQUE0QkMsV0FBNUI7QUFBQSxNQUFnQzhjLFVBQWhDO0FBQUEsTUFBbUM0ekQsV0FBbkM7QUFDQSxVQUFRM3JFLElBQVI7QUFDRSxTQUFLeXJFLHVCQUFhbFksS0FBbEI7QUFDQSxTQUFLa1ksdUJBQWE5WCxXQUFsQjtBQUErQjtBQUM3QjtBQUNEO0FBQ0QsU0FBSzhYLHVCQUFhalksV0FBbEI7QUFDQSxTQUFLaVksdUJBQWFoWSxXQUFsQjtBQUErQjtBQUM3QnRwRCxzQkFBYyw0Q0FBOEM4ZixRQUFELENBQVcyaEQsY0FBWCxFQUEzRDtBQUNBdndFLGlCQUFTbXdFLGtCQUFrQnJoRSxXQUFsQixFQUErQmdoRSxNQUEvQixDQUFUO0FBQ0E7QUFDRDtBQUNELFNBQUtNLHVCQUFhN1gsaUJBQWxCO0FBQ0EsU0FBSzZYLHVCQUFhL1gsT0FBbEI7QUFBMkI7QUFDekJ2cEQsc0JBQWMsNENBQThDOGYsUUFBRCxDQUFXMmhELGNBQVgsRUFBM0Q7QUFDQSxhQUFLNXdFLElBQUksQ0FBSixFQUFPQyxLQUFLa1AsWUFBWTlPLE1BQTdCLEVBQXFDTCxJQUFJQyxFQUF6QyxFQUE2QyxFQUFFRCxDQUEvQyxFQUFrRDtBQUNoREssb0JBQVVtd0Usa0JBQWtCcmhFLFlBQVluUCxDQUFaLENBQWxCLEVBQWtDbXdFLE1BQWxDLENBQVY7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxTQUFLTSx1QkFBYTVYLGFBQWxCO0FBQWlDO0FBQy9CMXBELHNCQUFjLDRDQUE4QzhmLFFBQUQsQ0FBVzJoRCxjQUFYLEVBQTNEO0FBQ0EsYUFBSzV3RSxJQUFJLENBQUosRUFBT0MsS0FBS2tQLFlBQVk5TyxNQUE3QixFQUFxQ0wsSUFBSUMsRUFBekMsRUFBNkMsRUFBRUQsQ0FBL0MsRUFBa0Q7QUFDaEQwd0UsbUJBQVN2aEUsWUFBWW5QLENBQVosQ0FBVDtBQUNBLGVBQUsrYyxJQUFJLENBQUosRUFBTzR6RCxLQUFLRCxPQUFPcndFLE1BQXhCLEVBQWdDMGMsSUFBSTR6RCxFQUFwQyxFQUF3QyxFQUFFNXpELENBQTFDLEVBQTZDO0FBQzNDMWMsc0JBQVVtd0Usa0JBQWtCRSxPQUFPM3pELENBQVAsQ0FBbEIsRUFBNkJvekQsTUFBN0IsQ0FBVjtBQUNEO0FBQ0Y7QUFDRDtBQUNEO0FBQ0QsU0FBS00sdUJBQWEzWCxtQkFBbEI7QUFBdUM7QUFDckMsWUFBTTdqQyxhQUFhLGdEQUFrRGhHLFFBQUQsQ0FBVzRoRCxhQUFYLEVBQXBFO0FBQ0EsYUFBSzd3RSxJQUFJLENBQUosRUFBT0MsS0FBS2cxQixXQUFXNTBCLE1BQTVCLEVBQW9DTCxJQUFJQyxFQUF4QyxFQUE0QyxFQUFFRCxDQUE5QyxFQUFpRDtBQUMvQ0ssb0JBQVV5dkUsVUFBVTc2QyxXQUFXajFCLENBQVgsQ0FBVixFQUF5QjRtRCxXQUF6QixDQUFWO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFBUztBQUNQLGNBQU0sSUFBSTdqRCxLQUFKLENBQVUsZ0NBQWdDaUMsSUFBMUMsQ0FBTjtBQUNEO0FBdENIO0FBd0NBLFNBQU8zRSxNQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBU3l3RSxlQUFULENBQXlCM2hFLFdBQXpCLEVBQXNDZ2hFLE1BQXRDLEVBQThDO0FBQzVDLE1BQUkxWixPQUFPLENBQVg7QUFDQSxNQUFNeDNDLE1BQU05UCxZQUFZOU8sTUFBeEI7QUFDQSxNQUFJdXhCLEtBQUt6aUIsWUFBWThQLE1BQU0sQ0FBbEIsRUFBcUIsQ0FBckIsQ0FBVDtBQUNBLE1BQUk0UyxLQUFLMWlCLFlBQVk4UCxNQUFNLENBQWxCLEVBQXFCLENBQXJCLENBQVQ7QUFDQSxPQUFLLElBQUlqZixJQUFJLENBQWIsRUFBZ0JBLElBQUlpZixHQUFwQixFQUF5QmpmLEdBQXpCLEVBQThCO0FBQzVCLFFBQU04eEIsS0FBSzNpQixZQUFZblAsQ0FBWixFQUFlLENBQWYsQ0FBWDtBQUNBLFFBQU0reEIsS0FBSzVpQixZQUFZblAsQ0FBWixFQUFlLENBQWYsQ0FBWDtBQUNBeTJELFlBQVEscUJBQVUza0MsS0FBS0YsRUFBZixLQUNILElBQUk1VyxLQUFLekcsR0FBTCxDQUFTLHFCQUFVc2QsRUFBVixDQUFULENBQUosR0FDRDdXLEtBQUt6RyxHQUFMLENBQVMscUJBQVV3ZCxFQUFWLENBQVQsQ0FGSSxDQUFSO0FBR0FILFNBQUtFLEVBQUw7QUFDQUQsU0FBS0UsRUFBTDtBQUNEO0FBQ0QsU0FBTzBrQyxPQUFPMFosTUFBUCxHQUFnQkEsTUFBaEIsR0FBeUIsR0FBaEM7QUFDRDs7QUFHRDs7Ozs7Ozs7OztBQVVPLFNBQVM5YixPQUFULENBQWlCcGxDLFFBQWpCLEVBQTJCMjNCLFdBQTNCLEVBQXdDO0FBQzdDLE1BQU1odkMsVUFBVWd2QyxlQUFlLEVBQS9CO0FBQ0EsTUFBTXVwQixTQUFTdjRELFFBQVF1NEQsTUFBUixJQUFrQkosY0FBakM7QUFDQSxNQUFNOWlFLGFBQWEySyxRQUFRM0ssVUFBUixJQUFzQixXQUF6QztBQUNBLE1BQU1qSSxPQUFPaXFCLFNBQVM4USxPQUFULEVBQWI7QUFDQSxNQUFJLzZCLFNBQVN5ckUsdUJBQWEzWCxtQkFBMUIsRUFBK0M7QUFDN0M3cEMsZUFBV0EsU0FBU21rQyxLQUFULEdBQWlCa0osU0FBakIsQ0FBMkJydkQsVUFBM0IsRUFBdUMsV0FBdkMsQ0FBWDtBQUNEO0FBQ0QsTUFBSXdwRCxPQUFPLENBQVg7QUFDQSxNQUFJdG5ELG9CQUFKO0FBQUEsTUFBaUJ1aEUsZUFBakI7QUFBQSxNQUF5QjF3RSxVQUF6QjtBQUFBLE1BQTRCQyxXQUE1QjtBQUFBLE1BQWdDOGMsVUFBaEM7QUFBQSxNQUFtQzR6RCxXQUFuQztBQUNBLFVBQVEzckUsSUFBUjtBQUNFLFNBQUt5ckUsdUJBQWFsWSxLQUFsQjtBQUNBLFNBQUtrWSx1QkFBYTlYLFdBQWxCO0FBQ0EsU0FBSzhYLHVCQUFhalksV0FBbEI7QUFDQSxTQUFLaVksdUJBQWE3WCxpQkFBbEI7QUFDQSxTQUFLNlgsdUJBQWFoWSxXQUFsQjtBQUErQjtBQUM3QjtBQUNEO0FBQ0QsU0FBS2dZLHVCQUFhL1gsT0FBbEI7QUFBMkI7QUFDekJ2cEQsc0JBQWMscUNBQXVDOGYsUUFBRCxDQUFXMmhELGNBQVgsRUFBcEQ7QUFDQW5hLGVBQU96N0MsS0FBS2pHLEdBQUwsQ0FBUys3RCxnQkFBZ0IzaEUsWUFBWSxDQUFaLENBQWhCLEVBQWdDZ2hFLE1BQWhDLENBQVQsQ0FBUDtBQUNBLGFBQUtud0UsSUFBSSxDQUFKLEVBQU9DLEtBQUtrUCxZQUFZOU8sTUFBN0IsRUFBcUNMLElBQUlDLEVBQXpDLEVBQTZDLEVBQUVELENBQS9DLEVBQWtEO0FBQ2hEeTJELGtCQUFRejdDLEtBQUtqRyxHQUFMLENBQVMrN0QsZ0JBQWdCM2hFLFlBQVluUCxDQUFaLENBQWhCLEVBQWdDbXdFLE1BQWhDLENBQVQsQ0FBUjtBQUNEO0FBQ0Q7QUFDRDtBQUNELFNBQUtNLHVCQUFhNVgsYUFBbEI7QUFBaUM7QUFDL0IxcEQsc0JBQWMsNENBQThDOGYsUUFBRCxDQUFXMmhELGNBQVgsRUFBM0Q7QUFDQSxhQUFLNXdFLElBQUksQ0FBSixFQUFPQyxLQUFLa1AsWUFBWTlPLE1BQTdCLEVBQXFDTCxJQUFJQyxFQUF6QyxFQUE2QyxFQUFFRCxDQUEvQyxFQUFrRDtBQUNoRDB3RSxtQkFBU3ZoRSxZQUFZblAsQ0FBWixDQUFUO0FBQ0F5MkQsa0JBQVF6N0MsS0FBS2pHLEdBQUwsQ0FBUys3RCxnQkFBZ0JKLE9BQU8sQ0FBUCxDQUFoQixFQUEyQlAsTUFBM0IsQ0FBVCxDQUFSO0FBQ0EsZUFBS3B6RCxJQUFJLENBQUosRUFBTzR6RCxLQUFLRCxPQUFPcndFLE1BQXhCLEVBQWdDMGMsSUFBSTR6RCxFQUFwQyxFQUF3QyxFQUFFNXpELENBQTFDLEVBQTZDO0FBQzNDMDVDLG9CQUFRejdDLEtBQUtqRyxHQUFMLENBQVMrN0QsZ0JBQWdCSixPQUFPM3pELENBQVAsQ0FBaEIsRUFBMkJvekQsTUFBM0IsQ0FBVCxDQUFSO0FBQ0Q7QUFDRjtBQUNEO0FBQ0Q7QUFDRCxTQUFLTSx1QkFBYTNYLG1CQUFsQjtBQUF1QztBQUNyQyxZQUFNN2pDLGFBQWEsZ0RBQWtEaEcsUUFBRCxDQUFXNGhELGFBQVgsRUFBcEU7QUFDQSxhQUFLN3dFLElBQUksQ0FBSixFQUFPQyxLQUFLZzFCLFdBQVc1MEIsTUFBNUIsRUFBb0NMLElBQUlDLEVBQXhDLEVBQTRDLEVBQUVELENBQTlDLEVBQWlEO0FBQy9DeTJELGtCQUFRcEMsUUFBUXAvQixXQUFXajFCLENBQVgsQ0FBUixFQUF1QjRtRCxXQUF2QixDQUFSO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFBUztBQUNQLGNBQU0sSUFBSTdqRCxLQUFKLENBQVUsZ0NBQWdDaUMsSUFBMUMsQ0FBTjtBQUNEO0FBcENIO0FBc0NBLFNBQU95eEQsSUFBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7OztBQVdPLFNBQVN0aEIsTUFBVCxDQUFnQjY2QixFQUFoQixFQUFvQjk2RCxRQUFwQixFQUE4Qi9JLE9BQTlCLEVBQXVDK2pFLFVBQXZDLEVBQW1EO0FBQ3hELE1BQU1DLFNBQVNELGNBQWNILGNBQTdCO0FBQ0EsTUFBTUssT0FBTyxxQkFBVUosR0FBRyxDQUFILENBQVYsQ0FBYjtBQUNBLE1BQU1lLE9BQU8scUJBQVVmLEdBQUcsQ0FBSCxDQUFWLENBQWI7QUFDQSxNQUFNZ0IsT0FBTzk3RCxXQUFXaTdELE1BQXhCO0FBQ0EsTUFBTXAvQyxNQUFNL1YsS0FBS3RHLElBQUwsQ0FDVnNHLEtBQUt6RyxHQUFMLENBQVM2N0QsSUFBVCxJQUFpQnAxRCxLQUFLeEcsR0FBTCxDQUFTdzhELElBQVQsQ0FBakIsR0FDRWgyRCxLQUFLeEcsR0FBTCxDQUFTNDdELElBQVQsSUFBaUJwMUQsS0FBS3pHLEdBQUwsQ0FBU3k4RCxJQUFULENBQWpCLEdBQWtDaDJELEtBQUt4RyxHQUFMLENBQVNySSxPQUFULENBRjFCLENBQVo7QUFHQSxNQUFNeXlELE1BQU1tUyxPQUFPLzFELEtBQUt3ZSxLQUFMLENBQ2pCeGUsS0FBS3pHLEdBQUwsQ0FBU3BJLE9BQVQsSUFBb0I2TyxLQUFLekcsR0FBTCxDQUFTeThELElBQVQsQ0FBcEIsR0FBcUNoMkQsS0FBS3hHLEdBQUwsQ0FBUzQ3RCxJQUFULENBRHBCLEVBRWpCcDFELEtBQUt4RyxHQUFMLENBQVN3OEQsSUFBVCxJQUFpQmgyRCxLQUFLekcsR0FBTCxDQUFTNjdELElBQVQsSUFBaUJwMUQsS0FBS3pHLEdBQUwsQ0FBU3djLEdBQVQsQ0FGakIsQ0FBbkI7QUFHQSxTQUFPLENBQUMscUJBQVU2dEMsR0FBVixDQUFELEVBQWlCLHFCQUFVN3RDLEdBQVYsQ0FBakIsQ0FBUDtBQUNELEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNQRDs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7QUFsQkE7OztBQTZCQSxJQUFNazZCLFdBQVcsU0FBWEEsUUFBVyxDQUFTRCxpQkFBVCxFQUE0Qjs7QUFFM0NqQix3QkFBWXByQyxJQUFaLENBQWlCLElBQWpCOztBQUVBOzs7QUFHQSxPQUFLeXZELGFBQUwsR0FBcUJwakIsc0JBQXNCaG5ELFNBQXRCLEdBQWtDZ25ELGlCQUFsQyxHQUFzRCxJQUEzRTs7QUFFQTs7OztBQUlBLE9BQUtpbUIsTUFBTCxHQUFjLENBQWQ7O0FBRUE7Ozs7QUFJQSxPQUFLQyxRQUFMLEdBQWdCLEVBQWhCOztBQUVBOzs7O0FBSUEsT0FBS0MsT0FBTCxHQUFlLElBQWY7O0FBRUE7Ozs7QUFJQSxPQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUVELENBakNEOztBQW1DQSxxQkFBU25tQixRQUFULEVBQW1CbEIscUJBQW5COztBQUdBOzs7QUFHQWtCLFNBQVN2c0MsU0FBVCxDQUFtQjBzQyxjQUFuQixHQUFvQyxZQUFXO0FBQzdDLFNBQU8sS0FBS0ssUUFBTCxLQUFrQixLQUFLMmlCLGFBQTlCO0FBQ0QsQ0FGRDs7QUFLQTs7O0FBR0FuakIsU0FBU3ZzQyxTQUFULENBQW1CdzhDLEtBQW5CLEdBQTJCLFlBQVc7QUFDcEMsT0FBSytWLE1BQUwsR0FBYyxDQUFkO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixFQUFoQjtBQUNBLE9BQUtDLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLM25CLGFBQUwsQ0FBbUJwQixvQkFBVTBKLEtBQTdCO0FBQ0QsQ0FORDs7QUFTQTs7OztBQUlBOUcsU0FBU3ZzQyxTQUFULENBQW1COHRELFdBQW5CLEdBQWlDLFVBQVNuakUsR0FBVCxFQUFjO0FBQzdDLFNBQU8sS0FBSzZuRSxRQUFMLENBQWNoekQsY0FBZCxDQUE2QjdVLEdBQTdCLENBQVA7QUFDRCxDQUZEOztBQUtBOzs7Ozs7OztBQVFBNGhELFNBQVN2c0MsU0FBVCxDQUFtQmdILE9BQW5CLEdBQTZCLFVBQVNxRCxDQUFULEVBQVkybkMsUUFBWixFQUFzQjtBQUNqRCxNQUFJMmdCLFFBQVEsS0FBS0YsT0FBakI7QUFDQSxTQUFPRSxLQUFQLEVBQWM7QUFDWnRvRCxNQUFFcEssSUFBRixDQUFPK3hDLFFBQVAsRUFBaUIyZ0IsTUFBTUMsTUFBdkIsRUFBK0JELE1BQU1wRixJQUFyQyxFQUEyQyxJQUEzQztBQUNBb0YsWUFBUUEsTUFBTUUsS0FBZDtBQUNEO0FBQ0YsQ0FORDs7QUFTQTs7OztBQUlBdG1CLFNBQVN2c0MsU0FBVCxDQUFtQmpULEdBQW5CLEdBQXlCLFVBQVNwQyxHQUFULEVBQWM7QUFDckMsTUFBTWdvRSxRQUFRLEtBQUtILFFBQUwsQ0FBYzduRSxHQUFkLENBQWQ7QUFDQSx1QkFBT2dvRSxVQUFVcnRFLFNBQWpCLEVBQ0UsRUFERixFQUZxQyxDQUc5QjtBQUNQLE1BQUlxdEUsVUFBVSxLQUFLRCxPQUFuQixFQUE0QjtBQUMxQixXQUFPQyxNQUFNQyxNQUFiO0FBQ0QsR0FGRCxNQUVPLElBQUlELFVBQVUsS0FBS0YsT0FBbkIsRUFBNEI7QUFDakMsU0FBS0EsT0FBTCxHQUFlLCtDQUFpRCxLQUFLQSxPQUFMLENBQWFJLEtBQTdFO0FBQ0EsU0FBS0osT0FBTCxDQUFhSyxLQUFiLEdBQXFCLElBQXJCO0FBQ0QsR0FITSxNQUdBO0FBQ0xILFVBQU1FLEtBQU4sQ0FBWUMsS0FBWixHQUFvQkgsTUFBTUcsS0FBMUI7QUFDQUgsVUFBTUcsS0FBTixDQUFZRCxLQUFaLEdBQW9CRixNQUFNRSxLQUExQjtBQUNEO0FBQ0RGLFFBQU1FLEtBQU4sR0FBYyxJQUFkO0FBQ0FGLFFBQU1HLEtBQU4sR0FBYyxLQUFLSixPQUFuQjtBQUNBLE9BQUtBLE9BQUwsQ0FBYUcsS0FBYixHQUFxQkYsS0FBckI7QUFDQSxPQUFLRCxPQUFMLEdBQWVDLEtBQWY7QUFDQSxTQUFPQSxNQUFNQyxNQUFiO0FBQ0QsQ0FsQkQ7O0FBcUJBOzs7OztBQUtBcm1CLFNBQVN2c0MsU0FBVCxDQUFtQml0QyxNQUFuQixHQUE0QixVQUFTdGlELEdBQVQsRUFBYztBQUN4QyxNQUFNZ29FLFFBQVEsS0FBS0gsUUFBTCxDQUFjN25FLEdBQWQsQ0FBZDtBQUNBLHVCQUFPZ29FLFVBQVVydEUsU0FBakIsRUFBNEIsRUFBNUIsRUFGd0MsQ0FFUDtBQUNqQyxNQUFJcXRFLFVBQVUsS0FBS0QsT0FBbkIsRUFBNEI7QUFDMUIsU0FBS0EsT0FBTCxHQUFlLCtDQUFpREMsTUFBTUcsS0FBdEU7QUFDQSxRQUFJLEtBQUtKLE9BQVQsRUFBa0I7QUFDaEIsV0FBS0EsT0FBTCxDQUFhRyxLQUFiLEdBQXFCLElBQXJCO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBSUYsVUFBVSxLQUFLRixPQUFuQixFQUE0QjtBQUNqQyxTQUFLQSxPQUFMLEdBQWUsK0NBQWlERSxNQUFNRSxLQUF0RTtBQUNBLFFBQUksS0FBS0osT0FBVCxFQUFrQjtBQUNoQixXQUFLQSxPQUFMLENBQWFLLEtBQWIsR0FBcUIsSUFBckI7QUFDRDtBQUNGLEdBTE0sTUFLQTtBQUNMSCxVQUFNRSxLQUFOLENBQVlDLEtBQVosR0FBb0JILE1BQU1HLEtBQTFCO0FBQ0FILFVBQU1HLEtBQU4sQ0FBWUQsS0FBWixHQUFvQkYsTUFBTUUsS0FBMUI7QUFDRDtBQUNELFNBQU8sS0FBS0wsUUFBTCxDQUFjN25FLEdBQWQsQ0FBUDtBQUNBLElBQUUsS0FBSzRuRSxNQUFQO0FBQ0EsU0FBT0ksTUFBTUMsTUFBYjtBQUNELENBcEJEOztBQXVCQTs7O0FBR0FybUIsU0FBU3ZzQyxTQUFULENBQW1CK3NDLFFBQW5CLEdBQThCLFlBQVc7QUFDdkMsU0FBTyxLQUFLd2xCLE1BQVo7QUFDRCxDQUZEOztBQUtBOzs7QUFHQWhtQixTQUFTdnNDLFNBQVQsQ0FBbUIycUMsT0FBbkIsR0FBNkIsWUFBVztBQUN0QyxNQUFNNXdDLE9BQU8sSUFBSXZZLEtBQUosQ0FBVSxLQUFLK3dFLE1BQWYsQ0FBYjtBQUNBLE1BQUlqeEUsSUFBSSxDQUFSO0FBQ0EsTUFBSXF4RSxjQUFKO0FBQ0EsT0FBS0EsUUFBUSxLQUFLRCxPQUFsQixFQUEyQkMsS0FBM0IsRUFBa0NBLFFBQVFBLE1BQU1HLEtBQWhELEVBQXVEO0FBQ3JELzRELFNBQUt6WSxHQUFMLElBQVlxeEUsTUFBTXBGLElBQWxCO0FBQ0Q7QUFDRCxTQUFPeHpELElBQVA7QUFDRCxDQVJEOztBQVdBOzs7QUFHQXd5QyxTQUFTdnNDLFNBQVQsQ0FBbUJ5OEMsU0FBbkIsR0FBK0IsWUFBVztBQUN4QyxNQUFNdHZELFNBQVMsSUFBSTNMLEtBQUosQ0FBVSxLQUFLK3dFLE1BQWYsQ0FBZjtBQUNBLE1BQUlqeEUsSUFBSSxDQUFSO0FBQ0EsTUFBSXF4RSxjQUFKO0FBQ0EsT0FBS0EsUUFBUSxLQUFLRCxPQUFsQixFQUEyQkMsS0FBM0IsRUFBa0NBLFFBQVFBLE1BQU1HLEtBQWhELEVBQXVEO0FBQ3JEM2xFLFdBQU83TCxHQUFQLElBQWNxeEUsTUFBTUMsTUFBcEI7QUFDRDtBQUNELFNBQU96bEUsTUFBUDtBQUNELENBUkQ7O0FBV0E7OztBQUdBby9DLFNBQVN2c0MsU0FBVCxDQUFtQjJzQyxRQUFuQixHQUE4QixZQUFXO0FBQ3ZDLFNBQU8sS0FBSzhsQixPQUFMLENBQWFHLE1BQXBCO0FBQ0QsQ0FGRDs7QUFLQTs7O0FBR0FybUIsU0FBU3ZzQyxTQUFULENBQW1CK3lELFdBQW5CLEdBQWlDLFlBQVc7QUFDMUMsU0FBTyxLQUFLTixPQUFMLENBQWFsRixJQUFwQjtBQUNELENBRkQ7O0FBS0E7Ozs7QUFJQWhoQixTQUFTdnNDLFNBQVQsQ0FBbUJndEMsWUFBbkIsR0FBa0MsWUFBVztBQUMzQyxTQUFPLEtBQUswbEIsT0FBTCxDQUFhbkYsSUFBcEI7QUFDRCxDQUZEOztBQUtBOzs7QUFHQWhoQixTQUFTdnNDLFNBQVQsQ0FBbUJrRyxHQUFuQixHQUF5QixZQUFXO0FBQ2xDLE1BQU15c0QsUUFBUSxLQUFLRixPQUFuQjtBQUNBLFNBQU8sS0FBS0QsUUFBTCxDQUFjRyxNQUFNcEYsSUFBcEIsQ0FBUDtBQUNBLE1BQUlvRixNQUFNRSxLQUFWLEVBQWlCO0FBQ2ZGLFVBQU1FLEtBQU4sQ0FBWUMsS0FBWixHQUFvQixJQUFwQjtBQUNEO0FBQ0QsT0FBS0wsT0FBTCxHQUFlLCtDQUFpREUsTUFBTUUsS0FBdEU7QUFDQSxNQUFJLENBQUMsS0FBS0osT0FBVixFQUFtQjtBQUNqQixTQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNEO0FBQ0QsSUFBRSxLQUFLSCxNQUFQO0FBQ0EsU0FBT0ksTUFBTUMsTUFBYjtBQUNELENBWkQ7O0FBZUE7Ozs7QUFJQXJtQixTQUFTdnNDLFNBQVQsQ0FBbUI3ZCxPQUFuQixHQUE2QixVQUFTd0ksR0FBVCxFQUFjNkMsS0FBZCxFQUFxQjtBQUNoRCxPQUFLVCxHQUFMLENBQVNwQyxHQUFULEVBRGdELENBQ2hDO0FBQ2hCLE9BQUs2bkUsUUFBTCxDQUFjN25FLEdBQWQsRUFBbUJpb0UsTUFBbkIsR0FBNEJwbEUsS0FBNUI7QUFDRCxDQUhEOztBQU1BOzs7O0FBSUErK0MsU0FBU3ZzQyxTQUFULENBQW1CNVQsR0FBbkIsR0FBeUIsVUFBU3pCLEdBQVQsRUFBYzZDLEtBQWQsRUFBcUI7QUFDNUMsdUJBQU8sRUFBRTdDLE9BQU8sS0FBSzZuRSxRQUFkLENBQVAsRUFDRSxFQURGLEVBRDRDLENBRXJDO0FBQ1AsTUFBTUcsUUFBUSwrQ0FBaUQ7QUFDN0RwRixVQUFNNWlFLEdBRHVEO0FBRTdEa29FLFdBQU8sSUFGc0Q7QUFHN0RDLFdBQU8sS0FBS0osT0FIaUQ7QUFJN0RFLFlBQVFwbEU7QUFKcUQsR0FBL0Q7QUFNQSxNQUFJLENBQUMsS0FBS2tsRSxPQUFWLEVBQW1CO0FBQ2pCLFNBQUtELE9BQUwsR0FBZUUsS0FBZjtBQUNELEdBRkQsTUFFTztBQUNMLFNBQUtELE9BQUwsQ0FBYUcsS0FBYixHQUFxQkYsS0FBckI7QUFDRDtBQUNELE9BQUtELE9BQUwsR0FBZUMsS0FBZjtBQUNBLE9BQUtILFFBQUwsQ0FBYzduRSxHQUFkLElBQXFCZ29FLEtBQXJCO0FBQ0EsSUFBRSxLQUFLSixNQUFQO0FBQ0QsQ0FqQkQ7O0FBb0JBOzs7OztBQUtBaG1CLFNBQVN2c0MsU0FBVCxDQUFtQmd6RCxPQUFuQixHQUE2QixVQUFTenFFLElBQVQsRUFBZTtBQUMxQyxPQUFLbW5FLGFBQUwsR0FBcUJubkUsSUFBckI7QUFDRCxDQUZEOztBQUtBOzs7QUFHQWdrRCxTQUFTdnNDLFNBQVQsQ0FBbUJpekQsS0FBbkIsR0FBMkIsWUFBVztBQUNwQyxTQUFPLEtBQUt2bUIsY0FBTCxFQUFQLEVBQThCO0FBQzVCLFNBQUt4bUMsR0FBTDtBQUNEO0FBQ0YsQ0FKRDtrQkFLZXFtQyxROzs7Ozs7Ozs7Ozs7Ozs7OztRQ3JSQ1csYyxHQUFBQSxjO1FBa0JBZ21CLFMsR0FBQUEsUztRQVVBanFCLE0sR0FBQUEsTTtRQVVBa3FCLE8sR0FBQUEsTztRQVNBbnhELEksR0FBQUEsSTtRQVNBb3hELE8sR0FBQUEsTztRQTBCQUMsZ0IsR0FBQUEsZ0I7QUF0R2hCOzs7O0FBS0E7Ozs7Ozs7QUFRQTs7Ozs7OztBQU9PLFNBQVNubUIsY0FBVCxDQUF3QnA2QixDQUF4QixFQUEyQnRTLENBQTNCLEVBQThCZ1EsQ0FBOUIsRUFBaUM4aUQsYUFBakMsRUFBZ0Q7QUFDckQsTUFBSUEsa0JBQWtCaHVFLFNBQXRCLEVBQWlDO0FBQy9CZ3VFLGtCQUFjLENBQWQsSUFBbUJ4Z0QsQ0FBbkI7QUFDQXdnRCxrQkFBYyxDQUFkLElBQW1COXlELENBQW5CO0FBQ0E4eUQsa0JBQWMsQ0FBZCxJQUFtQjlpRCxDQUFuQjtBQUNBLFdBQU84aUQsYUFBUDtBQUNELEdBTEQsTUFLTztBQUNMLFdBQU8sQ0FBQ3hnRCxDQUFELEVBQUl0UyxDQUFKLEVBQU9nUSxDQUFQLENBQVA7QUFDRDtBQUNGOztBQUdEOzs7Ozs7QUFNTyxTQUFTMGlELFNBQVQsQ0FBbUJwZ0QsQ0FBbkIsRUFBc0J0UyxDQUF0QixFQUF5QmdRLENBQXpCLEVBQTRCO0FBQ2pDLFNBQU9zQyxJQUFJLEdBQUosR0FBVXRTLENBQVYsR0FBYyxHQUFkLEdBQW9CZ1EsQ0FBM0I7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTeTRCLE1BQVQsQ0FBZ0JqQixTQUFoQixFQUEyQjtBQUNoQyxTQUFPa3JCLFVBQVVsckIsVUFBVSxDQUFWLENBQVYsRUFBd0JBLFVBQVUsQ0FBVixDQUF4QixFQUFzQ0EsVUFBVSxDQUFWLENBQXRDLENBQVA7QUFDRDs7QUFHRDs7Ozs7QUFLTyxTQUFTbXJCLE9BQVQsQ0FBaUJ4b0UsR0FBakIsRUFBc0I7QUFDM0IsU0FBT0EsSUFBSXpJLEtBQUosQ0FBVSxHQUFWLEVBQWVGLEdBQWYsQ0FBbUJ5dEIsTUFBbkIsQ0FBUDtBQUNEOztBQUdEOzs7O0FBSU8sU0FBU3pOLElBQVQsQ0FBY2dtQyxTQUFkLEVBQXlCO0FBQzlCLFNBQU8sQ0FBQ0EsVUFBVSxDQUFWLEtBQWdCQSxVQUFVLENBQVYsQ0FBakIsSUFBaUNBLFVBQVUsQ0FBVixDQUF4QztBQUNEOztBQUdEOzs7O0FBSU8sU0FBU29yQixPQUFULENBQWlCcHJCLFNBQWpCLEVBQTRCO0FBQ2pDLE1BQU1sMUIsSUFBSWsxQixVQUFVLENBQVYsQ0FBVjtBQUNBLE1BQU11ckIsU0FBUyxJQUFJL3hFLEtBQUosQ0FBVXN4QixDQUFWLENBQWY7QUFDQSxNQUFJMGdELE9BQU8sS0FBTTFnRCxJQUFJLENBQXJCO0FBQ0EsTUFBSXh4QixVQUFKO0FBQUEsTUFBT215RSxpQkFBUDtBQUNBLE9BQUtueUUsSUFBSSxDQUFULEVBQVlBLElBQUl3eEIsQ0FBaEIsRUFBbUIsRUFBRXh4QixDQUFyQixFQUF3QjtBQUN0QjtBQUNBbXlFLGVBQVcsRUFBWDtBQUNBLFFBQUl6ckIsVUFBVSxDQUFWLElBQWV3ckIsSUFBbkIsRUFBeUI7QUFDdkJDLGtCQUFZLENBQVo7QUFDRDtBQUNELFFBQUl6ckIsVUFBVSxDQUFWLElBQWV3ckIsSUFBbkIsRUFBeUI7QUFDdkJDLGtCQUFZLENBQVo7QUFDRDtBQUNERixXQUFPanlFLENBQVAsSUFBWWtiLE9BQU9DLFlBQVAsQ0FBb0JnM0QsUUFBcEIsQ0FBWjtBQUNBRCxhQUFTLENBQVQ7QUFDRDtBQUNELFNBQU9ELE9BQU83bUUsSUFBUCxDQUFZLEVBQVosQ0FBUDtBQUNEOztBQUdEOzs7OztBQUtPLFNBQVMybUUsZ0JBQVQsQ0FBMEJyckIsU0FBMUIsRUFBcUN6K0MsUUFBckMsRUFBK0M7QUFDcEQsTUFBTXVwQixJQUFJazFCLFVBQVUsQ0FBVixDQUFWO0FBQ0EsTUFBTXhuQyxJQUFJd25DLFVBQVUsQ0FBVixDQUFWO0FBQ0EsTUFBTXgzQixJQUFJdzNCLFVBQVUsQ0FBVixDQUFWOztBQUVBLE1BQUl6K0MsU0FBU1EsVUFBVCxLQUF3QitvQixDQUF4QixJQUE2QkEsSUFBSXZwQixTQUFTNEIsVUFBVCxFQUFyQyxFQUE0RDtBQUMxRCxXQUFPLEtBQVA7QUFDRDtBQUNELE1BQU13ckQsU0FBU3B0RCxTQUFTbEIsU0FBVCxFQUFmO0FBQ0EsTUFBSW1sRCxrQkFBSjtBQUNBLE1BQUksQ0FBQ21KLE1BQUwsRUFBYTtBQUNYbkosZ0JBQVlqa0QsU0FBU21xRSxnQkFBVCxDQUEwQjVnRCxDQUExQixDQUFaO0FBQ0QsR0FGRCxNQUVPO0FBQ0wwNkIsZ0JBQVlqa0QsU0FBU3krRCx5QkFBVCxDQUFtQ3JSLE1BQW5DLEVBQTJDN2pDLENBQTNDLENBQVo7QUFDRDtBQUNELE1BQUksQ0FBQzA2QixTQUFMLEVBQWdCO0FBQ2QsV0FBTyxJQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT0EsVUFBVUMsVUFBVixDQUFxQmp0QyxDQUFyQixFQUF3QmdRLENBQXhCLENBQVA7QUFDRDtBQUNGLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDeEdlbWpELGdCLEdBQUFBLGdCO1FBZ0JBcEgsSyxHQUFBQSxLO1FBd0JBcUgsZSxHQUFBQSxlO1FBZ0NBQyxTLEdBQUFBLFM7UUFzREFDLG1CLEdBQUFBLG1CO1FBWUFDLG9CLEdBQUFBLG9COztBQXpKaEI7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQTs7Ozs7QUFiQTs7O0FBa0JPLFNBQVNKLGdCQUFULENBQTBCcGxFLFVBQTFCLEVBQXNDO0FBQzNDLE1BQUloRixXQUFXZ0YsV0FBV3N6RCxrQkFBWCxFQUFmO0FBQ0EsTUFBSSxDQUFDdDRELFFBQUwsRUFBZTtBQUNiQSxlQUFXdXFFLG9CQUFvQnZsRSxVQUFwQixDQUFYO0FBQ0FBLGVBQVd1ekQsa0JBQVgsQ0FBOEJ2NEQsUUFBOUI7QUFDRDtBQUNELFNBQU9BLFFBQVA7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU2dqRSxLQUFULENBQWVoakUsUUFBZixFQUF5QnkrQyxTQUF6QixFQUFvQ3o1QyxVQUFwQyxFQUFnRDtBQUNyRCxNQUFNdWtCLElBQUlrMUIsVUFBVSxDQUFWLENBQVY7QUFDQSxNQUFNLy9DLFNBQVNzQixTQUFTeXFFLGtCQUFULENBQTRCaHNCLFNBQTVCLENBQWY7QUFDQSxNQUFNaXNCLG1CQUFtQkYscUJBQXFCeGxFLFVBQXJCLENBQXpCO0FBQ0EsTUFBSSxDQUFDLGdDQUFtQjBsRSxnQkFBbkIsRUFBcUNoc0UsTUFBckMsQ0FBTCxFQUFtRDtBQUNqRCxRQUFNaXNFLGFBQWEsc0JBQVNELGdCQUFULENBQW5CO0FBQ0EsUUFBTUUsYUFBYTczRCxLQUFLaEcsSUFBTCxDQUFVLENBQUMyOUQsaUJBQWlCLENBQWpCLElBQXNCaHNFLE9BQU8sQ0FBUCxDQUF2QixJQUFvQ2lzRSxVQUE5QyxDQUFuQjtBQUNBanNFLFdBQU8sQ0FBUCxLQUFhaXNFLGFBQWFDLFVBQTFCO0FBQ0EsV0FBTzVxRSxTQUFTNnFFLHdCQUFULENBQWtDbnNFLE1BQWxDLEVBQTBDNnFCLENBQTFDLENBQVA7QUFDRCxHQUxELE1BS087QUFDTCxXQUFPazFCLFNBQVA7QUFDRDtBQUNGOztBQUdEOzs7Ozs7Ozs7QUFTTyxTQUFTNHJCLGVBQVQsQ0FBeUJqZCxNQUF6QixFQUFpQzBkLFdBQWpDLEVBQThDQyxZQUE5QyxFQUE0REMsVUFBNUQsRUFBd0U7QUFDN0UsTUFBTXZjLFNBQVN1YyxlQUFlanZFLFNBQWYsR0FBMkJpdkUsVUFBM0IsR0FBd0N0YyxpQkFBT0csUUFBOUQ7O0FBRUEsTUFBTXQwRCxjQUFjMHdFLHNCQUFzQjdkLE1BQXRCLEVBQThCMGQsV0FBOUIsRUFBMkNDLFlBQTNDLENBQXBCOztBQUVBLFNBQU8sSUFBSUcsa0JBQUosQ0FBYTtBQUNsQjlkLFlBQVFBLE1BRFU7QUFFbEIrZCxZQUFRLHVCQUFVL2QsTUFBVixFQUFrQnFCLE1BQWxCLENBRlU7QUFHbEJsMEQsaUJBQWFBLFdBSEs7QUFJbEIwRixjQUFVOHFFO0FBSlEsR0FBYixDQUFQO0FBTUQ7O0FBR0Q7Ozs7Ozs7Ozs7O0FBWUE7Ozs7OztBQU1PLFNBQVNULFNBQVQsQ0FBbUIzckIsV0FBbkIsRUFBZ0M7QUFDckMsTUFBTWh2QyxVQUFVLGtEQUFvRCxFQUFwRTtBQUNBLG1CQUFPQSxPQUFQLEVBQWdCZ3ZDLGdCQUFnQjVpRCxTQUFoQixHQUNkNGlELFdBRGMsR0FDQSw0Q0FBOEMsRUFEOUQ7QUFFQSxNQUFJaHZDLFFBQVF5OUMsTUFBUixLQUFtQnJ4RCxTQUF2QixFQUFrQztBQUNoQzRULFlBQVF5OUMsTUFBUixHQUFpQixlQUFjLFdBQWQsRUFBMkJ0dUQsU0FBM0IsRUFBakI7QUFDRDtBQUNENlEsVUFBUXBWLFdBQVIsR0FBc0Iwd0Usc0JBQ3BCdDdELFFBQVF5OUMsTUFEWSxFQUNKejlDLFFBQVF6UCxPQURKLEVBQ2F5UCxRQUFRMVAsUUFEckIsQ0FBdEI7QUFFQSxTQUFPMFAsUUFBUXpQLE9BQWY7O0FBRUEsU0FBTyxJQUFJZ3JFLGtCQUFKLENBQWF2N0QsT0FBYixDQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7OztBQVNBLFNBQVNzN0QscUJBQVQsQ0FBK0I3ZCxNQUEvQixFQUF1QzBkLFdBQXZDLEVBQW9EQyxZQUFwRCxFQUFrRTtBQUNoRSxNQUFNN3FFLFVBQVU0cUUsZ0JBQWdCL3VFLFNBQWhCLEdBQ2QrdUUsV0FEYyxHQUNBTSx3QkFEaEI7O0FBR0EsTUFBTWppRSxTQUFTLHVCQUFVaWtELE1BQVYsQ0FBZjtBQUNBLE1BQU1sa0QsUUFBUSxzQkFBU2trRCxNQUFULENBQWQ7O0FBRUEsTUFBTW50RCxXQUFXLGtCQUFPOHFFLGlCQUFpQmh2RSxTQUFqQixHQUN0Qmd2RSxZQURzQixHQUNQTSx5QkFEQSxDQUFqQjtBQUVBLE1BQU05cUUsZ0JBQWdCd1MsS0FBS2xHLEdBQUwsQ0FDcEIzRCxRQUFRakosU0FBUyxDQUFULENBRFksRUFDQ2tKLFNBQVNsSixTQUFTLENBQVQsQ0FEVixDQUF0Qjs7QUFHQSxNQUFNN0gsU0FBUzhILFVBQVUsQ0FBekI7QUFDQSxNQUFNM0YsY0FBYyxJQUFJdEMsS0FBSixDQUFVRyxNQUFWLENBQXBCO0FBQ0EsT0FBSyxJQUFJbXhCLElBQUksQ0FBYixFQUFnQkEsSUFBSW54QixNQUFwQixFQUE0QixFQUFFbXhCLENBQTlCLEVBQWlDO0FBQy9CaHZCLGdCQUFZZ3ZCLENBQVosSUFBaUJocEIsZ0JBQWdCd1MsS0FBS3VXLEdBQUwsQ0FBUyxDQUFULEVBQVlDLENBQVosQ0FBakM7QUFDRDtBQUNELFNBQU9odkIsV0FBUDtBQUNEOztBQUdEOzs7Ozs7Ozs7QUFTTyxTQUFTZ3dFLG1CQUFULENBQTZCdmxFLFVBQTdCLEVBQXlDOGxFLFdBQXpDLEVBQXNEQyxZQUF0RCxFQUFvRUMsVUFBcEUsRUFBZ0Y7QUFDckYsTUFBTTVkLFNBQVNvZCxxQkFBcUJ4bEUsVUFBckIsQ0FBZjtBQUNBLFNBQU9xbEUsZ0JBQWdCamQsTUFBaEIsRUFBd0IwZCxXQUF4QixFQUFxQ0MsWUFBckMsRUFBbURDLFVBQW5ELENBQVA7QUFDRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU1Isb0JBQVQsQ0FBOEJ4bEUsVUFBOUIsRUFBMEM7QUFDL0NBLGVBQWEsZUFBY0EsVUFBZCxDQUFiO0FBQ0EsTUFBSW9vRCxTQUFTcG9ELFdBQVdsRyxTQUFYLEVBQWI7QUFDQSxNQUFJLENBQUNzdUQsTUFBTCxFQUFhO0FBQ1gsUUFBTWtlLE9BQU8sTUFBTTVXLHNCQUFnQlksZ0JBQU1DLE9BQXRCLENBQU4sR0FBdUN2d0QsV0FBVzJ3RCxnQkFBWCxFQUFwRDtBQUNBdkksYUFBUyw0QkFBZSxDQUFDa2UsSUFBaEIsRUFBc0IsQ0FBQ0EsSUFBdkIsRUFBNkJBLElBQTdCLEVBQW1DQSxJQUFuQyxDQUFUO0FBQ0Q7QUFDRCxTQUFPbGUsTUFBUDtBQUNELEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pLRDs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7QUF2Q0E7OztBQWlEQSxJQUFNOGQsV0FBVyxTQUFYQSxRQUFXLENBQVN2N0QsT0FBVCxFQUFrQjs7QUFFakM7Ozs7QUFJQSxPQUFLdlAsT0FBTCxHQUFldVAsUUFBUXZQLE9BQVIsS0FBb0JyRSxTQUFwQixHQUFnQzRULFFBQVF2UCxPQUF4QyxHQUFrRCxDQUFqRTs7QUFFQTs7OztBQUlBLE9BQUttckUsWUFBTCxHQUFvQjU3RCxRQUFRcFYsV0FBNUI7QUFDQSx1QkFBTyxxQkFBUyxLQUFLZ3hFLFlBQWQsRUFBNEIsVUFBU3ZvRSxDQUFULEVBQVlnZixDQUFaLEVBQWU7QUFDaEQsV0FBT0EsSUFBSWhmLENBQVg7QUFDRCxHQUZNLEVBRUosSUFGSSxDQUFQLEVBRVUsRUFGVixFQWJpQyxDQWVsQjs7O0FBR2Y7QUFDQSxNQUFJd29FLG1CQUFKO0FBQ0EsTUFBSSxDQUFDNzdELFFBQVE4N0QsT0FBYixFQUFzQjtBQUNwQixTQUFLLElBQUkxekUsSUFBSSxDQUFSLEVBQVdDLEtBQUssS0FBS3V6RSxZQUFMLENBQWtCbnpFLE1BQWxCLEdBQTJCLENBQWhELEVBQW1ETCxJQUFJQyxFQUF2RCxFQUEyRCxFQUFFRCxDQUE3RCxFQUFnRTtBQUM5RCxVQUFJLENBQUN5ekUsVUFBTCxFQUFpQjtBQUNmQSxxQkFBYSxLQUFLRCxZQUFMLENBQWtCeHpFLENBQWxCLElBQXVCLEtBQUt3ekUsWUFBTCxDQUFrQnh6RSxJQUFJLENBQXRCLENBQXBDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBSSxLQUFLd3pFLFlBQUwsQ0FBa0J4ekUsQ0FBbEIsSUFBdUIsS0FBS3d6RSxZQUFMLENBQWtCeHpFLElBQUksQ0FBdEIsQ0FBdkIsS0FBb0R5ekUsVUFBeEQsRUFBb0U7QUFDbEVBLHVCQUFhenZFLFNBQWI7QUFDQTtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUdEOzs7O0FBSUEsT0FBSzJ2RSxXQUFMLEdBQW1CRixVQUFuQjs7QUFHQTs7OztBQUlBLE9BQUt0ckUsT0FBTCxHQUFlLEtBQUtxckUsWUFBTCxDQUFrQm56RSxNQUFsQixHQUEyQixDQUExQzs7QUFFQTs7OztBQUlBLE9BQUt1ekUsT0FBTCxHQUFlaDhELFFBQVF3N0QsTUFBUixLQUFtQnB2RSxTQUFuQixHQUErQjRULFFBQVF3N0QsTUFBdkMsR0FBZ0QsSUFBL0Q7O0FBRUE7Ozs7QUFJQSxPQUFLUyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsTUFBSWo4RCxRQUFRODdELE9BQVIsS0FBb0IxdkUsU0FBeEIsRUFBbUM7QUFDakMsU0FBSzZ2RSxRQUFMLEdBQWdCajhELFFBQVE4N0QsT0FBeEI7QUFDQSx5QkFBTyxLQUFLRyxRQUFMLENBQWN4ekUsTUFBZCxJQUF3QixLQUFLbXpFLFlBQUwsQ0FBa0JuekUsTUFBakQsRUFDRSxFQURGLEVBRmlDLENBRzFCO0FBQ1I7O0FBRUQsTUFBTWcxRCxTQUFTejlDLFFBQVF5OUMsTUFBdkI7O0FBRUEsTUFBSUEsV0FBV3J4RCxTQUFYLElBQ0EsQ0FBQyxLQUFLNHZFLE9BRE4sSUFDaUIsQ0FBQyxLQUFLQyxRQUQzQixFQUNxQztBQUNuQyxTQUFLRCxPQUFMLEdBQWUsd0JBQVd2ZSxNQUFYLENBQWY7QUFDRDs7QUFFRCx1QkFDRyxDQUFDLEtBQUt1ZSxPQUFOLElBQWlCLEtBQUtDLFFBQXZCLElBQXFDLEtBQUtELE9BQUwsSUFBZ0IsQ0FBQyxLQUFLQyxRQUQ3RCxFQUVFLEVBRkYsRUF2RWlDLENBeUUxQjs7QUFFUDs7OztBQUlBLE9BQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxNQUFJbDhELFFBQVFtOEQsU0FBUixLQUFzQi92RSxTQUExQixFQUFxQztBQUNuQyxTQUFLOHZFLFVBQUwsR0FBa0JsOEQsUUFBUW04RCxTQUExQjtBQUNBLHlCQUFPLEtBQUtELFVBQUwsQ0FBZ0J6ekUsTUFBaEIsSUFBMEIsS0FBS216RSxZQUFMLENBQWtCbnpFLE1BQW5ELEVBQ0UsRUFERixFQUZtQyxDQUc1QjtBQUNSOztBQUVEOzs7O0FBSUEsT0FBSzJ6RSxTQUFMLEdBQWlCcDhELFFBQVExUCxRQUFSLEtBQXFCbEUsU0FBckIsR0FDZjRULFFBQVExUCxRQURPLEdBRWYsQ0FBQyxLQUFLNHJFLFVBQU4sR0FBbUJSLHlCQUFuQixHQUF1QyxJQUZ6QztBQUdBLHVCQUNHLENBQUMsS0FBS1UsU0FBTixJQUFtQixLQUFLRixVQUF6QixJQUNHLEtBQUtFLFNBQUwsSUFBa0IsQ0FBQyxLQUFLRixVQUY3QixFQUdFLEVBSEYsRUE3RmlDLENBZ0cxQjs7QUFFUDs7OztBQUlBLE9BQUt0VSxPQUFMLEdBQWVuSyxXQUFXcnhELFNBQVgsR0FBdUJxeEQsTUFBdkIsR0FBZ0MsSUFBL0M7O0FBR0E7Ozs7QUFJQSxPQUFLNGUsZUFBTCxHQUF1QixJQUF2Qjs7QUFFQTs7OztBQUlBLE9BQUtDLFFBQUwsR0FBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFoQjs7QUFFQSxNQUFJdDhELFFBQVF1OEQsS0FBUixLQUFrQm53RSxTQUF0QixFQUFpQztBQUMvQixTQUFLaXdFLGVBQUwsR0FBdUJyOEQsUUFBUXU4RCxLQUFSLENBQWN6ekUsR0FBZCxDQUFrQixVQUFTdUcsSUFBVCxFQUFldXFCLENBQWYsRUFBa0I7QUFDekQsVUFBTTA2QixZQUFZLElBQUlMLG1CQUFKLENBQ2hCN3dDLEtBQUtuRyxHQUFMLENBQVMsQ0FBVCxFQUFZNU4sS0FBSyxDQUFMLENBQVosQ0FEZ0IsRUFDTStULEtBQUtsRyxHQUFMLENBQVM3TixLQUFLLENBQUwsSUFBVSxDQUFuQixFQUFzQixDQUFDLENBQXZCLENBRE4sRUFFaEIrVCxLQUFLbkcsR0FBTCxDQUFTLENBQVQsRUFBWTVOLEtBQUssQ0FBTCxDQUFaLENBRmdCLEVBRU0rVCxLQUFLbEcsR0FBTCxDQUFTN04sS0FBSyxDQUFMLElBQVUsQ0FBbkIsRUFBc0IsQ0FBQyxDQUF2QixDQUZOLENBQWxCO0FBR0EsYUFBT2lsRCxTQUFQO0FBQ0QsS0FMc0IsRUFLcEIsSUFMb0IsQ0FBdkI7QUFNRCxHQVBELE1BT08sSUFBSW1KLE1BQUosRUFBWTtBQUNqQixTQUFLK2Usb0JBQUwsQ0FBMEIvZSxNQUExQjtBQUNEO0FBRUYsQ0FoSUQ7O0FBbUlBOzs7O0FBSUEsSUFBTWdmLGVBQWUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBckI7O0FBR0E7Ozs7Ozs7O0FBUUFsQixTQUFTejBELFNBQVQsQ0FBbUI0MUQsZ0JBQW5CLEdBQXNDLFVBQVNqZixNQUFULEVBQWlCaHdELElBQWpCLEVBQXVCZ2dCLFFBQXZCLEVBQWlDO0FBQ3JFLE1BQU02bUMsWUFBWSxLQUFLd2EseUJBQUwsQ0FBK0JyUixNQUEvQixFQUF1Q2h3RCxJQUF2QyxDQUFsQjtBQUNBLE9BQUssSUFBSXJGLElBQUlrc0QsVUFBVUosSUFBbEIsRUFBd0I3ckQsS0FBS2lzRCxVQUFVSCxJQUE1QyxFQUFrRC9yRCxLQUFLQyxFQUF2RCxFQUEyRCxFQUFFRCxDQUE3RCxFQUFnRTtBQUM5RCxTQUFLLElBQUkrYyxJQUFJbXZDLFVBQVVGLElBQWxCLEVBQXdCMmtCLEtBQUt6a0IsVUFBVUQsSUFBNUMsRUFBa0RsdkMsS0FBSzR6RCxFQUF2RCxFQUEyRCxFQUFFNXpELENBQTdELEVBQWdFO0FBQzlEc0ksZUFBUyxDQUFDaGdCLElBQUQsRUFBT3JGLENBQVAsRUFBVStjLENBQVYsQ0FBVDtBQUNEO0FBQ0Y7QUFDRixDQVBEOztBQVVBOzs7Ozs7Ozs7QUFTQW8yRCxTQUFTejBELFNBQVQsQ0FBbUI2MUQsK0JBQW5CLEdBQXFELFVBQVM3dEIsU0FBVCxFQUFvQnJoQyxRQUFwQixFQUE4QnFyQyxRQUE5QixFQUF3QzhqQixhQUF4QyxFQUF1RC9lLFVBQXZELEVBQW1FO0FBQ3RILE1BQUl2SixrQkFBSjtBQUFBLE1BQWVodEMsVUFBZjtBQUFBLE1BQWtCZ1EsVUFBbEI7QUFDQSxNQUFJdWxELGtCQUFrQixJQUF0QjtBQUNBLE1BQUlqakQsSUFBSWsxQixVQUFVLENBQVYsSUFBZSxDQUF2QjtBQUNBLE1BQUksS0FBS2l0QixXQUFMLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCejBELFFBQUl3bkMsVUFBVSxDQUFWLENBQUo7QUFDQXgzQixRQUFJdzNCLFVBQVUsQ0FBVixDQUFKO0FBQ0QsR0FIRCxNQUdPO0FBQ0wrdEIsc0JBQWtCLEtBQUtycUUsa0JBQUwsQ0FBd0JzOEMsU0FBeEIsRUFBbUMrTyxVQUFuQyxDQUFsQjtBQUNEO0FBQ0QsU0FBT2prQyxLQUFLLEtBQUtucEIsT0FBakIsRUFBMEI7QUFDeEIsUUFBSSxLQUFLc3JFLFdBQUwsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUJ6MEQsVUFBSWxFLEtBQUsvRixLQUFMLENBQVdpSyxJQUFJLENBQWYsQ0FBSjtBQUNBZ1EsVUFBSWxVLEtBQUsvRixLQUFMLENBQVdpYSxJQUFJLENBQWYsQ0FBSjtBQUNBZzlCLGtCQUFZLCtCQUF3Qmh0QyxDQUF4QixFQUEyQkEsQ0FBM0IsRUFBOEJnUSxDQUE5QixFQUFpQ0EsQ0FBakMsRUFBb0NzbEQsYUFBcEMsQ0FBWjtBQUNELEtBSkQsTUFJTztBQUNMdG9CLGtCQUFZLEtBQUt3YSx5QkFBTCxDQUErQitOLGVBQS9CLEVBQWdEampELENBQWhELEVBQW1EZ2pELGFBQW5ELENBQVo7QUFDRDtBQUNELFFBQUludkQsU0FBUzFHLElBQVQsQ0FBYyt4QyxRQUFkLEVBQXdCbC9CLENBQXhCLEVBQTJCMDZCLFNBQTNCLENBQUosRUFBMkM7QUFDekMsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFFMTZCLENBQUY7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNELENBeEJEOztBQTJCQTs7OztBQUlBMmhELFNBQVN6MEQsU0FBVCxDQUFtQjNYLFNBQW5CLEdBQStCLFlBQVc7QUFDeEMsU0FBTyxLQUFLeTRELE9BQVo7QUFDRCxDQUZEOztBQUtBOzs7OztBQUtBMlQsU0FBU3owRCxTQUFULENBQW1CN1UsVUFBbkIsR0FBZ0MsWUFBVztBQUN6QyxTQUFPLEtBQUsxQixPQUFaO0FBQ0QsQ0FGRDs7QUFLQTs7Ozs7QUFLQWdyRSxTQUFTejBELFNBQVQsQ0FBbUJqVyxVQUFuQixHQUFnQyxZQUFXO0FBQ3pDLFNBQU8sS0FBS0osT0FBWjtBQUNELENBRkQ7O0FBS0E7Ozs7OztBQU1BOHFFLFNBQVN6MEQsU0FBVCxDQUFtQmcyRCxTQUFuQixHQUErQixVQUFTbGpELENBQVQsRUFBWTtBQUN6QyxNQUFJLEtBQUtvaUQsT0FBVCxFQUFrQjtBQUNoQixXQUFPLEtBQUtBLE9BQVo7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPLEtBQUtDLFFBQUwsQ0FBY3JpRCxDQUFkLENBQVA7QUFDRDtBQUNGLENBTkQ7O0FBU0E7Ozs7OztBQU1BMmhELFNBQVN6MEQsU0FBVCxDQUFtQmhXLGFBQW5CLEdBQW1DLFVBQVM4b0IsQ0FBVCxFQUFZO0FBQzdDLFNBQU8sS0FBS2dpRCxZQUFMLENBQWtCaGlELENBQWxCLENBQVA7QUFDRCxDQUZEOztBQUtBOzs7OztBQUtBMmhELFNBQVN6MEQsU0FBVCxDQUFtQjJzRCxjQUFuQixHQUFvQyxZQUFXO0FBQzdDLFNBQU8sS0FBS21JLFlBQVo7QUFDRCxDQUZEOztBQUtBOzs7Ozs7QUFNQUwsU0FBU3owRCxTQUFULENBQW1CaTJELDBCQUFuQixHQUFnRCxVQUFTanVCLFNBQVQsRUFBb0I4dEIsYUFBcEIsRUFBbUMvZSxVQUFuQyxFQUErQztBQUM3RixNQUFJL08sVUFBVSxDQUFWLElBQWUsS0FBS3YrQyxPQUF4QixFQUFpQztBQUMvQixRQUFJLEtBQUt3ckUsV0FBTCxLQUFxQixDQUF6QixFQUE0QjtBQUMxQixVQUFNN25CLE9BQU9wRixVQUFVLENBQVYsSUFBZSxDQUE1QjtBQUNBLFVBQU1zRixPQUFPdEYsVUFBVSxDQUFWLElBQWUsQ0FBNUI7QUFDQSxhQUFPLCtCQUF3Qm9GLElBQXhCLEVBQThCQSxPQUFPLENBQXJDLEVBQXdDRSxJQUF4QyxFQUE4Q0EsT0FBTyxDQUFyRCxFQUF3RHdvQixhQUF4RCxDQUFQO0FBQ0Q7QUFDRCxRQUFNQyxrQkFBa0IsS0FBS3JxRSxrQkFBTCxDQUF3QnM4QyxTQUF4QixFQUFtQytPLFVBQW5DLENBQXhCO0FBQ0EsV0FBTyxLQUFLaVIseUJBQUwsQ0FDTCtOLGVBREssRUFDWS90QixVQUFVLENBQVYsSUFBZSxDQUQzQixFQUM4Qjh0QixhQUQ5QixDQUFQO0FBRUQ7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVpEOztBQWVBOzs7Ozs7O0FBT0FyQixTQUFTejBELFNBQVQsQ0FBbUJrMkQsa0JBQW5CLEdBQXdDLFVBQVNwakQsQ0FBVCxFQUFZMDZCLFNBQVosRUFBdUJ1SixVQUF2QixFQUFtQztBQUN6RSxNQUFNMmQsU0FBUyxLQUFLc0IsU0FBTCxDQUFlbGpELENBQWYsQ0FBZjtBQUNBLE1BQU13bEMsYUFBYSxLQUFLdHVELGFBQUwsQ0FBbUI4b0IsQ0FBbkIsQ0FBbkI7QUFDQSxNQUFNdHBCLFdBQVcsa0JBQU8sS0FBSzYrRCxXQUFMLENBQWlCdjFDLENBQWpCLENBQVAsRUFBNEIsS0FBSzBpRCxRQUFqQyxDQUFqQjtBQUNBLE1BQU1wb0IsT0FBT3NuQixPQUFPLENBQVAsSUFBWWxuQixVQUFVSixJQUFWLEdBQWlCNWpELFNBQVMsQ0FBVCxDQUFqQixHQUErQjh1RCxVQUF4RDtBQUNBLE1BQU1qTCxPQUFPcW5CLE9BQU8sQ0FBUCxJQUFZLENBQUNsbkIsVUFBVUgsSUFBVixHQUFpQixDQUFsQixJQUF1QjdqRCxTQUFTLENBQVQsQ0FBdkIsR0FBcUM4dUQsVUFBOUQ7QUFDQSxNQUFNaEwsT0FBT29uQixPQUFPLENBQVAsSUFBWWxuQixVQUFVRixJQUFWLEdBQWlCOWpELFNBQVMsQ0FBVCxDQUFqQixHQUErQjh1RCxVQUF4RDtBQUNBLE1BQU0vSyxPQUFPbW5CLE9BQU8sQ0FBUCxJQUFZLENBQUNsbkIsVUFBVUQsSUFBVixHQUFpQixDQUFsQixJQUF1Qi9qRCxTQUFTLENBQVQsQ0FBdkIsR0FBcUM4dUQsVUFBOUQ7QUFDQSxTQUFPLDRCQUFlbEwsSUFBZixFQUFxQkUsSUFBckIsRUFBMkJELElBQTNCLEVBQWlDRSxJQUFqQyxFQUF1Q3dKLFVBQXZDLENBQVA7QUFDRCxDQVREOztBQVlBOzs7Ozs7O0FBT0EwZCxTQUFTejBELFNBQVQsQ0FBbUJnb0QseUJBQW5CLEdBQStDLFVBQVNyUixNQUFULEVBQWlCN2pDLENBQWpCLEVBQW9CZ2pELGFBQXBCLEVBQW1DO0FBQ2hGLE1BQU05dEIsWUFBWTJ0QixZQUFsQjtBQUNBLE9BQUtRLHNCQUFMLENBQTRCeGYsT0FBTyxDQUFQLENBQTVCLEVBQXVDQSxPQUFPLENBQVAsQ0FBdkMsRUFBa0Q3akMsQ0FBbEQsRUFBcUQsS0FBckQsRUFBNERrMUIsU0FBNUQ7QUFDQSxNQUFNb0YsT0FBT3BGLFVBQVUsQ0FBVixDQUFiO0FBQ0EsTUFBTXNGLE9BQU90RixVQUFVLENBQVYsQ0FBYjtBQUNBLE9BQUttdUIsc0JBQUwsQ0FBNEJ4ZixPQUFPLENBQVAsQ0FBNUIsRUFBdUNBLE9BQU8sQ0FBUCxDQUF2QyxFQUFrRDdqQyxDQUFsRCxFQUFxRCxJQUFyRCxFQUEyRGsxQixTQUEzRDtBQUNBLFNBQU8sK0JBQXdCb0YsSUFBeEIsRUFBOEJwRixVQUFVLENBQVYsQ0FBOUIsRUFBNENzRixJQUE1QyxFQUFrRHRGLFVBQVUsQ0FBVixDQUFsRCxFQUFnRTh0QixhQUFoRSxDQUFQO0FBQ0QsQ0FQRDs7QUFVQTs7OztBQUlBckIsU0FBU3owRCxTQUFULENBQW1CZzBELGtCQUFuQixHQUF3QyxVQUFTaHNCLFNBQVQsRUFBb0I7QUFDMUQsTUFBTTBzQixTQUFTLEtBQUtzQixTQUFMLENBQWVodUIsVUFBVSxDQUFWLENBQWYsQ0FBZjtBQUNBLE1BQU1zUSxhQUFhLEtBQUt0dUQsYUFBTCxDQUFtQmcrQyxVQUFVLENBQVYsQ0FBbkIsQ0FBbkI7QUFDQSxNQUFNeCtDLFdBQVcsa0JBQU8sS0FBSzYrRCxXQUFMLENBQWlCcmdCLFVBQVUsQ0FBVixDQUFqQixDQUFQLEVBQXVDLEtBQUt3dEIsUUFBNUMsQ0FBakI7QUFDQSxTQUFPLENBQ0xkLE9BQU8sQ0FBUCxJQUFZLENBQUMxc0IsVUFBVSxDQUFWLElBQWUsR0FBaEIsSUFBdUJ4K0MsU0FBUyxDQUFULENBQXZCLEdBQXFDOHVELFVBRDVDLEVBRUxvYyxPQUFPLENBQVAsSUFBWSxDQUFDMXNCLFVBQVUsQ0FBVixJQUFlLEdBQWhCLElBQXVCeCtDLFNBQVMsQ0FBVCxDQUF2QixHQUFxQzh1RCxVQUY1QyxDQUFQO0FBSUQsQ0FSRDs7QUFXQTs7Ozs7Ozs7QUFRQW1jLFNBQVN6MEQsU0FBVCxDQUFtQnRVLGtCQUFuQixHQUF3QyxVQUFTczhDLFNBQVQsRUFBb0IrTyxVQUFwQixFQUFnQztBQUN0RSxNQUFNMmQsU0FBUyxLQUFLc0IsU0FBTCxDQUFlaHVCLFVBQVUsQ0FBVixDQUFmLENBQWY7QUFDQSxNQUFNc1EsYUFBYSxLQUFLdHVELGFBQUwsQ0FBbUJnK0MsVUFBVSxDQUFWLENBQW5CLENBQW5CO0FBQ0EsTUFBTXgrQyxXQUFXLGtCQUFPLEtBQUs2K0QsV0FBTCxDQUFpQnJnQixVQUFVLENBQVYsQ0FBakIsQ0FBUCxFQUF1QyxLQUFLd3RCLFFBQTVDLENBQWpCO0FBQ0EsTUFBTXBvQixPQUFPc25CLE9BQU8sQ0FBUCxJQUFZMXNCLFVBQVUsQ0FBVixJQUFleCtDLFNBQVMsQ0FBVCxDQUFmLEdBQTZCOHVELFVBQXREO0FBQ0EsTUFBTWhMLE9BQU9vbkIsT0FBTyxDQUFQLElBQVkxc0IsVUFBVSxDQUFWLElBQWV4K0MsU0FBUyxDQUFULENBQWYsR0FBNkI4dUQsVUFBdEQ7QUFDQSxNQUFNakwsT0FBT0QsT0FBTzVqRCxTQUFTLENBQVQsSUFBYzh1RCxVQUFsQztBQUNBLE1BQU0vSyxPQUFPRCxPQUFPOWpELFNBQVMsQ0FBVCxJQUFjOHVELFVBQWxDO0FBQ0EsU0FBTyw0QkFBZWxMLElBQWYsRUFBcUJFLElBQXJCLEVBQTJCRCxJQUEzQixFQUFpQ0UsSUFBakMsRUFBdUN3SixVQUF2QyxDQUFQO0FBQ0QsQ0FURDs7QUFZQTs7Ozs7Ozs7Ozs7QUFXQTBkLFNBQVN6MEQsU0FBVCxDQUFtQm8yRCxpQ0FBbkIsR0FBdUQsVUFBU2xmLFVBQVQsRUFBcUJvQixVQUFyQixFQUFpQ2diLGFBQWpDLEVBQWdEO0FBQ3JHLFNBQU8sS0FBSytDLCtCQUFMLENBQ0xuZixXQUFXLENBQVgsQ0FESyxFQUNVQSxXQUFXLENBQVgsQ0FEVixFQUN5Qm9CLFVBRHpCLEVBQ3FDLEtBRHJDLEVBQzRDZ2IsYUFENUMsQ0FBUDtBQUVELENBSEQ7O0FBTUE7Ozs7Ozs7Ozs7Ozs7QUFhQW1CLFNBQVN6MEQsU0FBVCxDQUFtQnEyRCwrQkFBbkIsR0FBcUQsVUFDbkQ3MUQsQ0FEbUQsRUFDaERnUSxDQURnRCxFQUM3QzhuQyxVQUQ2QyxFQUNqQ2dlLHlCQURpQyxFQUNOaEQsYUFETSxFQUNTO0FBQzVELE1BQU14Z0QsSUFBSSxLQUFLKzBDLGlCQUFMLENBQXVCdlAsVUFBdkIsQ0FBVjtBQUNBLE1BQU0zckMsUUFBUTJyQyxhQUFhLEtBQUt0dUQsYUFBTCxDQUFtQjhvQixDQUFuQixDQUEzQjtBQUNBLE1BQU00aEQsU0FBUyxLQUFLc0IsU0FBTCxDQUFlbGpELENBQWYsQ0FBZjtBQUNBLE1BQU10cEIsV0FBVyxrQkFBTyxLQUFLNitELFdBQUwsQ0FBaUJ2MUMsQ0FBakIsQ0FBUCxFQUE0QixLQUFLMGlELFFBQWpDLENBQWpCOztBQUVBLE1BQU1lLFVBQVVELDRCQUE0QixHQUE1QixHQUFrQyxDQUFsRDtBQUNBLE1BQU1FLFVBQVVGLDRCQUE0QixDQUE1QixHQUFnQyxHQUFoRDtBQUNBLE1BQU1HLGNBQWNuNkQsS0FBSy9GLEtBQUwsQ0FBVyxDQUFDaUssSUFBSWswRCxPQUFPLENBQVAsQ0FBTCxJQUFrQnBjLFVBQWxCLEdBQStCaWUsT0FBMUMsQ0FBcEI7QUFDQSxNQUFNRyxjQUFjcDZELEtBQUsvRixLQUFMLENBQVcsQ0FBQ2lhLElBQUlra0QsT0FBTyxDQUFQLENBQUwsSUFBa0JwYyxVQUFsQixHQUErQmtlLE9BQTFDLENBQXBCO0FBQ0EsTUFBSUcsYUFBYWhxRCxRQUFROHBELFdBQVIsR0FBc0JqdEUsU0FBUyxDQUFULENBQXZDO0FBQ0EsTUFBSW90RSxhQUFhanFELFFBQVErcEQsV0FBUixHQUFzQmx0RSxTQUFTLENBQVQsQ0FBdkM7O0FBRUEsTUFBSThzRSx5QkFBSixFQUErQjtBQUM3QkssaUJBQWFyNkQsS0FBS2hHLElBQUwsQ0FBVXFnRSxVQUFWLElBQXdCLENBQXJDO0FBQ0FDLGlCQUFhdDZELEtBQUtoRyxJQUFMLENBQVVzZ0UsVUFBVixJQUF3QixDQUFyQztBQUNELEdBSEQsTUFHTztBQUNMRCxpQkFBYXI2RCxLQUFLL0YsS0FBTCxDQUFXb2dFLFVBQVgsQ0FBYjtBQUNBQyxpQkFBYXQ2RCxLQUFLL0YsS0FBTCxDQUFXcWdFLFVBQVgsQ0FBYjtBQUNEOztBQUVELFNBQU8sK0JBQXdCOWpELENBQXhCLEVBQTJCNmpELFVBQTNCLEVBQXVDQyxVQUF2QyxFQUFtRHRELGFBQW5ELENBQVA7QUFDRCxDQXZCRDs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7OztBQWVBbUIsU0FBU3owRCxTQUFULENBQW1CbTJELHNCQUFuQixHQUE0QyxVQUFTMzFELENBQVQsRUFBWWdRLENBQVosRUFBZXNDLENBQWYsRUFBa0J3akQseUJBQWxCLEVBQTZDaEQsYUFBN0MsRUFBNEQ7QUFDdEcsTUFBTW9CLFNBQVMsS0FBS3NCLFNBQUwsQ0FBZWxqRCxDQUFmLENBQWY7QUFDQSxNQUFNd2xDLGFBQWEsS0FBS3R1RCxhQUFMLENBQW1COG9CLENBQW5CLENBQW5CO0FBQ0EsTUFBTXRwQixXQUFXLGtCQUFPLEtBQUs2K0QsV0FBTCxDQUFpQnYxQyxDQUFqQixDQUFQLEVBQTRCLEtBQUswaUQsUUFBakMsQ0FBakI7O0FBRUEsTUFBTWUsVUFBVUQsNEJBQTRCLEdBQTVCLEdBQWtDLENBQWxEO0FBQ0EsTUFBTUUsVUFBVUYsNEJBQTRCLENBQTVCLEdBQWdDLEdBQWhEO0FBQ0EsTUFBTUcsY0FBY242RCxLQUFLL0YsS0FBTCxDQUFXLENBQUNpSyxJQUFJazBELE9BQU8sQ0FBUCxDQUFMLElBQWtCcGMsVUFBbEIsR0FBK0JpZSxPQUExQyxDQUFwQjtBQUNBLE1BQU1HLGNBQWNwNkQsS0FBSy9GLEtBQUwsQ0FBVyxDQUFDaWEsSUFBSWtrRCxPQUFPLENBQVAsQ0FBTCxJQUFrQnBjLFVBQWxCLEdBQStCa2UsT0FBMUMsQ0FBcEI7QUFDQSxNQUFJRyxhQUFhRixjQUFjanRFLFNBQVMsQ0FBVCxDQUEvQjtBQUNBLE1BQUlvdEUsYUFBYUYsY0FBY2x0RSxTQUFTLENBQVQsQ0FBL0I7O0FBRUEsTUFBSThzRSx5QkFBSixFQUErQjtBQUM3QkssaUJBQWFyNkQsS0FBS2hHLElBQUwsQ0FBVXFnRSxVQUFWLElBQXdCLENBQXJDO0FBQ0FDLGlCQUFhdDZELEtBQUtoRyxJQUFMLENBQVVzZ0UsVUFBVixJQUF3QixDQUFyQztBQUNELEdBSEQsTUFHTztBQUNMRCxpQkFBYXI2RCxLQUFLL0YsS0FBTCxDQUFXb2dFLFVBQVgsQ0FBYjtBQUNBQyxpQkFBYXQ2RCxLQUFLL0YsS0FBTCxDQUFXcWdFLFVBQVgsQ0FBYjtBQUNEOztBQUVELFNBQU8sK0JBQXdCOWpELENBQXhCLEVBQTJCNmpELFVBQTNCLEVBQXVDQyxVQUF2QyxFQUFtRHRELGFBQW5ELENBQVA7QUFDRCxDQXJCRDs7QUF3QkE7Ozs7Ozs7O0FBUUFtQixTQUFTejBELFNBQVQsQ0FBbUJvMEQsd0JBQW5CLEdBQThDLFVBQVNsZCxVQUFULEVBQXFCcGtDLENBQXJCLEVBQXdCd2dELGFBQXhCLEVBQXVDO0FBQ25GLFNBQU8sS0FBSzZDLHNCQUFMLENBQ0xqZixXQUFXLENBQVgsQ0FESyxFQUNVQSxXQUFXLENBQVgsQ0FEVixFQUN5QnBrQyxDQUR6QixFQUM0QixLQUQ1QixFQUNtQ3dnRCxhQURuQyxDQUFQO0FBRUQsQ0FIRDs7QUFNQTs7OztBQUlBbUIsU0FBU3owRCxTQUFULENBQW1CNjJELHNCQUFuQixHQUE0QyxVQUFTN3VCLFNBQVQsRUFBb0I7QUFDOUQsU0FBTyxLQUFLOHNCLFlBQUwsQ0FBa0I5c0IsVUFBVSxDQUFWLENBQWxCLENBQVA7QUFDRCxDQUZEOztBQUtBOzs7Ozs7OztBQVFBeXNCLFNBQVN6MEQsU0FBVCxDQUFtQnFvRCxXQUFuQixHQUFpQyxVQUFTdjFDLENBQVQsRUFBWTtBQUMzQyxNQUFJLEtBQUt3aUQsU0FBVCxFQUFvQjtBQUNsQixXQUFPLEtBQUtBLFNBQVo7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPLEtBQUtGLFVBQUwsQ0FBZ0J0aUQsQ0FBaEIsQ0FBUDtBQUNEO0FBQ0YsQ0FORDs7QUFTQTs7OztBQUlBMmhELFNBQVN6MEQsU0FBVCxDQUFtQjB6RCxnQkFBbkIsR0FBc0MsVUFBUzVnRCxDQUFULEVBQVk7QUFDaEQsTUFBSSxDQUFDLEtBQUt5aUQsZUFBVixFQUEyQjtBQUN6QixXQUFPLElBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPLEtBQUtBLGVBQUwsQ0FBcUJ6aUQsQ0FBckIsQ0FBUDtBQUNEO0FBQ0YsQ0FORDs7QUFTQTs7Ozs7Ozs7QUFRQTJoRCxTQUFTejBELFNBQVQsQ0FBbUI2bkQsaUJBQW5CLEdBQXVDLFVBQVN2UCxVQUFULEVBQXFCd2UsYUFBckIsRUFBb0M7QUFDekUsTUFBTWhrRCxJQUFJLDhCQUFrQixLQUFLZ2lELFlBQXZCLEVBQXFDeGMsVUFBckMsRUFBaUR3ZSxpQkFBaUIsQ0FBbEUsQ0FBVjtBQUNBLFNBQU8saUJBQU1oa0QsQ0FBTixFQUFTLEtBQUtucEIsT0FBZCxFQUF1QixLQUFLRixPQUE1QixDQUFQO0FBQ0QsQ0FIRDs7QUFNQTs7OztBQUlBZ3JFLFNBQVN6MEQsU0FBVCxDQUFtQjAxRCxvQkFBbkIsR0FBMEMsVUFBUy9lLE1BQVQsRUFBaUI7QUFDekQsTUFBTWgxRCxTQUFTLEtBQUttekUsWUFBTCxDQUFrQm56RSxNQUFqQztBQUNBLE1BQU1vMUUsaUJBQWlCLElBQUl2MUUsS0FBSixDQUFVRyxNQUFWLENBQXZCO0FBQ0EsT0FBSyxJQUFJbXhCLElBQUksS0FBS25wQixPQUFsQixFQUEyQm1wQixJQUFJbnhCLE1BQS9CLEVBQXVDLEVBQUVteEIsQ0FBekMsRUFBNEM7QUFDMUNpa0QsbUJBQWVqa0QsQ0FBZixJQUFvQixLQUFLazFDLHlCQUFMLENBQStCclIsTUFBL0IsRUFBdUM3akMsQ0FBdkMsQ0FBcEI7QUFDRDtBQUNELE9BQUt5aUQsZUFBTCxHQUF1QndCLGNBQXZCO0FBQ0QsQ0FQRDtrQkFRZXRDLFE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNWpCZjs7OztBQUlBOzs7O0FBSU8sSUFBTUUsOENBQW1CLEVBQXpCOztBQUVQOzs7O0FBSU8sSUFBTUMsZ0RBQW9CLEdBQTFCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDRFNvQyxrQixHQUFBQSxrQjtRQXdDQUMsbUIsR0FBQUEsbUI7UUFjQUMsMEIsR0FBQUEsMEI7UUE4QkEzRyxtQixHQUFBQSxtQjtRQVNBNEcsUyxHQUFBQSxTOztBQXZHaEI7O0FBQ0E7O0FBQ0E7O0FBR0E7Ozs7O0FBS08sU0FBU0gsa0JBQVQsQ0FBNEJJLFFBQTVCLEVBQXNDN3RFLFFBQXRDLEVBQWdEO0FBQ3JELE1BQU04dEUsU0FBUyxRQUFmO0FBQ0EsTUFBTUMsU0FBUyxRQUFmO0FBQ0EsTUFBTUMsU0FBUyxRQUFmO0FBQ0EsTUFBTUMsYUFBYSxTQUFuQjtBQUNBO0FBQ0U7Ozs7OztBQU1BLGNBQVN4dkIsU0FBVCxFQUFvQitiLFVBQXBCLEVBQWdDeDFELFVBQWhDLEVBQTRDO0FBQzFDLFVBQUksQ0FBQ3k1QyxTQUFMLEVBQWdCO0FBQ2QsZUFBTzFpRCxTQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTzh4RSxTQUFTajFFLE9BQVQsQ0FBaUJrMUUsTUFBakIsRUFBeUJydkIsVUFBVSxDQUFWLEVBQWFoaEQsUUFBYixFQUF6QixFQUNKN0UsT0FESSxDQUNJbTFFLE1BREosRUFDWXR2QixVQUFVLENBQVYsRUFBYWhoRCxRQUFiLEVBRFosRUFFSjdFLE9BRkksQ0FFSW8xRSxNQUZKLEVBRVksWUFBVztBQUMxQixjQUFNL21ELElBQUksQ0FBQ3czQixVQUFVLENBQVYsQ0FBRCxHQUFnQixDQUExQjtBQUNBLGlCQUFPeDNCLEVBQUV4cEIsUUFBRixFQUFQO0FBQ0QsU0FMSSxFQU1KN0UsT0FOSSxDQU1JcTFFLFVBTkosRUFNZ0IsWUFBVztBQUM5QixjQUFNMWtELElBQUlrMUIsVUFBVSxDQUFWLENBQVY7QUFDQSxjQUFNcHhDLFFBQVFyTixTQUFTbXFFLGdCQUFULENBQTBCNWdELENBQTFCLENBQWQ7QUFDQSwrQkFBT2xjLEtBQVAsRUFBYyxFQUFkLEVBSDhCLENBR1g7QUFDbkIsY0FBTTRaLElBQUk1WixNQUFNKzJDLFNBQU4sS0FBb0IzRixVQUFVLENBQVYsQ0FBOUI7QUFDQSxpQkFBT3gzQixFQUFFeHBCLFFBQUYsRUFBUDtBQUNELFNBWkksQ0FBUDtBQWFEO0FBQ0Y7QUF6Qkg7QUEyQkQ7O0FBR0Q7Ozs7O0FBaERBOzs7QUFxRE8sU0FBU2l3RSxtQkFBVCxDQUE2QlEsU0FBN0IsRUFBd0NsdUUsUUFBeEMsRUFBa0Q7QUFDdkQsTUFBTWdYLE1BQU1rM0QsVUFBVTkxRSxNQUF0QjtBQUNBLE1BQU0rMUUsbUJBQW1CLElBQUlsMkUsS0FBSixDQUFVK2UsR0FBVixDQUF6QjtBQUNBLE9BQUssSUFBSWpmLElBQUksQ0FBYixFQUFnQkEsSUFBSWlmLEdBQXBCLEVBQXlCLEVBQUVqZixDQUEzQixFQUE4QjtBQUM1Qm8yRSxxQkFBaUJwMkUsQ0FBakIsSUFBc0IwMUUsbUJBQW1CUyxVQUFVbjJFLENBQVYsQ0FBbkIsRUFBaUNpSSxRQUFqQyxDQUF0QjtBQUNEO0FBQ0QsU0FBTzJ0RSwyQkFBMkJRLGdCQUEzQixDQUFQO0FBQ0Q7O0FBR0Q7Ozs7QUFJTyxTQUFTUiwwQkFBVCxDQUFvQ1EsZ0JBQXBDLEVBQXNEO0FBQzNELE1BQUlBLGlCQUFpQi8xRSxNQUFqQixLQUE0QixDQUFoQyxFQUFtQztBQUNqQyxXQUFPKzFFLGlCQUFpQixDQUFqQixDQUFQO0FBQ0Q7QUFDRDtBQUNFOzs7Ozs7QUFNQSxjQUFTMXZCLFNBQVQsRUFBb0IrYixVQUFwQixFQUFnQ3gxRCxVQUFoQyxFQUE0QztBQUMxQyxVQUFJLENBQUN5NUMsU0FBTCxFQUFnQjtBQUNkLGVBQU8xaUQsU0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLFlBQU1zZixJQUFJLHFCQUFjb2pDLFNBQWQsQ0FBVjtBQUNBLFlBQU1wdUMsUUFBUSxrQkFBT2dMLENBQVAsRUFBVTh5RCxpQkFBaUIvMUUsTUFBM0IsQ0FBZDtBQUNBLGVBQU8rMUUsaUJBQWlCOTlELEtBQWpCLEVBQXdCb3VDLFNBQXhCLEVBQW1DK2IsVUFBbkMsRUFBK0N4MUQsVUFBL0MsQ0FBUDtBQUNEO0FBQ0Y7QUFmSDtBQWlCRDs7QUFHRDs7Ozs7O0FBTU8sU0FBU2dpRSxtQkFBVCxDQUE2QnZvQixTQUE3QixFQUF3QytiLFVBQXhDLEVBQW9EeDFELFVBQXBELEVBQWdFO0FBQ3JFLFNBQU9qSixTQUFQO0FBQ0Q7O0FBR0Q7Ozs7QUFJTyxTQUFTNnhFLFNBQVQsQ0FBbUI3ekUsR0FBbkIsRUFBd0I7QUFDN0IsTUFBTWdILE9BQU8sRUFBYjtBQUNBLE1BQUkzRyxRQUFRLHNCQUFzQmlnQixJQUF0QixDQUEyQnRnQixHQUEzQixDQUFaO0FBQ0EsTUFBSUssS0FBSixFQUFXO0FBQ1Q7QUFDQSxRQUFNZzBFLGdCQUFnQmgwRSxNQUFNLENBQU4sRUFBU3VaLFVBQVQsQ0FBb0IsQ0FBcEIsQ0FBdEI7QUFDQSxRQUFNMDZELGVBQWVqMEUsTUFBTSxDQUFOLEVBQVN1WixVQUFULENBQW9CLENBQXBCLENBQXJCO0FBQ0EsUUFBSXUyRCxpQkFBSjtBQUNBLFNBQUtBLFdBQVdrRSxhQUFoQixFQUErQmxFLFlBQVltRSxZQUEzQyxFQUF5RCxFQUFFbkUsUUFBM0QsRUFBcUU7QUFDbkVucEUsV0FBS2hJLElBQUwsQ0FBVWdCLElBQUluQixPQUFKLENBQVl3QixNQUFNLENBQU4sQ0FBWixFQUFzQjZZLE9BQU9DLFlBQVAsQ0FBb0JnM0QsUUFBcEIsQ0FBdEIsQ0FBVjtBQUNEO0FBQ0QsV0FBT25wRSxJQUFQO0FBQ0Q7QUFDRDNHLFVBQVFBLFFBQVEsa0JBQWtCaWdCLElBQWxCLENBQXVCdGdCLEdBQXZCLENBQWhCO0FBQ0EsTUFBSUssS0FBSixFQUFXO0FBQ1Q7QUFDQSxRQUFNaWtCLE9BQU82QyxTQUFTOW1CLE1BQU0sQ0FBTixDQUFULEVBQW1CLEVBQW5CLENBQWI7QUFDQSxTQUFLLElBQUlyQyxJQUFJbXBCLFNBQVM5bUIsTUFBTSxDQUFOLENBQVQsRUFBbUIsRUFBbkIsQ0FBYixFQUFxQ3JDLEtBQUtzbUIsSUFBMUMsRUFBZ0R0bUIsR0FBaEQsRUFBcUQ7QUFDbkRnSixXQUFLaEksSUFBTCxDQUFVZ0IsSUFBSW5CLE9BQUosQ0FBWXdCLE1BQU0sQ0FBTixDQUFaLEVBQXNCckMsRUFBRTBGLFFBQUYsRUFBdEIsQ0FBVjtBQUNEO0FBQ0QsV0FBT3NELElBQVA7QUFDRDtBQUNEQSxPQUFLaEksSUFBTCxDQUFVZ0IsR0FBVjtBQUNBLFNBQU9nSCxJQUFQO0FBQ0QsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNpSmUwbEQsVSxHQUFBQSxVO0FBblJoQjs7OztBQUlBOzs7O0FBS0E7Ozs7QUFJTyxJQUFNNm5CLG9CQUFNLENBQVo7O0FBR1A7Ozs7QUFJTyxJQUFNQyxnQ0FBWSxNQUFsQjs7QUFHUDs7OztBQUlPLElBQU1DLGdEQUFvQixNQUExQjs7QUFHUDs7OztBQUlPLElBQU1DLDhDQUFtQixVQUF6Qjs7QUFHUDs7OztBQUlPLElBQU1DLGdDQUFZLE1BQWxCOztBQUdQOzs7O0FBSU8sSUFBTUMsMENBQWlCLE1BQXZCOztBQUdQOzs7O0FBSU8sSUFBTUMsb0RBQXNCLE1BQTVCOztBQUdQOzs7O0FBSU8sSUFBTUMsc0NBQWUsTUFBckI7O0FBR1A7Ozs7QUFJTyxJQUFNQyxzREFBdUIsTUFBN0I7O0FBR1A7Ozs7QUFJTyxJQUFNQyxvQ0FBYyxNQUFwQjs7QUFHUDs7OztBQUlPLElBQU1DLG9DQUFjLE1BQXBCOztBQUdQOzs7O0FBSU8sSUFBTUMsc0NBQWUsTUFBckI7O0FBR1A7Ozs7QUFJTyxJQUFNQyxnQ0FBWSxNQUFsQjs7QUFHUDs7OztBQUlPLElBQU1DLHdCQUFRLE1BQWQ7O0FBR1A7Ozs7QUFJTyxJQUFNQyxzQ0FBZSxNQUFyQjs7QUFHUDs7OztBQUlPLElBQU1DLGtDQUFhLE1BQW5COztBQUdQOzs7O0FBSU8sSUFBTUMsc0NBQWUsTUFBckI7O0FBR1A7Ozs7QUFJTyxJQUFNQyx3Q0FBZ0IsTUFBdEI7O0FBR1A7Ozs7QUFJTyxJQUFNQywwQ0FBaUIsTUFBdkI7O0FBR1A7Ozs7QUFJTyxJQUFNQyxzQ0FBZSxNQUFyQjs7QUFHUDs7OztBQUlPLElBQU1DLHdCQUFRLE1BQWQ7O0FBR1A7Ozs7QUFJTyxJQUFNQyxzQkFBTyxNQUFiOztBQUdQOzs7O0FBSU8sSUFBTUMsNENBQWtCLE1BQXhCOztBQUdQOzs7O0FBSU8sSUFBTUMsd0NBQWdCLE1BQXRCOztBQUdQOzs7O0FBSU8sSUFBTUMsb0NBQWMsTUFBcEI7O0FBR1A7Ozs7QUFJTyxJQUFNQywwQkFBUyxNQUFmOztBQUdQOzs7O0FBSU8sSUFBTUMsa0RBQXFCLE1BQTNCOztBQUdQOzs7O0FBSU8sSUFBTUMsa0RBQXFCLE1BQTNCOztBQUdQOzs7O0FBSU8sSUFBTUMsMENBQWlCLE1BQXZCOztBQUdQOzs7O0FBSU8sSUFBTUMsMENBQWlCLE1BQXZCOztBQUdQOzs7O0FBSU8sSUFBTUMsa0NBQWEsTUFBbkI7O0FBR1A7Ozs7QUFJTyxJQUFNQyw4QkFBVyxNQUFqQjs7QUFHUDs7OztBQUlPLElBQU1DLHdDQUFnQixNQUF0Qjs7QUFHUDs7OztBQUlPLElBQU1DLDBDQUFpQixNQUF2Qjs7QUFHUDs7OztBQUlPLElBQU1DLG9DQUFjLE1BQXBCOztBQUdQOzs7QUFJQTs7OztBQUlBLElBQU1DLGNBQWMsQ0FDbEIsb0JBRGtCLEVBRWxCLE9BRmtCLEVBR2xCLFdBSGtCLEVBSWxCLFdBSmtCLENBQXBCOztBQVFBOzs7OztBQUtPLFNBQVNocUIsVUFBVCxDQUFvQmhHLE1BQXBCLEVBQTRCaXdCLGNBQTVCLEVBQTRDO0FBQ2pELE1BQU0xNEUsS0FBS3k0RSxZQUFZcjRFLE1BQXZCO0FBQ0EsT0FBSyxJQUFJTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlDLEVBQXBCLEVBQXdCLEVBQUVELENBQTFCLEVBQTZCO0FBQzNCLFFBQUk7QUFDRixVQUFNeXNCLFVBQVVpOEIsT0FBT2dHLFVBQVAsQ0FBa0JncUIsWUFBWTE0RSxDQUFaLENBQWxCLEVBQWtDMjRFLGNBQWxDLENBQWhCO0FBQ0EsVUFBSWxzRCxPQUFKLEVBQWE7QUFDWCxlQUFPLHNDQUF1Q0E7QUFBOUM7QUFDRDtBQUNGLEtBTEQsQ0FLRSxPQUFPN25CLENBQVAsRUFBVTtBQUNWO0FBQ0Q7QUFDRjtBQUNELFNBQU8sSUFBUDtBQUNELEM7Ozs7Ozs7Ozs7Ozs7O0FDaFNEO0FBQ0EsQ0FBQyxZQUFXO0FBQ1YsTUFBSW5FLFFBQUo7O0FBRUFpWixTQUFPQyxPQUFQLEdBQWlCO0FBQ2ZpL0QsVUFBTSxrQkFEUztBQUVmNXNFLFVBQU0sUUFGUztBQUdmNnNFLFdBQU8sY0FIUTtBQUlmQyxVQUFNLGtCQUpTO0FBS2Z0NEUsY0FBVSxvQkFBVztBQUNuQixhQUFPQyxRQUFQO0FBQ0QsS0FQYztBQVFmczRFLGFBQVMsaUJBQVMvc0UsSUFBVCxFQUFlO0FBQ3RCLGFBQU8sdUNBQXdDQSxLQUFLbkwsT0FBTCxDQUFhLE1BQWIsRUFBcUIsR0FBckIsQ0FBL0M7QUFDRCxLQVZjO0FBV2ZtNEUsbUJBQWUsdUJBQVNodEUsSUFBVCxFQUFlO0FBQzVCLGFBQU9BLElBQVA7QUFDRDtBQWJjLEdBQWpCOztBQWdCQXZMLGFBQVcsQ0FBQyxTQUFELEVBQVksTUFBWixFQUFvQixlQUFwQixFQUFxQyxVQUFyQyxFQUFpRCxNQUFqRCxFQUF5RCxPQUF6RCxFQUFrRSxTQUFsRSxFQUE2RSxZQUE3RSxFQUEyRixpQkFBM0YsRUFBOEcsU0FBOUcsRUFBeUgsUUFBekgsRUFBbUksU0FBbkksRUFBOEksTUFBOUksRUFBc0osVUFBdEosRUFBa0ssYUFBbEssRUFBaUwsZUFBakwsRUFBa00sa0JBQWxNLEVBQXNOLFlBQXROLEVBQW9PLGVBQXBPLEVBQXFQLE9BQXJQLEVBQThQLE9BQTlQLEVBQXVRLGVBQXZRLEVBQXdSLE9BQXhSLEVBQWlTLFNBQWpTLEVBQTRTLGlCQUE1UyxFQUErVCxRQUEvVCxFQUF5VSxVQUF6VSxFQUFxVixrQkFBclYsRUFBeVcsYUFBelcsRUFBd1gsVUFBeFgsRUFBb1ksVUFBcFksRUFBZ1osV0FBaFosRUFBNlosV0FBN1osRUFBMGEsT0FBMWEsRUFBbWIsT0FBbmIsRUFBNGIsU0FBNWIsRUFBdWMsUUFBdmMsRUFBaWQsUUFBamQsRUFBMmQsUUFBM2QsRUFBcWUsMEJBQXJlLEVBQWlnQixlQUFqZ0IsRUFBa2hCLE9BQWxoQixFQUEyaEIsY0FBM2hCLEVBQTJpQixZQUEzaUIsRUFBeWpCLE9BQXpqQixFQUFra0IsUUFBbGtCLEVBQTRrQixTQUE1a0IsRUFBdWxCLGNBQXZsQixFQUF1bUIscUJBQXZtQixFQUE4bkIsZUFBOW5CLEVBQStvQixnQkFBL29CLEVBQWlxQixPQUFqcUIsRUFBMHFCLFVBQTFxQixFQUFzckIsUUFBdHJCLEVBQWdzQixVQUFoc0IsRUFBNHNCLE1BQTVzQixFQUFvdEIsTUFBcHRCLEVBQTR0QixNQUE1dEIsRUFBb3VCLE1BQXB1QixFQUE0dUIsT0FBNXVCLEVBQXF2QixTQUFydkIsRUFBZ3dCLE1BQWh3QixFQUF3d0IsWUFBeHdCLEVBQXN4QixRQUF0eEIsRUFBZ3lCLFdBQWh5QixFQUE2eUIsWUFBN3lCLEVBQTJ6QixTQUEzekIsRUFBczBCLGNBQXQwQixFQUFzMUIscUJBQXQxQixFQUE2MkIsY0FBNzJCLEVBQTYzQixtQkFBNzNCLEVBQWs1QixvQkFBbDVCLEVBQXc2QixZQUF4NkIsRUFBczdCLFdBQXQ3QixFQUFtOEIsU0FBbjhCLEVBQTg4QixPQUE5OEIsRUFBdTlCLFlBQXY5QixFQUFxK0IsU0FBcitCLEVBQWcvQixPQUFoL0IsRUFBeS9CLFVBQXovQixFQUFxZ0MsU0FBcmdDLEVBQWdoQyxXQUFoaEMsRUFBNmhDLFNBQTdoQyxFQUF3aUMsaUJBQXhpQyxFQUEyakMsT0FBM2pDLEVBQW9rQyxlQUFwa0MsRUFBcWxDLGFBQXJsQyxFQUFvbUMsT0FBcG1DLEVBQTZtQyxrQkFBN21DLEVBQWlvQyxTQUFqb0MsRUFBNG9DLFFBQTVvQyxFQUFzcEMsZUFBdHBDLEVBQXVxQyxPQUF2cUMsRUFBZ3JDLFFBQWhyQyxFQUEwckMsVUFBMXJDLEVBQXNzQyxZQUF0c0MsRUFBb3RDLGVBQXB0QyxFQUFxdUMsU0FBcnVDLEVBQWd2QyxZQUFodkMsRUFBOHZDLGdCQUE5dkMsRUFBZ3hDLGFBQWh4QyxFQUEreEMsTUFBL3hDLEVBQXV5QyxTQUF2eUMsRUFBa3pDLFlBQWx6QyxFQUFnMEMsZ0JBQWgwQyxFQUFrMUMsT0FBbDFDLEVBQTIxQyxpQkFBMzFDLEVBQTgyQyxjQUE5MkMsRUFBODNDLGlCQUE5M0MsRUFBaTVDLFlBQWo1QyxFQUErNUMsZ0JBQS81QyxFQUFpN0MsUUFBajdDLEVBQTI3QyxPQUEzN0MsRUFBbzhDLFFBQXA4QyxFQUE4OEMsV0FBOThDLEVBQTI5QyxhQUEzOUMsRUFBMCtDLGFBQTErQyxFQUF5L0MsVUFBei9DLEVBQXFnRCxPQUFyZ0QsRUFBOGdELE9BQTlnRCxFQUF1aEQsZ0JBQXZoRCxFQUF5aUQsbUJBQXppRCxFQUE4akQsWUFBOWpELEVBQTRrRCxXQUE1a0QsRUFBeWxELFFBQXpsRCxFQUFtbUQsUUFBbm1ELEVBQTZtRCxjQUE3bUQsRUFBNm5ELG9CQUE3bkQsRUFBbXBELGFBQW5wRCxFQUFrcUQsWUFBbHFELEVBQWdyRCxRQUFockQsRUFBMHJELG9CQUExckQsRUFBZ3RELFdBQWh0RCxFQUE2dEQsZ0JBQTd0RCxFQUErdUQsUUFBL3VELEVBQXl2RCxtQkFBenZELEVBQTh3RCxjQUE5d0QsRUFBOHhELE9BQTl4RCxFQUF1eUQsUUFBdnlELEVBQWl6RCxPQUFqekQsRUFBMHpELFVBQTF6RCxFQUFzMEQsUUFBdDBELEVBQWcxRCxtQkFBaDFELEVBQXEyRCxnQkFBcjJELEVBQXUzRCxNQUF2M0QsRUFBKzNELGNBQS8zRCxFQUErNEQsVUFBLzRELEVBQTI1RCxPQUEzNUQsRUFBbzZELFdBQXA2RCxFQUFpN0QsYUFBajdELEVBQWc4RCxhQUFoOEQsRUFBKzhELFdBQS84RCxFQUE0OUQsU0FBNTlELEVBQXUrRCxjQUF2K0QsRUFBdS9ELGFBQXYvRCxFQUFzZ0UsUUFBdGdFLEVBQWdoRSxPQUFoaEUsRUFBeWhFLFFBQXpoRSxFQUFtaUUsV0FBbmlFLEVBQWdqRSxTQUFoakUsRUFBMmpFLFVBQTNqRSxFQUF1a0UsdUJBQXZrRSxFQUFnbUUsY0FBaG1FLEVBQWduRSxXQUFobkUsRUFBNm5FLGFBQTduRSxFQUE0b0UsY0FBNW9FLEVBQTRwRSxlQUE1cEUsRUFBNnFFLFNBQTdxRSxFQUF3ckUsUUFBeHJFLEVBQWtzRSxRQUFsc0UsRUFBNHNFLGFBQTVzRSxFQUEydEUsUUFBM3RFLEVBQXF1RSxnQkFBcnVFLEVBQXV2RSxTQUF2dkUsRUFBa3dFLHNCQUFsd0UsRUFBMHhFLFVBQTF4RSxFQUFzeUUsT0FBdHlFLEVBQSt5RSxRQUEveUUsRUFBeXpFLG1CQUF6ekUsRUFBODBFLGdCQUE5MEUsRUFBZzJFLGVBQWgyRSxFQUFpM0UsVUFBajNFLEVBQTYzRSxZQUE3M0UsRUFBMjRFLFVBQTM0RSxFQUF1NUUsZUFBdjVFLEVBQXc2RSxXQUF4NkUsRUFBcTdFLGNBQXI3RSxFQUFxOEUsUUFBcjhFLEVBQSs4RSxhQUEvOEUsRUFBODlFLFlBQTk5RSxFQUE0K0UsT0FBNStFLEVBQXEvRSxPQUFyL0UsRUFBOC9FLGFBQTkvRSxFQUE2Z0YsWUFBN2dGLEVBQTJoRixpQkFBM2hGLEVBQThpRixhQUE5aUYsRUFBNmpGLFdBQTdqRixFQUEwa0YsV0FBMWtGLEVBQXVsRixhQUF2bEYsRUFBc21GLFlBQXRtRixFQUFvbkYsT0FBcG5GLEVBQTZuRixXQUE3bkYsRUFBMG9GLE9BQTFvRixFQUFtcEYsVUFBbnBGLEVBQStwRixhQUEvcEYsRUFBOHFGLE9BQTlxRixFQUF1ckYsa0JBQXZyRixFQUEyc0YsYUFBM3NGLEVBQTB0RixjQUExdEYsRUFBMHVGLFlBQTF1RixFQUF3dkYsV0FBeHZGLEVBQXF3RixXQUFyd0YsRUFBa3hGLFdBQWx4RixFQUEreEYsU0FBL3hGLEVBQTB5RixpQkFBMXlGLEVBQTZ6RixPQUE3ekYsRUFBczBGLEtBQXQwRixFQUE2MEYsT0FBNzBGLEVBQXMxRixlQUF0MUYsRUFBdTJGLGNBQXYyRixFQUF1M0YsV0FBdjNGLEVBQW80RixrQkFBcDRGLEVBQXc1RixZQUF4NUYsRUFBczZGLFVBQXQ2RixFQUFrN0YsV0FBbDdGLEVBQSs3RixVQUEvN0YsRUFBMjhGLFFBQTM4RixFQUFxOUYsUUFBcjlGLEVBQSs5RixPQUEvOUYsRUFBdytGLGNBQXgrRixFQUF3L0YsV0FBeC9GLEVBQXFnRyxXQUFyZ0csRUFBa2hHLFlBQWxoRyxFQUFnaUcsV0FBaGlHLEVBQTZpRyxVQUE3aUcsRUFBeWpHLFNBQXpqRyxFQUFva0csWUFBcGtHLEVBQWtsRyxrQkFBbGxHLEVBQXNtRyxPQUF0bUcsRUFBK21HLGNBQS9tRyxFQUErbkcsY0FBL25HLEVBQStvRyxzQkFBL29HLEVBQXVxRyxhQUF2cUcsRUFBc3JHLFVBQXRyRyxFQUFrc0csUUFBbHNHLEVBQTRzRyxTQUE1c0csRUFBdXRHLFNBQXZ0RyxFQUFrdUcsV0FBbHVHLEVBQSt1RyxXQUEvdUcsRUFBNHZHLGlCQUE1dkcsRUFBK3dHLFVBQS93RyxFQUEyeEcsUUFBM3hHLEVBQXF5RyxVQUFyeUcsRUFBaXpHLFNBQWp6RyxFQUE0ekcsZUFBNXpHLEVBQTYwRyxvQkFBNzBHLEVBQW0yRyxLQUFuMkcsRUFBMDJHLFNBQTEyRyxFQUFxM0csY0FBcjNHLEVBQXE0RyxjQUFyNEcsRUFBcTVHLFFBQXI1RyxFQUErNUcsZUFBLzVHLEVBQWc3RyxnQkFBaDdHLEVBQWs4RyxlQUFsOEcsRUFBbTlHLFFBQW45RyxFQUE2OUcsbUJBQTc5RyxFQUFrL0csWUFBbC9HLEVBQWdnSCxZQUFoZ0gsRUFBOGdILFVBQTlnSCxFQUEwaEgsdUJBQTFoSCxFQUFtakgsVUFBbmpILEVBQStqSCxhQUEvakgsRUFBOGtILGNBQTlrSCxFQUE4bEgsYUFBOWxILEVBQTZtSCxRQUE3bUgsRUFBdW5ILFFBQXZuSCxFQUFpb0gsT0FBam9ILEVBQTBvSCxVQUExb0gsRUFBc3BILFFBQXRwSCxFQUFncUgsUUFBaHFILEVBQTBxSCxpQkFBMXFILEVBQTZySCxTQUE3ckgsRUFBd3NILGNBQXhzSCxFQUF3dEgsU0FBeHRILEVBQW11SCxTQUFudUgsRUFBOHVILGNBQTl1SCxFQUE4dkgsY0FBOXZILEVBQTh3SCxhQUE5d0gsRUFBNnhILHNCQUE3eEgsRUFBcXpILE1BQXJ6SCxFQUE2ekgsZUFBN3pILEVBQTgwSCxlQUE5MEgsRUFBKzFILGlCQUEvMUgsRUFBazNILGdCQUFsM0gsRUFBbzRILFVBQXA0SCxFQUFnNUgsaUJBQWg1SCxFQUFtNkgsb0JBQW42SCxFQUF5N0gscUJBQXo3SCxFQUFnOUgsd0JBQWg5SCxFQUEwK0gsaUJBQTErSCxFQUE2L0gsb0JBQTcvSCxFQUFtaEksc0JBQW5oSSxFQUEyaUkseUJBQTNpSSxFQUFza0ksc0JBQXRrSSxFQUE4bEkseUJBQTlsSSxFQUF5bkksU0FBem5JLEVBQW9vSSxTQUFwb0ksRUFBK29JLFNBQS9vSSxFQUEwcEksYUFBMXBJLEVBQXlxSSxPQUF6cUksRUFBa3JJLGNBQWxySSxFQUFrc0ksT0FBbHNJLEVBQTJzSSxnQkFBM3NJLEVBQTZ0SSxjQUE3dEksRUFBNnVJLFdBQTd1SSxFQUEwdkksVUFBMXZJLEVBQXN3SSxXQUF0d0ksRUFBbXhJLE1BQW54SSxFQUEyeEksa0JBQTN4SSxFQUEreUkseUJBQS95SSxFQUEwMEksT0FBMTBJLEVBQW0xSSxnQkFBbjFJLEVBQXEySSxZQUFyMkksRUFBbTNJLGNBQW4zSSxFQUFtNEksY0FBbjRJLEVBQW01SSxjQUFuNUksRUFBbTZJLFVBQW42SSxFQUErNkksUUFBLzZJLEVBQXk3SSxPQUF6N0ksRUFBazhJLGlCQUFsOEksRUFBcTlJLE9BQXI5SSxFQUE4OUksTUFBOTlJLEVBQXMrSSxtQkFBdCtJLEVBQTIvSSx5QkFBMy9JLEVBQXNoSixPQUF0aEosRUFBK2hKLE9BQS9oSixFQUF3aUosU0FBeGlKLEVBQW1qSixXQUFuakosRUFBZ2tKLE9BQWhrSixFQUF5a0osT0FBemtKLEVBQWtsSixnQkFBbGxKLEVBQW9tSixRQUFwbUosRUFBOG1KLFlBQTltSixFQUE0bkosWUFBNW5KLEVBQTBvSixZQUExb0osRUFBd3BKLE9BQXhwSixFQUFpcUosT0FBanFKLEVBQTBxSixPQUExcUosRUFBbXJKLE9BQW5ySixFQUE0ckosVUFBNXJKLEVBQXdzSixTQUF4c0osRUFBbXRKLFdBQW50SixFQUFndUosUUFBaHVKLEVBQTB1SixRQUExdUosRUFBb3ZKLE9BQXB2SixFQUE2dkosUUFBN3ZKLEVBQXV3SixXQUF2d0osRUFBb3hKLFFBQXB4SixFQUE4eEosaUJBQTl4SixFQUFpekosT0FBanpKLEVBQTB6SixhQUExekosRUFBeTBKLFVBQXowSixFQUFxMUosUUFBcjFKLEVBQSsxSixNQUEvMUosRUFBdTJKLGVBQXYySixFQUF3M0osY0FBeDNKLEVBQXc0SixRQUF4NEosRUFBazVKLFFBQWw1SixFQUE0NUosT0FBNTVKLEVBQXE2SixtQkFBcjZKLEVBQTA3SixhQUExN0osRUFBeThKLFlBQXo4SixFQUF1OUosaUJBQXY5SixFQUEwK0osV0FBMStKLEVBQXUvSixhQUF2L0osRUFBc2dLLFNBQXRnSyxFQUFpaEssYUFBamhLLEVBQWdpSyxrQkFBaGlLLEVBQW9qSyxpQkFBcGpLLEVBQXVrSyxpQkFBdmtLLEVBQTBsSyxnQkFBMWxLLEVBQTRtSyxNQUE1bUssRUFBb25LLHVCQUFwbkssRUFBNm9LLG1CQUE3b0ssRUFBa3FLLGdCQUFscUssRUFBb3JLLGNBQXBySyxFQUFvc0ssVUFBcHNLLEVBQWd0SyxTQUFodEssRUFBMnRLLFNBQTN0SyxFQUFzdUssb0JBQXR1SyxFQUE0dkssT0FBNXZLLEVBQXF3SyxlQUFyd0ssRUFBc3hLLE1BQXR4SyxFQUE4eEssVUFBOXhLLEVBQTB5SyxTQUExeUssRUFBcXpLLFdBQXJ6SyxFQUFrMEssY0FBbDBLLEVBQWsxSyxjQUFsMUssRUFBazJLLFdBQWwySyxFQUErMkssV0FBLzJLLEVBQTQzSyxVQUE1M0ssRUFBdzRLLFFBQXg0SyxFQUFrNUssYUFBbDVLLEVBQWk2SyxRQUFqNkssRUFBMjZLLE1BQTM2SyxFQUFtN0ssU0FBbjdLLEVBQTg3SyxXQUE5N0ssRUFBMjhLLFNBQTM4SyxFQUFzOUssUUFBdDlLLEVBQWcrSyxlQUFoK0ssRUFBaS9LLFlBQWovSyxFQUErL0ssUUFBLy9LLEVBQXlnTCxhQUF6Z0wsRUFBd2hMLFVBQXhoTCxFQUFvaUwsY0FBcGlMLEVBQW9qTCxjQUFwakwsRUFBb2tMLG1CQUFwa0wsRUFBeWxMLE9BQXpsTCxFQUFrbUwsYUFBbG1MLEVBQWluTCxjQUFqbkwsRUFBaW9MLGFBQWpvTCxFQUFncEwsVUFBaHBMLEVBQTRwTCxTQUE1cEwsRUFBdXFMLFdBQXZxTCxFQUFvckwsa0JBQXByTCxFQUF3c0wsU0FBeHNMLEVBQW10TCxnQkFBbnRMLEVBQXF1TCxPQUFydUwsRUFBOHVMLGdCQUE5dUwsRUFBZ3dMLFNBQWh3TCxFQUEyd0wsT0FBM3dMLEVBQW94TCxPQUFweEwsRUFBNnhMLFVBQTd4TCxFQUF5eUwsU0FBenlMLEVBQW96TCxzQkFBcHpMLEVBQTQwTCxTQUE1MEwsRUFBdTFMLFFBQXYxTCxFQUFpMkwsWUFBajJMLEVBQSsyTCx1QkFBLzJMLEVBQXc0TCxzQkFBeDRMLEVBQWc2TCxNQUFoNkwsRUFBdzZMLFVBQXg2TCxFQUFvN0wsd0JBQXA3TCxFQUE4OEwsZUFBOThMLEVBQSs5TCxZQUEvOUwsRUFBNitMLFVBQTcrTCxFQUF5L0wsZ0JBQXovTCxFQUEyZ00scUJBQTNnTSxFQUFraU0sZUFBbGlNLEVBQW1qTSxNQUFuak0sRUFBMmpNLGVBQTNqTSxFQUE0a00sS0FBNWtNLEVBQW1sTSxRQUFubE0sRUFBNmxNLFFBQTdsTSxFQUF1bU0sWUFBdm1NLEVBQXFuTSxZQUFybk0sRUFBbW9NLFNBQW5vTSxFQUE4b00sV0FBOW9NLEVBQTJwTSxRQUEzcE0sRUFBcXFNLFFBQXJxTSxFQUErcU0sU0FBL3FNLEVBQTByTSxTQUExck0sRUFBcXNNLHNCQUFyc00sRUFBNnRNLGNBQTd0TSxFQUE2dU0sV0FBN3VNLEVBQTB2TSxZQUExdk0sRUFBd3dNLFVBQXh3TSxFQUFveE0sV0FBcHhNLEVBQWl5TSxXQUFqeU0sRUFBOHlNLFdBQTl5TSxFQUEyek0sWUFBM3pNLEVBQXkwTSxhQUF6ME0sRUFBdzFNLFdBQXgxTSxFQUFxMk0sYUFBcjJNLEVBQW8zTSxRQUFwM00sRUFBODNNLFFBQTkzTSxFQUF3NE0sZ0JBQXg0TSxFQUEwNU0sU0FBMTVNLEVBQXE2TSxpQkFBcjZNLEVBQXc3TSxXQUF4N00sRUFBcThNLGFBQXI4TSxFQUFvOU0sd0JBQXA5TSxFQUE4K00sV0FBOStNLEVBQTIvTSxxQkFBMy9NLEVBQWtoTixhQUFsaE4sRUFBaWlOLFVBQWppTixFQUE2aU4sU0FBN2lOLEVBQXdqTixTQUF4ak4sRUFBbWtOLGlCQUFua04sRUFBc2xOLFFBQXRsTixFQUFnbU4sa0JBQWhtTixFQUFvbk4sVUFBcG5OLEVBQWdvTixhQUFob04sRUFBK29OLEtBQS9vTixFQUFzcE4sUUFBdHBOLEVBQWdxTixhQUFocU4sRUFBK3FOLFNBQS9xTixFQUEwck4sU0FBMXJOLEVBQXFzTixpQkFBcnNOLEVBQXd0TixnQkFBeHROLEVBQTB1TixVQUExdU4sRUFBc3ZOLGtCQUF0dk4sRUFBMHdOLFVBQTF3TixFQUFzeE4sV0FBdHhOLEVBQW15TixnQkFBbnlOLEVBQXF6TixTQUFyek4sRUFBZzBOLFlBQWgwTixFQUE4ME4sYUFBOTBOLEVBQTYxTixhQUE3MU4sRUFBNDJOLG9CQUE1Mk4sRUFBazROLGNBQWw0TixFQUFrNU4saUJBQWw1TixFQUFxNk4sV0FBcjZOLEVBQWs3TixhQUFsN04sRUFBaThOLFNBQWo4TixFQUE0OE4sU0FBNThOLEVBQXU5TixrQkFBdjlOLEVBQTIrTixxQkFBMytOLEVBQWtnTyxTQUFsZ08sRUFBNmdPLGFBQTdnTyxFQUE0aE8sUUFBNWhPLEVBQXNpTyxlQUF0aU8sRUFBdWpPLFlBQXZqTyxFQUFxa08sU0FBcmtPLEVBQWdsTyxNQUFobE8sRUFBd2xPLFVBQXhsTyxFQUFvbU8sa0JBQXBtTyxFQUF3bk8scUJBQXhuTyxFQUErb08sU0FBL29PLEVBQTBwTyxZQUExcE8sRUFBd3FPLFlBQXhxTyxFQUFzck8sTUFBdHJPLEVBQThyTyxVQUE5ck8sRUFBMHNPLGNBQTFzTyxFQUEwdE8sU0FBMXRPLEVBQXF1TyxrQkFBcnVPLEVBQXl2TyxrQkFBenZPLEVBQTZ3TyxnQkFBN3dPLEVBQSt4TyxPQUEveE8sRUFBd3lPLGFBQXh5TyxFQUF1ek8sZ0JBQXZ6TyxFQUF5ME8sZ0JBQXowTyxFQUEyMU8sVUFBMzFPLEVBQXUyTyxZQUF2Mk8sRUFBcTNPLFNBQXIzTyxFQUFnNE8sY0FBaDRPLEVBQWc1TyxRQUFoNU8sRUFBMDVPLFVBQTE1TyxFQUFzNk8sY0FBdDZPLEVBQXM3TyxtQkFBdDdPLEVBQTI4TyxXQUEzOE8sRUFBdzlPLFdBQXg5TyxFQUFxK08sZ0JBQXIrTyxFQUF1L08sU0FBdi9PLEVBQWtnUCxpQkFBbGdQLEVBQXFoUCxRQUFyaFAsRUFBK2hQLFVBQS9oUCxFQUEyaVAsU0FBM2lQLEVBQXNqUCxjQUF0alAsRUFBc2tQLFlBQXRrUCxFQUFvbFAsVUFBcGxQLEVBQWdtUCxRQUFobVAsRUFBMG1QLGNBQTFtUCxFQUEwblAsVUFBMW5QLEVBQXNvUCxRQUF0b1AsRUFBZ3BQLE9BQWhwUCxFQUF5cFAsV0FBenBQLEVBQXNxUCxjQUF0cVAsRUFBc3JQLFdBQXRyUCxFQUFtc1AsZUFBbnNQLEVBQW90UCxTQUFwdFAsRUFBK3RQLGVBQS90UCxFQUFndlAsUUFBaHZQLEVBQTB2UCxlQUExdlAsRUFBMndQLFdBQTN3UCxFQUF3eFAsUUFBeHhQLEVBQWt5UCxRQUFseVAsRUFBNHlQLGtCQUE1eVAsRUFBZzBQLGFBQWgwUCxFQUErMFAsYUFBLzBQLEVBQTgxUCxXQUE5MVAsRUFBMjJQLFdBQTMyUCxFQUF3M1AsU0FBeDNQLEVBQW00UCxXQUFuNFAsRUFBZzVQLFdBQWg1UCxFQUE2NVAsU0FBNzVQLEVBQXc2UCxVQUF4NlAsRUFBbzdQLGNBQXA3UCxFQUFvOFAsV0FBcDhQLEVBQWk5UCxPQUFqOVAsRUFBMDlQLGdCQUExOVAsRUFBNCtQLFdBQTUrUCxFQUF5L1AsTUFBei9QLEVBQWlnUSxRQUFqZ1EsRUFBMmdRLGFBQTNnUSxFQUEwaFEsUUFBMWhRLEVBQW9pUSxZQUFwaVEsRUFBa2pRLGdCQUFsalEsRUFBb2tRLFdBQXBrUSxFQUFpbFEsUUFBamxRLEVBQTJsUSxLQUEzbFEsRUFBa21RLFlBQWxtUSxFQUFnblEsU0FBaG5RLEVBQTJuUSxNQUEzblEsRUFBbW9RLE9BQW5vUSxFQUE0b1EsU0FBNW9RLEVBQXVwUSxVQUF2cFEsRUFBbXFRLGFBQW5xUSxFQUFrclEsUUFBbHJRLEVBQTRyUSxRQUE1clEsRUFBc3NRLFVBQXRzUSxFQUFrdFEsU0FBbHRRLEVBQTZ0USxPQUE3dFEsRUFBc3VRLGNBQXR1USxFQUFzdlEsWUFBdHZRLEVBQW93USxnQkFBcHdRLEVBQXN4USxXQUF0eFEsRUFBbXlRLGFBQW55USxFQUFrelEsb0JBQWx6USxFQUF3MFEsd0JBQXgwUSxFQUFrMlEsUUFBbDJRLEVBQTQyUSxPQUE1MlEsRUFBcTNRLFlBQXIzUSxFQUFtNFEsaUJBQW40USxFQUFzNVEsV0FBdDVRLEVBQW02USxhQUFuNlEsRUFBazdRLFVBQWw3USxFQUE4N1EsWUFBOTdRLEVBQTQ4USxTQUE1OFEsRUFBdTlRLGtCQUF2OVEsRUFBMitRLFdBQTMrUSxFQUF3L1EsU0FBeC9RLEVBQW1nUixlQUFuZ1IsRUFBb2hSLFVBQXBoUixFQUFnaVIsU0FBaGlSLEVBQTJpUixZQUEzaVIsRUFBeWpSLFlBQXpqUixFQUF1a1IsU0FBdmtSLEVBQWtsUixRQUFsbFIsRUFBNGxSLFFBQTVsUixFQUFzbVIsU0FBdG1SLEVBQWluUixTQUFqblIsRUFBNG5SLGVBQTVuUixFQUE2b1IsWUFBN29SLEVBQTJwUixPQUEzcFIsRUFBb3FSLFlBQXBxUixFQUFrclIsa0JBQWxyUixFQUFzc1IsaUJBQXRzUixFQUF5dFIsaUJBQXp0UixFQUE0dVIsa0JBQTV1UixFQUFnd1IsZUFBaHdSLEVBQWl4UixZQUFqeFIsRUFBK3hSLFdBQS94UixFQUE0eVIsUUFBNXlSLEVBQXN6UixZQUF0elIsRUFBbzBSLHNCQUFwMFIsRUFBNDFSLFdBQTUxUixFQUF5MlIsZUFBejJSLEVBQTAzUixpQkFBMTNSLEVBQTY0Uix1QkFBNzRSLEVBQXM2UixzQkFBdDZSLEVBQTg3UixPQUE5N1IsRUFBdThSLFFBQXY4UixFQUFpOVIscUJBQWo5UixFQUF3K1IsUUFBeCtSLEVBQWsvUixXQUFsL1IsRUFBKy9SLGtCQUEvL1IsRUFBbWhTLE1BQW5oUyxFQUEyaFMsU0FBM2hTLEVBQXNpUyxXQUF0aVMsRUFBbWpTLGFBQW5qUyxFQUFra1Msb0JBQWxrUyxFQUF3bFMsV0FBeGxTLEVBQXFtUyxXQUFybVMsRUFBa25TLFFBQWxuUyxFQUE0blMsT0FBNW5TLEVBQXFvUyxNQUFyb1MsRUFBNm9TLE9BQTdvUyxFQUFzcFMsb0JBQXRwUyxFQUE0cVMsWUFBNXFTLEVBQTByUyxhQUExclMsRUFBeXNTLG9CQUF6c1MsRUFBK3RTLFFBQS90UyxFQUF5dVMsU0FBenVTLEVBQW92UyxTQUFwdlMsRUFBK3ZTLE9BQS92UyxFQUF3d1MsV0FBeHdTLEVBQXF4UyxlQUFyeFMsRUFBc3lTLGFBQXR5UyxFQUFxelMsU0FBcnpTLEVBQWcwUyxTQUFoMFMsRUFBMjBTLFNBQTMwUyxFQUFzMVMsWUFBdDFTLEVBQW8yUyxRQUFwMlMsRUFBODJTLGtCQUE5MlMsRUFBazRTLGFBQWw0UyxFQUFpNVMsT0FBajVTLEVBQTA1UyxnQkFBMTVTLEVBQTQ2UyxVQUE1NlMsRUFBdzdTLFdBQXg3UyxFQUFxOFMsZ0JBQXI4UyxFQUF1OVMsb0JBQXY5UyxFQUE2K1MsU0FBNytTLEVBQXcvUyxRQUF4L1MsRUFBa2dULE1BQWxnVCxFQUEwZ1QsT0FBMWdULEVBQW1oVCxhQUFuaFQsRUFBa2lULFFBQWxpVCxFQUE0aVQsY0FBNWlULEVBQTRqVCxhQUE1alQsRUFBMmtULGNBQTNrVCxFQUEybFQsT0FBM2xULEVBQW9tVCxVQUFwbVQsRUFBZ25ULE1BQWhuVCxFQUF3blQsT0FBeG5ULEVBQWlvVCxTQUFqb1QsRUFBNG9ULFVBQTVvVCxFQUF3cFQsVUFBeHBULEVBQW9xVCx5QkFBcHFULEVBQStyVCxVQUEvclQsRUFBMnNULGlCQUEzc1QsRUFBOHRULFFBQTl0VCxFQUF3dVQsV0FBeHVULEVBQXF2VCxXQUFydlQsRUFBa3dULFVBQWx3VCxFQUE4d1QsV0FBOXdULEVBQTJ4VCxtQkFBM3hULEVBQWd6VCxhQUFoelQsRUFBK3pULFlBQS96VCxFQUE2MFQsWUFBNzBULEVBQTIxVCxZQUEzMVQsRUFBeTJULFFBQXoyVCxDQUFYO0FBRUQsQ0FyQkQsRUFxQkdrZSxJQXJCSCxZOzs7Ozs7Ozs7Ozs7Ozs7O0FDREEsSUFBSXFMLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLLElBQUlpdkQsUUFBSixDQUFhLGFBQWIsR0FBVDtBQUNBLENBSEQsQ0FHRSxPQUFPcjBFLENBQVAsRUFBVTtBQUNYO0FBQ0EsS0FBSSxRQUFPeEIsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUF0QixFQUFnQzRtQixJQUFJNW1CLE1BQUo7QUFDaEM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBc1csT0FBT0MsT0FBUCxHQUFpQnFRLENBQWpCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTWt2RCxPQUFPO0FBQ1h4NUUsU0FBT0EsWUFESTtBQUVYRCxtQkFBaUJBLHNCQUZOO0FBR1hELGNBQVlBLGlCQUhEO0FBSVgyNUUsaUJBQWVBO0FBSkosQ0FBYjtBQU1BLElBQUkvMUUsTUFBSixFQUFZO0FBQ1ZBLFNBQU84MUUsSUFBUCxHQUFjQSxJQUFkO0FBQ0Q7a0JBQ2NBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDaURDRSxRLEdBQUFBLFE7O2tCQTZKRCxVQUFTQyxPQUFULEVBQWtCLzJFLE9BQWxCLEVBQTJCQyxNQUEzQixFQUFtQ0MsV0FBbkMsRUFBZ0RTLFVBQWhELEVBQTREQyxjQUE1RCxFQUEyRW8yRSxXQUEzRSxFQUF3RnY1RSxLQUF4RixFQUErRjtBQUM1RyxNQUFJLENBQUN5QyxXQUFMLEVBQWtCO0FBQ2hCQSxrQkFBYyxFQUFkO0FBQ0EsU0FBSyxJQUFJZzlDLE1BQU0saUJBQWYsRUFBa0NoOUMsWUFBWW5DLE1BQVosR0FBcUIsRUFBdkQsRUFBMkRtL0MsT0FBTyxDQUFsRSxFQUFxRTtBQUNuRWg5QyxrQkFBWXhCLElBQVosQ0FBaUJ3K0MsR0FBakI7QUFDRDtBQUNGO0FBQ0QsTUFBSSxPQUFPbDlDLE9BQVAsSUFBa0IsUUFBdEIsRUFBZ0M7QUFDOUJBLGNBQVVNLEtBQUtDLEtBQUwsQ0FBV1AsT0FBWCxDQUFWO0FBQ0Q7QUFDRCxNQUFJQSxRQUFRUSxPQUFSLElBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLFVBQU0sSUFBSUMsS0FBSixDQUFVLDZCQUFWLENBQU47QUFDRDs7QUFFRCxNQUFJdzJFLHNCQUFKO0FBQ0EsTUFBSXIyRSxrQkFBa0IsQ0FBQ28yRSxXQUF2QixFQUFvQztBQUNsQyxRQUFNRSxNQUFNLElBQUl2eUIsS0FBSixFQUFaO0FBQ0F1eUIsUUFBSXp2RSxXQUFKLEdBQWtCLFdBQWxCO0FBQ0F5dkUsUUFBSUMsTUFBSixHQUFhLFlBQVc7QUFDdEJILG9CQUFjRSxHQUFkO0FBQ0FELHNCQUFnQixDQUFDQyxJQUFJcm9FLEtBQUwsRUFBWXFvRSxJQUFJcG9FLE1BQWhCLENBQWhCO0FBQ0Fpb0UsY0FBUTN4QixPQUFSO0FBQ0QsS0FKRDtBQUtBOHhCLFFBQUl0dkUsR0FBSixHQUFVaEgsY0FBVjtBQUNEOztBQUVELE1BQU00cEIsTUFBTTVyQixTQUFTRyxhQUFULENBQXVCLFFBQXZCLEVBQWlDcXRELFVBQWpDLENBQTRDLElBQTVDLENBQVo7QUFDQSxNQUFNZ3JCLGVBQWUsRUFBckI7O0FBRUEsV0FBU0MsZUFBVCxDQUF5QnZ1RCxJQUF6QixFQUErQnd1RCxRQUEvQixFQUF5QzlzRCxHQUF6QyxFQUE4QztBQUM1QyxRQUFJK3NELFlBQVkvc0QsSUFBSWd0RCxXQUFKLENBQWdCMXVELElBQWhCLEVBQXNCamEsS0FBdEM7QUFDQSxRQUFJMG9FLFlBQVlELFFBQWhCLEVBQTBCO0FBQ3hCLFVBQUlwNkIsT0FBTSxFQUFWO0FBQ0EsVUFBSXU2QixPQUFPLEVBQVg7QUFDQSxVQUFJQyxZQUFZNXVELEtBQUt4cUIsS0FBTCxDQUFXLEVBQVgsQ0FBaEI7QUFDQW81RSxnQkFBVXQwRCxPQUFWLENBQWtCLFVBQUN1MEQsVUFBRCxFQUFnQjtBQUNoQyxZQUFJQyxXQUFXSCxLQUFLM3VFLElBQUwsQ0FBVSxFQUFWLElBQWdCNnVFLFVBQS9CO0FBQ0EsWUFBSW50RCxJQUFJZ3RELFdBQUosQ0FBZ0JJLFFBQWhCLEVBQTBCL29FLEtBQTFCLEdBQWtDeW9FLFFBQXRDLEVBQWdEO0FBQzlDcDZCLGVBQUl4K0MsSUFBSixDQUFTKzRFLEtBQUszdUUsSUFBTCxDQUFVLEVBQVYsQ0FBVDtBQUNBMnVFLGlCQUFPLENBQUNFLFVBQUQsQ0FBUDtBQUNELFNBSEQsTUFHTztBQUNMRixlQUFLLzRFLElBQUwsQ0FBVWk1RSxVQUFWO0FBQ0Q7QUFDRixPQVJEO0FBU0F6NkIsV0FBSXgrQyxJQUFKLENBQVMrNEUsS0FBSzN1RSxJQUFMLENBQVUsRUFBVixDQUFUO0FBQ0EsYUFBT28wQyxJQUFQO0FBQ0Q7QUFDRCxXQUFPLENBQUNwMEIsSUFBRCxDQUFQO0FBQ0Q7O0FBRUQsV0FBUyt1RCxRQUFULENBQWtCL3VELElBQWxCLEVBQXdCenFCLElBQXhCLEVBQThCeTVFLEVBQTlCLEVBQWtDO0FBQ2hDLFFBQU0vd0UsTUFBTSt3RSxLQUFLLEdBQUwsR0FBV3o1RSxJQUFYLEdBQWtCLEdBQWxCLEdBQXdCeXFCLElBQXBDO0FBQ0EsUUFBSWl2RCxjQUFjWCxhQUFhcndFLEdBQWIsQ0FBbEI7QUFDQSxRQUFJLENBQUNneEUsV0FBTCxFQUFrQjtBQUNoQnZ0RCxVQUFJbnNCLElBQUosR0FBV0EsSUFBWDtBQUNBLFVBQU0yNUUsUUFBUXh0RCxJQUFJZ3RELFdBQUosQ0FBZ0IsR0FBaEIsRUFBcUIzb0UsS0FBbkM7QUFDQSxVQUFNQSxRQUFRbXBFLFFBQVFGLEVBQXRCO0FBQ0EsVUFBSUcsUUFBUSxFQUFaO0FBQ0EsVUFBSSxtQkFBbUJ4OEQsSUFBbkIsQ0FBd0JxTixJQUF4QixDQUFKLEVBQW1DO0FBQ2pDbXZELGdCQUFRWixnQkFBZ0J2dUQsSUFBaEIsRUFBc0JqYSxLQUF0QixFQUE2QjJiLEdBQTdCLENBQVI7QUFDRCxPQUZELE1BRU87QUFDTHl0RCxnQkFBUW52RCxLQUFLeHFCLEtBQUwsQ0FBVyxHQUFYLENBQVI7QUFDRDtBQUNELFVBQUk2TyxPQUFPLEVBQVg7QUFDQSxVQUFNNGxDLFFBQVEsRUFBZDtBQUNBLFdBQUssSUFBSXIxQyxJQUFJLENBQVIsRUFBV0MsS0FBS3M2RSxNQUFNbDZFLE1BQTNCLEVBQW1DTCxJQUFJQyxFQUF2QyxFQUEyQyxFQUFFRCxDQUE3QyxFQUFnRDtBQUM5QyxZQUFNdzZFLE9BQU9ELE1BQU12NkUsQ0FBTixDQUFiO0FBQ0EsWUFBSzhzQixJQUFJZ3RELFdBQUosQ0FBZ0JycUUsT0FBTytxRSxJQUF2QixFQUE2QnJwRSxLQUE3QixJQUFzQ0EsS0FBM0MsRUFBbUQ7QUFDakQxQixrQkFBUSxDQUFDQSxPQUFPLEdBQVAsR0FBYSxFQUFkLElBQW9CK3FFLElBQTVCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsY0FBSS9xRSxJQUFKLEVBQVU7QUFDUjRsQyxrQkFBTXIwQyxJQUFOLENBQVd5TyxJQUFYO0FBQ0Q7QUFDREEsaUJBQU8rcUUsSUFBUDtBQUNEO0FBQ0Y7QUFDRCxVQUFJL3FFLElBQUosRUFBVTtBQUNSNGxDLGNBQU1yMEMsSUFBTixDQUFXeU8sSUFBWDtBQUNEO0FBQ0RpcUUsbUJBQWFyd0UsR0FBYixJQUFvQmd4RSxjQUFjaGxDLE1BQU1qcUMsSUFBTixDQUFXLElBQVgsQ0FBbEM7QUFDRDtBQUNELFdBQU9pdkUsV0FBUDtBQUNEOztBQUVELE1BQU1JLFlBQVksb0NBQVluNEUsUUFBUW9DLE1BQXBCLENBQWxCOztBQUVBLE1BQU1nMkUsc0JBQXNCLEVBQTVCO0FBQ0EsTUFBTUMsZUFBZSxFQUFyQjtBQUNBLE1BQUlDLHFCQUFKO0FBQ0EsT0FBSyxJQUFJNTZFLElBQUksQ0FBUixFQUFXQyxLQUFLdzZFLFVBQVVwNkUsTUFBL0IsRUFBdUNMLElBQUlDLEVBQTNDLEVBQStDLEVBQUVELENBQWpELEVBQW9EO0FBQ2xELFFBQU00QixRQUFRNjRFLFVBQVV6NkUsQ0FBVixDQUFkO0FBQ0EsUUFBTXNMLFVBQVUxSixNQUFNK0MsRUFBdEI7QUFDQSxRQUFJLE9BQU9wQyxNQUFQLElBQWlCLFFBQWpCLElBQTZCWCxNQUFNVyxNQUFOLElBQWdCQSxNQUE3QyxJQUNGQSxPQUFPeEIsT0FBUCxDQUFldUssT0FBZixNQUE0QixDQUFDLENBRC9CLEVBQ2tDO0FBQ2hDLFVBQU11dkUsY0FBY2o1RSxNQUFNLGNBQU4sQ0FBcEI7QUFDQSxVQUFJLENBQUNnNUUsWUFBTCxFQUFtQjtBQUNqQkEsdUJBQWVoNUUsTUFBTVcsTUFBckI7QUFDRDtBQUNELFVBQUltQyxTQUFTZzJFLG9CQUFvQkcsV0FBcEIsQ0FBYjtBQUNBLFVBQUksQ0FBQ24yRSxNQUFMLEVBQWE7QUFDWEEsaUJBQVNnMkUsb0JBQW9CRyxXQUFwQixJQUFtQyxFQUE1QztBQUNEO0FBQ0RuMkUsYUFBTzFELElBQVAsQ0FBWTtBQUNWWSxlQUFPQSxLQURHO0FBRVYwVyxlQUFPdFk7QUFGRyxPQUFaO0FBSUEyNkUsbUJBQWEzNUUsSUFBYixDQUFrQnNLLE9BQWxCO0FBQ0Q7QUFDRDtBQUNBLFdBQU93dkUsY0FBY3h2RSxPQUFkLENBQVA7QUFDQSxXQUFPeXZFLFlBQVl6dkUsT0FBWixDQUFQO0FBQ0Q7QUFDRCxNQUFNMHZFLGlCQUFpQixFQUF2Qjs7QUFFQSxNQUFNQyxTQUFTLEVBQWY7QUFDQSxNQUFNQyxlQUFlLEVBQXJCOztBQUVBLE1BQU1yaUMsZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFTbnFCLE9BQVQsRUFBa0Jzb0MsVUFBbEIsRUFBOEI7QUFDbEQsUUFBTS9pRCxhQUFheWEsUUFBUTQ2QixhQUFSLEVBQW5CO0FBQ0E1NkIsWUFBUXlzRCxRQUFSLEdBQW1CenNELFFBQVF5c0QsUUFBUixJQUFvQixFQUF2QztBQUNBLFFBQU16MkUsU0FBU2cyRSxvQkFBb0J6bUUsV0FBV3JTLEtBQS9CLENBQWY7QUFDQSxRQUFJLENBQUM4QyxNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0QsUUFBSVcsT0FBTzdDLFlBQVl6QixPQUFaLENBQW9CaTJELFVBQXBCLENBQVg7QUFDQSxRQUFJM3hELFFBQVEsQ0FBQyxDQUFiLEVBQWdCO0FBQ2RBLGFBQU8yVixLQUFLdEssS0FBTCxDQUFXLGdDQUFxQnNtRCxVQUFyQixFQUFpQ3gwRCxXQUFqQyxDQUFYLENBQVA7QUFDRDtBQUNELFFBQU13QyxPQUFPNG5CLE1BQU04QixRQUFRMHNELFdBQVIsR0FBc0JyN0MsT0FBdEIsRUFBTixDQUFiO0FBQ0EsUUFBTWhYLElBQUk7QUFDUjlVLGtCQUFZQSxVQURKO0FBRVJqUCxZQUFNQTtBQUZFLEtBQVY7QUFJQSxRQUFJcTJFLGVBQWUsQ0FBQyxDQUFwQjtBQUNBLFNBQUssSUFBSXI3RSxLQUFJLENBQVIsRUFBV0MsTUFBS3lFLE9BQU9yRSxNQUE1QixFQUFvQ0wsS0FBSUMsR0FBeEMsRUFBNEMsRUFBRUQsRUFBOUMsRUFBaUQ7QUFDL0MsVUFBTXM3RSxZQUFZNTJFLE9BQU8xRSxFQUFQLENBQWxCO0FBQ0EsVUFBTTRCLFNBQVEwNUUsVUFBVTE1RSxLQUF4QjtBQUNBLFVBQU0wSixXQUFVMUosT0FBTStDLEVBQXRCOztBQUVBLFVBQU05QyxTQUFTRCxPQUFNQyxNQUFOLElBQWdCMDVFLFFBQS9CO0FBQ0EsVUFBTW4yRSxRQUFReEQsT0FBTXdELEtBQU4sSUFBZW0yRSxRQUE3QjtBQUNBLFVBQUkxNUUsT0FBTytELFVBQVAsS0FBc0IsTUFBdEIsSUFBaUMsYUFBYWhFLE1BQWIsSUFBc0J5RCxPQUFPekQsT0FBTTBHLE9BQXBFLElBQ0QsYUFBYTFHLE1BQWIsSUFBc0J5RCxRQUFRekQsT0FBTXdHLE9BRHZDLEVBQ2lEO0FBQy9DO0FBQ0Q7QUFDRHNtQixjQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsSUFBeUJxcEIsUUFBUXlzRCxRQUFSLENBQWlCOTFFLElBQWpCLEtBQTBCLEVBQW5EO0FBQ0EsVUFBTW1KLFNBQVM1TSxPQUFNNE0sTUFBckI7QUFDQSxVQUFJb3FFLGFBQUo7QUFBQSxVQUFVNEMsZ0JBQVY7QUFDQSxVQUFJLENBQUNodEUsTUFBRCxJQUFXaXRFLGVBQWVud0UsUUFBZixFQUF3QmtELE1BQXhCLEVBQWdDdWEsQ0FBaEMsRUFBbUMxakIsSUFBbkMsQ0FBZixFQUF5RDtBQUN2RCxZQUFJb0gsY0FBSjtBQUFBLFlBQVc5RyxnQkFBWDtBQUFBLFlBQW9CMkosYUFBcEI7QUFBQSxZQUEwQncxRCxlQUExQjtBQUFBLFlBQWtDNFcsb0JBQWxDO0FBQUEsWUFBK0NwM0UsY0FBL0M7QUFDQSxZQUFNZ1UsUUFBUWdqRSxVQUFVaGpFLEtBQXhCO0FBQ0EsWUFBSXRULFFBQVEsQ0FBUixJQUFhcEQsT0FBTW9ELElBQU4sSUFBYyxNQUEvQixFQUF1QztBQUNyQ1csb0JBQVV5ekUsU0FBU3gzRSxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGNBQXpCLEVBQXlDeUQsSUFBekMsRUFBK0MwakIsQ0FBL0MsQ0FBVjtBQUNBLGNBQUksa0JBQWtCM2pCLEtBQXRCLEVBQTZCO0FBQzNCLGdCQUFNdTJFLFlBQVl2QyxTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsY0FBekIsRUFBeUN5RCxJQUF6QyxFQUErQzBqQixDQUEvQyxDQUFsQjtBQUNBLGdCQUFJNHlELFNBQUosRUFBZTtBQUNiL0MscUJBQU8sT0FBTytDLFNBQVAsS0FBcUIsUUFBckIsR0FBZ0NDLGFBQWFELFNBQWIsRUFBd0IxbkUsVUFBeEIsQ0FBaEMsR0FBc0UwbkUsVUFBVWoyRSxRQUFWLEVBQTdFO0FBQ0Esa0JBQUk0ekUsZUFBZXIyRSxVQUFmLElBQTZCQSxXQUFXMjFFLElBQVgsQ0FBakMsRUFBbUQ7QUFDakQsa0JBQUV5QyxZQUFGO0FBQ0Esb0JBQUkzc0QsUUFBUXlzRCxRQUFSLENBQWlCOTFFLElBQWpCLEVBQXVCdEUsT0FBdkIsQ0FBK0J1SyxRQUEvQixNQUE0QyxDQUFDLENBQWpELEVBQW9EO0FBQ2xEb2pCLDBCQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsRUFBdUJyRSxJQUF2QixDQUE0QnNLLFFBQTVCO0FBQ0Q7QUFDRGhILHdCQUFRMjJFLE9BQU9JLFlBQVAsQ0FBUjtBQUNBLG9CQUFJLENBQUMvMkUsS0FBRCxJQUFVLENBQUNBLE1BQU11M0UsT0FBTixFQUFYLElBQThCdjNFLE1BQU13M0UsU0FBTixFQUE5QixJQUFtRHgzRSxNQUFNeTNFLE9BQU4sRUFBdkQsRUFBd0U7QUFDdEV6M0UsMEJBQVEyMkUsT0FBT0ksWUFBUCxJQUF1QixJQUFJVyxlQUFKLENBQVU7QUFDdkMxc0UsMEJBQU0sSUFBSTJzRSxjQUFKO0FBRGlDLG1CQUFWLENBQS9CO0FBR0Q7QUFDRDNzRSx1QkFBT2hMLE1BQU11M0UsT0FBTixFQUFQO0FBQ0F2M0Usc0JBQU00M0UsU0FBTixDQUFnQjVqRSxLQUFoQjtBQUNBLG9CQUFNNmpFLGlCQUFpQnZELE9BQU8sR0FBUCxHQUFhanpFLE9BQXBDO0FBQ0Esb0JBQUl5MkUsVUFBVWxCLGFBQWFpQixjQUFiLENBQWQ7QUFDQSxvQkFBSSxDQUFDQyxPQUFMLEVBQWM7QUFDWixzQkFBTUMsa0JBQWtCcDVFLFdBQVcyMUUsSUFBWCxDQUF4QjtBQUNBLHNCQUFNbHdCLFNBQVN4bkQsU0FBU0csYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0FxbkQseUJBQU92M0MsS0FBUCxHQUFla3JFLGdCQUFnQmxyRSxLQUEvQjtBQUNBdTNDLHlCQUFPdDNDLE1BQVAsR0FBZ0JpckUsZ0JBQWdCanJFLE1BQWhDO0FBQ0Esc0JBQU0wYixPQUFNNDdCLE9BQU9nRyxVQUFQLENBQWtCLElBQWxCLENBQVo7QUFDQTVoQyx1QkFBSXd2RCxXQUFKLEdBQWtCMzJFLE9BQWxCO0FBQ0FtbkIsdUJBQUl5MkMsU0FBSixDQUNFK1YsV0FERixFQUVFK0MsZ0JBQWdCbjlELENBRmxCLEVBR0VtOUQsZ0JBQWdCbnRELENBSGxCLEVBSUVtdEQsZ0JBQWdCbHJFLEtBSmxCLEVBS0VrckUsZ0JBQWdCanJFLE1BTGxCLEVBTUUsQ0FORixFQU9FLENBUEYsRUFRRWlyRSxnQkFBZ0JsckUsS0FSbEIsRUFTRWtyRSxnQkFBZ0JqckUsTUFUbEI7QUFXQWdyRSw0QkFBVXR2RCxLQUFJeXZELGFBQUosQ0FBa0I3ekIsTUFBbEIsRUFBMEIsUUFBMUIsQ0FBVjtBQUNBd3lCLCtCQUFhaUIsY0FBYixJQUErQkMsT0FBL0I7QUFDRDtBQUNEOXNFLHFCQUFLa3RFLFFBQUwsQ0FBY0osT0FBZDtBQUNEO0FBQ0Y7QUFDRixXQTNDRCxNQTJDTyxJQUFJLGdCQUFnQmgzRSxLQUFwQixFQUEyQjtBQUNoQ3FILG9CQUFRZ3dFLGlCQUFpQnJELFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5QixZQUF6QixFQUF1Q3lELElBQXZDLEVBQTZDMGpCLENBQTdDLENBQWpCLEVBQWtFcGpCLE9BQWxFLENBQVI7QUFDQSxnQkFBSThHLEtBQUosRUFBVztBQUNULGdCQUFFNHVFLFlBQUY7QUFDQSxrQkFBSTNzRCxRQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsRUFBdUJ0RSxPQUF2QixDQUErQnVLLFFBQS9CLE1BQTRDLENBQUMsQ0FBakQsRUFBb0Q7QUFDbERvakIsd0JBQVF5c0QsUUFBUixDQUFpQjkxRSxJQUFqQixFQUF1QnJFLElBQXZCLENBQTRCc0ssUUFBNUI7QUFDRDtBQUNEaEgsc0JBQVEyMkUsT0FBT0ksWUFBUCxDQUFSO0FBQ0Esa0JBQUksQ0FBQy8yRSxLQUFELElBQVUsQ0FBQ0EsTUFBTXUzRSxPQUFOLEVBQVgsSUFBOEJ2M0UsTUFBTXczRSxTQUFOLEVBQTlCLElBQW1EeDNFLE1BQU15M0UsT0FBTixFQUF2RCxFQUF3RTtBQUN0RXozRSx3QkFBUTIyRSxPQUFPSSxZQUFQLElBQXVCLElBQUlXLGVBQUosQ0FBVTtBQUN2QzFzRSx3QkFBTSxJQUFJMnNFLGNBQUo7QUFEaUMsaUJBQVYsQ0FBL0I7QUFHRDtBQUNEM3NFLHFCQUFPaEwsTUFBTXUzRSxPQUFOLEVBQVA7QUFDQXZzRSxtQkFBS2t0RSxRQUFMLENBQWMvdkUsS0FBZDtBQUNBbkksb0JBQU00M0UsU0FBTixDQUFnQjVqRSxLQUFoQjtBQUNEO0FBQ0QsZ0JBQUksd0JBQXdCbFQsS0FBNUIsRUFBbUM7QUFDakNzMkUsNEJBQWNlLGlCQUFpQnJELFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5QixvQkFBekIsRUFBK0N5RCxJQUEvQyxFQUFxRDRPLFVBQXJELENBQWpCLEVBQW1GdE8sT0FBbkYsQ0FBZDtBQUNELGFBRkQsTUFFTyxJQUFJLG9CQUFvQlAsS0FBeEIsRUFBK0I7QUFDcENzMkUsNEJBQWNqdkUsS0FBZDtBQUNEO0FBQ0QsZ0JBQUlpdkUsV0FBSixFQUFpQjtBQUNmLGdCQUFFTCxZQUFGO0FBQ0Esa0JBQUkzc0QsUUFBUXlzRCxRQUFSLENBQWlCOTFFLElBQWpCLEVBQXVCdEUsT0FBdkIsQ0FBK0J1SyxRQUEvQixNQUE0QyxDQUFDLENBQWpELEVBQW9EO0FBQ2xEb2pCLHdCQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsRUFBdUJyRSxJQUF2QixDQUE0QnNLLFFBQTVCO0FBQ0Q7QUFDRGhILHNCQUFRMjJFLE9BQU9JLFlBQVAsQ0FBUjtBQUNBLGtCQUFJLENBQUMvMkUsS0FBRCxJQUFVLENBQUNBLE1BQU13M0UsU0FBTixFQUFYLElBQWdDeDNFLE1BQU11M0UsT0FBTixFQUFoQyxJQUFtRHYzRSxNQUFNeTNFLE9BQU4sRUFBdkQsRUFBd0U7QUFDdEV6M0Usd0JBQVEyMkUsT0FBT0ksWUFBUCxJQUF1QixJQUFJVyxlQUFKLENBQVU7QUFDdkNsWCwwQkFBUSxJQUFJNFgsZ0JBQUo7QUFEK0IsaUJBQVYsQ0FBL0I7QUFHRDtBQUNENVgsdUJBQVN4Z0UsTUFBTXczRSxTQUFOLEVBQVQ7QUFDQWhYLHFCQUFPMFgsUUFBUCxDQUFnQmQsV0FBaEI7QUFDQTVXLHFCQUFPNlgsUUFBUCxDQUFnQixDQUFoQjtBQUNBcjRFLG9CQUFNNDNFLFNBQU4sQ0FBZ0I1akUsS0FBaEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxZQUFJdFQsUUFBUSxDQUFSLElBQWFwRCxPQUFNb0QsSUFBTixJQUFjLE1BQS9CLEVBQXVDO0FBQUE7QUFDckN5SCxvQkFBUSxFQUFFLGtCQUFrQnJILEtBQXBCLEtBQThCLGdCQUFnQkEsS0FBOUMsR0FDTnEzRSxpQkFBaUJyRCxTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsWUFBekIsRUFBdUN5RCxJQUF2QyxFQUE2QzBqQixDQUE3QyxDQUFqQixFQUFrRXF3RCxTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsY0FBekIsRUFBeUN5RCxJQUF6QyxFQUErQzBqQixDQUEvQyxDQUFsRSxDQURNLEdBRU4va0IsU0FGRjtBQUdBLGdCQUFNbU4sUUFBUWlvRSxTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsWUFBekIsRUFBdUN5RCxJQUF2QyxFQUE2QzBqQixDQUE3QyxDQUFkO0FBQ0EsZ0JBQUl0YyxTQUFTMEUsUUFBUSxDQUFyQixFQUF3QjtBQUN0QixnQkFBRWtxRSxZQUFGO0FBQ0Esa0JBQUkzc0QsUUFBUXlzRCxRQUFSLENBQWlCOTFFLElBQWpCLEVBQXVCdEUsT0FBdkIsQ0FBK0J1SyxRQUEvQixNQUE0QyxDQUFDLENBQWpELEVBQW9EO0FBQ2xEb2pCLHdCQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsRUFBdUJyRSxJQUF2QixDQUE0QnNLLFFBQTVCO0FBQ0Q7QUFDRGhILHNCQUFRMjJFLE9BQU9JLFlBQVAsQ0FBUjtBQUNBLGtCQUFJLENBQUMvMkUsS0FBRCxJQUFVLENBQUNBLE1BQU13M0UsU0FBTixFQUFYLElBQWdDeDNFLE1BQU11M0UsT0FBTixFQUFoQyxJQUFtRHYzRSxNQUFNeTNFLE9BQU4sRUFBdkQsRUFBd0U7QUFDdEV6M0Usd0JBQVEyMkUsT0FBT0ksWUFBUCxJQUF1QixJQUFJVyxlQUFKLENBQVU7QUFDdkNsWCwwQkFBUSxJQUFJNFgsZ0JBQUo7QUFEK0IsaUJBQVYsQ0FBL0I7QUFHRDtBQUNENVgsdUJBQVN4Z0UsTUFBTXczRSxTQUFOLEVBQVQ7QUFDQWhYLHFCQUFPOFgsVUFBUCxDQUFrQnhELFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixVQUExQixFQUFzQ3lELElBQXRDLEVBQTRDMGpCLENBQTVDLENBQWxCO0FBQ0ErN0MscUJBQU8rWCxXQUFQLENBQW1CekQsU0FBU3gzRSxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLFdBQTFCLEVBQXVDeUQsSUFBdkMsRUFBNkMwakIsQ0FBN0MsQ0FBbkI7QUFDQSs3QyxxQkFBT2dZLGFBQVAsQ0FBcUIxRCxTQUFTeDNFLE1BQVQsRUFBZ0IsUUFBaEIsRUFBMEIsa0JBQTFCLEVBQThDeUQsSUFBOUMsRUFBb0QwakIsQ0FBcEQsQ0FBckI7QUFDQSs3QyxxQkFBTzBYLFFBQVAsQ0FBZ0IvdkUsS0FBaEI7QUFDQXE0RCxxQkFBTzZYLFFBQVAsQ0FBZ0J4ckUsS0FBaEI7QUFDQTJ6RCxxQkFBT2lZLFdBQVAsQ0FBbUIzM0UsTUFBTSxnQkFBTixJQUNqQmcwRSxTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsZ0JBQXpCLEVBQTJDeUQsSUFBM0MsRUFBaUQwakIsQ0FBakQsRUFBb0Ryb0IsR0FBcEQsQ0FBd0QsVUFBU3dlLENBQVQsRUFBWTtBQUNsRSx1QkFBT0EsSUFBSS9OLEtBQVg7QUFDRCxlQUZELENBRGlCLEdBR1osSUFIUDtBQUlBN00sb0JBQU00M0UsU0FBTixDQUFnQjVqRSxLQUFoQjtBQUNEO0FBM0JvQztBQTRCdEM7O0FBRUQsWUFBSTBrRSxXQUFXLEtBQWY7QUFDQSxZQUFJNXhELE9BQU8sSUFBWDtBQUNBLFlBQUk2eEQsa0JBQUo7QUFDQSxZQUFJLENBQUNqNEUsUUFBUSxDQUFSLElBQWFBLFFBQVEsQ0FBdEIsS0FBNEIsZ0JBQWdCbkQsTUFBaEQsRUFBd0Q7QUFDdEQsY0FBTTg1RSxhQUFZdkMsU0FBU3gzRSxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLFlBQTFCLEVBQXdDeUQsSUFBeEMsRUFBOEMwakIsQ0FBOUMsQ0FBbEI7QUFDQSxjQUFJNHlELFVBQUosRUFBZTtBQUNiL0MsbUJBQU8sT0FBTytDLFVBQVAsS0FBcUIsUUFBckIsR0FDSEMsYUFBYUQsVUFBYixFQUF3QjFuRSxVQUF4QixDQURHLEdBRUgwbkUsV0FBVWoyRSxRQUFWLEVBRko7QUFHQSxnQkFBSXczRSxZQUFZbDVFLFNBQWhCO0FBQ0EsZ0JBQUlzMUUsZUFBZXIyRSxVQUFmLElBQTZCQSxXQUFXMjFFLElBQVgsQ0FBakMsRUFBbUQ7QUFDakQsa0JBQUk1ekUsUUFBUSxDQUFaLEVBQWU7QUFDYixvQkFBTW00RSxPQUFPenVELFFBQVEwc0QsV0FBUixFQUFiO0FBQ0E7QUFDQSxvQkFBSStCLEtBQUtDLGVBQVQsRUFBMEI7QUFDeEIsc0JBQU0vbkIsU0FBUzhuQixLQUFLcDJFLFNBQUwsRUFBZjtBQUNBLHNCQUFNRSxPQUFPK1QsS0FBSzdHLElBQUwsQ0FBVTZHLEtBQUtsRyxHQUFMLENBQ3JCa0csS0FBS3VXLEdBQUwsQ0FBUyxDQUFDOGpDLE9BQU8sQ0FBUCxJQUFZQSxPQUFPLENBQVAsQ0FBYixJQUEwQjJCLFVBQW5DLEVBQStDLENBQS9DLENBRHFCLEVBRXJCaDhDLEtBQUt1VyxHQUFMLENBQVMsQ0FBQzhqQyxPQUFPLENBQVAsSUFBWUEsT0FBTyxDQUFQLENBQWIsSUFBMEIyQixVQUFuQyxFQUErQyxDQUEvQyxDQUZxQixDQUFWLENBQWI7QUFHQSxzQkFBSS92RCxPQUFPLEdBQVgsRUFBZ0I7QUFDZDtBQUNBaTJFLGdDQUFZLElBQUl0cUUsZUFBSixDQUFVdXFFLEtBQUtDLGVBQUwsRUFBVixDQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Qsa0JBQUlwNEUsU0FBUyxDQUFULElBQWNrNEUsU0FBbEIsRUFBNkI7QUFDM0Isa0JBQUU3QixZQUFGO0FBQ0Esb0JBQUkzc0QsUUFBUXlzRCxRQUFSLENBQWlCOTFFLElBQWpCLEVBQXVCdEUsT0FBdkIsQ0FBK0J1SyxRQUEvQixNQUE0QyxDQUFDLENBQWpELEVBQW9EO0FBQ2xEb2pCLDBCQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsRUFBdUJyRSxJQUF2QixDQUE0QnNLLFFBQTVCO0FBQ0Q7QUFDRGhILHdCQUFRMjJFLE9BQU9JLFlBQVAsQ0FBUjtBQUNBLG9CQUFJLENBQUMvMkUsS0FBRCxJQUFVLENBQUNBLE1BQU1nRyxRQUFOLEVBQVgsSUFBK0JoRyxNQUFNdTNFLE9BQU4sRUFBL0IsSUFBa0R2M0UsTUFBTXczRSxTQUFOLEVBQXRELEVBQXlFO0FBQ3ZFeDNFLDBCQUFRMjJFLE9BQU9JLFlBQVAsSUFBdUIsSUFBSVcsZUFBSixFQUEvQjtBQUNEO0FBQ0QxM0Usc0JBQU0rNEUsV0FBTixDQUFrQkgsU0FBbEI7QUFDQSxvQkFBTUksV0FBV2xFLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixXQUExQixFQUF1Q3lELElBQXZDLEVBQTZDMGpCLENBQTdDLENBQWpCO0FBQ0Esb0JBQU13MEQsWUFBWW40RSxNQUFNLFlBQU4sTUFBd0JwQixTQUF4QixHQUFvQ28xRSxTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsWUFBekIsRUFBdUN5RCxJQUF2QyxFQUE2QzBqQixDQUE3QyxDQUFwQyxHQUFzRixJQUF4RztBQUNBLG9CQUFNeTBELGdCQUFnQnBFLFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5QixnQkFBekIsRUFBMkN5RCxJQUEzQyxFQUFpRDBqQixDQUFqRCxDQUF0QjtBQUNBLG9CQUFNMDBELHNCQUFzQnJFLFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5Qix1QkFBekIsRUFBa0R5RCxJQUFsRCxFQUF3RDBqQixDQUF4RCxDQUE1QjtBQUNBLG9CQUFNMjBELGtCQUFrQnRFLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixhQUExQixFQUF5Q3lELElBQXpDLEVBQStDMGpCLENBQS9DLENBQXhCO0FBQ0Esb0JBQU00MEQsYUFBYXZFLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixhQUExQixFQUF5Q3lELElBQXpDLEVBQStDMGpCLENBQS9DLENBQW5COztBQWYyQix3Q0FtQnZCNjBELGlCQUFpQkYsZUFBakIsQ0FuQnVCO0FBQUEsb0JBaUJ6QkcsWUFqQnlCLHFCQWlCekJBLFlBakJ5QjtBQUFBLDhEQWtCekJDLFVBbEJ5QjtBQUFBLG9CQWtCekJBLFVBbEJ5Qix5Q0FrQlpKLGVBbEJZOztBQW9CM0Isb0JBQUl2QixrQkFBaUJ2RCxPQUFPLEdBQVAsR0FBYTBFLFFBQWIsR0FBd0IsR0FBeEIsR0FBOEJFLGFBQTlCLEdBQThDLEdBQTlDLEdBQW9EQyxtQkFBcEQsR0FBMEUsR0FBMUUsR0FBZ0ZLLFVBQWhGLEdBQTZGLEdBQTdGLEdBQW1HSCxVQUFuRyxHQUFnSCxHQUFoSCxHQUFzSEUsWUFBM0k7QUFDQSxvQkFBSU4sY0FBYyxJQUFsQixFQUF3QjtBQUN0QnBCLHFDQUFrQixNQUFNb0IsU0FBeEI7QUFDRDtBQUNEL0IsMEJBQVVSLGVBQWVtQixlQUFmLENBQVY7QUFDQSxvQkFBSSxDQUFDWCxPQUFMLEVBQWM7QUFDWixzQkFBTWEsbUJBQWtCcDVFLFdBQVcyMUUsSUFBWCxDQUF4QjtBQUNBLHNCQUFNbHdCLFVBQVN4bkQsU0FBU0csYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0FxbkQsMEJBQU92M0MsS0FBUCxHQUFla3JFLGlCQUFnQmxyRSxLQUEvQjtBQUNBdTNDLDBCQUFPdDNDLE1BQVAsR0FBZ0JpckUsaUJBQWdCanJFLE1BQWhDO0FBQ0Esc0JBQU0wYixRQUFNNDdCLFFBQU9nRyxVQUFQLENBQWtCLElBQWxCLENBQVo7QUFDQTVoQyx3QkFBSXkyQyxTQUFKLENBQ0UrVixXQURGLEVBRUUrQyxpQkFBZ0JuOUQsQ0FGbEIsRUFHRW05RCxpQkFBZ0JudEQsQ0FIbEIsRUFJRW10RCxpQkFBZ0JsckUsS0FKbEIsRUFLRWtyRSxpQkFBZ0JqckUsTUFMbEIsRUFNRSxDQU5GLEVBT0UsQ0FQRixFQVFFaXJFLGlCQUFnQmxyRSxLQVJsQixFQVNFa3JFLGlCQUFnQmpyRSxNQVRsQjtBQVdBLHNCQUFNNUcsT0FBT3NpQixNQUFJaXhELFlBQUosQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUJyMUIsUUFBT3YzQyxLQUE5QixFQUFxQ3UzQyxRQUFPdDNDLE1BQTVDLENBQWI7QUFDQSxzQkFBSW1zRSxjQUFjLElBQWxCLEVBQXdCO0FBQ3RCO0FBQ0E5d0UsNEJBQVFnd0UsaUJBQWlCYyxTQUFqQixFQUE0QixDQUE1QixDQUFSO0FBQ0EseUJBQUssSUFBSXZ2RCxJQUFJLENBQVIsRUFBV2d3RCxLQUFLeHpFLEtBQUtBLElBQUwsQ0FBVW5LLE1BQS9CLEVBQXVDMnRCLElBQUlnd0QsRUFBM0MsRUFBK0Nod0QsS0FBSyxDQUFwRCxFQUF1RDtBQUNyRHhqQiwyQkFBS0EsSUFBTCxDQUFVd2pCLENBQVYsSUFBZXZoQixNQUFNLENBQU4sQ0FBZjtBQUNBakMsMkJBQUtBLElBQUwsQ0FBVXdqQixJQUFJLENBQWQsSUFBbUJ2aEIsTUFBTSxDQUFOLENBQW5CO0FBQ0FqQywyQkFBS0EsSUFBTCxDQUFVd2pCLElBQUksQ0FBZCxJQUFtQnZoQixNQUFNLENBQU4sQ0FBbkI7QUFDRDtBQUNGO0FBQ0RxZ0Isd0JBQUlteEQsWUFBSixDQUFpQnp6RSxJQUFqQixFQUF1QixDQUF2QixFQUEwQixDQUExQjtBQUNBLHNCQUFNMHpFLGtCQUFrQixDQUFDVixjQUFjLENBQWQsSUFBbUJuQixpQkFBZ0JsckUsS0FBcEMsRUFBMkNxc0UsY0FBYyxDQUFkLElBQW1CbkIsaUJBQWdCanJFLE1BQTlFLENBQXhCO0FBQ0FvcUUsNEJBQVVSLGVBQWVtQixlQUFmLElBQWlDLElBQUlnQyxjQUFKLENBQVM7QUFDbEQzRSx5QkFBSzl3QixPQUQ2QztBQUVsRDAxQixrQ0FBY04sVUFGb0M7QUFHbER0eEUsNEJBQVEsQ0FBQ214RSxXQUFXLENBQVgsSUFBZ0JFLGFBQWEsQ0FBYixDQUFoQixHQUFrQ0ssZ0JBQWdCLENBQWhCLENBQW5DLEVBQXVEUCxXQUFXLENBQVgsSUFBZ0JFLGFBQWEsQ0FBYixDQUFoQixHQUFrQ0ssZ0JBQWdCLENBQWhCLENBQXpGLENBSDBDO0FBSWxERyw2QkFBUyxDQUFDMzFCLFFBQU92M0MsS0FBUixFQUFldTNDLFFBQU90M0MsTUFBdEIsQ0FKeUM7QUFLbERpYSwyQkFBT2l5RCxXQUFXakIsaUJBQWdCNVo7QUFMZ0IsbUJBQVQsQ0FBM0M7QUFPRDtBQUNELG9CQUFJNmIsY0FBY2xGLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixhQUExQixFQUF5Q3lELElBQXpDLEVBQStDMGpCLENBQS9DLENBQWxCO0FBQ0Esb0JBQUl1MUQsWUFBWXY5RSxPQUFaLElBQXVCdTlFLFlBQVl2OUUsT0FBWixDQUFvQixHQUFwQixNQUE2QixDQUF4RCxFQUEyRDtBQUN6RHU5RSxnQ0FBYyxNQUFNMUMsYUFBYTBDLFdBQWIsRUFBMEJycUUsVUFBMUIsQ0FBcEI7QUFDRDtBQUNEdW5FLHdCQUFRK0MsV0FBUixDQUFvQixtQkFBUUQsV0FBUixDQUFwQjtBQUNBOUMsd0JBQVFnRCxVQUFSLENBQW1CcEYsU0FBU3gzRSxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGNBQXpCLEVBQXlDeUQsSUFBekMsRUFBK0MwakIsQ0FBL0MsQ0FBbkI7QUFDQXprQixzQkFBTW02RSxRQUFOLENBQWVqRCxPQUFmO0FBQ0Fwd0QsdUJBQU85bUIsTUFBTXkzRSxPQUFOLEVBQVA7QUFDQXozRSxzQkFBTW82RSxPQUFOLENBQWMxNkUsU0FBZDtBQUNBTSxzQkFBTTQzRSxTQUFOLENBQWdCLFFBQVE1akUsS0FBeEI7QUFDQTBrRSwyQkFBVyxJQUFYO0FBQ0FDLDRCQUFZLEtBQVo7QUFDRCxlQTFFRCxNQTBFTztBQUNMQSw0QkFBWSxJQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsWUFBSWo0RSxRQUFRLENBQVIsSUFBYSxtQkFBbUJJLEtBQXBDLEVBQTJDO0FBQ3pDLFlBQUVpMkUsWUFBRjtBQUNBLGNBQUkzc0QsUUFBUXlzRCxRQUFSLENBQWlCOTFFLElBQWpCLEVBQXVCdEUsT0FBdkIsQ0FBK0J1SyxRQUEvQixNQUE0QyxDQUFDLENBQWpELEVBQW9EO0FBQ2xEb2pCLG9CQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsRUFBdUJyRSxJQUF2QixDQUE0QnNLLFFBQTVCO0FBQ0Q7QUFDRGhILGtCQUFRMjJFLE9BQU9JLFlBQVAsQ0FBUjtBQUNBLGNBQUksQ0FBQy8yRSxLQUFELElBQVUsQ0FBQ0EsTUFBTWdHLFFBQU4sRUFBWCxJQUErQmhHLE1BQU11M0UsT0FBTixFQUEvQixJQUFrRHYzRSxNQUFNdzNFLFNBQU4sRUFBdEQsRUFBeUU7QUFDdkV4M0Usb0JBQVEyMkUsT0FBT0ksWUFBUCxJQUF1QixJQUFJVyxlQUFKLEVBQS9CO0FBQ0Q7QUFDRCxjQUFNMkMsZUFBZXZGLFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5QixlQUF6QixFQUEwQ3lELElBQTFDLEVBQWdEMGpCLENBQWhELENBQXJCO0FBQ0EsY0FBTTYxRCxvQkFBb0J4RixTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIscUJBQXpCLEVBQWdEeUQsSUFBaEQsRUFBc0QwakIsQ0FBdEQsQ0FBMUI7QUFDQSxjQUFNODFELGNBQWN6RixTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsY0FBekIsRUFBeUN5RCxJQUF6QyxFQUErQzBqQixDQUEvQyxDQUFwQjtBQUNBLGNBQU0rMUQsZ0JBQWdCMUYsU0FBU3gzRSxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGdCQUF6QixFQUEyQ3lELElBQTNDLEVBQWlEMGpCLENBQWpELENBQXRCO0FBQ0EsY0FBTWcyRCxvQkFBb0IzRixTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIscUJBQXpCLEVBQWdEeUQsSUFBaEQsRUFBc0QwakIsQ0FBdEQsQ0FBMUI7QUFDQSxjQUFNaTJELHNCQUFzQjVGLFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5Qix1QkFBekIsRUFBa0R5RCxJQUFsRCxFQUF3RDBqQixDQUF4RCxDQUE1QjtBQUNBLGNBQU1rMkQsWUFBWU4sZUFBZSxHQUFmLEdBQXFCQyxpQkFBckIsR0FBeUMsR0FBekMsR0FDaEJDLFdBRGdCLEdBQ0YsR0FERSxHQUNJQyxhQURKLEdBQ29CLEdBRHBCLEdBQzBCQyxpQkFEMUIsR0FDOEMsR0FEOUMsR0FDb0RDLG1CQUR0RTtBQUVBeEQsb0JBQVVSLGVBQWVpRSxTQUFmLENBQVY7QUFDQSxjQUFJLENBQUN6RCxPQUFMLEVBQWM7QUFDWkEsc0JBQVUsSUFBSTBELGdCQUFKLENBQVc7QUFDbkIvTyxzQkFBUXdPLFlBRFc7QUFFbkI3WixzQkFBUWlhLHNCQUFzQixDQUF0QixHQUEwQi82RSxTQUExQixHQUFzQyxJQUFJMDRFLGdCQUFKLENBQVc7QUFDdkR2ckUsdUJBQU80dEUsaUJBRGdEO0FBRXZEdHlFLHVCQUFPZ3dFLGlCQUFpQm1DLGlCQUFqQixFQUFvQ0ksbUJBQXBDO0FBRmdELGVBQVgsQ0FGM0I7QUFNbkIxdkUsb0JBQU0sSUFBSTJzRSxjQUFKLENBQVM7QUFDYnh2RSx1QkFBT2d3RSxpQkFBaUJvQyxXQUFqQixFQUE4QkMsYUFBOUI7QUFETSxlQUFUO0FBTmEsYUFBWCxDQUFWO0FBVUQ7QUFDRHg2RSxnQkFBTW02RSxRQUFOLENBQWVqRCxPQUFmO0FBQ0Fwd0QsaUJBQU85bUIsTUFBTXkzRSxPQUFOLEVBQVA7QUFDQXozRSxnQkFBTW82RSxPQUFOLENBQWMxNkUsU0FBZDtBQUNBTSxnQkFBTSs0RSxXQUFOLENBQWtCcjVFLFNBQWxCO0FBQ0FNLGdCQUFNNDNFLFNBQU4sQ0FBZ0IsUUFBUTVqRSxLQUF4QjtBQUNBMGtFLHFCQUFXLElBQVg7QUFDRDs7QUFFRCxZQUFJdG1ELGNBQUo7QUFDQSxZQUFJLGdCQUFnQjcwQixNQUFwQixFQUE0QjtBQUMxQixjQUFNczlFLFlBQVkvRixTQUFTeDNFLE1BQVQsRUFBZ0IsUUFBaEIsRUFBMEIsWUFBMUIsRUFBd0N5RCxJQUF4QyxFQUE4QzBqQixDQUE5QyxDQUFsQjtBQUNBMk4sa0JBQVFrbEQsYUFBYXVELFNBQWIsRUFBd0JsckUsVUFBeEIsQ0FBUjtBQUNEO0FBQ0QsWUFBSXlpQixTQUFTLENBQUN1bUQsU0FBZCxFQUF5QjtBQUN2QixjQUFJLENBQUNELFFBQUwsRUFBZTtBQUNiLGNBQUUzQixZQUFGO0FBQ0EsZ0JBQUkzc0QsUUFBUXlzRCxRQUFSLENBQWlCOTFFLElBQWpCLEVBQXVCdEUsT0FBdkIsQ0FBK0J1SyxRQUEvQixNQUE0QyxDQUFDLENBQWpELEVBQW9EO0FBQ2xEb2pCLHNCQUFReXNELFFBQVIsQ0FBaUI5MUUsSUFBakIsRUFBdUJyRSxJQUF2QixDQUE0QnNLLFFBQTVCO0FBQ0Q7QUFDRGhILG9CQUFRMjJFLE9BQU9JLFlBQVAsQ0FBUjtBQUNBLGdCQUFJLENBQUMvMkUsS0FBRCxJQUFVLENBQUNBLE1BQU15M0UsT0FBTixFQUFYLElBQThCejNFLE1BQU11M0UsT0FBTixFQUE5QixJQUFpRHYzRSxNQUFNdzNFLFNBQU4sRUFBckQsRUFBd0U7QUFDdEV4M0Usc0JBQVEyMkUsT0FBT0ksWUFBUCxJQUF1QixJQUFJVyxlQUFKLEVBQS9CO0FBQ0Q7QUFDRDEzRSxrQkFBTW02RSxRQUFOLENBQWV6NkUsU0FBZjtBQUNBTSxrQkFBTSs0RSxXQUFOLENBQWtCcjVFLFNBQWxCO0FBQ0Q7QUFDRCxjQUFJLENBQUNNLE1BQU15M0UsT0FBTixFQUFMLEVBQXNCO0FBQ3BCejNFLGtCQUFNbzZFLE9BQU4sQ0FBY3R6RCxRQUFRLElBQUlnMEQsY0FBSixFQUF0QjtBQUNEO0FBQ0RoMEQsaUJBQU85bUIsTUFBTXkzRSxPQUFOLEVBQVA7QUFDQSxjQUFNc0QsV0FBV2pHLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixXQUExQixFQUF1Q3lELElBQXZDLEVBQTZDMGpCLENBQTdDLENBQWpCO0FBQ0EsY0FBTXUyRCxpQkFBaUJsRyxTQUFTeDNFLE1BQVQsRUFBZ0IsUUFBaEIsRUFBMEIsa0JBQTFCLEVBQThDeUQsSUFBOUMsRUFBb0QwakIsQ0FBcEQsQ0FBdkI7QUFDQSxjQUFNcG9CLE9BQU8sK0JBQU80K0UsV0FBV25HLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixXQUExQixFQUF1Q3lELElBQXZDLEVBQTZDMGpCLENBQTdDLENBQVgsQ0FBUCxFQUFvRXMyRCxRQUFwRSxDQUFiO0FBQ0EsY0FBTUcsZ0JBQWdCMzlFLE9BQU8sZ0JBQVAsQ0FBdEI7QUFDQSxjQUFJMjlFLGlCQUFpQixXQUFyQixFQUFrQztBQUNoQzlvRCxvQkFBUUEsTUFBTThJLFdBQU4sRUFBUjtBQUNELFdBRkQsTUFFTyxJQUFJZ2dELGlCQUFpQixXQUFyQixFQUFrQztBQUN2QzlvRCxvQkFBUUEsTUFBTTFZLFdBQU4sRUFBUjtBQUNEO0FBQ0QsY0FBTXloRSxlQUFlejZFLFFBQVEsQ0FBUixHQUFZMHhCLEtBQVosR0FBb0J5akQsU0FBU3pqRCxLQUFULEVBQWdCLzFCLElBQWhCLEVBQXNCeTRFLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixnQkFBMUIsRUFBNEN5RCxJQUE1QyxFQUFrRDBqQixDQUFsRCxDQUF0QixDQUF6QztBQUNBcUMsZUFBS3N6RCxPQUFMLENBQWFlLFlBQWI7QUFDQXIwRCxlQUFLczBELE9BQUwsQ0FBYS8rRSxJQUFiO0FBQ0F5cUIsZUFBS216RCxXQUFMLENBQWlCLG1CQUFRbkYsU0FBU3gzRSxNQUFULEVBQWdCLFFBQWhCLEVBQTBCLGFBQTFCLEVBQXlDeUQsSUFBekMsRUFBK0MwakIsQ0FBL0MsQ0FBUixDQUFqQjtBQUNBLGNBQU00MkQsYUFBYXZHLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixhQUExQixFQUF5Q3lELElBQXpDLEVBQStDMGpCLENBQS9DLENBQW5CO0FBQ0EsY0FBTTYyRCxZQUFhNUMsWUFBWWg0RSxRQUFRLENBQXJCLEdBQTBCLE9BQTFCLEdBQW9DbzBFLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixrQkFBMUIsRUFBOEN5RCxJQUE5QyxFQUFvRDBqQixDQUFwRCxDQUF0RDtBQUNBcUMsZUFBS3kwRCxZQUFMLENBQWtCRCxTQUFsQjtBQUNBLGNBQUlFLGdCQUFnQjFHLFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5QixpQkFBekIsRUFBNEN5RCxJQUE1QyxFQUFrRDBqQixDQUFsRCxDQUFwQjtBQUNBLGNBQU1nM0QsYUFBYTNHLFNBQVN4M0UsTUFBVCxFQUFnQixRQUFoQixFQUEwQixhQUExQixFQUF5Q3lELElBQXpDLEVBQStDMGpCLENBQS9DLENBQW5CO0FBQ0EsY0FBTWkzRCxnQkFBZ0I1RyxTQUFTeDNFLE1BQVQsRUFBZ0IsT0FBaEIsRUFBeUIsZ0JBQXpCLEVBQTJDeUQsSUFBM0MsRUFBaUQwakIsQ0FBakQsQ0FBdEI7QUFDQSxjQUFJazNELFVBQVUsQ0FBZDtBQUNBLGNBQUlDLFVBQVUsQ0FBZDtBQUNBLGNBQUlDLFlBQVksUUFBaEI7QUFDQSxjQUFJUixXQUFXNStFLE9BQVgsQ0FBbUIsTUFBbkIsTUFBK0IsQ0FBQyxDQUFwQyxFQUF1QztBQUNyQ28vRSx3QkFBWSxNQUFaO0FBQ0FELHNCQUFVSixhQUFWO0FBQ0QsV0FIRCxNQUdPLElBQUlILFdBQVc1K0UsT0FBWCxDQUFtQixPQUFuQixNQUFnQyxDQUFDLENBQXJDLEVBQXdDO0FBQzdDby9FLHdCQUFZLE9BQVo7QUFDQUQsc0JBQVUsQ0FBQ0osYUFBWDtBQUNEO0FBQ0QsY0FBSUYsYUFBYSxPQUFqQixFQUEwQjtBQUN4QngwRCxpQkFBS2cxRCxZQUFMLENBQWtCRCxTQUFsQjtBQUNELFdBRkQsTUFFTztBQUNMLzBELGlCQUFLaTFELFdBQUwsQ0FBaUIsbUJBQVFqSCxTQUFTeDNFLE1BQVQsRUFBZ0IsUUFBaEIsRUFBMEIsZ0JBQTFCLEVBQTRDeUQsSUFBNUMsRUFBa0QwakIsQ0FBbEQsQ0FBUixJQUFnRTJOLE1BQU1yMkIsTUFBdEUsR0FBK0VvL0UsYUFBYXAvRSxNQUE3RztBQUNBK3FCLGlCQUFLZzFELFlBQUw7QUFDRDtBQUNELGNBQUlFLGVBQWUsUUFBbkI7QUFDQSxjQUFJWCxXQUFXNStFLE9BQVgsQ0FBbUIsUUFBbkIsS0FBZ0MsQ0FBcEMsRUFBdUM7QUFDckN1L0UsMkJBQWUsUUFBZjtBQUNBTCxzQkFBVSxDQUFDSCxhQUFELEdBQWtCLE9BQU9SLGlCQUFpQixDQUF4QixDQUFELEdBQStCRCxRQUExRDtBQUNELFdBSEQsTUFHTyxJQUFJTSxXQUFXNStFLE9BQVgsQ0FBbUIsS0FBbkIsS0FBNkIsQ0FBakMsRUFBb0M7QUFDekN1L0UsMkJBQWUsS0FBZjtBQUNBTCxzQkFBVUgsZ0JBQWlCLE9BQU9SLGlCQUFpQixDQUF4QixDQUFELEdBQStCRCxRQUF6RDtBQUNEO0FBQ0RqMEQsZUFBS20xRCxlQUFMLENBQXFCRCxZQUFyQjtBQUNBbDFELGVBQUtvMUQsVUFBTCxDQUFnQlQsV0FBVyxDQUFYLElBQWdCVixRQUFoQixHQUEyQmEsT0FBM0IsR0FBcUNGLGNBQWMsQ0FBZCxDQUFyRDtBQUNBNTBELGVBQUtxMUQsVUFBTCxDQUFnQlYsV0FBVyxDQUFYLElBQWdCVixRQUFoQixHQUEyQlksT0FBM0IsR0FBcUNELGNBQWMsQ0FBZCxDQUFyRDtBQUNBcjZFLG9CQUFVeXpFLFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5QixjQUF6QixFQUF5Q3lELElBQXpDLEVBQStDMGpCLENBQS9DLENBQVY7QUFDQSxjQUFNd0MsWUFBWSxJQUFJMHdELGNBQUosRUFBbEI7O0FBRUExd0Qsb0JBQVVpeEQsUUFBVixDQUFtQkMsaUJBQWlCckQsU0FBU3gzRSxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLFlBQXpCLEVBQXVDeUQsSUFBdkMsRUFBNkMwakIsQ0FBN0MsQ0FBakIsRUFBa0VwakIsT0FBbEUsS0FBNkUsZUFBaEc7QUFDQXlsQixlQUFLczFELE9BQUwsQ0FBYW4xRCxTQUFiO0FBQ0EsY0FBTW8xRCxZQUFZbEUsaUJBQWlCckQsU0FBU3gzRSxNQUFULEVBQWdCLE9BQWhCLEVBQXlCLGlCQUF6QixFQUE0Q3lELElBQTVDLEVBQWtEMGpCLENBQWxELENBQWpCLEVBQXVFcGpCLE9BQXZFLENBQWxCO0FBQ0EsY0FBSWc3RSxTQUFKLEVBQWU7QUFDYixnQkFBTUMsV0FBVyxJQUFJbEUsZ0JBQUosRUFBakI7QUFDQWtFLHFCQUFTcEUsUUFBVCxDQUFrQm1FLFNBQWxCO0FBQ0FDLHFCQUFTakUsUUFBVCxDQUFrQnZELFNBQVN4M0UsTUFBVCxFQUFnQixPQUFoQixFQUF5QixpQkFBekIsRUFBNEN5RCxJQUE1QyxFQUFrRDBqQixDQUFsRCxDQUFsQjtBQUNBcUMsaUJBQUt5MUQsU0FBTCxDQUFlRCxRQUFmO0FBQ0QsV0FMRCxNQUtPO0FBQ0x4MUQsaUJBQUt5MUQsU0FBTCxDQUFlNzhFLFNBQWY7QUFDRDtBQUNETSxnQkFBTTQzRSxTQUFOLENBQWdCLFFBQVE1akUsS0FBeEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsUUFBSStpRSxlQUFlLENBQUMsQ0FBcEIsRUFBdUI7QUFDckJKLGFBQU81NkUsTUFBUCxHQUFnQmc3RSxlQUFlLENBQS9CO0FBQ0EsYUFBT0osTUFBUDtBQUNEO0FBQ0YsR0FoWUQ7O0FBa1lBNUIsVUFBUTkwRSxRQUFSLENBQWlCczBDLGFBQWpCO0FBQ0F3Z0MsVUFBUXZ1RSxHQUFSLENBQVksZUFBWixFQUE2Qjh2RSxZQUE3QjtBQUNBdkIsVUFBUXZ1RSxHQUFSLENBQVksZUFBWixFQUE2QjZ2RSxZQUE3QjtBQUNBLFNBQU85aEMsYUFBUDtBQUNELEM7O0FBL3NCRDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQU9BOzs7O0FBQ0E7Ozs7QUFNQSxJQUFNOXlCLGFBQWF0TSw0QkFBR3NNLFVBQXRCLEMsQ0EzQkE7Ozs7OztBQTRCQSxJQUFNNmQsa0JBQWtCbnFCLDRCQUFHbXFCLGVBQTNCO0FBQ0EsSUFBTXhCLGVBQWVqeUIsOEJBQVdpeUIsWUFBaEM7QUFDQSxJQUFNUywyQkFBMkIxeUIsOEJBQVcweUIsd0JBQTVDOztBQUVBLElBQU1qVyxRQUFRO0FBQ1osV0FBUyxDQURHO0FBRVosZ0JBQWMsQ0FGRjtBQUdaLGdCQUFjLENBSEY7QUFJWixxQkFBbUIsQ0FKUDtBQUtaLGFBQVcsQ0FMQztBQU1aLGtCQUFnQjtBQU5KLENBQWQ7QUFRQSxJQUFNazBELGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBU0MsYUFBVCxFQUF3QjNnRCxZQUF4QixFQUFzQztBQUMzRCxNQUFNNGdELHFCQUFxQm4rQyx5QkFBeUJrK0MsYUFBekIsRUFBd0MzZ0QsWUFBeEMsQ0FBM0I7QUFDQSxNQUFJNGdELG1CQUFtQjluRSxNQUFuQixLQUE4QixPQUFsQyxFQUEyQztBQUN6QyxVQUFNLElBQUluVyxLQUFKLENBQVVpK0UsbUJBQW1COTBFLEtBQW5CLENBQXlCeEwsR0FBekIsQ0FBNkI7QUFBQSxhQUFVeUQsSUFBSWtGLEdBQWQsVUFBc0JsRixJQUFJOGlCLE9BQTFCO0FBQUEsS0FBN0IsRUFBa0U3YixJQUFsRSxDQUF1RSxJQUF2RSxDQUFWLENBQU47QUFDRDtBQUNELFNBQU80MUUsbUJBQW1COTBFLEtBQTFCO0FBQ0QsQ0FORDs7QUFRQSxJQUFNcXZFLFdBQVcsRUFBakI7QUFDQSxJQUFNMEYsVUFBVSxFQUFDNTdFLE1BQU0sQ0FBUCxFQUFoQjtBQUNBLElBQU15MUUsZ0JBQWdCLEVBQXRCOztBQUVBOzs7Ozs7Ozs7QUFTTyxTQUFTMUIsUUFBVCxDQUFrQngzRSxLQUFsQixFQUF5QnMvRSxhQUF6QixFQUF3Q25xRSxRQUF4QyxFQUFrRDFSLElBQWxELEVBQXdEcXBCLE9BQXhELEVBQWlFO0FBQ3RFLE1BQU1wakIsVUFBVTFKLE1BQU0rQyxFQUF0QjtBQUNBLE1BQUksQ0FBQ20yRSxjQUFjeHZFLE9BQWQsQ0FBTCxFQUE2QjtBQUMzQnd2RSxrQkFBY3h2RSxPQUFkLElBQXlCLEVBQXpCO0FBQ0Q7QUFDRCxNQUFNNjFFLFlBQVlyRyxjQUFjeHZFLE9BQWQsQ0FBbEI7QUFDQSxNQUFJLENBQUM2MUUsVUFBVXBxRSxRQUFWLENBQUwsRUFBMEI7QUFDeEIsUUFBSTdLLFFBQVEsQ0FBQ3RLLE1BQU1zL0UsYUFBTixLQUF3QjNGLFFBQXpCLEVBQW1DeGtFLFFBQW5DLENBQVo7QUFDQSxRQUFNcXBCLGVBQWVSLDBCQUFRc2hELGFBQVIsU0FBeUJ0L0UsTUFBTW9ELElBQS9CLEVBQXVDK1IsUUFBdkMsQ0FBckI7QUFDQSxRQUFJN0ssVUFBVWxJLFNBQWQsRUFBeUI7QUFDdkJrSSxjQUFRazBCLGFBQWFLLE9BQXJCO0FBQ0Q7QUFDRCxRQUFJMmdELFNBQVNoL0MsYUFBY2wyQixLQUFkLENBQWI7QUFDQSxRQUFJLENBQUNrMUUsTUFBRCxJQUFXcjdELFdBQVc3WixLQUFYLENBQWYsRUFBa0M7QUFDaENBLGNBQVEwM0IsZ0JBQWdCMTNCLEtBQWhCLEVBQXVCazBCLFlBQXZCLENBQVI7QUFDQWdoRCxlQUFTLElBQVQ7QUFDRDtBQUNELFFBQUlBLE1BQUosRUFBWTtBQUNWLFVBQU1KLHFCQUFxQkYsZUFBZTUwRSxLQUFmLEVBQXNCazBCLFlBQXRCLENBQTNCO0FBQ0ErZ0QsZ0JBQVVwcUUsUUFBVixJQUFzQmlxRSxtQkFBbUJqMEQsUUFBbkIsQ0FBNEJ1VSxJQUE1QixDQUFpQzAvQyxrQkFBakMsQ0FBdEI7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJNWdELGFBQWFwN0IsSUFBYixJQUFxQixPQUF6QixFQUFrQztBQUNoQ2tILGdCQUFRekcseUJBQU01QyxLQUFOLENBQVlxSixLQUFaLENBQVI7QUFDRDtBQUNEaTFFLGdCQUFVcHFFLFFBQVYsSUFBc0IsWUFBVztBQUMvQixlQUFPN0ssS0FBUDtBQUNELE9BRkQ7QUFHRDtBQUNGO0FBQ0QrMEUsVUFBUTU3RSxJQUFSLEdBQWVBLElBQWY7QUFDQSxTQUFPODdFLFVBQVVwcUUsUUFBVixFQUFvQmtxRSxPQUFwQixFQUE2QnZ5RCxPQUE3QixDQUFQO0FBQ0Q7O0FBRUQsU0FBU2t2RCxnQkFBVCxDQUEwQkUsVUFBMUIsRUFBc0M7QUFDcEMsTUFBSUQsZUFBZSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQW5CO0FBQ0EsTUFBSSxDQUFDLFVBQUQsRUFBYSxXQUFiLEVBQTBCLGFBQTFCLEVBQXlDLGNBQXpDLEVBQXlEOThFLE9BQXpELENBQWlFKzhFLFVBQWpFLElBQStFLENBQUMsQ0FBcEYsRUFBdUY7QUFDckZELG1CQUFlLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZjtBQUNEO0FBQ0QsTUFBSUMsZUFBZSxNQUFuQixFQUEyQjtBQUN6QkEsaUJBQWEsVUFBYjtBQUNBRCxtQkFBZSxDQUFDLENBQUQsRUFBSSxHQUFKLENBQWY7QUFDRDtBQUNELE1BQUlDLGVBQWUsT0FBbkIsRUFBNEI7QUFDMUJBLGlCQUFhLFVBQWI7QUFDQUQsbUJBQWUsQ0FBQyxDQUFELEVBQUksR0FBSixDQUFmO0FBQ0Q7QUFDRCxNQUFJQyxlQUFlLFFBQW5CLEVBQTZCO0FBQzNCQSxpQkFBYSxVQUFiO0FBQ0FELG1CQUFlLENBQUMsR0FBRCxFQUFNLENBQU4sQ0FBZjtBQUNEO0FBQ0QsTUFBSUMsZUFBZSxLQUFuQixFQUEwQjtBQUN4QkEsaUJBQWEsVUFBYjtBQUNBRCxtQkFBZSxDQUFDLEdBQUQsRUFBTSxDQUFOLENBQWY7QUFDRDtBQUNEO0FBQ0EsU0FBTztBQUNMQSxrQkFBY0EsWUFEVDtBQUVMQyxnQkFBWUE7QUFGUCxHQUFQO0FBSUQ7O0FBRUQsSUFBTXVELFVBQVUsRUFBaEI7O0FBRUEsU0FBUzlCLFVBQVQsQ0FBb0J4L0UsS0FBcEIsRUFBMkJGLGNBQTNCLEVBQTJDO0FBQ3pDLE1BQUl3aEYsUUFBUXRoRixLQUFSLENBQUosRUFBb0I7QUFDbEIsV0FBT3NoRixRQUFRdGhGLEtBQVIsQ0FBUDtBQUNEO0FBQ0QsTUFBSUYsY0FBSixFQUFvQjtBQUNsQixTQUFLLElBQUlHLElBQUksQ0FBUixFQUFXQyxLQUFLRixNQUFNTSxNQUEzQixFQUFtQ0wsSUFBSUMsRUFBdkMsRUFBMkMsRUFBRUQsQ0FBN0MsRUFBZ0Q7QUFDOUMsVUFBTVcsT0FBT1osTUFBTUMsQ0FBTixDQUFiO0FBQ0EsVUFBSUgsZUFBZWtCLE9BQWYsQ0FBdUJKLElBQXZCLEtBQWdDLENBQUMsQ0FBckMsRUFBd0M7QUFDdEMwZ0YsZ0JBQVF0aEYsS0FBUixJQUFpQlksSUFBakI7QUFDQTtBQUNEO0FBQ0Y7QUFDRCxRQUFJLENBQUMwZ0YsUUFBUXRoRixLQUFSLENBQUwsRUFBcUI7QUFDbkI7QUFDQXNoRixjQUFRdGhGLEtBQVIsSUFBaUJBLE1BQU1BLE1BQU1NLE1BQU4sR0FBZSxDQUFyQixDQUFqQjtBQUNEO0FBQ0YsR0FaRCxNQVlPO0FBQ0xnaEYsWUFBUXRoRixLQUFSLElBQWlCQSxNQUFNLENBQU4sQ0FBakI7QUFDRDtBQUNELFNBQU9zaEYsUUFBUXRoRixLQUFSLENBQVA7QUFDRDs7QUFFRCxJQUFNZzdFLGNBQWMsRUFBcEI7O0FBRUEsU0FBU1UsY0FBVCxDQUF3Qm53RSxPQUF4QixFQUFpQ2tELE1BQWpDLEVBQXlDa2dCLE9BQXpDLEVBQWtEcnBCLElBQWxELEVBQXdEO0FBQ3RELE1BQUksRUFBRWlHLFdBQVd5dkUsV0FBYixDQUFKLEVBQStCO0FBQzdCQSxnQkFBWXp2RSxPQUFaLElBQXVCLHNDQUFha0QsTUFBYixFQUFxQkEsTUFBNUM7QUFDRDtBQUNEeXlFLFVBQVE1N0UsSUFBUixHQUFlQSxJQUFmO0FBQ0EsU0FBTzAxRSxZQUFZenZFLE9BQVosRUFBcUIyMUUsT0FBckIsRUFBOEJ2eUQsT0FBOUIsQ0FBUDtBQUNEOztBQUdELFNBQVMrdEQsZ0JBQVQsQ0FBMEJod0UsS0FBMUIsRUFBaUM5RyxPQUFqQyxFQUEwQztBQUN4QyxNQUFJOEcsS0FBSixFQUFXO0FBQ1QsUUFBSUEsTUFBTXhCLENBQU4sS0FBWSxDQUFaLElBQWlCdEYsWUFBWSxDQUFqQyxFQUFvQztBQUNsQyxhQUFPM0IsU0FBUDtBQUNEO0FBQ0QsUUFBTWlILElBQUl3QixNQUFNeEIsQ0FBaEI7QUFDQXRGLGNBQVVBLFlBQVkzQixTQUFaLEdBQXdCLENBQXhCLEdBQTRCMkIsT0FBdEM7QUFDQSxXQUFPLFVBQVVxVixLQUFLdEssS0FBTCxDQUFXakUsTUFBTTNJLENBQU4sR0FBVSxHQUFWLEdBQWdCbUgsQ0FBM0IsQ0FBVixHQUEwQyxHQUExQyxHQUFnRCtQLEtBQUt0SyxLQUFMLENBQVdqRSxNQUFNdWQsQ0FBTixHQUFVLEdBQVYsR0FBZ0IvZSxDQUEzQixDQUFoRCxHQUNMLEdBREssR0FDQytQLEtBQUt0SyxLQUFMLENBQVdqRSxNQUFNd2QsQ0FBTixHQUFVLEdBQVYsR0FBZ0JoZixDQUEzQixDQURELEdBQ2lDLEdBRGpDLEdBQ3dDQSxJQUFJdEYsT0FENUMsR0FDdUQsR0FEOUQ7QUFFRDtBQUNELFNBQU84RyxLQUFQO0FBQ0Q7O0FBRUQsSUFBTTYwRSxnQkFBZ0Isd0JBQXRCOztBQUVBLFNBQVMxRixZQUFULENBQXNCeHdELElBQXRCLEVBQTRCblgsVUFBNUIsRUFBd0M7QUFDdEMsTUFBSTdSLGNBQUo7QUFDQSxLQUFHO0FBQ0RBLFlBQVFncEIsS0FBSy9vQixLQUFMLENBQVdpL0UsYUFBWCxDQUFSO0FBQ0EsUUFBSWwvRSxLQUFKLEVBQVc7QUFDVCxVQUFNOEosUUFBUStILFdBQVc3UixNQUFNLENBQU4sQ0FBWCxLQUF3QixFQUF0QztBQUNBZ3BCLGFBQU9ocEIsTUFBTSxDQUFOLElBQVc4SixLQUFYLEdBQW1COUosTUFBTSxDQUFOLENBQTFCO0FBQ0Q7QUFDRixHQU5ELFFBTVNBLEtBTlQ7QUFPQSxTQUFPZ3BCLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUN4TGdCd04sTyxHQUFBQSxPO1FBSUEyb0Qsb0IsR0FBQUEsb0I7QUFKVCxTQUFTM29ELE9BQVQsQ0FBaUI0b0QsT0FBakIsRUFBMEI7QUFDL0IsU0FBT0EsVUFBVXhtRSxLQUFLZ1csRUFBZixHQUFvQixHQUEzQjtBQUNEOztBQUVNLFNBQVN1d0Qsb0JBQVQsQ0FBOEJ2cUIsVUFBOUIsRUFBMEN4MEQsV0FBMUMsRUFBdUQ7QUFDNUQsTUFBSXhDLElBQUksQ0FBUjtBQUNBLE1BQU1DLEtBQUt1QyxZQUFZbkMsTUFBdkI7QUFDQSxTQUFPTCxJQUFJQyxFQUFYLEVBQWUsRUFBRUQsQ0FBakIsRUFBb0I7QUFDbEIsUUFBTXloRixZQUFZai9FLFlBQVl4QyxDQUFaLENBQWxCO0FBQ0EsUUFBSXloRixZQUFZenFCLFVBQVosSUFBMEJoM0QsSUFBSSxDQUFKLEdBQVFDLEVBQXRDLEVBQTBDO0FBQ3hDLFVBQU13ekUsYUFBYWp4RSxZQUFZeEMsQ0FBWixJQUFpQndDLFlBQVl4QyxJQUFJLENBQWhCLENBQXBDO0FBQ0EsYUFBT0EsSUFBSWdiLEtBQUtpVyxHQUFMLENBQVN6dUIsWUFBWXhDLENBQVosSUFBaUJnM0QsVUFBMUIsSUFBd0NoOEMsS0FBS2lXLEdBQUwsQ0FBU3dpRCxVQUFULENBQW5EO0FBQ0Q7QUFDRjtBQUNELFNBQU94ekUsS0FBSyxDQUFaO0FBQ0QsQzs7Ozs7Ozs7Ozs7QUNmRCxvRDs7Ozs7Ozs7Ozs7QUNBQSwyRDs7Ozs7Ozs7Ozs7QUNBQSwrRDs7Ozs7Ozs7Ozs7QUNBQSwyRDs7Ozs7Ozs7Ozs7QUNBQSwyRDs7Ozs7Ozs7Ozs7QUNBQSwyRDs7Ozs7Ozs7Ozs7QUNBQSw2RDs7Ozs7Ozs7Ozs7QUNBQSxpRTs7Ozs7Ozs7Ozs7QUNBQSxxRDs7Ozs7Ozs7Ozs7QUNBQSxnRTs7Ozs7Ozs7Ozs7QUNBQSw4RDs7Ozs7Ozs7Ozs7QUNBQSxrRTs7Ozs7Ozs7Ozs7QUNBQSw2RDs7Ozs7Ozs7Ozs7QUNBQSwyRDs7Ozs7Ozs7Ozs7QUNBQSwyRDs7Ozs7Ozs7Ozs7QUNBQSw2RDs7Ozs7Ozs7Ozs7QUNBQSw0RDs7Ozs7Ozs7Ozs7QUNBQSwyRDs7Ozs7Ozs7Ozs7QUNBQSx5RCIsImZpbGUiOiJvbG1zLWRlYnVnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwib2wvTWFwXCIpLCByZXF1aXJlKFwib2wvT2JzZXJ2YWJsZVwiKSwgcmVxdWlyZShcIm9sL2Zvcm1hdC9HZW9KU09OXCIpLCByZXF1aXJlKFwib2wvZm9ybWF0L01WVFwiKSwgcmVxdWlyZShcIm9sL2dlb20vUG9pbnRcIiksIHJlcXVpcmUoXCJvbC9sYXllci9UaWxlXCIpLCByZXF1aXJlKFwib2wvbGF5ZXIvVmVjdG9yXCIpLCByZXF1aXJlKFwib2wvbGF5ZXIvVmVjdG9yVGlsZVwiKSwgcmVxdWlyZShcIm9sL3Byb2pcIiksIHJlcXVpcmUoXCJvbC9zb3VyY2UvVGlsZUpTT05cIiksIHJlcXVpcmUoXCJvbC9zb3VyY2UvVmVjdG9yXCIpLCByZXF1aXJlKFwib2wvc291cmNlL1ZlY3RvclRpbGVcIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9DaXJjbGVcIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9GaWxsXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvSWNvblwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL1N0cm9rZVwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL1N0eWxlXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvVGV4dFwiKSwgcmVxdWlyZShcIm9sL3RpbGVncmlkXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcIm9sL01hcFwiLCBcIm9sL09ic2VydmFibGVcIiwgXCJvbC9mb3JtYXQvR2VvSlNPTlwiLCBcIm9sL2Zvcm1hdC9NVlRcIiwgXCJvbC9nZW9tL1BvaW50XCIsIFwib2wvbGF5ZXIvVGlsZVwiLCBcIm9sL2xheWVyL1ZlY3RvclwiLCBcIm9sL2xheWVyL1ZlY3RvclRpbGVcIiwgXCJvbC9wcm9qXCIsIFwib2wvc291cmNlL1RpbGVKU09OXCIsIFwib2wvc291cmNlL1ZlY3RvclwiLCBcIm9sL3NvdXJjZS9WZWN0b3JUaWxlXCIsIFwib2wvc3R5bGUvQ2lyY2xlXCIsIFwib2wvc3R5bGUvRmlsbFwiLCBcIm9sL3N0eWxlL0ljb25cIiwgXCJvbC9zdHlsZS9TdHJva2VcIiwgXCJvbC9zdHlsZS9TdHlsZVwiLCBcIm9sL3N0eWxlL1RleHRcIiwgXCJvbC90aWxlZ3JpZFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJvbG1zXCJdID0gZmFjdG9yeShyZXF1aXJlKFwib2wvTWFwXCIpLCByZXF1aXJlKFwib2wvT2JzZXJ2YWJsZVwiKSwgcmVxdWlyZShcIm9sL2Zvcm1hdC9HZW9KU09OXCIpLCByZXF1aXJlKFwib2wvZm9ybWF0L01WVFwiKSwgcmVxdWlyZShcIm9sL2dlb20vUG9pbnRcIiksIHJlcXVpcmUoXCJvbC9sYXllci9UaWxlXCIpLCByZXF1aXJlKFwib2wvbGF5ZXIvVmVjdG9yXCIpLCByZXF1aXJlKFwib2wvbGF5ZXIvVmVjdG9yVGlsZVwiKSwgcmVxdWlyZShcIm9sL3Byb2pcIiksIHJlcXVpcmUoXCJvbC9zb3VyY2UvVGlsZUpTT05cIiksIHJlcXVpcmUoXCJvbC9zb3VyY2UvVmVjdG9yXCIpLCByZXF1aXJlKFwib2wvc291cmNlL1ZlY3RvclRpbGVcIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9DaXJjbGVcIiksIHJlcXVpcmUoXCJvbC9zdHlsZS9GaWxsXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvSWNvblwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL1N0cm9rZVwiKSwgcmVxdWlyZShcIm9sL3N0eWxlL1N0eWxlXCIpLCByZXF1aXJlKFwib2wvc3R5bGUvVGV4dFwiKSwgcmVxdWlyZShcIm9sL3RpbGVncmlkXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJvbG1zXCJdID0gZmFjdG9yeShyb290W1wib2xcIl1bXCJNYXBcIl0sIHJvb3RbXCJvbFwiXVtcIk9ic2VydmFibGVcIl0sIHJvb3RbXCJvbFwiXVtcImZvcm1hdFwiXVtcIkdlb0pTT05cIl0sIHJvb3RbXCJvbFwiXVtcImZvcm1hdFwiXVtcIk1WVFwiXSwgcm9vdFtcIm9sXCJdW1wiZ2VvbVwiXVtcIlBvaW50XCJdLCByb290W1wib2xcIl1bXCJsYXllclwiXVtcIlRpbGVcIl0sIHJvb3RbXCJvbFwiXVtcImxheWVyXCJdW1wiVmVjdG9yXCJdLCByb290W1wib2xcIl1bXCJsYXllclwiXVtcIlZlY3RvclRpbGVcIl0sIHJvb3RbXCJvbFwiXVtcInByb2pcIl0sIHJvb3RbXCJvbFwiXVtcInNvdXJjZVwiXVtcIlRpbGVKU09OXCJdLCByb290W1wib2xcIl1bXCJzb3VyY2VcIl1bXCJWZWN0b3JcIl0sIHJvb3RbXCJvbFwiXVtcInNvdXJjZVwiXVtcIlZlY3RvclRpbGVcIl0sIHJvb3RbXCJvbFwiXVtcInN0eWxlXCJdW1wiQ2lyY2xlXCJdLCByb290W1wib2xcIl1bXCJzdHlsZVwiXVtcIkZpbGxcIl0sIHJvb3RbXCJvbFwiXVtcInN0eWxlXCJdW1wiSWNvblwiXSwgcm9vdFtcIm9sXCJdW1wic3R5bGVcIl1bXCJTdHJva2VcIl0sIHJvb3RbXCJvbFwiXVtcInN0eWxlXCJdW1wiU3R5bGVcIl0sIHJvb3RbXCJvbFwiXVtcInN0eWxlXCJdW1wiVGV4dFwiXSwgcm9vdFtcIm9sXCJdW1widGlsZWdyaWRcIl0pO1xufSkod2luZG93LCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX01hcF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX09ic2VydmFibGVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9mb3JtYXRfR2VvSlNPTl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX2Zvcm1hdF9NVlRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9nZW9tX1BvaW50X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfbGF5ZXJfVGlsZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX2xheWVyX1ZlY3Rvcl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX2xheWVyX1ZlY3RvclRpbGVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9wcm9qX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc291cmNlX1RpbGVKU09OX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc291cmNlX1ZlY3Rvcl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3NvdXJjZV9WZWN0b3JUaWxlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc3R5bGVfQ2lyY2xlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc3R5bGVfRmlsbF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX0ljb25fXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9TdHJva2VfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9TdHlsZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX1RleHRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF90aWxlZ3JpZF9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9vbG1zLmpzXCIpO1xuIiwiLypcclxub2wtbWFwYm94LXN0eWxlIC0gVXNlIE1hcGJveCBTdHlsZSBvYmplY3RzIHdpdGggT3BlbkxheWVyc1xyXG5Db3B5cmlnaHQgMjAxNi1wcmVzZW50IEJvdW5kbGVzcyBTcGF0aWFsLCBJbmMuXHJcbkxpY2Vuc2U6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ib3VuZGxlc3NnZW8vb2wtbWFwYm94LWdsLXN0eWxlL21hc3Rlci9MSUNFTlNFXHJcbiovXHJcblxyXG5pbXBvcnQge0NvbG9yfSBmcm9tICdAbWFwYm94L21hcGJveC1nbC1zdHlsZS1zcGVjJztcclxuaW1wb3J0IG1iMmNzcyBmcm9tICdtYXBib3gtdG8tY3NzLWZvbnQnO1xyXG5pbXBvcnQgYXBwbHlTdHlsZUZ1bmN0aW9uLCB7Z2V0VmFsdWV9IGZyb20gJy4vc3R5bGVmdW5jdGlvbic7XHJcbmltcG9ydCBnb29nbGVGb250cyBmcm9tICd3ZWJmb250LW1hdGNoZXIvbGliL2ZvbnRzL2dvb2dsZSc7XHJcbmltcG9ydCB7ZnJvbUxvbkxhdH0gZnJvbSAnb2wvcHJvaic7XHJcbmltcG9ydCB7Y3JlYXRlWFlafSBmcm9tICdvbC90aWxlZ3JpZCc7XHJcbmltcG9ydCBNYXAgZnJvbSAnb2wvTWFwJztcclxuaW1wb3J0IEdlb0pTT04gZnJvbSAnb2wvZm9ybWF0L0dlb0pTT04nO1xyXG5pbXBvcnQgTVZUIGZyb20gJ29sL2Zvcm1hdC9NVlQnO1xyXG5pbXBvcnQge3VuQnlLZXl9IGZyb20gJ29sL09ic2VydmFibGUnO1xyXG5pbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUnO1xyXG5pbXBvcnQgVmVjdG9yTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVmVjdG9yJztcclxuaW1wb3J0IFZlY3RvclRpbGVMYXllciBmcm9tICdvbC9sYXllci9WZWN0b3JUaWxlJztcclxuaW1wb3J0IFRpbGVKU09OIGZyb20gJ29sL3NvdXJjZS9UaWxlSlNPTic7XHJcbmltcG9ydCBWZWN0b3JTb3VyY2UgZnJvbSAnb2wvc291cmNlL1ZlY3Rvcic7XHJcbmltcG9ydCBWZWN0b3JUaWxlU291cmNlIGZyb20gJ29sL3NvdXJjZS9WZWN0b3JUaWxlJztcclxuaW1wb3J0IFhZWiBmcm9tICdvbC9zb3VyY2UvWFlaJztcclxuXHJcbnZhciBhdmFpbGFibGVGb250cztcclxuXHJcbmZ1bmN0aW9uIGxvYWRGb250KGZvbnRzKSB7XHJcbiAgdmFyIGksIGlpO1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShmb250cykpIHtcclxuICAgIHZhciBzdG9wcyA9IGZvbnRzLnN0b3BzO1xyXG4gICAgaWYgKHN0b3BzKSB7XHJcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gc3RvcHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgIGxvYWRGb250KHN0b3BzW2ldWzFdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgZ29vZ2xlRmFtaWxpZXMgPSBnb29nbGVGb250cy5nZXROYW1lcygpO1xyXG4gIHZhciBmYW1pbGllcyA9IGZvbnRzLm1hcChmdW5jdGlvbihmb250KSB7XHJcbiAgICByZXR1cm4gbWIyY3NzKGZvbnQsIDEpLnNwbGl0KCcgMXB4ICcpWzFdLnJlcGxhY2UoL1wiL2csICcnKTtcclxuICB9KTtcclxuICBmb3IgKGkgPSAwLCBpaSA9IGZhbWlsaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgIHZhciBmYW1pbHkgPSBmYW1pbGllc1tpXTtcclxuICAgIHZhciBmb250ID0gZm9udHNbaV07XHJcbiAgICBpZiAoZ29vZ2xlRmFtaWxpZXMuaW5kZXhPZihmYW1pbHkpICE9PSAtMSkge1xyXG4gICAgICBpZiAoIWF2YWlsYWJsZUZvbnRzKSB7XHJcbiAgICAgICAgYXZhaWxhYmxlRm9udHMgPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYXZhaWxhYmxlRm9udHMuaW5kZXhPZihmb250KSA9PSAtMSkge1xyXG4gICAgICAgIGF2YWlsYWJsZUZvbnRzLnB1c2goZm9udCk7XHJcbiAgICAgICAgdmFyIGZvbnRVcmwgPSAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PScgKyBmYW1pbHkucmVwbGFjZSgvIC9nLCAnKycpO1xyXG4gICAgICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tocmVmPVwiJyArIGZvbnRVcmwgKyAnXCJdJykpIHtcclxuICAgICAgICAgIHZhciBtYXJrdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XHJcbiAgICAgICAgICBtYXJrdXAuaHJlZiA9IGZvbnRVcmw7XHJcbiAgICAgICAgICBtYXJrdXAucmVsID0gJ3N0eWxlc2hlZXQnO1xyXG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChtYXJrdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0Rm9udCA9IFsnT3BlbiBTYW5zIFJlZ3VsYXInLCAnQXJpYWwgUmVndWxhciddO1xyXG5cclxuZnVuY3Rpb24gcHJlcHJvY2VzcyhsYXllcikge1xyXG4gIGlmICgnbGF5b3V0JyBpbiBsYXllciAmJiAndGV4dC1maWVsZCcgaW4gbGF5ZXIubGF5b3V0KSB7XHJcbiAgICBsb2FkRm9udChsYXllci5sYXlvdXRbJ3RleHQtZm9udCddIHx8IGRlZmF1bHRGb250KTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBzcHJpdGVSZWdFeCA9IC9eKC4qKShcXD8uKikkLztcclxuXHJcbmZ1bmN0aW9uIHdpdGhQYXRoKHVybCwgcGF0aCkge1xyXG4gIGlmIChwYXRoICYmIHVybC5pbmRleE9mKCdodHRwJykgIT0gMCkge1xyXG4gICAgdXJsID0gcGF0aCArIHVybDtcclxuICB9XHJcbiAgcmV0dXJuIHVybDtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9TcHJpdGVVcmwodXJsLCBwYXRoLCBleHRlbnNpb24pIHtcclxuICB1cmwgPSB3aXRoUGF0aCh1cmwsIHBhdGgpO1xyXG4gIHZhciBwYXJ0cyA9IHVybC5tYXRjaChzcHJpdGVSZWdFeCk7XHJcbiAgcmV0dXJuIHBhcnRzID9cclxuICAgIHBhcnRzWzFdICsgZXh0ZW5zaW9uICsgKHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1syXSA6ICcnKSA6XHJcbiAgICB1cmwgKyBleHRlbnNpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgc3R5bGUgZnVuY3Rpb24gdG8gYW4gYG9sLmxheWVyLlZlY3RvclRpbGVgIG9yIGBvbC5sYXllci5WZWN0b3JgXHJcbiAqIHdpdGggYW4gYG9sLnNvdXJjZS5WZWN0b3JUaWxlYCBvciBhbiBgb2wuc291cmNlLlZlY3RvcmAuIFRoZSBzdHlsZSBmdW5jdGlvblxyXG4gKiB3aWxsIHJlbmRlciBhbGwgbGF5ZXJzIGZyb20gdGhlIGBnbFN0eWxlYCBvYmplY3QgdGhhdCB1c2UgdGhlIHNwZWNpZmllZFxyXG4gKiBgc291cmNlYCwgb3IgYSBzdWJzZXQgb2YgbGF5ZXJzIGZyb20gdGhlIHNhbWUgc291cmNlLiBUaGUgc291cmNlIG5lZWRzIHRvIGJlXHJcbiAqIGEgYFwidHlwZVwiOiBcInZlY3RvclwiYCwgYFwidHlwZVwiOiBcImdlb2pzb25cImAgb3IgYFwidHlwZVwiOiBcInJhc3RlclwiYCBzb3VyY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2wubGF5ZXIuVmVjdG9yVGlsZX0gbGF5ZXIgT3BlbkxheWVycyBsYXllci5cclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBnbFN0eWxlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgYHNvdXJjZWAga2V5IG9yIGFuIGFycmF5IG9mIGxheWVyIGBpZGBzIGZyb20gdGhlXHJcbiAqIE1hcGJveCBTdHlsZSBvYmplY3QuIFdoZW4gYSBgc291cmNlYCBrZXkgaXMgcHJvdmlkZWQsIGFsbCBsYXllcnMgZm9yIHRoZVxyXG4gKiBzcGVjaWZpZWQgc291cmNlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHN0eWxlIGZ1bmN0aW9uLiBXaGVuIGxheWVyIGBpZGBzXHJcbiAqIGFyZSBwcm92aWRlZCwgdGhleSBtdXN0IGJlIGZyb20gbGF5ZXJzIHRoYXQgdXNlIHRoZSBzYW1lIHNvdXJjZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoPXVuZGVmaW5lZF0gUGF0aCBvZiB0aGUgc3R5bGUgZmlsZS4gT25seSByZXF1aXJlZCB3aGVuXHJcbiAqIGEgcmVsYXRpdmUgcGF0aCBpcyB1c2VkIHdpdGggdGhlIGBcInNwcml0ZVwiYCBwcm9wZXJ0eSBvZiB0aGUgc3R5bGUuXHJcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3Jlc29sdXRpb25zPXVuZGVmaW5lZF0gUmVzb2x1dGlvbnMgZm9yIG1hcHBpbmcgcmVzb2x1dGlvbiB0byB6b29tIGxldmVsLlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgc3R5bGUgY2FuIGJlIHVzZWRcclxuICogZm9yIHJlbmRlcmluZy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlKGxheWVyLCBnbFN0eWxlLCBzb3VyY2UsIHBhdGgsIHJlc29sdXRpb25zKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG5cclxuICAgIGlmICh0eXBlb2YgZ2xTdHlsZSAhPSAnb2JqZWN0Jykge1xyXG4gICAgICBnbFN0eWxlID0gSlNPTi5wYXJzZShnbFN0eWxlKTtcclxuICAgIH1cclxuICAgIGlmIChnbFN0eWxlLnZlcnNpb24gIT0gOCkge1xyXG4gICAgICByZWplY3QobmV3IEVycm9yKCdnbFN0eWxlIHZlcnNpb24gOCByZXF1aXJlZC4nKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc3ByaXRlU2NhbGUsIHNwcml0ZURhdGEsIHNwcml0ZUltYWdlVXJsO1xyXG4gICAgaWYgKGdsU3R5bGUuc3ByaXRlKSB7XHJcbiAgICAgIHNwcml0ZVNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMS41ID8gMC41IDogMTtcclxuICAgICAgdmFyIHNpemVGYWN0b3IgPSBzcHJpdGVTY2FsZSA9PSAwLjUgPyAnQDJ4JyA6ICcnO1xyXG4gICAgICB2YXIgc3ByaXRlVXJsID0gdG9TcHJpdGVVcmwoZ2xTdHlsZS5zcHJpdGUsIHBhdGgsIHNpemVGYWN0b3IgKyAnLmpzb24nKTtcclxuXHJcbiAgICAgIGZldGNoKHNwcml0ZVVybCwge2NyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgLy8gaWYgdGhlIHJlc3BvbnNlIGlzIHJlYWR5IHJldHVybiB0aGUgSlNPTiBwcm9taXNlXHJcbiAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc2l6ZUZhY3RvciAhPT0gJycpIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBKU09OIHByb21pc2UgZm9yIHRoZSBsb3ctcmVzb2x1dGlvbiBzcHJpdGVzLlxyXG4gICAgICAgICAgICBzaXplRmFjdG9yID0gJyc7XHJcbiAgICAgICAgICAgIHNwcml0ZVVybCA9IHRvU3ByaXRlVXJsKGdsU3R5bGUuc3ByaXRlLCBwYXRoLCAnLmpzb24nKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHNwcml0ZVVybCwge2NyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nfSkudGhlbihyID0+IHIuanNvbigpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNwcml0ZXNKc29uKSB7XHJcbiAgICAgICAgICBpZiAoc3ByaXRlc0pzb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnTm8gc3ByaXRlcyBmb3VuZC4nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3ByaXRlRGF0YSA9IHNwcml0ZXNKc29uO1xyXG4gICAgICAgICAgc3ByaXRlSW1hZ2VVcmwgPSB0b1Nwcml0ZVVybChnbFN0eWxlLnNwcml0ZSwgcGF0aCwgc2l6ZUZhY3RvciArICcucG5nJyk7XHJcbiAgICAgICAgICBvbkNoYW5nZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU3ByaXRlcyBjYW5ub3QgYmUgbG9hZGVkIGZyb20gJyArIHNwcml0ZVVybCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHlsZTtcclxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xyXG4gICAgICBpZiAoIXN0eWxlICYmICghZ2xTdHlsZS5zcHJpdGUgfHwgc3ByaXRlRGF0YSkgJiYgKCFhdmFpbGFibGVGb250cyB8fCBhdmFpbGFibGVGb250cy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIHN0eWxlID0gYXBwbHlTdHlsZUZ1bmN0aW9uKGxheWVyLCBnbFN0eWxlLCBzb3VyY2UsIHJlc29sdXRpb25zLCBzcHJpdGVEYXRhLCBzcHJpdGVJbWFnZVVybCwgYXZhaWxhYmxlRm9udHMpO1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSBlbHNlIGlmIChzdHlsZSkge1xyXG4gICAgICAgIGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChsYXllciBpbnN0YW5jZW9mIFZlY3RvclRpbGVMYXllciB8fCBsYXllciBpbnN0YW5jZW9mIFZlY3RvckxheWVyKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGxheWVycyA9IGdsU3R5bGUubGF5ZXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PSAnc3RyaW5nJyAmJiBsYXllcnNbaV0uc291cmNlID09IHNvdXJjZSB8fCBzb3VyY2UuaW5kZXhPZihsYXllcnNbaV0uaWQpID49IDApIHtcclxuICAgICAgICAgICAgcHJlcHJvY2VzcyhsYXllcnNbaV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvbkNoYW5nZSgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICB9LCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRCYWNrZ3JvdW5kKG1hcCwgbGF5ZXIpIHtcclxuICBjb25zdCBiYWNrZ3JvdW5kID0ge1xyXG4gICAgdHlwZTogbGF5ZXIudHlwZVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gdXBkYXRlU3R5bGUoKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IG1hcC5nZXRUYXJnZXRFbGVtZW50KCk7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGxheW91dCA9IGxheWVyLmxheW91dCB8fCB7fTtcclxuICAgIHZhciBwYWludCA9IGxheWVyLnBhaW50IHx8IHt9O1xyXG4gICAgYmFja2dyb3VuZFsncGFpbnQnXSA9IHBhaW50O1xyXG4gICAgYmFja2dyb3VuZC5pZCA9ICdvbG1zLWJnLScgKyBwYWludFsnYmFja2dyb3VuZC1vcGFjaXR5J10gKyBwYWludFsnYmFja2dyb3VuZC1jb2xvciddO1xyXG4gICAgdmFyIHpvb20gPSBtYXAuZ2V0VmlldygpLmdldFpvb20oKTtcclxuICAgIGlmIChwYWludFsnYmFja2dyb3VuZC1jb2xvciddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgYmcgPSBnZXRWYWx1ZShiYWNrZ3JvdW5kLCAncGFpbnQnLCAnYmFja2dyb3VuZC1jb2xvcicsIHpvb20sIHt9KTtcclxuICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gQ29sb3IucGFyc2UoYmcpLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFpbnRbJ2JhY2tncm91bmQtb3BhY2l0eSddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gZ2V0VmFsdWUoYmFja2dyb3VuZCwgJ3BhaW50JywgJ2JhY2tncm91bmQtb3BhY2l0eScsIHpvb20sIHt9KTtcclxuICAgIH1cclxuICAgIGlmIChsYXlvdXQudmlzaWJpbGl0eSA9PSAnbm9uZScpIHtcclxuICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcclxuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gJyc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChtYXAuZ2V0VGFyZ2V0RWxlbWVudCgpKSB7XHJcbiAgICB1cGRhdGVTdHlsZSgpO1xyXG4gIH1cclxuICBtYXAub24oWydjaGFuZ2U6cmVzb2x1dGlvbicsICdjaGFuZ2U6dGFyZ2V0J10sIHVwZGF0ZVN0eWxlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgcHJvcGVydGllcyBvZiB0aGUgTWFwYm94IFN0eWxlJ3MgZmlyc3QgYGJhY2tncm91bmRgIGxheWVyIHRvIHRoZSBtYXAuXHJcbiAqIEBwYXJhbSB7b2wuTWFwfSBtYXAgT3BlbkxheWVycyBNYXAuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBnbFN0eWxlIE1hcGJveCBTdHlsZSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlCYWNrZ3JvdW5kKG1hcCwgZ2xTdHlsZSkge1xyXG4gIGdsU3R5bGUubGF5ZXJzLnNvbWUoZnVuY3Rpb24obCkge1xyXG4gICAgaWYgKGwudHlwZSA9PSAnYmFja2dyb3VuZCcpIHtcclxuICAgICAgc2V0QmFja2dyb3VuZChtYXAsIGwpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U291cmNlSWRCeVJlZihsYXllcnMsIHJlZikge1xyXG4gIHZhciBzb3VyY2VJZDtcclxuICBsYXllcnMuc29tZShmdW5jdGlvbihsYXllcikge1xyXG4gICAgaWYgKGxheWVyLmlkID09IHJlZikge1xyXG4gICAgICBzb3VyY2VJZCA9IGxheWVyLnNvdXJjZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHNvdXJjZUlkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzU3R5bGUoZ2xTdHlsZSwgbWFwLCBiYXNlVXJsLCBob3N0LCBwYXRoLCBhY2Nlc3NUb2tlbikge1xyXG4gIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcclxuICBpZiAoJ2NlbnRlcicgaW4gZ2xTdHlsZSAmJiAhdmlldy5nZXRDZW50ZXIoKSkge1xyXG4gICAgdmlldy5zZXRDZW50ZXIoZnJvbUxvbkxhdChnbFN0eWxlLmNlbnRlcikpO1xyXG4gIH1cclxuICBpZiAoJ3pvb20nIGluIGdsU3R5bGUgJiYgdmlldy5nZXRab29tKCkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmlldy5zZXRab29tKGdsU3R5bGUuem9vbSk7XHJcbiAgfVxyXG4gIGlmICghdmlldy5nZXRDZW50ZXIoKSB8fCB2aWV3LmdldFpvb20oKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2aWV3LmZpdCh2aWV3LmdldFByb2plY3Rpb24oKS5nZXRFeHRlbnQoKSwge1xyXG4gICAgICBuZWFyZXN0OiB0cnVlLFxyXG4gICAgICBzaXplOiBtYXAuZ2V0U2l6ZSgpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKGdsU3R5bGUuc3ByaXRlKSB7XHJcbiAgICBpZiAoZ2xTdHlsZS5zcHJpdGUuaW5kZXhPZignbWFwYm94Oi8vJykgPT0gMCkge1xyXG4gICAgICBnbFN0eWxlLnNwcml0ZSA9IGJhc2VVcmwgKyAnL3Nwcml0ZScgKyBhY2Nlc3NUb2tlbjtcclxuICAgIH0gZWxzZSBpZiAoZ2xTdHlsZS5zcHJpdGUuaW5kZXhPZignaHR0cCcpICE9IDApIHtcclxuICAgICAgZ2xTdHlsZS5zcHJpdGUgPSAoaG9zdCA/IChob3N0ICsgcGF0aCkgOiAnJykgKyBnbFN0eWxlLnNwcml0ZSArIGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGdsTGF5ZXJzID0gZ2xTdHlsZS5sYXllcnM7XHJcbiAgdmFyIGdlb0pzb25Gb3JtYXQgPSBuZXcgR2VvSlNPTigpO1xyXG4gIHZhciBsYXllcklkcyA9IFtdO1xyXG5cclxuICBmdW5jdGlvbiBmaW5hbGl6ZUxheWVyKGxheWVyKSB7XHJcbiAgICBpZiAobGF5ZXJJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBtYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gICAgICB2YXIgc2V0U3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcHBseVN0eWxlKGxheWVyLCBnbFN0eWxlLCBsYXllcklkcywgcGF0aCkudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGxheWVyLnNldFZpc2libGUodHJ1ZSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgLyplc2xpbnQgbm8tY29uc29sZTogW1wiZXJyb3JcIiwgeyBhbGxvdzogW1wiZXJyb3JcIl0gfV0gKi9cclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChsYXllci5nZXRTb3VyY2UoKSkge1xyXG4gICAgICAgIHNldFN0eWxlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGF5ZXIub25jZSgnY2hhbmdlOnNvdXJjZScsIHNldFN0eWxlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGdsTGF5ZXIsIGdsU291cmNlLCBnbFNvdXJjZUlkLCBpZCwgbGF5ZXIsIG1hcGlkLCB1cmw7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZ2xMYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgZ2xMYXllciA9IGdsTGF5ZXJzW2ldO1xyXG4gICAgaWYgKGdsTGF5ZXIudHlwZSA9PSAnYmFja2dyb3VuZCcpIHtcclxuICAgICAgc2V0QmFja2dyb3VuZChtYXAsIGdsTGF5ZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWQgPSBnbExheWVyLnNvdXJjZSB8fCBnZXRTb3VyY2VJZEJ5UmVmKGdsTGF5ZXJzLCBnbExheWVyLnJlZik7XHJcbiAgICAgIGlmIChpZCAhPSBnbFNvdXJjZUlkKSB7XHJcbiAgICAgICAgZmluYWxpemVMYXllcihsYXllcik7XHJcbiAgICAgICAgbGF5ZXJJZHMgPSBbXTtcclxuICAgICAgICBnbFNvdXJjZSA9IGdsU3R5bGUuc291cmNlc1tpZF07XHJcbiAgICAgICAgdXJsID0gZ2xTb3VyY2UudXJsO1xyXG4gICAgICAgIHZhciB0aWxlcyA9IGdsU291cmNlLnRpbGVzO1xyXG4gICAgICAgIGlmICh1cmwpIHtcclxuICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignbWFwYm94Oi8vJykgPT0gMCkge1xyXG4gICAgICAgICAgICBtYXBpZCA9IHVybC5yZXBsYWNlKCdtYXBib3g6Ly8nLCAnJyk7XHJcbiAgICAgICAgICAgIHRpbGVzID0gWydhJywgJ2InLCAnYycsICdkJ10ubWFwKGZ1bmN0aW9uKGhvc3QpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJ2h0dHBzOi8vJyArIGhvc3QgKyAnLnRpbGVzLm1hcGJveC5jb20vdjQvJyArIG1hcGlkICtcclxuICAgICAgICAgICAgICAgICAgJy97en0ve3h9L3t5fS4nICtcclxuICAgICAgICAgICAgICAgICAgKGdsU291cmNlLnR5cGUgPT0gJ3ZlY3RvcicgPyAndmVjdG9yLnBiZicgOiAncG5nJykgK1xyXG4gICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZ2xTb3VyY2UudHlwZSA9PSAndmVjdG9yJykge1xyXG4gICAgICAgICAgbGF5ZXIgPSB0aWxlcyA/IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRpbGVHcmlkID0gY3JlYXRlWFlaKHtcclxuICAgICAgICAgICAgICB0aWxlU2l6ZTogNTEyLFxyXG4gICAgICAgICAgICAgIG1heFpvb206ICdtYXh6b29tJyBpbiBnbFNvdXJjZSA/IGdsU291cmNlLm1heHpvb20gOiAyMixcclxuICAgICAgICAgICAgICBtaW5ab29tOiBnbFNvdXJjZS5taW56b29tXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvclRpbGVMYXllcih7XHJcbiAgICAgICAgICAgICAgZGVjbHV0dGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgIG1heFJlc29sdXRpb246IHRpbGVHcmlkLmdldE1pblpvb20oKSA+IDAgP1xyXG4gICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih0aWxlR3JpZC5nZXRNaW5ab29tKCkpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIHNvdXJjZTogbmV3IFZlY3RvclRpbGVTb3VyY2Uoe1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRpb25zOiBnbFNvdXJjZS5hdHRyaWJ1dGlvbixcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogbmV3IE1WVCgpLFxyXG4gICAgICAgICAgICAgICAgdGlsZUdyaWQ6IHRpbGVHcmlkLFxyXG4gICAgICAgICAgICAgICAgdXJsczogdGlsZXNcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICB6SW5kZXg6IGlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KSgpIDogKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgVmVjdG9yVGlsZUxheWVyKHtcclxuICAgICAgICAgICAgICBkZWNsdXR0ZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgekluZGV4OiBpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgdGlsZWpzb24gPSBuZXcgVGlsZUpTT04oe1xyXG4gICAgICAgICAgICAgIHVybDogdXJsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGlsZWpzb24ub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGlmICh0aWxlanNvbi5nZXRTdGF0ZSgpID09ICdyZWFkeScpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aWxlSlNPTkRvYyA9IHRpbGVqc29uLmdldFRpbGVKU09OKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlsZXMgPSBBcnJheS5pc0FycmF5KHRpbGVKU09ORG9jLnRpbGVzKSA/IHRpbGVKU09ORG9jLnRpbGVzIDogW3RpbGVKU09ORG9jLnRpbGVzXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRpbGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHRpbGUgPSB0aWxlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHRpbGUuaW5kZXhPZignaHR0cCcpICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlc1tpXSA9IGdsU291cmNlLnVybCArIHRpbGU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0aWxlR3JpZCA9IHRpbGVqc29uLmdldFRpbGVHcmlkKCk7XHJcbiAgICAgICAgICAgICAgICBsYXllci5zZXRTb3VyY2UobmV3IFZlY3RvclRpbGVTb3VyY2Uoe1xyXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGlvbnM6IHRpbGVqc29uLmdldEF0dHJpYnV0aW9ucygpIHx8IHRpbGVKU09ORG9jLmF0dHJpYnV0aW9uLFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXQ6IG5ldyBNVlQoKSxcclxuICAgICAgICAgICAgICAgICAgdGlsZUdyaWQ6IGNyZWF0ZVhZWih7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWm9vbTogdGlsZUdyaWQuZ2V0TWluWm9vbSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFpvb206IHRpbGVHcmlkLmdldE1heFpvb20oKSxcclxuICAgICAgICAgICAgICAgICAgICB0aWxlU2l6ZTogNTEyXHJcbiAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICB1cmxzOiB0aWxlc1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGVHcmlkLmdldE1pblpvb20oKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgbGF5ZXIuc2V0TWF4UmVzb2x1dGlvbihcclxuICAgICAgICAgICAgICAgICAgICB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHRpbGVHcmlkLmdldE1pblpvb20oKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdW5CeUtleShrZXkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcclxuICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChnbFNvdXJjZS50eXBlID09ICdyYXN0ZXInKSB7XHJcbiAgICAgICAgICB2YXIgc291cmNlO1xyXG4gICAgICAgICAgaWYgKCFnbFNvdXJjZS50aWxlcykge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaWxlSlNPTih7XHJcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc291cmNlID0gbmV3IFhZWih7XHJcbiAgICAgICAgICAgICAgYXR0cmlidXRpb25zOiBnbFNvdXJjZS5hdHRyaWJ1dGlvbixcclxuICAgICAgICAgICAgICBtaW5ab29tOiBnbFNvdXJjZS5taW56b29tLFxyXG4gICAgICAgICAgICAgIG1heFpvb206ICdtYXh6b29tJyBpbiBnbFNvdXJjZSA/IGdsU291cmNlLm1heHpvb20gOiAyMixcclxuICAgICAgICAgICAgICB0aWxlU2l6ZTogZ2xTb3VyY2UudGlsZVNpemUgfHwgNTEyLFxyXG4gICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgIHVybHM6IGdsU291cmNlLnRpbGVzLFxyXG4gICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNvdXJjZS5zZXRUaWxlTG9hZEZ1bmN0aW9uKGZ1bmN0aW9uKHRpbGUsIHNyYykge1xyXG4gICAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoJ3tiYm94LWVwc2ctMzg1N30nKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgIHZhciBiYm94ID0gc291cmNlLmdldFRpbGVHcmlkKCkuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGUuZ2V0VGlsZUNvb3JkKCkpO1xyXG4gICAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKCd7YmJveC1lcHNnLTM4NTd9JywgYmJveC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBsYXllciA9IG5ldyBUaWxlTGF5ZXIoe1xyXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICAgICAgdmlzaWJsZTogZ2xMYXllci5sYXlvdXQgPyBnbExheWVyLmxheW91dC52aXNpYmlsaXR5ICE9PSAnbm9uZScgOiB0cnVlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGdsU291cmNlLnR5cGUgPT0gJ2dlb2pzb24nKSB7XHJcbiAgICAgICAgICB2YXIgZGF0YSA9IGdsU291cmNlLmRhdGE7XHJcbiAgICAgICAgICB2YXIgZmVhdHVyZXMsIGdlb0pzb25Vcmw7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZ2VvSnNvblVybCA9IHdpdGhQYXRoKGRhdGEsIHBhdGgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZmVhdHVyZXMgPSBnZW9Kc29uRm9ybWF0LnJlYWRGZWF0dXJlcyhkYXRhLCB7ZmVhdHVyZVByb2plY3Rpb246ICdFUFNHOjM4NTcnfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsYXllciA9IG5ldyBWZWN0b3JMYXllcih7XHJcbiAgICAgICAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSh7XHJcbiAgICAgICAgICAgICAgYXR0cmlidXRpb25zOiBnbFNvdXJjZS5hdHRyaWJ1dGlvbixcclxuICAgICAgICAgICAgICBmZWF0dXJlczogZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgZm9ybWF0OiBnZW9Kc29uRm9ybWF0LFxyXG4gICAgICAgICAgICAgIHVybDogZ2VvSnNvblVybFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHpJbmRleDogaVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsU291cmNlSWQgPSBpZDtcclxuICAgICAgfVxyXG4gICAgICBsYXllcklkcy5wdXNoKGdsTGF5ZXIuaWQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmaW5hbGl6ZUxheWVyKGxheWVyKTtcclxuICBtYXAuc2V0KCdtYXBib3gtc3R5bGUnLCBnbFN0eWxlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFuZCBhcHBsaWVzIGEgTWFwYm94IFN0eWxlIG9iamVjdCB0byBhbiBPcGVuTGF5ZXJzIE1hcC4gVGhpcyBpbmNsdWRlc1xyXG4gKiB0aGUgbWFwIGJhY2tncm91bmQsIHRoZSBsYXllcnMsIHRoZSBjZW50ZXIgYW5kIHRoZSB6b29tLlxyXG4gKlxyXG4gKiBUaGUgY2VudGVyIGFuZCB6b29tIHdpbGwgb25seSBiZSBzZXQgaWYgcHJlc2VudCBpbiB0aGUgTWFwYm94IFN0eWxlIGRvY3VtZW50LFxyXG4gKiBhbmQgaWYgbm90IGFscmVhZHkgc2V0IG9uIHRoZSBPcGVuTGF5ZXJzIG1hcC5cclxuICpcclxuICogTGF5ZXJzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIE9wZW5MYXllcnMgbWFwLCB3aXRob3V0IGFmZmVjdGluZyBhbnkgbGF5ZXJzIHRoYXRcclxuICogbWlnaHQgYWxyZWFkeSBiZSBzZXQgb24gdGhlIG1hcC5cclxuICpcclxuICogTGF5ZXJzIGFkZGVkIGJ5IGBhcHBseSgpYCB3aWxsIGhhdmUgdHdvIGFkZGl0aW9uYWwgcHJvcGVydGllczpcclxuICpcclxuICogICogYG1hcGJveC1zb3VyY2VgOiBUaGUgYGlkYCBvZiB0aGUgTWFwYm94IFN0eWxlIGRvY3VtZW50J3Mgc291cmNlIHRoYXQgdGhlXHJcbiAqICAgIE9wZW5MYXllcnMgbGF5ZXIgd2FzIGNyZWF0ZWQgZnJvbS4gVXN1YWxseSBgYXBwbHkoKWAgY3JlYXRlcyBvbmVcclxuICogICAgT3BlbkxheWVycyBsYXllciBwZXIgTWFwYm94IFN0eWxlIHNvdXJjZSwgdW5sZXNzIHRoZSBsYXllciBzdGFjayBoYXNcclxuICogICAgbGF5ZXJzIGZyb20gZGlmZmVyZW50IHNvdXJjZXMgaW4gYmV0d2Vlbi5cclxuICogICogYG1hcGJveC1sYXllcnNgOiBUaGUgYGlkYHMgb2YgdGhlIE1hcGJveCBTdHlsZSBkb2N1bWVudCdzIGxheWVycyB0aGF0IGFyZVxyXG4gKiAgICBpbmNsdWRlZCBpbiB0aGUgT3BlbkxheWVycyBsYXllci5cclxuICpcclxuICogVGhlIG1hcCByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIHdpbGwgaGF2ZSBhbiBhZGRpdGlvbmFsIGBtYXBib3gtc3R5bGVgXHJcbiAqIHByb3BlcnR5IHdoaWNoIGhvbGRzIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29sLk1hcHxIVE1MRWxlbWVudHxzdHJpbmd9IG1hcCBFaXRoZXIgYW4gZXhpc3RpbmcgT3BlbkxheWVycyBNYXBcclxuICogaW5zdGFuY2UsIG9yIGEgSFRNTCBlbGVtZW50LCBvciB0aGUgaWQgb2YgYSBIVE1MIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHRoZVxyXG4gKiB0YXJnZXQgb2YgYSBuZXcgT3BlbkxheWVycyBNYXAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gc3R5bGUgSlNPTiBzdHlsZSBvYmplY3Qgb3Igc3R5bGUgdXJsIHBvaW50aW5nIHRvIGFcclxuICogTWFwYm94IFN0eWxlIG9iamVjdC4gV2hlbiB1c2luZyBNYXBib3ggQVBJcywgdGhlIHVybCBtdXN0IGNvbnRhaW4gYW4gYWNjZXNzXHJcbiAqIHRva2VuIGFuZCBsb29rIGxpa2VcclxuICogYGh0dHBzOi8vYXBpLm1hcGJveC5jb20vc3R5bGVzL3YxL21hcGJveC9icmlnaHQtdjk/YWNjZXNzX3Rva2VuPVt5b3VyX2FjY2Vzc190b2tlbl9oZXJlXWAuXHJcbiAqIFdoZW4gcGFzc2VkIGFzIEpTT04gc3R5bGUgb2JqZWN0LCBhbGwgT3BlbkxheWVycyBsYXllcnMgY3JlYXRlZCBieSBgYXBwbHkoKWBcclxuICogd2lsbCBiZSBpbW1lZGlhdGVseSBhdmFpbGFibGUsIGJ1dCB0aGV5IG1heSBub3QgaGF2ZSBhIHNvdXJjZSB5ZXQgKGkuZS4gd2hlblxyXG4gKiB0aGV5IGFyZSBkZWZpbmVkIGJ5IGEgVGlsZUpTT04gdXJsIGluIHRoZSBNYXBib3ggU3R5bGUgZG9jdW1lbnQpLiBXaGVuIHBhc3NlZFxyXG4gKiBhcyBzdHlsZSB1cmwsIGxheWVycyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgd2hlbiB0aGUgTWFwYm94IFN0eWxlIGRvY3VtZW50XHJcbiAqIGlzIGxvYWRlZCBhbmQgcGFyc2VkLlxyXG4gKiBAcmV0dXJuIHtvbC5NYXB9IFRoZSBPcGVuTGF5ZXJzIE1hcCBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggdGhlXHJcbiAqIGNvbnRlbnRzIGRlc2NyaWJlZCBpbiB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseShtYXAsIHN0eWxlKSB7XHJcblxyXG4gIHZhciBhY2Nlc3NUb2tlbiwgYmFzZVVybCwgaG9zdCwgcGF0aDtcclxuICBhY2Nlc3NUb2tlbiA9IGJhc2VVcmwgPSBob3N0ID0gcGF0aCA9ICcnO1xyXG5cclxuICBpZiAoIShtYXAgaW5zdGFuY2VvZiBNYXApKSB7XHJcbiAgICBtYXAgPSBuZXcgTWFwKHtcclxuICAgICAgdGFyZ2V0OiBtYXBcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBwYXJ0cyA9IHN0eWxlLm1hdGNoKHNwcml0ZVJlZ0V4KTtcclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICBiYXNlVXJsID0gcGFydHNbMV07XHJcbiAgICAgIGFjY2Vzc1Rva2VuID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdIDogJyc7XHJcbiAgICB9XHJcblxyXG4gICAgZmV0Y2goc3R5bGUsIHtcclxuICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcclxuICAgIH0pXHJcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgfSlcclxuICAgICAgLnRoZW4oZnVuY3Rpb24oZ2xTdHlsZSkge1xyXG4gICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQScpO1xyXG4gICAgICAgIGEuaHJlZiA9IHN0eWxlO1xyXG4gICAgICAgIHBhdGggPSBhLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmpvaW4oJy8nKSArICcvJztcclxuICAgICAgICBob3N0ID0gc3R5bGUuc3Vic3RyKDAsIHN0eWxlLmluZGV4T2YocGF0aCkpO1xyXG5cclxuICAgICAgICBwcm9jZXNzU3R5bGUoZ2xTdHlsZSwgbWFwLCBiYXNlVXJsLCBob3N0LCBwYXRoLCBhY2Nlc3NUb2tlbik7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgc3R5bGUpO1xyXG4gICAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgcHJvY2Vzc1N0eWxlKHN0eWxlLCBtYXApO1xyXG4gICAgfSwgMCk7XHJcbiAgfVxyXG4gIHJldHVybiBtYXA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIE9wZW5MYXllcnMgbGF5ZXIgaW5zdGFuY2UgdGhhdCBjb250YWlucyB0aGUgcHJvdmlkZWQgTWFwYm94IFN0eWxlXHJcbiAqIGBsYXllcmAuIE5vdGUgdGhhdCBtdWx0aXBsZSBNYXBib3ggU3R5bGUgbGF5ZXJzIGFyZSBjb21iaW5lZCBpbiBhIHNpbmdsZVxyXG4gKiBPcGVuTGF5ZXJzIGxheWVyIGluc3RhbmNlIHdoZW4gdGhleSB1c2UgdGhlIHNhbWUgTWFwYm94IFN0eWxlIGBzb3VyY2VgLlxyXG4gKiBAcGFyYW0ge29sLk1hcH0gbWFwIE9wZW5MYXllcnMgTWFwLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJJZCBNYXBib3ggU3R5bGUgbGF5ZXIgaWQuXHJcbiAqIEByZXR1cm4ge29sLmxheWVyLkxheWVyfSBsYXllciBPcGVuTGF5ZXJzIGxheWVyIGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExheWVyKG1hcCwgbGF5ZXJJZCkge1xyXG4gIGNvbnN0IGxheWVycyA9IG1hcC5nZXRMYXllcnMoKS5nZXRBcnJheSgpO1xyXG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICBpZiAobGF5ZXJzW2ldLmdldCgnbWFwYm94LWxheWVycycpLmluZGV4T2YobGF5ZXJJZCkgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBsYXllcnNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBPcGVuTGF5ZXJzIHNvdXJjZSBpbnN0YW5jZSBmb3IgdGhlIHByb3ZpZGVkIE1hcGJveCBTdHlsZSBgc291cmNlYC5cclxuICogQHBhcmFtIHtvbC5NYXB9IG1hcCBPcGVuTGF5ZXJzIE1hcC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZUlkIE1hcGJveCBTdHlsZSBzb3VyY2UgaWQuXHJcbiAqIEByZXR1cm4ge29sLmxheWVyLkxheWVyfSBsYXllciBPcGVuTGF5ZXJzIGxheWVyIGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvdXJjZShtYXAsIHNvdXJjZUlkKSB7XHJcbiAgY29uc3QgbGF5ZXJzID0gbWFwLmdldExheWVycygpLmdldEFycmF5KCk7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IGxheWVyc1tpXS5nZXRTb3VyY2UoKTtcclxuICAgIGlmIChsYXllcnNbaV0uZ2V0KCdtYXBib3gtc291cmNlJykuaW5kZXhPZihzb3VyY2VJZCkgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsInZhciAkdmVyc2lvbiA9IDg7XG52YXIgJHJvb3QgPSB7XG5cdHZlcnNpb246IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IFtcblx0XHRcdDhcblx0XHRdLFxuXHRcdGRvYzogXCJTdHlsZSBzcGVjaWZpY2F0aW9uIHZlcnNpb24gbnVtYmVyLiBNdXN0IGJlIDguXCIsXG5cdFx0ZXhhbXBsZTogOFxuXHR9LFxuXHRuYW1lOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgc3R5bGUuXCIsXG5cdFx0ZXhhbXBsZTogXCJCcmlnaHRcIlxuXHR9LFxuXHRtZXRhZGF0YToge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgc3R5bGVzaGVldCwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy5cIlxuXHR9LFxuXHRjZW50ZXI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIkRlZmF1bHQgbWFwIGNlbnRlciBpbiBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLiAgVGhlIHN0eWxlIGNlbnRlciB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuXHRcdGV4YW1wbGU6IFtcblx0XHRcdC03My45NzQ5LFxuXHRcdFx0NDAuNzczNlxuXHRcdF1cblx0fSxcblx0em9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIkRlZmF1bHQgem9vbSBsZXZlbC4gIFRoZSBzdHlsZSB6b29tIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG5cdFx0ZXhhbXBsZTogMTIuNVxuXHR9LFxuXHRiZWFyaW5nOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRwZXJpb2Q6IDM2MCxcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0ZG9jOiBcIkRlZmF1bHQgYmVhcmluZywgaW4gZGVncmVlcy4gVGhlIGJlYXJpbmcgaXMgdGhlIGNvbXBhc3MgZGlyZWN0aW9uIHRoYXQgaXMgXFxcInVwXFxcIjsgZm9yIGV4YW1wbGUsIGEgYmVhcmluZyBvZiA5MMKwIG9yaWVudHMgdGhlIG1hcCBzbyB0aGF0IGVhc3QgaXMgdXAuIFRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcblx0XHRleGFtcGxlOiAyOVxuXHR9LFxuXHRwaXRjaDoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0dW5pdHM6IFwiZGVncmVlc1wiLFxuXHRcdGRvYzogXCJEZWZhdWx0IHBpdGNoLCBpbiBkZWdyZWVzLiBaZXJvIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHN1cmZhY2UsIGZvciBhIGxvb2sgc3RyYWlnaHQgZG93biBhdCB0aGUgbWFwLCB3aGlsZSBhIGdyZWF0ZXIgdmFsdWUgbGlrZSA2MCBsb29rcyBhaGVhZCB0b3dhcmRzIHRoZSBob3Jpem9uLiBUaGUgc3R5bGUgcGl0Y2ggd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcblx0XHRleGFtcGxlOiA1MFxuXHR9LFxuXHRsaWdodDoge1xuXHRcdHR5cGU6IFwibGlnaHRcIixcblx0XHRkb2M6IFwiVGhlIGdsb2JhbCBsaWdodCBzb3VyY2UuXCIsXG5cdFx0ZXhhbXBsZToge1xuXHRcdFx0YW5jaG9yOiBcInZpZXdwb3J0XCIsXG5cdFx0XHRjb2xvcjogXCJ3aGl0ZVwiLFxuXHRcdFx0aW50ZW5zaXR5OiAwLjRcblx0XHR9XG5cdH0sXG5cdHRlcnJhaW46IHtcblx0XHR0eXBlOiBcInRlcnJhaW5cIixcblx0XHRkb2M6IFwiQSBnbG9iYWwgbW9kaWZpZXIgdGhhdCBlbGV2YXRlcyBsYXllcnMgYW5kIG1hcmtlcnMgYmFzZWQgb24gYSBERU0gZGF0YSBzb3VyY2UuXCJcblx0fSxcblx0Zm9nOiB7XG5cdFx0dHlwZTogXCJmb2dcIixcblx0XHRkb2M6IFwiQSBnbG9iYWwgZWZmZWN0IHRoYXQgZmFkZXMgbGF5ZXJzIGFuZCBtYXJrZXJzIGJhc2VkIG9uIHRoZWlyIGRpc3RhbmNlIHRvIHRoZSBjYW1lcmEuIFRoZSBmb2cgY2FuIGJlIHVzZWQgdG8gYXBwcm94aW1hdGUgdGhlIGVmZmVjdCBvZiBhdG1vc3BoZXJlIG9uIGRpc3RhbnQgb2JqZWN0cyBhbmQgZW5oYW5jZSB0aGUgZGVwdGggcGVyY2VwdGlvbiBvZiB0aGUgbWFwIHdoZW4gdXNlZCB3aXRoIHRlcnJhaW4gb3IgM0QgZmVhdHVyZXMuXCJcblx0fSxcblx0c291cmNlczoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwic291cmNlc1wiLFxuXHRcdGRvYzogXCJEYXRhIHNvdXJjZSBzcGVjaWZpY2F0aW9ucy5cIixcblx0XHRleGFtcGxlOiB7XG5cdFx0XHRcIm1hcGJveC1zdHJlZXRzXCI6IHtcblx0XHRcdFx0dHlwZTogXCJ2ZWN0b3JcIixcblx0XHRcdFx0dXJsOiBcIm1hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NlwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRzcHJpdGU6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLiBUaGlzIHByb3BlcnR5IGlzIHJlcXVpcmVkIGlmIGFueSBsYXllciB1c2VzIHRoZSBgYmFja2dyb3VuZC1wYXR0ZXJuYCwgYGZpbGwtcGF0dGVybmAsIGBsaW5lLXBhdHRlcm5gLCBgZmlsbC1leHRydXNpb24tcGF0dGVybmAsIG9yIGBpY29uLWltYWdlYCBwcm9wZXJ0aWVzLiBUaGUgVVJMIG11c3QgYmUgYWJzb2x1dGUsIGNvbnRhaW5pbmcgdGhlIFtzY2hlbWUsIGF1dGhvcml0eSBhbmQgcGF0aCBjb21wb25lbnRzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUkwjU3ludGF4KS5cIixcblx0XHRleGFtcGxlOiBcIm1hcGJveDovL3Nwcml0ZXMvbWFwYm94L2JyaWdodC12OFwiXG5cdH0sXG5cdGdseXBoczoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkEgVVJMIHRlbXBsYXRlIGZvciBsb2FkaW5nIHNpZ25lZC1kaXN0YW5jZS1maWVsZCBnbHlwaCBzZXRzIGluIFBCRiBmb3JtYXQuIFRoZSBVUkwgbXVzdCBpbmNsdWRlIGB7Zm9udHN0YWNrfWAgYW5kIGB7cmFuZ2V9YCB0b2tlbnMuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlIGB0ZXh0LWZpZWxkYCBsYXlvdXQgcHJvcGVydHkuIFRoZSBVUkwgbXVzdCBiZSBhYnNvbHV0ZSwgY29udGFpbmluZyB0aGUgW3NjaGVtZSwgYXV0aG9yaXR5IGFuZCBwYXRoIGNvbXBvbmVudHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSTCNTeW50YXgpLlwiLFxuXHRcdGV4YW1wbGU6IFwibWFwYm94Oi8vZm9udHMvbWFwYm94L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmXCJcblx0fSxcblx0dHJhbnNpdGlvbjoge1xuXHRcdHR5cGU6IFwidHJhbnNpdGlvblwiLFxuXHRcdGRvYzogXCJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcywgdG8gYmUgdXNlZCBmb3IgdGltaW5nIHRyYW5zaXRpb25zIGJldHdlZW4gb25lIHZhbHVlIGFuZCB0aGUgbmV4dCB3aGVuIG5vIHByb3BlcnR5LXNwZWNpZmljIHRyYW5zaXRpb24gaXMgc2V0LiBDb2xsaXNpb24tYmFzZWQgc3ltYm9sIGZhZGluZyBpcyBjb250cm9sbGVkIGluZGVwZW5kZW50bHkgb2YgdGhlIHN0eWxlJ3MgYHRyYW5zaXRpb25gIHByb3BlcnR5LlwiLFxuXHRcdGV4YW1wbGU6IHtcblx0XHRcdGR1cmF0aW9uOiAzMDAsXG5cdFx0XHRkZWxheTogMFxuXHRcdH1cblx0fSxcblx0cHJvamVjdGlvbjoge1xuXHRcdHR5cGU6IFwicHJvamVjdGlvblwiLFxuXHRcdGRvYzogXCJUaGUgcHJvamVjdGlvbiB0aGUgbWFwIHNob3VsZCBiZSByZW5kZXJlZCBpbi4gU3Vwb3J0ZWQgcHJvamVjdGlvbnMgYXJlIEFsYmVycywgRXF1YWwgRWFydGgsIEVxdWlyZWN0YW5ndWxhciAoV0dTODQpLCBMYW1iZXJ0IGNvbmZvcm1hbCBjb25pYywgTWVyY2F0b3IsIE5hdHVyYWwgRWFydGgsIGFuZCBXaW5rZWwgVHJpcGVsLiBUZXJyYWluLCBmb2csIHNreSBhbmQgQ3VzdG9tTGF5ZXJJbnRlcmZhY2UgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHByb2plY3Rpb25zIG90aGVyIHRoYW4gbWVyY2F0b3IuXCIsXG5cdFx0ZXhhbXBsZToge1xuXHRcdFx0bmFtZTogXCJhbGJlcnNcIixcblx0XHRcdGNlbnRlcjogW1xuXHRcdFx0XHQtMTU0LFxuXHRcdFx0XHQ1MFxuXHRcdFx0XSxcblx0XHRcdHBhcmFsbGVsczogW1xuXHRcdFx0XHQ1NSxcblx0XHRcdFx0NjVcblx0XHRcdF1cblx0XHR9XG5cdH0sXG5cdGxheWVyczoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJsYXllclwiLFxuXHRcdGRvYzogXCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIixcblx0XHRleGFtcGxlOiBbXG5cdFx0XHR7XG5cdFx0XHRcdGlkOiBcIndhdGVyXCIsXG5cdFx0XHRcdHNvdXJjZTogXCJtYXBib3gtc3RyZWV0c1wiLFxuXHRcdFx0XHRcInNvdXJjZS1sYXllclwiOiBcIndhdGVyXCIsXG5cdFx0XHRcdHR5cGU6IFwiZmlsbFwiLFxuXHRcdFx0XHRwYWludDoge1xuXHRcdFx0XHRcdFwiZmlsbC1jb2xvclwiOiBcIiMwMGZmZmZcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XVxuXHR9XG59O1xudmFyIHNvdXJjZXMgPSB7XG5cdFwiKlwiOiB7XG5cdFx0dHlwZTogXCJzb3VyY2VcIixcblx0XHRkb2M6IFwiU3BlY2lmaWNhdGlvbiBvZiBhIGRhdGEgc291cmNlLiBGb3IgdmVjdG9yIGFuZCByYXN0ZXIgc291cmNlcywgZWl0aGVyIFRpbGVKU09OIG9yIGEgVVJMIHRvIGEgVGlsZUpTT04gbXVzdCBiZSBwcm92aWRlZC4gRm9yIGltYWdlIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLiBGb3IgR2VvSlNPTiBzb3VyY2VzLCBhIFVSTCBvciBpbmxpbmUgR2VvSlNPTiBtdXN0IGJlIHByb3ZpZGVkLlwiXG5cdH1cbn07XG52YXIgc291cmNlID0gW1xuXHRcInNvdXJjZV92ZWN0b3JcIixcblx0XCJzb3VyY2VfcmFzdGVyXCIsXG5cdFwic291cmNlX3Jhc3Rlcl9kZW1cIixcblx0XCJzb3VyY2VfZ2VvanNvblwiLFxuXHRcInNvdXJjZV92aWRlb1wiLFxuXHRcInNvdXJjZV9pbWFnZVwiXG5dO1xudmFyIHNvdXJjZV92ZWN0b3IgPSB7XG5cdHR5cGU6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZlY3Rvcjoge1xuXHRcdFx0XHRkb2M6IFwiQSB2ZWN0b3IgdGlsZSBzb3VyY2UuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgdHlwZSBvZiB0aGUgc291cmNlLlwiXG5cdH0sXG5cdHVybDoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxUaWxlc2V0IElEPmAuXCJcblx0fSxcblx0dGlsZXM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG5cdH0sXG5cdGJvdW5kczoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDQsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdC0xODAsXG5cdFx0XHQtODUuMDUxMTI5LFxuXHRcdFx0MTgwLFxuXHRcdFx0ODUuMDUxMTI5XG5cdFx0XSxcblx0XHRkb2M6IFwiQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBvZiB0aGUgc291dGh3ZXN0IGFuZCBub3J0aGVhc3QgY29ybmVycyBvZiB0aGUgc291cmNlJ3MgYm91bmRpbmcgYm94IGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6IGBbc3cubG5nLCBzdy5sYXQsIG5lLmxuZywgbmUubGF0XWAuIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBpbmNsdWRlZCBpbiBhIHNvdXJjZSwgbm8gdGlsZXMgb3V0c2lkZSBvZiB0aGUgZ2l2ZW4gYm91bmRzIGFyZSByZXF1ZXN0ZWQgYnkgTWFwYm94IEdMLlwiXG5cdH0sXG5cdHNjaGVtZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0eHl6OiB7XG5cdFx0XHRcdGRvYzogXCJTbGlwcHkgbWFwIHRpbGVuYW1lcyBzY2hlbWUuXCJcblx0XHRcdH0sXG5cdFx0XHR0bXM6IHtcblx0XHRcdFx0ZG9jOiBcIk9TR2VvIHNwZWMgc2NoZW1lLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ4eXpcIixcblx0XHRkb2M6IFwiSW5mbHVlbmNlcyB0aGUgeSBkaXJlY3Rpb24gb2YgdGhlIHRpbGUgY29vcmRpbmF0ZXMuIFRoZSBnbG9iYWwtbWVyY2F0b3IgKGFrYSBTcGhlcmljYWwgTWVyY2F0b3IpIHByb2ZpbGUgaXMgYXNzdW1lZC5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMjIsXG5cdFx0ZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcblx0fSxcblx0YXR0cmlidXRpb246IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJDb250YWlucyBhbiBhdHRyaWJ1dGlvbiB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgbWFwIGlzIHNob3duIHRvIGEgdXNlci5cIlxuXHR9LFxuXHRwcm9tb3RlSWQ6IHtcblx0XHR0eXBlOiBcInByb21vdGVJZFwiLFxuXHRcdGRvYzogXCJBIHByb3BlcnR5IHRvIHVzZSBhcyBhIGZlYXR1cmUgaWQgKGZvciBmZWF0dXJlIHN0YXRlKS4gRWl0aGVyIGEgcHJvcGVydHkgbmFtZSwgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7PHNvdXJjZUxheWVyPjogPHByb3BlcnR5TmFtZT59YC4gSWYgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIGZvciBhIHZlY3RvciB0aWxlIHNvdXJjZSwgdGhlIHNhbWUgcHJvcGVydHkgaXMgdXNlZCBhY3Jvc3MgYWxsIGl0cyBzb3VyY2UgbGF5ZXJzLlwiXG5cdH0sXG5cdHZvbGF0aWxlOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJBIHNldHRpbmcgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzb3VyY2UncyB0aWxlcyBhcmUgY2FjaGVkIGxvY2FsbHkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRhbmRyb2lkOiBcIjkuMy4wXCIsXG5cdFx0XHRcdGlvczogXCI1LjEwLjBcIlxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG5cdH1cbn07XG52YXIgc291cmNlX3Jhc3RlciA9IHtcblx0dHlwZToge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0cmFzdGVyOiB7XG5cdFx0XHRcdGRvYzogXCJBIHJhc3RlciB0aWxlIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSB0eXBlIG9mIHRoZSBzb3VyY2UuXCJcblx0fSxcblx0dXJsOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPFRpbGVzZXQgSUQ+YC5cIlxuXHR9LFxuXHR0aWxlczoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0Ym91bmRzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogNCxcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0LTE4MCxcblx0XHRcdC04NS4wNTExMjksXG5cdFx0XHQxODAsXG5cdFx0XHQ4NS4wNTExMjlcblx0XHRdLFxuXHRcdGRvYzogXCJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuXCJcblx0fSxcblx0bWluem9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcblx0fSxcblx0bWF4em9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDIyLFxuXHRcdGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG5cdH0sXG5cdHRpbGVTaXplOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNTEyLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuXHR9LFxuXHRzY2hlbWU6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHh5ejoge1xuXHRcdFx0XHRkb2M6IFwiU2xpcHB5IG1hcCB0aWxlbmFtZXMgc2NoZW1lLlwiXG5cdFx0XHR9LFxuXHRcdFx0dG1zOiB7XG5cdFx0XHRcdGRvYzogXCJPU0dlbyBzcGVjIHNjaGVtZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwieHl6XCIsXG5cdFx0ZG9jOiBcIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuXCJcblx0fSxcblx0YXR0cmlidXRpb246IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJDb250YWlucyBhbiBhdHRyaWJ1dGlvbiB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgbWFwIGlzIHNob3duIHRvIGEgdXNlci5cIlxuXHR9LFxuXHR2b2xhdGlsZToge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiQSBzZXR0aW5nIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc291cmNlJ3MgdGlsZXMgYXJlIGNhY2hlZCBsb2NhbGx5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0YW5kcm9pZDogXCI5LjMuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNS4xMC4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFwiKlwiOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0ZG9jOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuXHR9XG59O1xudmFyIHNvdXJjZV9yYXN0ZXJfZGVtID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRcInJhc3Rlci1kZW1cIjoge1xuXHRcdFx0XHRkb2M6IFwiQSBSR0ItZW5jb2RlZCByYXN0ZXIgREVNIHNvdXJjZVwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG5cdH0sXG5cdHRpbGVzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRib3VuZHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQtMTgwLFxuXHRcdFx0LTg1LjA1MTEyOSxcblx0XHRcdDE4MCxcblx0XHRcdDg1LjA1MTEyOVxuXHRcdF0sXG5cdFx0ZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuXHR9LFxuXHRtYXh6b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMjIsXG5cdFx0ZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcblx0fSxcblx0dGlsZVNpemU6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiA1MTIsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG5cdH0sXG5cdGF0dHJpYnV0aW9uOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcblx0fSxcblx0ZW5jb2Rpbmc6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHRlcnJhcml1bToge1xuXHRcdFx0XHRkb2M6IFwiVGVycmFyaXVtIGZvcm1hdCBQTkcgdGlsZXMuIFNlZSBodHRwczovL2F3cy5hbWF6b24uY29tL2VzL3B1YmxpYy1kYXRhc2V0cy90ZXJyYWluLyBmb3IgbW9yZSBpbmZvLlwiXG5cdFx0XHR9LFxuXHRcdFx0bWFwYm94OiB7XG5cdFx0XHRcdGRvYzogXCJNYXBib3ggVGVycmFpbiBSR0IgdGlsZXMuIFNlZSBodHRwczovL3d3dy5tYXBib3guY29tL2hlbHAvYWNjZXNzLWVsZXZhdGlvbi1kYXRhLyNtYXBib3gtdGVycmFpbi1yZ2IgZm9yIG1vcmUgaW5mby5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwYm94XCIsXG5cdFx0ZG9jOiBcIlRoZSBlbmNvZGluZyB1c2VkIGJ5IHRoaXMgc291cmNlLiBNYXBib3ggVGVycmFpbiBSR0IgaXMgdXNlZCBieSBkZWZhdWx0XCJcblx0fSxcblx0dm9sYXRpbGU6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIkEgc2V0dGluZyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNvdXJjZSdzIHRpbGVzIGFyZSBjYWNoZWQgbG9jYWxseS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGFuZHJvaWQ6IFwiOS4zLjBcIixcblx0XHRcdFx0aW9zOiBcIjUuMTAuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcIipcIjoge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcblx0fVxufTtcbnZhciBzb3VyY2VfZ2VvanNvbiA9IHtcblx0dHlwZToge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0Z2VvanNvbjoge1xuXHRcdFx0XHRkb2M6IFwiQSBHZW9KU09OIGRhdGEgc291cmNlLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgR2VvSlNPTiBzb3VyY2UuXCJcblx0fSxcblx0ZGF0YToge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJBIFVSTCB0byBhIEdlb0pTT04gZmlsZSwgb3IgaW5saW5lIEdlb0pTT04uXCJcblx0fSxcblx0bWF4em9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDE4LFxuXHRcdGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHZlY3RvciB0aWxlcyAoaGlnaGVyIG1lYW5zIGdyZWF0ZXIgZGV0YWlsIGF0IGhpZ2ggem9vbSBsZXZlbHMpLlwiXG5cdH0sXG5cdGF0dHJpYnV0aW9uOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcblx0fSxcblx0YnVmZmVyOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMTI4LFxuXHRcdG1heGltdW06IDUxMixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdGRvYzogXCJTaXplIG9mIHRoZSB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGUuIEEgdmFsdWUgb2YgMCBwcm9kdWNlcyBubyBidWZmZXIuIEEgdmFsdWUgb2YgNTEyIHByb2R1Y2VzIGEgYnVmZmVyIGFzIHdpZGUgYXMgdGhlIHRpbGUgaXRzZWxmLiBMYXJnZXIgdmFsdWVzIHByb2R1Y2UgZmV3ZXIgcmVuZGVyaW5nIGFydGlmYWN0cyBuZWFyIHRpbGUgZWRnZXMgYW5kIHNsb3dlciBwZXJmb3JtYW5jZS5cIlxuXHR9LFxuXHRmaWx0ZXI6IHtcblx0XHR0eXBlOiBcIipcIixcblx0XHRkb2M6IFwiQW4gZXhwcmVzc2lvbiBmb3IgZmlsdGVyaW5nIGZlYXR1cmVzIHByaW9yIHRvIHByb2Nlc3NpbmcgdGhlbSBmb3IgcmVuZGVyaW5nLlwiXG5cdH0sXG5cdHRvbGVyYW5jZToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAuMzc1LFxuXHRcdGRvYzogXCJEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlciBnZW9tZXRyaWVzIGFuZCBmYXN0ZXIgcGVyZm9ybWFuY2UpLlwiXG5cdH0sXG5cdGNsdXN0ZXI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRoZSBkYXRhIGlzIGEgY29sbGVjdGlvbiBvZiBwb2ludCBmZWF0dXJlcywgc2V0dGluZyB0aGlzIHRvIHRydWUgY2x1c3RlcnMgdGhlIHBvaW50cyBieSByYWRpdXMgaW50byBncm91cHMuIENsdXN0ZXIgZ3JvdXBzIGJlY29tZSBuZXcgYFBvaW50YCBmZWF0dXJlcyBpbiB0aGUgc291cmNlIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzOlxcbiAqIGBjbHVzdGVyYCBJcyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGEgY2x1c3RlciBcXG4gKiBgY2x1c3Rlcl9pZGAgQSB1bnFpdWUgaWQgZm9yIHRoZSBjbHVzdGVyIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgW2NsdXN0ZXIgaW5zcGVjdGlvbiBtZXRob2RzXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI2dlb2pzb25zb3VyY2UjZ2V0Y2x1c3RlcmV4cGFuc2lvbnpvb20pXFxuICogYHBvaW50X2NvdW50YCBOdW1iZXIgb2Ygb3JpZ2luYWwgcG9pbnRzIGdyb3VwZWQgaW50byB0aGlzIGNsdXN0ZXJcXG4gKiBgcG9pbnRfY291bnRfYWJicmV2aWF0ZWRgIEFuIGFiYnJldmlhdGVkIHBvaW50IGNvdW50XCJcblx0fSxcblx0Y2x1c3RlclJhZGl1czoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDUwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0ZG9jOiBcIlJhZGl1cyBvZiBlYWNoIGNsdXN0ZXIgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLiBBIHZhbHVlIG9mIDUxMiBpbmRpY2F0ZXMgYSByYWRpdXMgZXF1YWwgdG8gdGhlIHdpZHRoIG9mIGEgdGlsZS5cIlxuXHR9LFxuXHRjbHVzdGVyTWF4Wm9vbToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIk1heCB6b29tIG9uIHdoaWNoIHRvIGNsdXN0ZXIgcG9pbnRzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZC4gRGVmYXVsdHMgdG8gb25lIHpvb20gbGVzcyB0aGFuIG1heHpvb20gKHNvIHRoYXQgbGFzdCB6b29tIGZlYXR1cmVzIGFyZSBub3QgY2x1c3RlcmVkKS4gQ2x1c3RlcnMgYXJlIHJlLWV2YWx1YXRlZCBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzIHNvIHNldHRpbmcgY2x1c3Rlck1heFpvb20gdG8gMTQgbWVhbnMgdGhlIGNsdXN0ZXJzIHdpbGwgYmUgZGlzcGxheWVkIHVudGlsIHoxNS5cIlxuXHR9LFxuXHRjbHVzdGVyTWluUG9pbnRzOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiTWluaW11bSBudW1iZXIgb2YgcG9pbnRzIG5lY2Vzc2FyeSB0byBmb3JtIGEgY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIERlZmF1bHRzIHRvIGAyYC5cIlxuXHR9LFxuXHRjbHVzdGVyUHJvcGVydGllczoge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJBbiBvYmplY3QgZGVmaW5pbmcgY3VzdG9tIHByb3BlcnRpZXMgb24gdGhlIGdlbmVyYXRlZCBjbHVzdGVycyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQsIGFnZ3JlZ2F0aW5nIHZhbHVlcyBmcm9tIGNsdXN0ZXJlZCBwb2ludHMuIEhhcyB0aGUgZm9ybSBge1xcXCJwcm9wZXJ0eV9uYW1lXFxcIjogW29wZXJhdG9yLCBtYXBfZXhwcmVzc2lvbl19YC4gYG9wZXJhdG9yYCBpcyBhbnkgZXhwcmVzc2lvbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXQgbGVhc3QgMiBvcGVyYW5kcyAoZS5nLiBgXFxcIitcXFwiYCBvciBgXFxcIm1heFxcXCJgKSDigJQgaXQgYWNjdW11bGF0ZXMgdGhlIHByb3BlcnR5IHZhbHVlIGZyb20gY2x1c3RlcnMvcG9pbnRzIHRoZSBjbHVzdGVyIGNvbnRhaW5zOyBgbWFwX2V4cHJlc3Npb25gIHByb2R1Y2VzIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSBwb2ludC5cXG5cXG5FeGFtcGxlOiBge1xcXCJzdW1cXFwiOiBbXFxcIitcXFwiLCBbXFxcImdldFxcXCIsIFxcXCJzY2FsZXJhbmtcXFwiXV19YC5cXG5cXG5Gb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIGluIHBsYWNlIG9mIGBvcGVyYXRvcmAsIHlvdSBjYW4gdXNlIGEgY3VzdG9tIHJlZHVjZSBleHByZXNzaW9uIHRoYXQgcmVmZXJlbmNlcyBhIHNwZWNpYWwgYFtcXFwiYWNjdW11bGF0ZWRcXFwiXWAgdmFsdWUsIGUuZy46XFxuYHtcXFwic3VtXFxcIjogW1tcXFwiK1xcXCIsIFtcXFwiYWNjdW11bGF0ZWRcXFwiXSwgW1xcXCJnZXRcXFwiLCBcXFwic3VtXFxcIl1dLCBbXFxcImdldFxcXCIsIFxcXCJzY2FsZXJhbmtcXFwiXV19YFwiXG5cdH0sXG5cdGxpbmVNZXRyaWNzOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRvIGNhbGN1bGF0ZSBsaW5lIGRpc3RhbmNlIG1ldHJpY3MuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGxpbmUgbGF5ZXJzIHRoYXQgc3BlY2lmeSBgbGluZS1ncmFkaWVudGAgdmFsdWVzLlwiXG5cdH0sXG5cdGdlbmVyYXRlSWQ6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdG8gZ2VuZXJhdGUgaWRzIGZvciB0aGUgZ2VvanNvbiBmZWF0dXJlcy4gV2hlbiBlbmFibGVkLCB0aGUgYGZlYXR1cmUuaWRgIHByb3BlcnR5IHdpbGwgYmUgYXV0byBhc3NpZ25lZCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gdGhlIGBmZWF0dXJlc2AgYXJyYXksIG92ZXItd3JpdGluZyBhbnkgcHJldmlvdXMgdmFsdWVzLlwiXG5cdH0sXG5cdHByb21vdGVJZDoge1xuXHRcdHR5cGU6IFwicHJvbW90ZUlkXCIsXG5cdFx0ZG9jOiBcIkEgcHJvcGVydHkgdG8gdXNlIGFzIGEgZmVhdHVyZSBpZCAoZm9yIGZlYXR1cmUgc3RhdGUpLiBFaXRoZXIgYSBwcm9wZXJ0eSBuYW1lLCBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHs8c291cmNlTGF5ZXI+OiA8cHJvcGVydHlOYW1lPn1gLlwiXG5cdH1cbn07XG52YXIgc291cmNlX3ZpZGVvID0ge1xuXHR0eXBlOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aWRlbzoge1xuXHRcdFx0XHRkb2M6IFwiQSB2aWRlbyBkYXRhIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHZpZGVvIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmxzOiB7XG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJVUkxzIHRvIHZpZGVvIGNvbnRlbnQgaW4gb3JkZXIgb2YgcHJlZmVycmVkIGZvcm1hdC5cIlxuXHR9LFxuXHRjb29yZGluYXRlczoge1xuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdGRvYzogXCJDb3JuZXJzIG9mIHZpZGVvIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLlwiLFxuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRsZW5ndGg6IDQsXG5cdFx0dmFsdWU6IHtcblx0XHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRcdGxlbmd0aDogMixcblx0XHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdFx0ZG9jOiBcIkEgc2luZ2xlIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpci5cIlxuXHRcdH1cblx0fVxufTtcbnZhciBzb3VyY2VfaW1hZ2UgPSB7XG5cdHR5cGU6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGltYWdlOiB7XG5cdFx0XHRcdGRvYzogXCJBbiBpbWFnZSBkYXRhIHNvdXJjZS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIGltYWdlIHNvdXJjZS5cIlxuXHR9LFxuXHR1cmw6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJVUkwgdGhhdCBwb2ludHMgdG8gYW4gaW1hZ2UuXCJcblx0fSxcblx0Y29vcmRpbmF0ZXM6IHtcblx0XHRyZXF1aXJlZDogdHJ1ZSxcblx0XHRkb2M6IFwiQ29ybmVycyBvZiBpbWFnZSBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy5cIixcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdHZhbHVlOiB7XG5cdFx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0XHRsZW5ndGg6IDIsXG5cdFx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRcdGRvYzogXCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJcblx0XHR9XG5cdH1cbn07XG52YXIgbGF5ZXIgPSB7XG5cdGlkOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiVW5pcXVlIGxheWVyIG5hbWUuXCIsXG5cdFx0cmVxdWlyZWQ6IHRydWVcblx0fSxcblx0dHlwZToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0ZmlsbDoge1xuXHRcdFx0XHRkb2M6IFwiQSBmaWxsZWQgcG9seWdvbiB3aXRoIGFuIG9wdGlvbmFsIHN0cm9rZWQgYm9yZGVyLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRsaW5lOiB7XG5cdFx0XHRcdGRvYzogXCJBIHN0cm9rZWQgbGluZS5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3ltYm9sOiB7XG5cdFx0XHRcdGRvYzogXCJBbiBpY29uIG9yIGEgdGV4dCBsYWJlbC5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y2lyY2xlOiB7XG5cdFx0XHRcdGRvYzogXCJBIGZpbGxlZCBjaXJjbGUuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhlYXRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIkEgaGVhdG1hcC5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0XCJmaWxsLWV4dHJ1c2lvblwiOiB7XG5cdFx0XHRcdGRvYzogXCJBbiBleHRydWRlZCAoM0QpIHBvbHlnb24uXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJhc3Rlcjoge1xuXHRcdFx0XHRkb2M6IFwiUmFzdGVyIG1hcCB0ZXh0dXJlcyBzdWNoIGFzIHNhdGVsbGl0ZSBpbWFnZXJ5LlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRoaWxsc2hhZGU6IHtcblx0XHRcdFx0ZG9jOiBcIkNsaWVudC1zaWRlIGhpbGxzaGFkaW5nIHZpc3VhbGl6YXRpb24gYmFzZWQgb24gREVNIGRhdGEuIEN1cnJlbnRseSwgdGhlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgTWFwYm94IFRlcnJhaW4gUkdCIGFuZCBNYXB6ZW4gVGVycmFyaXVtIHRpbGVzLlwiLFxuXHRcdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRiYWNrZ3JvdW5kOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYmFja2dyb3VuZCBjb2xvciBvciBwYXR0ZXJuIG9mIHRoZSBtYXAuXCIsXG5cdFx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNreToge1xuXHRcdFx0XHRkb2M6IFwiQSBzcGhlcmljYWwgZG9tZSBhcm91bmQgdGhlIG1hcCB0aGF0IGlzIGFsd2F5cyByZW5kZXJlZCBiZWhpbmQgYWxsIG90aGVyIGxheWVycy5cIixcblx0XHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRcdGpzOiBcIjIuMC4wXCIsXG5cdFx0XHRcdFx0XHRpb3M6IFwiMTAuMC4wXCIsXG5cdFx0XHRcdFx0XHRhbmRyb2lkOiBcIjEwLjAuMFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIixcblx0XHRyZXF1aXJlZDogdHJ1ZVxuXHR9LFxuXHRtZXRhZGF0YToge1xuXHRcdHR5cGU6IFwiKlwiLFxuXHRcdGRvYzogXCJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgbGF5ZXIsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcblx0fSxcblx0c291cmNlOiB7XG5cdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRkb2M6IFwiTmFtZSBvZiBhIHNvdXJjZSBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGxheWVyLiBSZXF1aXJlZCBmb3IgYWxsIGxheWVyIHR5cGVzIGV4Y2VwdCBgYmFja2dyb3VuZGAuXCJcblx0fSxcblx0XCJzb3VyY2UtbGF5ZXJcIjoge1xuXHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0ZG9jOiBcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBmb3IgdmVjdG9yIHRpbGUgc291cmNlczsgcHJvaGliaXRlZCBmb3IgYWxsIG90aGVyIHNvdXJjZSB0eXBlcywgaW5jbHVkaW5nIEdlb0pTT04gc291cmNlcy5cIlxuXHR9LFxuXHRtaW56b29tOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDI0LFxuXHRcdGRvYzogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgbGF5ZXIuIEF0IHpvb20gbGV2ZWxzIGxlc3MgdGhhbiB0aGUgbWluem9vbSwgdGhlIGxheWVyIHdpbGwgYmUgaGlkZGVuLlwiXG5cdH0sXG5cdG1heHpvb206IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMjQsXG5cdFx0ZG9jOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBsYXllci4gQXQgem9vbSBsZXZlbHMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRoZSBtYXh6b29tLCB0aGUgbGF5ZXIgd2lsbCBiZSBoaWRkZW4uXCJcblx0fSxcblx0ZmlsdGVyOiB7XG5cdFx0dHlwZTogXCJmaWx0ZXJcIixcblx0XHRkb2M6IFwiQW4gZXhwcmVzc2lvbiBzcGVjaWZ5aW5nIGNvbmRpdGlvbnMgb24gc291cmNlIGZlYXR1cmVzLiBPbmx5IGZlYXR1cmVzIHRoYXQgbWF0Y2ggdGhlIGZpbHRlciBhcmUgZGlzcGxheWVkLiBab29tIGV4cHJlc3Npb25zIGluIGZpbHRlcnMgYXJlIG9ubHkgZXZhbHVhdGVkIGF0IGludGVnZXIgem9vbSBsZXZlbHMuIFRoZSBgW1xcXCJmZWF0dXJlLXN0YXRlXFxcIiwgLi4uXWAgZXhwcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGZpbHRlciBleHByZXNzaW9ucy4gIFRoZSBgW1xcXCJwaXRjaFxcXCJdYCBhbmQgYFtcXFwiZGlzdGFuY2UtZnJvbS1jZW50ZXJcXFwiXWAgZXhwcmVzc2lvbnMgYXJlIHN1cHBvcnRlZCBvbmx5IGZvciBmaWx0ZXIgZXhwcmVzc2lvbnMgb24gdGhlIHN5bWJvbCBsYXllci5cIlxuXHR9LFxuXHRsYXlvdXQ6IHtcblx0XHR0eXBlOiBcImxheW91dFwiLFxuXHRcdGRvYzogXCJMYXlvdXQgcHJvcGVydGllcyBmb3IgdGhlIGxheWVyLlwiXG5cdH0sXG5cdHBhaW50OiB7XG5cdFx0dHlwZTogXCJwYWludFwiLFxuXHRcdGRvYzogXCJEZWZhdWx0IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCJcblx0fVxufTtcbnZhciBsYXlvdXQgPSBbXG5cdFwibGF5b3V0X2ZpbGxcIixcblx0XCJsYXlvdXRfbGluZVwiLFxuXHRcImxheW91dF9jaXJjbGVcIixcblx0XCJsYXlvdXRfaGVhdG1hcFwiLFxuXHRcImxheW91dF9maWxsLWV4dHJ1c2lvblwiLFxuXHRcImxheW91dF9zeW1ib2xcIixcblx0XCJsYXlvdXRfcmFzdGVyXCIsXG5cdFwibGF5b3V0X2hpbGxzaGFkZVwiLFxuXHRcImxheW91dF9iYWNrZ3JvdW5kXCIsXG5cdFwibGF5b3V0X3NreVwiXG5dO1xudmFyIGxheW91dF9iYWNrZ3JvdW5kID0ge1xuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGxheW91dF9za3kgPSB7XG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjIuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIxMC4wLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIxMC4wLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGxheW91dF9maWxsID0ge1xuXHRcImZpbGwtc29ydC1rZXlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiOS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjUuOC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMS4yLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI5LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNS44LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGxheW91dF9jaXJjbGUgPSB7XG5cdFwiY2lyY2xlLXNvcnQta2V5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIxLjIuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjkuMi4wXCIsXG5cdFx0XHRcdGlvczogXCI1LjkuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE2LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiOS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjUuOS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfaGVhdG1hcCA9IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfbGluZSA9IHtcblx0XCJsaW5lLWNhcFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRidXR0OiB7XG5cdFx0XHRcdGRvYzogXCJBIGNhcCB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIHRvIHRoZSBleGFjdCBlbmRwb2ludCBvZiB0aGUgbGluZS5cIlxuXHRcdFx0fSxcblx0XHRcdHJvdW5kOiB7XG5cdFx0XHRcdGRvYzogXCJBIGNhcCB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHRzcXVhcmU6IHtcblx0XHRcdFx0ZG9jOiBcIkEgY2FwIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIGRpc3RhbmNlIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGguXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcblx0XHRkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIyLjMuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWpvaW5cIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0YmV2ZWw6IHtcblx0XHRcdFx0ZG9jOiBcIkEgam9pbiB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSBkaXN0YW5jZSBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoLlwiXG5cdFx0XHR9LFxuXHRcdFx0cm91bmQ6IHtcblx0XHRcdFx0ZG9jOiBcIkEgam9pbiB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHRtaXRlcjoge1xuXHRcdFx0XHRkb2M6IFwiQSBqb2luIHdpdGggYSBzaGFycCwgYW5nbGVkIGNvcm5lciB3aGljaCBpcyBkcmF3biB3aXRoIHRoZSBvdXRlciBzaWRlcyBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBwYXRoIHVudGlsIHRoZXkgbWVldC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcblx0XHRkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1taXRlci1saW1pdFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMixcblx0XHRkb2M6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcImxpbmUtam9pblwiOiBcIm1pdGVyXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtcm91bmQtbGltaXRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEuMDUsXG5cdFx0ZG9jOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcImxpbmUtam9pblwiOiBcInJvdW5kXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtc29ydC1rZXlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMi4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiOS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjUuOC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMS4yLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI5LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNS44LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGxheW91dF9zeW1ib2wgPSB7XG5cdFwic3ltYm9sLXBsYWNlbWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRwb2ludDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGdlb21ldHJ5IGlzIGxvY2F0ZWQuXCJcblx0XHRcdH0sXG5cdFx0XHRsaW5lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGFiZWwgaXMgcGxhY2VkIGFsb25nIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJsaW5lLWNlbnRlclwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGFiZWwgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGxpbmUgb2YgdGhlIGdlb21ldHJ5LiBDYW4gb25seSBiZSB1c2VkIG9uIGBMaW5lU3RyaW5nYCBhbmQgYFBvbHlnb25gIGdlb21ldHJpZXMuIE5vdGUgdGhhdCBhIHNpbmdsZSBmZWF0dXJlIGluIGEgdmVjdG9yIHRpbGUgbWF5IGNvbnRhaW4gbXVsdGlwbGUgbGluZSBnZW9tZXRyaWVzLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJwb2ludFwiLFxuXHRcdGRvYzogXCJMYWJlbCBwbGFjZW1lbnQgcmVsYXRpdmUgdG8gaXRzIGdlb21ldHJ5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImBsaW5lLWNlbnRlcmAgdmFsdWVcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjQuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4zLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJzeW1ib2wtc3BhY2luZ1wiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMjUwLFxuXHRcdG1pbmltdW06IDEsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkRpc3RhbmNlIGJldHdlZW4gdHdvIHN5bWJvbCBhbmNob3JzLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIHRoZSBzeW1ib2xzIHdpbGwgbm90IGNyb3NzIHRpbGUgZWRnZXMgdG8gYXZvaWQgbXV0dWFsIGNvbGxpc2lvbnMuIFJlY29tbWVuZGVkIGluIGxheWVycyB0aGF0IGRvbid0IGhhdmUgZW5vdWdoIHBhZGRpbmcgaW4gdGhlIHZlY3RvciB0aWxlIHRvIHByZXZlbnQgY29sbGlzaW9ucywgb3IgaWYgaXQgaXMgYSBwb2ludCBzeW1ib2wgbGF5ZXIgcGxhY2VkIGFmdGVyIGEgbGluZSBzeW1ib2wgbGF5ZXIuIFdoZW4gdXNpbmcgYSBjbGllbnQgdGhhdCBzdXBwb3J0cyBnbG9iYWwgY29sbGlzaW9uIGRldGVjdGlvbiwgbGlrZSBNYXBib3ggR0wgSlMgdmVyc2lvbiAwLjQyLjAgb3IgZ3JlYXRlciwgZW5hYmxpbmcgdGhpcyBwcm9wZXJ0eSBpcyBub3QgbmVlZGVkIHRvIHByZXZlbnQgY2xpcHBlZCBsYWJlbHMgYXQgdGlsZSBib3VuZGFyaWVzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJzeW1ib2wtc29ydC1rZXlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGxvd2VyIHNvcnQga2V5cyBhcmUgZHJhd24gYW5kIHBsYWNlZCBmaXJzdC4gIFdoZW4gYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgYGZhbHNlYCwgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5IHdpbGwgaGF2ZSBwcmlvcml0eSBkdXJpbmcgcGxhY2VtZW50LiBXaGVuIGBpY29uLWFsbG93LW92ZXJsYXBgIG9yIGB0ZXh0LWFsbG93LW92ZXJsYXBgIGlzIHNldCB0byBgdHJ1ZWAsIGZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBvdmVybGFwIG92ZXIgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTEuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjExLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInN5bWJvbC16LW9yZGVyXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGF1dG86IHtcblx0XHRcdFx0ZG9jOiBcIlNvcnRzIHN5bWJvbHMgYnkgYHN5bWJvbC1zb3J0LWtleWAgaWYgc2V0LiBPdGhlcndpc2UsIHNvcnRzIHN5bWJvbHMgYnkgdGhlaXIgeS1wb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgaWYgYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCBvciBgaWNvbi1pZ25vcmUtcGxhY2VtZW50YCBvciBgdGV4dC1pZ25vcmUtcGxhY2VtZW50YCBpcyBgZmFsc2VgLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ2aWV3cG9ydC15XCI6IHtcblx0XHRcdFx0ZG9jOiBcIlNvcnRzIHN5bWJvbHMgYnkgdGhlaXIgeS1wb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgaWYgYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCBvciBgaWNvbi1pZ25vcmUtcGxhY2VtZW50YCBvciBgdGV4dC1pZ25vcmUtcGxhY2VtZW50YCBpcyBgZmFsc2VgLlwiXG5cdFx0XHR9LFxuXHRcdFx0c291cmNlOiB7XG5cdFx0XHRcdGRvYzogXCJTb3J0cyBzeW1ib2xzIGJ5IGBzeW1ib2wtc29ydC1rZXlgIGlmIHNldC4gT3RoZXJ3aXNlLCBubyBzb3J0aW5nIGlzIGFwcGxpZWQ7IHN5bWJvbHMgYXJlIHJlbmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBzb3VyY2UgZGF0YS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuXHRcdGRvYzogXCJEZXRlcm1pbmVzIHdoZXRoZXIgb3ZlcmxhcHBpbmcgc3ltYm9scyBpbiB0aGUgc2FtZSBsYXllciBhcmUgcmVuZGVyZWQgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcHBlYXIgaW4gdGhlIGRhdGEgc291cmNlIG9yIGJ5IHRoZWlyIHktcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LiBUbyBjb250cm9sIHRoZSBvcmRlciBhbmQgcHJpb3JpdGl6YXRpb24gb2Ygc3ltYm9scyBvdGhlcndpc2UsIHVzZSBgc3ltYm9sLXNvcnQta2V5YC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuNi4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEyLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSBpY29uLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tb3B0aW9uYWxcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgdGV4dCB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIGljb25zIHdoZW4gdGhlIGljb24gY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgdGV4dCBkb2VzIG5vdC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCIsXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIGFsaWducyBpY29ucyBlYXN0LXdlc3QuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgYWxpZ25zIGljb24geC1heGVzIHdpdGggdGhlIGxpbmUuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiUHJvZHVjZXMgaWNvbnMgd2hvc2UgeC1heGVzIGFyZSBhbGlnbmVkIHdpdGggdGhlIHgtYXhpcyBvZiB0aGUgdmlld3BvcnQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzeW1ib2wtcGxhY2VtZW50YC5cIlxuXHRcdFx0fSxcblx0XHRcdGF1dG86IHtcblx0XHRcdFx0ZG9jOiBcIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYHZpZXdwb3J0YC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYG1hcGAuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImF1dG9cIixcblx0XHRkb2M6IFwiSW4gY29tYmluYXRpb24gd2l0aCBgc3ltYm9sLXBsYWNlbWVudGAsIGRldGVybWluZXMgdGhlIHJvdGF0aW9uIGJlaGF2aW9yIG9mIGljb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiYGF1dG9gIHZhbHVlXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLXNpemVcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJmYWN0b3Igb2YgdGhlIG9yaWdpbmFsIGljb24gc2l6ZVwiLFxuXHRcdGRvYzogXCJTY2FsZXMgdGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIGljb24gYnkgdGhlIHByb3ZpZGVkIGZhY3Rvci4gVGhlIG5ldyBwaXhlbCBzaXplIG9mIHRoZSBpbWFnZSB3aWxsIGJlIHRoZSBvcmlnaW5hbCBwaXhlbCBzaXplIG11bHRpcGxpZWQgYnkgYGljb24tc2l6ZWAuIDEgaXMgdGhlIG9yaWdpbmFsIHNpemU7IDMgdHJpcGxlcyB0aGUgc2l6ZSBvZiB0aGUgaW1hZ2UuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi10ZXh0LWZpdFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBkaXNwbGF5ZWQgYXQgaXRzIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uXCJcblx0XHRcdH0sXG5cdFx0XHR3aWR0aDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgc2NhbGVkIGluIHRoZSB4LWRpbWVuc2lvbiB0byBmaXQgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0LlwiXG5cdFx0XHR9LFxuXHRcdFx0aGVpZ2h0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHktZGltZW5zaW9uIHRvIGZpdCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LlwiXG5cdFx0XHR9LFxuXHRcdFx0Ym90aDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgc2NhbGVkIGluIGJvdGggeC0gYW5kIHktZGltZW5zaW9ucy5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibm9uZVwiLFxuXHRcdGRvYzogXCJTY2FsZXMgdGhlIGljb24gdG8gZml0IGFyb3VuZCB0aGUgYXNzb2NpYXRlZCB0ZXh0LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjIuMVwiXG5cdFx0XHR9LFxuXHRcdFx0XCJzdHJldGNoYWJsZSBpY29uc1wiOiB7XG5cdFx0XHRcdGpzOiBcIjEuNi4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiOS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjUuOC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi10ZXh0LWZpdC1wYWRkaW5nXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiA0LFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MCxcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFkZGVkIHRvIGRpbWVuc2lvbnMgZGV0ZXJtaW5lZCBieSBgaWNvbi10ZXh0LWZpdGAsIGluIGNsb2Nrd2lzZSBvcmRlcjogdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcImljb24tdGV4dC1maXRcIjogW1xuXHRcdFx0XHRcdFwiYm90aFwiLFxuXHRcdFx0XHRcdFwid2lkdGhcIixcblx0XHRcdFx0XHRcImhlaWdodFwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImljb24taW1hZ2VcIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC5cIixcblx0XHR0b2tlbnM6IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLXJvdGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRwZXJpb2Q6IDM2MCxcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0ZG9jOiBcIlJvdGF0ZXMgdGhlIGljb24gY2xvY2t3aXNlLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tcGFkZGluZ1wiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSBpY29uIGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG5cdFx0dHlwZTogXCJib29sZWFuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJsaW5lXCIsXG5cdFx0XHRcdFx0XCJsaW5lLWNlbnRlclwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJpY29uLW9mZnNldFwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdGRvYzogXCJPZmZzZXQgZGlzdGFuY2Ugb2YgaWNvbiBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiBFYWNoIGNvbXBvbmVudCBpcyBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZSBvZiBgaWNvbi1zaXplYCB0byBvYnRhaW4gdGhlIGZpbmFsIG9mZnNldCBpbiBwaXhlbHMuIFdoZW4gY29tYmluZWQgd2l0aCBgaWNvbi1yb3RhdGVgIHRoZSBvZmZzZXQgd2lsbCBiZSBhcyBpZiB0aGUgcm90YXRlZCBkaXJlY3Rpb24gd2FzIHVwLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiUGFydCBvZiB0aGUgaWNvbiBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLXBpdGNoLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBpY29uIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGljb24gaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiQXV0b21hdGljYWxseSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiBgaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRgLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIk9yaWVudGF0aW9uIG9mIGljb24gd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4zOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiQXV0b21hdGljYWxseSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiBgdGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRgLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdXRvXCIsXG5cdFx0ZG9jOiBcIk9yaWVudGF0aW9uIG9mIHRleHQgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yMS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNC4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMi4xXCJcblx0XHRcdH0sXG5cdFx0XHRcImBhdXRvYCB2YWx1ZVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjUuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjMuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIHRleHQgZWFzdC13ZXN0LiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIGFsaWducyB0ZXh0IHgtYXhlcyB3aXRoIHRoZSBsaW5lLlwiXG5cdFx0XHR9LFxuXHRcdFx0dmlld3BvcnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlByb2R1Y2VzIGdseXBocyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLlwiXG5cdFx0XHR9LFxuXHRcdFx0YXV0bzoge1xuXHRcdFx0XHRkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgbWFwYC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuXHRcdGRvYzogXCJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgdGhlIGluZGl2aWR1YWwgZ2x5cGhzIGZvcm1pbmcgdGhlIHRleHQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJgYXV0b2AgdmFsdWVcIjoge1xuXHRcdFx0XHRqczogXCIwLjI1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI0LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy40LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4zLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtZmllbGRcIjoge1xuXHRcdHR5cGU6IFwiZm9ybWF0dGVkXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiXCIsXG5cdFx0dG9rZW5zOiB0cnVlLFxuXHRcdGRvYzogXCJWYWx1ZSB0byB1c2UgZm9yIGEgdGV4dCBsYWJlbC4gSWYgYSBwbGFpbiBgc3RyaW5nYCBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgYGZvcm1hdHRlZGAgd2l0aCBkZWZhdWx0L2luaGVyaXRlZCBmb3JtYXR0aW5nIG9wdGlvbnMuIFNERiBpbWFnZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gZm9ybWF0dGVkIHRleHQgYW5kIHdpbGwgYmUgaWdub3JlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtZm9udFwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcInN0cmluZ1wiLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHRcIk9wZW4gU2FucyBSZWd1bGFyXCIsXG5cdFx0XHRcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXG5cdFx0XSxcblx0XHRkb2M6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1zaXplXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxNixcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJGb250IHNpemUuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zNS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1tYXgtd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0ZG9jOiBcIlRoZSBtYXhpbXVtIGxpbmUgd2lkdGggZm9yIHRleHQgd3JhcHBpbmcuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuXHRcdFx0XHRcdFwicG9pbnRcIlxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40MC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMS4yLFxuXHRcdHVuaXRzOiBcImVtc1wiLFxuXHRcdGRvYzogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIyLjMuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0dW5pdHM6IFwiZW1zXCIsXG5cdFx0ZG9jOiBcIlRleHQgdHJhY2tpbmcgYW1vdW50LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtanVzdGlmeVwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvd2FyZHMgdGhlIGFuY2hvciBwb3NpdGlvbi5cIlxuXHRcdFx0fSxcblx0XHRcdGxlZnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIGxlZnQuXCJcblx0XHRcdH0sXG5cdFx0XHRjZW50ZXI6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGNlbnRlcmVkLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHJpZ2h0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiVGV4dCBqdXN0aWZpY2F0aW9uIG9wdGlvbnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4yLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNi4wXCJcblx0XHRcdH0sXG5cdFx0XHRhdXRvOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtcmFkaWFsLW9mZnNldFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHR1bml0czogXCJlbXNcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRkb2M6IFwiUmFkaWFsIG9mZnNldCBvZiB0ZXh0LCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzeW1ib2wncyBhbmNob3IuIFVzZWZ1bCBpbiBjb21iaW5hdGlvbiB3aXRoIGB0ZXh0LXZhcmlhYmxlLWFuY2hvcmAsIHdoaWNoIGRlZmF1bHRzIHRvIHVzaW5nIHRoZSB0d28tZGltZW5zaW9uYWwgYHRleHQtb2Zmc2V0YCBpZiBwcmVzZW50LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41NC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNTQuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjcuNC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIixcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH1cblx0fSxcblx0XCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG5cdFx0XHRcdFx0XCJwb2ludFwiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdGRvYzogXCJUbyBpbmNyZWFzZSB0aGUgY2hhbmNlIG9mIHBsYWNpbmcgaGlnaC1wcmlvcml0eSBsYWJlbHMgb24gdGhlIG1hcCwgeW91IGNhbiBwcm92aWRlIGFuIGFycmF5IG9mIGB0ZXh0LWFuY2hvcmAgbG9jYXRpb25zOiB0aGUgcmVuZGVyZXIgd2lsbCBhdHRlbXB0IHRvIHBsYWNlIHRoZSBsYWJlbCBhdCBlYWNoIGxvY2F0aW9uLCBpbiBvcmRlciwgYmVmb3JlIG1vdmluZyBvbnRvIHRoZSBuZXh0IGxhYmVsLiBVc2UgYHRleHQtanVzdGlmeTogYXV0b2AgdG8gY2hvb3NlIGp1c3RpZmljYXRpb24gYmFzZWQgb24gYW5jaG9yIHBvc2l0aW9uLiBUbyBhcHBseSBhbiBvZmZzZXQsIHVzZSB0aGUgYHRleHQtcmFkaWFsLW9mZnNldGAgb3IgdGhlIHR3by1kaW1lbnNpb25hbCBgdGV4dC1vZmZzZXRgLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC41NC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNy40LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMTAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGNlbnRlcjoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0bGVmdDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHR0b3A6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuXHRcdFx0fSxcblx0XHRcdGJvdHRvbToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJ0b3AtbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcInRvcC1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9LFxuXHRcdFx0XCJib3R0b20tbGVmdFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcblx0XHRcdH0sXG5cdFx0XHRcImJvdHRvbS1yaWdodFwiOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcblx0XHRkb2M6IFwiUGFydCBvZiB0aGUgdGV4dCBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwidGV4dC12YXJpYWJsZS1hbmNob3JcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjcuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjYuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogNDUsXG5cdFx0dW5pdHM6IFwiZGVncmVlc1wiLFxuXHRcdGRvYzogXCJNYXhpbXVtIGFuZ2xlIGNoYW5nZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuXHRcdFx0XHRcdFwibGluZVwiLFxuXHRcdFx0XHRcdFwibGluZS1jZW50ZXJcIlxuXHRcdFx0XHRdXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGhvcml6b250YWw6IHtcblx0XHRcdFx0ZG9jOiBcIklmIGEgdGV4dCdzIGxhbmd1YWdlIHN1cHBvcnRzIGhvcml6b250YWwgd3JpdGluZyBtb2RlLCBzeW1ib2xzIHdvdWxkIGJlIGxhaWQgb3V0IGhvcml6b250YWxseS5cIlxuXHRcdFx0fSxcblx0XHRcdHZlcnRpY2FsOiB7XG5cdFx0XHRcdGRvYzogXCJJZiBhIHRleHQncyBsYW5ndWFnZSBzdXBwb3J0cyB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUsIHN5bWJvbHMgd291bGQgYmUgbGFpZCBvdXQgdmVydGljYWxseS5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlRoZSBwcm9wZXJ0eSBhbGxvd3MgY29udHJvbCBvdmVyIGEgc3ltYm9sJ3Mgb3JpZW50YXRpb24uIE5vdGUgdGhhdCB0aGUgcHJvcGVydHkgdmFsdWVzIGFjdCBhcyBhIGhpbnQsIHNvIHRoYXQgYSBzeW1ib2wgd2hvc2UgbGFuZ3VhZ2UgZG9lc27igJl0IHN1cHBvcnQgdGhlIHByb3ZpZGVkIG9yaWVudGF0aW9uIHdpbGwgYmUgbGFpZCBvdXQgaW4gaXRzIG5hdHVyYWwgb3JpZW50YXRpb24uIEV4YW1wbGU6IEVuZ2xpc2ggcG9pbnQgc3ltYm9sIHdpbGwgYmUgcmVuZGVyZWQgaG9yaXpvbnRhbGx5IGV2ZW4gaWYgYXJyYXkgdmFsdWUgY29udGFpbnMgc2luZ2xlICd2ZXJ0aWNhbCcgZW51bSB2YWx1ZS4gRm9yIHN5bWJvbCB3aXRoIHBvaW50IHBsYWNlbWVudCwgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5IGRlZmluZSBwcmlvcml0eSBvcmRlciBmb3IgdGhlIHBsYWNlbWVudCBvZiBhbiBvcmllbnRhdGlvbiB2YXJpYW50LiBGb3Igc3ltYm9sIHdpdGggbGluZSBwbGFjZW1lbnQsIHRoZSBkZWZhdWx0IHRleHQgd3JpdGluZyBtb2RlIGlzIGVpdGhlciBbJ2hvcml6b250YWwnLCAndmVydGljYWwnXSBvciBbJ3ZlcnRpY2FsJywgJ2hvcml6b250YWwnXSwgdGhlIG9yZGVyIGRvZXNuJ3QgYWZmZWN0IHRoZSBwbGFjZW1lbnQuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjEuMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiOC4zLjBcIixcblx0XHRcdFx0aW9zOiBcIjUuMy4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1yb3RhdGVcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0cGVyaW9kOiAzNjAsXG5cdFx0dW5pdHM6IFwiZGVncmVlc1wiLFxuXHRcdGRvYzogXCJSb3RhdGVzIHRoZSB0ZXh0IGNsb2Nrd2lzZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjM1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LXBhZGRpbmdcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDIsXG5cdFx0bWluaW11bTogMCxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFyb3VuZCB0aGUgdGV4dCBib3VuZGluZyBib3ggdXNlZCBmb3IgZGV0ZWN0aW5nIHN5bWJvbCBjb2xsaXNpb25zLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdGRvYzogXCJJZiB0cnVlLCB0aGUgdGV4dCBtYXkgYmUgZmxpcHBlZCB2ZXJ0aWNhbGx5IHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCIsXG5cdFx0XHR7XG5cdFx0XHRcdFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0XCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcblx0XHRcdFx0XHRcImxpbmVcIixcblx0XHRcdFx0XHRcImxpbmUtY2VudGVyXCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtdHJhbnNmb3JtXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSB0ZXh0IGlzIG5vdCBhbHRlcmVkLlwiXG5cdFx0XHR9LFxuXHRcdFx0dXBwZXJjYXNlOiB7XG5cdFx0XHRcdGRvYzogXCJGb3JjZXMgYWxsIGxldHRlcnMgdG8gYmUgZGlzcGxheWVkIGluIHVwcGVyY2FzZS5cIlxuXHRcdFx0fSxcblx0XHRcdGxvd2VyY2FzZToge1xuXHRcdFx0XHRkb2M6IFwiRm9yY2VzIGFsbCBsZXR0ZXJzIHRvIGJlIGRpc3BsYXllZCBpbiBsb3dlcmNhc2UuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcIm5vbmVcIixcblx0XHRkb2M6IFwiU3BlY2lmaWVzIGhvdyB0byBjYXBpdGFsaXplIHRleHQsIHNpbWlsYXIgdG8gdGhlIENTUyBgdGV4dC10cmFuc2Zvcm1gIHByb3BlcnR5LlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LW9mZnNldFwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdGRvYzogXCJPZmZzZXQgZGlzdGFuY2Ugb2YgdGV4dCBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiBJZiB1c2VkIHdpdGggdGV4dC12YXJpYWJsZS1hbmNob3IsIGlucHV0IHZhbHVlcyB3aWxsIGJlIHRha2VuIGFzIGFic29sdXRlIHZhbHVlcy4gT2Zmc2V0cyBhbG9uZyB0aGUgeC0gYW5kIHktYXhpcyB3aWxsIGJlIGFwcGxpZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGUgYW5jaG9yIHBvc2l0aW9uLlwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdHVuaXRzOiBcImVtc1wiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwidGV4dC1yYWRpYWwtb2Zmc2V0XCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjM1LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWFsbG93LW92ZXJsYXBcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0XHRkb2M6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIG90aGVyIHN5bWJvbHMgY2FuIGJlIHZpc2libGUgZXZlbiBpZiB0aGV5IGNvbGxpZGUgd2l0aCB0aGUgdGV4dC5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LW9wdGlvbmFsXCI6IHtcblx0XHR0eXBlOiBcImJvb2xlYW5cIixcblx0XHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdFx0ZG9jOiBcIklmIHRydWUsIGljb25zIHdpbGwgZGlzcGxheSB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgdGV4dCB3aGVuIHRoZSB0ZXh0IGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIGljb24gZG9lcyBub3QuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiLFxuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufTtcbnZhciBsYXlvdXRfcmFzdGVyID0ge1xuXHR2aXNpYmlsaXR5OiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2aXNpYmxlOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcblx0XHRcdH0sXG5cdFx0XHRub25lOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG5cdFx0ZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIGxheW91dF9oaWxsc2hhZGUgPSB7XG5cdHZpc2liaWxpdHk6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHZpc2libGU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuXHRcdFx0fSxcblx0XHRcdG5vbmU6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcblx0XHRkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG5cdH1cbn07XG52YXIgZmlsdGVyID0ge1xuXHR0eXBlOiBcImFycmF5XCIsXG5cdHZhbHVlOiBcIipcIixcblx0ZG9jOiBcIkEgZmlsdGVyIHNlbGVjdHMgc3BlY2lmaWMgZmVhdHVyZXMgZnJvbSBhIGxheWVyLlwiXG59O1xudmFyIGZpbHRlcl9zeW1ib2wgPSB7XG5cdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRkb2M6IFwiRXhwcmVzc2lvbiB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgYSBzeW1ib2wuIFN5bWJvbHMgc3VwcG9ydCBkeW5hbWljIGZpbHRlcmluZywgbWVhbmluZyB0aGlzIGV4cHJlc3Npb24gY2FuIHVzZSB0aGUgYFtcXFwicGl0Y2hcXFwiXWAgYW5kIGBbXFxcImRpc3RhbmNlLWZyb20tY2VudGVyXFxcIl1gIGV4cHJlc3Npb25zIHRvIHJlZmVyZW5jZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdmlldy5cIixcblx0XCJkZWZhdWx0XCI6IGZhbHNlLFxuXHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIixcblx0ZXhwcmVzc2lvbjoge1xuXHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFwicGl0Y2hcIixcblx0XHRcdFwiZGlzdGFuY2UtZnJvbS1jZW50ZXJcIlxuXHRcdF1cblx0fVxufTtcbnZhciBmaWx0ZXJfZmlsbCA9IHtcblx0dHlwZTogXCJib29sZWFuXCIsXG5cdGRvYzogXCJFeHByZXNzaW9uIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSBhIHBvbHlnb24uIEZpbGwgbGF5ZXIgZG9lcyBOT1Qgc3VwcG9ydCBkeW5hbWljIGZpbHRlcmluZywgbWVhbmluZyB0aGlzIGV4cHJlc3Npb24gY2FuIE5PVCB1c2UgdGhlIGBbXFxcInBpdGNoXFxcIl1gIGFuZCBgW1xcXCJkaXN0YW5jZS1mcm9tLWNlbnRlclxcXCJdYCBleHByZXNzaW9ucyB0byByZWZlcmVuY2UgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHZpZXcuXCIsXG5cdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG5cdGV4cHJlc3Npb246IHtcblx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XCJmZWF0dXJlXCJcblx0XHRdXG5cdH1cbn07XG52YXIgZmlsdGVyX2xpbmUgPSB7XG5cdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRkb2M6IFwiRXhwcmVzc2lvbiB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgYSBQb2x5Z29uIG9yIExpbmVTdHJpbmcuIExpbmUgbGF5ZXIgZG9lcyBOT1Qgc3VwcG9ydCBkeW5hbWljIGZpbHRlcmluZywgbWVhbmluZyB0aGlzIGV4cHJlc3Npb24gY2FuIE5PVCB1c2UgdGhlIGBbXFxcInBpdGNoXFxcIl1gIGFuZCBgW1xcXCJkaXN0YW5jZS1mcm9tLWNlbnRlclxcXCJdYCBleHByZXNzaW9ucyB0byByZWZlcmVuY2UgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHZpZXcuXCIsXG5cdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG5cdGV4cHJlc3Npb246IHtcblx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XCJmZWF0dXJlXCJcblx0XHRdXG5cdH1cbn07XG52YXIgZmlsdGVyX2NpcmNsZSA9IHtcblx0dHlwZTogXCJib29sZWFuXCIsXG5cdGRvYzogXCJFeHByZXNzaW9uIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSBhIGNpcmNsZS4gQ2lyY2xlIGxheWVyIGRvZXMgTk9UIHN1cHBvcnQgZHluYW1pYyBmaWx0ZXJpbmcsIG1lYW5pbmcgdGhpcyBleHByZXNzaW9uIGNhbiBOT1QgdXNlIHRoZSBgW1xcXCJwaXRjaFxcXCJdYCBhbmQgYFtcXFwiZGlzdGFuY2UtZnJvbS1jZW50ZXJcXFwiXWAgZXhwcmVzc2lvbnMgdG8gcmVmZXJlbmNlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB2aWV3LlwiLFxuXHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiLFxuXHRleHByZXNzaW9uOiB7XG5cdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcInpvb21cIixcblx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XVxuXHR9XG59O1xudmFyIGZpbHRlcl9oZWF0bWFwID0ge1xuXHR0eXBlOiBcImJvb2xlYW5cIixcblx0ZG9jOiBcIkV4cHJlc3Npb24gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHBvaW50IGlzIGJlaW5nIGRpc3BsYXllZCBvciBub3QuIEhlYXRtYXAgbGF5ZXIgZG9lcyBOT1Qgc3VwcG9ydCBkeW5hbWljIGZpbHRlcmluZywgbWVhbmluZyB0aGlzIGV4cHJlc3Npb24gY2FuIE5PVCB1c2UgdGhlIGBbXFxcInBpdGNoXFxcIl1gIGFuZCBgW1xcXCJkaXN0YW5jZS1mcm9tLWNlbnRlclxcXCJdYCBleHByZXNzaW9ucyB0byByZWZlcmVuY2UgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHZpZXcuXCIsXG5cdFwiZGVmYXVsdFwiOiBmYWxzZSxcblx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG5cdGV4cHJlc3Npb246IHtcblx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XCJmZWF0dXJlXCJcblx0XHRdXG5cdH1cbn07XG52YXIgZmlsdGVyX29wZXJhdG9yID0ge1xuXHR0eXBlOiBcImVudW1cIixcblx0dmFsdWVzOiB7XG5cdFx0XCI9PVwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiPT1cXFwiLCBrZXksIHZhbHVlXWAgZXF1YWxpdHk6IGBmZWF0dXJlW2tleV0gPSB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCIhPVwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiIT1cXFwiLCBrZXksIHZhbHVlXWAgaW5lcXVhbGl0eTogYGZlYXR1cmVba2V5XSDiiaAgdmFsdWVgXCJcblx0XHR9LFxuXHRcdFwiPlwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiPlxcXCIsIGtleSwgdmFsdWVdYCBncmVhdGVyIHRoYW46IGBmZWF0dXJlW2tleV0gPiB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCI+PVwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiPj1cXFwiLCBrZXksIHZhbHVlXWAgZ3JlYXRlciB0aGFuIG9yIGVxdWFsOiBgZmVhdHVyZVtrZXldIOKJpSB2YWx1ZWBcIlxuXHRcdH0sXG5cdFx0XCI8XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI8XFxcIiwga2V5LCB2YWx1ZV1gIGxlc3MgdGhhbjogYGZlYXR1cmVba2V5XSA8IHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcIjw9XCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCI8PVxcXCIsIGtleSwgdmFsdWVdYCBsZXNzIHRoYW4gb3IgZXF1YWw6IGBmZWF0dXJlW2tleV0g4omkIHZhbHVlYFwiXG5cdFx0fSxcblx0XHRcImluXCI6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJpblxcXCIsIGtleSwgdjAsIC4uLiwgdm5dYCBzZXQgaW5jbHVzaW9uOiBgZmVhdHVyZVtrZXldIOKIiCB7djAsIC4uLiwgdm59YFwiXG5cdFx0fSxcblx0XHRcIiFpblwiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiIWluXFxcIiwga2V5LCB2MCwgLi4uLCB2bl1gIHNldCBleGNsdXNpb246IGBmZWF0dXJlW2tleV0g4oiJIHt2MCwgLi4uLCB2bn1gXCJcblx0XHR9LFxuXHRcdGFsbDoge1xuXHRcdFx0ZG9jOiBcImBbXFxcImFsbFxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgQU5EYDogYGYwIOKIpyAuLi4g4oinIGZuYFwiXG5cdFx0fSxcblx0XHRhbnk6IHtcblx0XHRcdGRvYzogXCJgW1xcXCJhbnlcXFwiLCBmMCwgLi4uLCBmbl1gIGxvZ2ljYWwgYE9SYDogYGYwIOKIqCAuLi4g4oioIGZuYFwiXG5cdFx0fSxcblx0XHRub25lOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwibm9uZVxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgTk9SYDogYMKsZjAg4oinIC4uLiDiiKcgwqxmbmBcIlxuXHRcdH0sXG5cdFx0aGFzOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiaGFzXFxcIiwga2V5XWAgYGZlYXR1cmVba2V5XWAgZXhpc3RzXCJcblx0XHR9LFxuXHRcdFwiIWhhc1wiOiB7XG5cdFx0XHRkb2M6IFwiYFtcXFwiIWhhc1xcXCIsIGtleV1gIGBmZWF0dXJlW2tleV1gIGRvZXMgbm90IGV4aXN0XCJcblx0XHR9LFxuXHRcdHdpdGhpbjoge1xuXHRcdFx0ZG9jOiBcImBbXFxcIndpdGhpblxcXCIsIG9iamVjdF1gIGZlYXR1cmUgZ2VvbWV0cnkgaXMgd2l0aGluIG9iamVjdCBnZW9tZXRyeVwiXG5cdFx0fVxuXHR9LFxuXHRkb2M6IFwiVGhlIGZpbHRlciBvcGVyYXRvci5cIlxufTtcbnZhciBnZW9tZXRyeV90eXBlID0ge1xuXHR0eXBlOiBcImVudW1cIixcblx0dmFsdWVzOiB7XG5cdFx0UG9pbnQ6IHtcblx0XHRcdGRvYzogXCJGaWx0ZXIgdG8gcG9pbnQgZ2VvbWV0cmllcy5cIlxuXHRcdH0sXG5cdFx0TGluZVN0cmluZzoge1xuXHRcdFx0ZG9jOiBcIkZpbHRlciB0byBsaW5lIGdlb21ldHJpZXMuXCJcblx0XHR9LFxuXHRcdFBvbHlnb246IHtcblx0XHRcdGRvYzogXCJGaWx0ZXIgdG8gcG9seWdvbiBnZW9tZXRyaWVzLlwiXG5cdFx0fVxuXHR9LFxuXHRkb2M6IFwiVGhlIGdlb21ldHJ5IHR5cGUgZm9yIHRoZSBmaWx0ZXIgdG8gc2VsZWN0LlwiXG59O1xudmFyIGZ1bmN0aW9uX3N0b3AgPSB7XG5cdHR5cGU6IFwiYXJyYXlcIixcblx0bWluaW11bTogMCxcblx0bWF4aW11bTogMjQsXG5cdHZhbHVlOiBbXG5cdFx0XCJudW1iZXJcIixcblx0XHRcImNvbG9yXCJcblx0XSxcblx0bGVuZ3RoOiAyLFxuXHRkb2M6IFwiWm9vbSBsZXZlbCBhbmQgdmFsdWUgcGFpci5cIlxufTtcbnZhciBleHByZXNzaW9uID0ge1xuXHR0eXBlOiBcImFycmF5XCIsXG5cdHZhbHVlOiBcIipcIixcblx0bWluaW11bTogMSxcblx0ZG9jOiBcIkFuIGV4cHJlc3Npb24gZGVmaW5lcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRhdGEtZHJpdmVuIHN0eWxlIHByb3BlcnRpZXMgb3IgZmVhdHVyZSBmaWx0ZXJzLlwiXG59O1xudmFyIGV4cHJlc3Npb25fbmFtZSA9IHtcblx0ZG9jOiBcIlwiLFxuXHR0eXBlOiBcImVudW1cIixcblx0dmFsdWVzOiB7XG5cdFx0XCJsZXRcIjoge1xuXHRcdFx0ZG9jOiBcIkJpbmRzIGV4cHJlc3Npb25zIHRvIG5hbWVkIHZhcmlhYmxlcywgd2hpY2ggY2FuIHRoZW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgcmVzdWx0IGV4cHJlc3Npb24gdXNpbmcgW1xcXCJ2YXJcXFwiLCBcXFwidmFyaWFibGVfbmFtZVxcXCJdLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVmFyaWFibGUgYmluZGluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ2YXJcIjoge1xuXHRcdFx0ZG9jOiBcIlJlZmVyZW5jZXMgdmFyaWFibGUgYm91bmQgdXNpbmcgXFxcImxldFxcXCIuXCIsXG5cdFx0XHRncm91cDogXCJWYXJpYWJsZSBiaW5kaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsaXRlcmFsOiB7XG5cdFx0XHRkb2M6IFwiUHJvdmlkZXMgYSBsaXRlcmFsIGFycmF5IG9yIG9iamVjdCB2YWx1ZS5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcnJheToge1xuXHRcdFx0ZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgaXMgYW4gYXJyYXkgKG9wdGlvbmFsbHkgd2l0aCBhIHNwZWNpZmljIGl0ZW0gdHlwZSBhbmQgbGVuZ3RoKS4gIElmLCB3aGVuIHRoZSBpbnB1dCBleHByZXNzaW9uIGlzIGV2YWx1YXRlZCwgaXQgaXMgbm90IG9mIHRoZSBhc3NlcnRlZCB0eXBlLCB0aGVuIHRoaXMgYXNzZXJ0aW9uIHdpbGwgY2F1c2UgdGhlIHdob2xlIGV4cHJlc3Npb24gdG8gYmUgYWJvcnRlZC5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhdDoge1xuXHRcdFx0ZG9jOiBcIlJldHJpZXZlcyBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXCIsXG5cdFx0XHRncm91cDogXCJMb29rdXBcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaW5cIjoge1xuXHRcdFx0ZG9jOiBcIkRldGVybWluZXMgd2hldGhlciBhbiBpdGVtIGV4aXN0cyBpbiBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBleGlzdHMgaW4gYSBzdHJpbmcuIEluIHRoZSBzcGVjaWZpYyBjYXNlIHdoZW4gdGhlIHNlY29uZCBhbmQgdGhpcmQgYXJndW1lbnRzIGFyZSBzdHJpbmcgbGl0ZXJhbHMsIHlvdSBtdXN0IHdyYXAgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaW4gYSBbYGxpdGVyYWxgXSgjdHlwZXMtbGl0ZXJhbCkgZXhwcmVzc2lvbiB0byBoaW50IGNvcnJlY3QgaW50ZXJwcmV0YXRpb24gdG8gdGhlIFt0eXBlIHN5c3RlbV0oI3R5cGUtc3lzdGVtKS5cIixcblx0XHRcdGdyb3VwOiBcIkxvb2t1cFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMS42LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjkuMS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjUuOC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xNS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJpbmRleC1vZlwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgZmlyc3QgcG9zaXRpb24gYXQgd2hpY2ggYW4gaXRlbSBjYW4gYmUgZm91bmQgaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgY2FuIGJlIGZvdW5kIGluIGEgc3RyaW5nLCBvciBgLTFgIGlmIHRoZSBpbnB1dCBjYW5ub3QgYmUgZm91bmQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgaW5kZXggZnJvbSB3aGVyZSB0byBiZWdpbiB0aGUgc2VhcmNoLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjEwLjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzbGljZToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYW4gaXRlbSBmcm9tIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGZyb20gYSBzdHJpbmcgZnJvbSBhIHNwZWNpZmllZCBzdGFydCBpbmRleCwgb3IgYmV0d2VlbiBhIHN0YXJ0IGluZGV4IGFuZCBhbiBlbmQgaW5kZXggaWYgc2V0LiBUaGUgcmV0dXJuIHZhbHVlIGlzIGluY2x1c2l2ZSBvZiB0aGUgc3RhcnQgaW5kZXggYnV0IG5vdCBvZiB0aGUgZW5kIGluZGV4LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjEwLjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImNhc2VcIjoge1xuXHRcdFx0ZG9jOiBcIlNlbGVjdHMgdGhlIGZpcnN0IG91dHB1dCB3aG9zZSBjb3JyZXNwb25kaW5nIHRlc3QgY29uZGl0aW9uIGV2YWx1YXRlcyB0byB0cnVlLCBvciB0aGUgZmFsbGJhY2sgdmFsdWUgb3RoZXJ3aXNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG1hdGNoOiB7XG5cdFx0XHRkb2M6IFwiU2VsZWN0cyB0aGUgb3V0cHV0IGZvciB3aGljaCB0aGUgbGFiZWwgdmFsdWUgbWF0Y2hlcyB0aGUgaW5wdXQgdmFsdWUsIG9yIHRoZSBmYWxsYmFjayB2YWx1ZSBpZiBubyBtYXRjaCBpcyBmb3VuZC4gVGhlIGlucHV0IGNhbiBiZSBhbnkgZXhwcmVzc2lvbiAoZm9yIGV4YW1wbGUsIGBbXFxcImdldFxcXCIsIFxcXCJidWlsZGluZ190eXBlXFxcIl1gKS4gRWFjaCBsYWJlbCBtdXN0IGJlIHVuaXF1ZSwgYW5kIG11c3QgYmUgZWl0aGVyOlxcbiAtIGEgc2luZ2xlIGxpdGVyYWwgdmFsdWU7IG9yXFxuIC0gYW4gYXJyYXkgb2YgbGl0ZXJhbCB2YWx1ZXMsIHRoZSB2YWx1ZXMgb2Ygd2hpY2ggbXVzdCBiZSBhbGwgc3RyaW5ncyBvciBhbGwgbnVtYmVycyAoZm9yIGV4YW1wbGUgYFsxMDAsIDEwMV1gIG9yIGBbXFxcImNcXFwiLCBcXFwiYlxcXCJdYCkuXFxuXFxuVGhlIGlucHV0IG1hdGNoZXMgaWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IG1hdGNoZXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5LCBzaW1pbGFyIHRvIHRoZSBgXFxcImluXFxcImAgb3BlcmF0b3IuXFxuSWYgdGhlIGlucHV0IHR5cGUgZG9lcyBub3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhlIGxhYmVscywgdGhlIHJlc3VsdCB3aWxsIGJlIHRoZSBmYWxsYmFjayB2YWx1ZS5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb2FsZXNjZToge1xuXHRcdFx0ZG9jOiBcIkV2YWx1YXRlcyBlYWNoIGV4cHJlc3Npb24gaW4gdHVybiB1bnRpbCB0aGUgZmlyc3QgdmFsaWQgdmFsdWUgaXMgb2J0YWluZWQuIEludmFsaWQgdmFsdWVzIGFyZSBgbnVsbGAgYW5kIFtgJ2ltYWdlJ2BdKCN0eXBlcy1pbWFnZSkgZXhwcmVzc2lvbnMgdGhhdCBhcmUgdW5hdmFpbGFibGUgaW4gdGhlIHN0eWxlLiBJZiBhbGwgdmFsdWVzIGFyZSBpbnZhbGlkLCBgY29hbGVzY2VgIHJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGxpc3RlZC5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdGVwOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgZGlzY3JldGUsIHN0ZXBwZWQgcmVzdWx0cyBieSBldmFsdWF0aW5nIGEgcGllY2V3aXNlLWNvbnN0YW50IGZ1bmN0aW9uIGRlZmluZWQgYnkgcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBUaGUgYGlucHV0YCBtYXkgYmUgYW55IG51bWVyaWMgZXhwcmVzc2lvbiAoZS5nLiwgYFtcXFwiZ2V0XFxcIiwgXFxcInBvcHVsYXRpb25cXFwiXWApLiBTdG9wIGlucHV0cyBtdXN0IGJlIG51bWVyaWMgbGl0ZXJhbHMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLiBSZXR1cm5zIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AganVzdCBsZXNzIHRoYW4gdGhlIGlucHV0LCBvciB0aGUgZmlyc3Qgb3V0cHV0IGlmIHRoZSBpbnB1dCBpcyBsZXNzIHRoYW4gdGhlIGZpcnN0IHN0b3AuXCIsXG5cdFx0XHRncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDIuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGludGVycG9sYXRlOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gVGhlIGBpbnB1dGAgbWF5IGJlIGFueSBudW1lcmljIGV4cHJlc3Npb24gKGUuZy4sIGBbXFxcImdldFxcXCIsIFxcXCJwb3B1bGF0aW9uXFxcIl1gKS4gU3RvcCBpbnB1dHMgbXVzdCBiZSBudW1lcmljIGxpdGVyYWxzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4gVGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYG51bWJlcmAsIGBhcnJheTxudW1iZXI+YCwgb3IgYGNvbG9yYC5cXG5cXG5JbnRlcnBvbGF0aW9uIHR5cGVzOlxcbi0gYFtcXFwibGluZWFyXFxcIl1gOiBJbnRlcnBvbGF0ZXMgbGluZWFybHkgYmV0d2VlbiB0aGUgcGFpciBvZiBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGlucHV0Llxcbi0gYFtcXFwiZXhwb25lbnRpYWxcXFwiLCBiYXNlXWA6IEludGVycG9sYXRlcyBleHBvbmVudGlhbGx5IGJldHdlZW4gdGhlIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgaW5wdXQuIGBiYXNlYCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgb3V0cHV0IGluY3JlYXNlczogaGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBvdXRwdXQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggdmFsdWVzIGNsb3NlIHRvIDEgdGhlIG91dHB1dCBpbmNyZWFzZXMgbGluZWFybHkuXFxuLSBgW1xcXCJjdWJpYy1iZXppZXJcXFwiLCB4MSwgeTEsIHgyLCB5Ml1gOiBJbnRlcnBvbGF0ZXMgdXNpbmcgdGhlIGN1YmljIGJlemllciBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBjb250cm9sIHBvaW50cy5cIixcblx0XHRcdGdyb3VwOiBcIlJhbXBzLCBzY2FsZXMsIGN1cnZlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40Mi4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJpbnRlcnBvbGF0ZS1oY2xcIjoge1xuXHRcdFx0ZG9jOiBcIlByb2R1Y2VzIGNvbnRpbnVvdXMsIHNtb290aCByZXN1bHRzIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXFxcInN0b3BzXFxcIikuIFdvcmtzIGxpa2UgYGludGVycG9sYXRlYCwgYnV0IHRoZSBvdXRwdXQgdHlwZSBtdXN0IGJlIGBjb2xvcmAsIGFuZCB0aGUgaW50ZXJwb2xhdGlvbiBpcyBwZXJmb3JtZWQgaW4gdGhlIEh1ZS1DaHJvbWEtTHVtaW5hbmNlIGNvbG9yIHNwYWNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ5LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImludGVycG9sYXRlLWxhYlwiOiB7XG5cdFx0XHRkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgQ0lFTEFCIGNvbG9yIHNwYWNlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ5LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsbjI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIG1hdGhlbWF0aWNhbCBjb25zdGFudCBsbigyKS5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHBpOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IHBpLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIG1hdGhlbWF0aWNhbCBjb25zdGFudCBlLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0eXBlb2ZcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RyaW5nOiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHN0cmluZy4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgc3RyaW5nIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIHN0cmluZ3MsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG51bWJlcjoge1xuXHRcdFx0ZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYSBudW1iZXIuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIG51bWJlciBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBudW1iZXJzLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRib29sZWFuOiB7XG5cdFx0XHRkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIGJvb2xlYW4uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIGJvb2xlYW4gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgYm9vbGVhbnMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdG9iamVjdDoge1xuXHRcdFx0ZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gb2JqZWN0LiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYW4gb2JqZWN0IGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIG9iamVjdHMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIGBjb2xsYXRvcmAgZm9yIHVzZSBpbiBsb2NhbGUtZGVwZW5kZW50IGNvbXBhcmlzb24gb3BlcmF0aW9ucy4gVGhlIGBjYXNlLXNlbnNpdGl2ZWAgYW5kIGBkaWFjcml0aWMtc2Vuc2l0aXZlYCBvcHRpb25zIGRlZmF1bHQgdG8gYGZhbHNlYC4gVGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgSUVURiBsYW5ndWFnZSB0YWcgb2YgdGhlIGxvY2FsZSB0byB1c2UuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGxvY2FsZSBpcyB1c2VkLiBJZiB0aGUgcmVxdWVzdGVkIGxvY2FsZSBpcyBub3QgYXZhaWxhYmxlLCB0aGUgYGNvbGxhdG9yYCB3aWxsIHVzZSBhIHN5c3RlbS1kZWZpbmVkIGZhbGxiYWNrIGxvY2FsZS4gVXNlIGByZXNvbHZlZC1sb2NhbGVgIHRvIHRlc3QgdGhlIHJlc3VsdHMgb2YgbG9jYWxlIGZhbGxiYWNrIGJlaGF2aW9yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGZvcm1hdDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYSBgZm9ybWF0dGVkYCBzdHJpbmcgZm9yIGRpc3BsYXlpbmcgbWl4ZWQtZm9ybWF0IHRleHQgaW4gdGhlIGB0ZXh0LWZpZWxkYCBwcm9wZXJ0eS4gVGhlIGlucHV0IG1heSBjb250YWluIGEgc3RyaW5nIGxpdGVyYWwgb3IgZXhwcmVzc2lvbiwgaW5jbHVkaW5nIGFuIFtgJ2ltYWdlJ2BdKCN0eXBlcy1pbWFnZSkgZXhwcmVzc2lvbi4gU3RyaW5ncyBtYXkgYmUgZm9sbG93ZWQgYnkgYSBzdHlsZSBvdmVycmlkZSBvYmplY3QgdGhhdCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuLSBgXFxcInRleHQtZm9udFxcXCJgOiBPdmVycmlkZXMgdGhlIGZvbnQgc3RhY2sgc3BlY2lmaWVkIGJ5IHRoZSByb290IGxheW91dCBwcm9wZXJ0eS5cXG4tIGBcXFwidGV4dC1jb2xvclxcXCJgOiBPdmVycmlkZXMgdGhlIGNvbG9yIHNwZWNpZmllZCBieSB0aGUgcm9vdCBwYWludCBwcm9wZXJ0eS5cXG4tIGBcXFwiZm9udC1zY2FsZVxcXCJgOiBBcHBsaWVzIGEgc2NhbGluZyBmYWN0b3Igb24gYHRleHQtc2l6ZWAgYXMgc3BlY2lmaWVkIGJ5IHRoZSByb290IGxheW91dCBwcm9wZXJ0eS5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ4LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNy4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuNi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xMi4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJ0ZXh0LWZvbnRcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDguMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi43LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC42LjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjEyLjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImZvbnQtc2NhbGVcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDguMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi43LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC42LjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjEyLjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInRleHQtY29sb3JcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjEuMy4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI3LjMuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjEwLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjE0LjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRpbWFnZToge1xuXHRcdFx0XHRcdGpzOiBcIjEuNi4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI4LjYuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI1LjcuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTUuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGltYWdlOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBhIFtgUmVzb2x2ZWRJbWFnZWBdKC9tYXBib3gtZ2wtanMvc3R5bGUtc3BlYy90eXBlcy8jcmVzb2x2ZWRpbWFnZSkgZm9yIHVzZSBpbiBbYGljb24taW1hZ2VgXSgvbWFwYm94LWdsLWpzL3N0eWxlLXNwZWMvbGF5ZXJzLyNsYXlvdXQtc3ltYm9sLWljb24taW1hZ2UpLCBgKi1wYXR0ZXJuYCBlbnRyaWVzLCBhbmQgYXMgYSBzZWN0aW9uIGluIHRoZSBbYCdmb3JtYXQnYF0oI3R5cGVzLWZvcm1hdCkgZXhwcmVzc2lvbi4gQSBbYCdjb2FsZXNjZSdgXSgjY29hbGVzY2UpIGV4cHJlc3Npb24gY29udGFpbmluZyBgaW1hZ2VgIGV4cHJlc3Npb25zIHdpbGwgZXZhbHVhdGUgdG8gdGhlIGZpcnN0IGxpc3RlZCBpbWFnZSB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgc3R5bGUuIFRoaXMgdmFsaWRhdGlvbiBwcm9jZXNzIGlzIHN5bmNocm9ub3VzIGFuZCByZXF1aXJlcyB0aGUgaW1hZ2UgdG8gaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBzdHlsZSBiZWZvcmUgcmVxdWVzdGluZyBpdCBpbiB0aGUgYCdpbWFnZSdgIGFyZ3VtZW50LlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjEuNC4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI4LjYuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI1LjcuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuMTUuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwibnVtYmVyLWZvcm1hdFwiOiB7XG5cdFx0XHRkb2M6IFwiQ29udmVydHMgdGhlIGlucHV0IG51bWJlciBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIHRoZSBwcm92aWRpbmcgZm9ybWF0dGluZyBydWxlcy4gSWYgc2V0LCB0aGUgYGxvY2FsZWAgYXJndW1lbnQgc3BlY2lmaWVzIHRoZSBsb2NhbGUgdG8gdXNlLCBhcyBhIEJDUCA0NyBsYW5ndWFnZSB0YWcuIElmIHNldCwgdGhlIGBjdXJyZW5jeWAgYXJndW1lbnQgc3BlY2lmaWVzIGFuIElTTyA0MjE3IGNvZGUgdG8gdXNlIGZvciBjdXJyZW5jeS1zdHlsZSBmb3JtYXR0aW5nLiBJZiBzZXQsIHRoZSBgbWluLWZyYWN0aW9uLWRpZ2l0c2AgYW5kIGBtYXgtZnJhY3Rpb24tZGlnaXRzYCBhcmd1bWVudHMgc3BlY2lmeSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBudW1iZXIgb2YgZnJhY3Rpb25hbCBkaWdpdHMgdG8gaW5jbHVkZS5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjU0LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjguNC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjUuNC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC4xNS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0by1zdHJpbmdcIjoge1xuXHRcdFx0ZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIHN0cmluZy4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCwgdGhlIHJlc3VsdCBpcyBgXFxcIlxcXCJgLiBJZiB0aGUgaW5wdXQgaXMgYSBbYGJvb2xlYW5gXSgjdHlwZXMtYm9vbGVhbiksIHRoZSByZXN1bHQgaXMgYFxcXCJ0cnVlXFxcImAgb3IgYFxcXCJmYWxzZVxcXCJgLiBJZiB0aGUgaW5wdXQgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBhcyBzcGVjaWZpZWQgYnkgdGhlIFtcXFwiTnVtYmVyVG9TdHJpbmdcXFwiIGFsZ29yaXRobV0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmctYXBwbGllZC10by10aGUtbnVtYmVyLXR5cGUpIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIHRoZSBpbnB1dCBpcyBhIFtgY29sb3JgXSgjY29sb3IpLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgb2YgdGhlIGZvcm0gYFxcXCJyZ2JhKHIsZyxiLGEpXFxcImAsIHdoZXJlIGByYCwgYGdgLCBhbmQgYGJgIGFyZSBudW1lcmFscyByYW5naW5nIGZyb20gMCB0byAyNTUsIGFuZCBgYWAgcmFuZ2VzIGZyb20gMCB0byAxLiBJZiB0aGUgaW5wdXQgaXMgYW4gW2AnaW1hZ2UnYF0oI3R5cGVzLWltYWdlKSBleHByZXNzaW9uLCBgJ3RvLXN0cmluZydgIHJldHVybnMgdGhlIGltYWdlIG5hbWUuIE90aGVyd2lzZSwgdGhlIGlucHV0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSB0aGUgW2BKU09OLnN0cmluZ2lmeWBdKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5KSBmdW5jdGlvbiBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLlwiLFxuXHRcdFx0Z3JvdXA6IFwiVHlwZXNcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwidG8tbnVtYmVyXCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIsIGlmIHBvc3NpYmxlLiBJZiB0aGUgaW5wdXQgaXMgYG51bGxgIG9yIGBmYWxzZWAsIHRoZSByZXN1bHQgaXMgMC4gSWYgdGhlIGlucHV0IGlzIGB0cnVlYCwgdGhlIHJlc3VsdCBpcyAxLiBJZiB0aGUgaW5wdXQgaXMgYSBzdHJpbmcsIGl0IGlzIGNvbnZlcnRlZCB0byBhIG51bWJlciBhcyBzcGVjaWZpZWQgYnkgdGhlIFtcXFwiVG9OdW1iZXIgQXBwbGllZCB0byB0aGUgU3RyaW5nIFR5cGVcXFwiIGFsZ29yaXRobV0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXItYXBwbGllZC10by10aGUtc3RyaW5nLXR5cGUpIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBjb252ZXJzaW9uIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgY2FuIGJlIGNvbnZlcnRlZCwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJUeXBlc1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0by1ib29sZWFuXCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBib29sZWFuLiBUaGUgcmVzdWx0IGlzIGBmYWxzZWAgd2hlbiB0aGVuIGlucHV0IGlzIGFuIGVtcHR5IHN0cmluZywgMCwgYGZhbHNlYCwgYG51bGxgLCBvciBgTmFOYDsgb3RoZXJ3aXNlIGl0IGlzIGB0cnVlYC5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRvLXJnYmFcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYSBmb3VyLWVsZW1lbnQgYXJyYXkgY29udGFpbmluZyB0aGUgaW5wdXQgY29sb3IncyByZWQsIGdyZWVuLCBibHVlLCBhbmQgYWxwaGEgY29tcG9uZW50cywgaW4gdGhhdCBvcmRlci5cIixcblx0XHRcdGdyb3VwOiBcIkNvbG9yXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRvLWNvbG9yXCI6IHtcblx0XHRcdGRvYzogXCJDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBjb2xvci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBjYW4gYmUgY29udmVydGVkLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIlR5cGVzXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZ2I6IHtcblx0XHRcdGRvYzogXCJDcmVhdGVzIGEgY29sb3IgdmFsdWUgZnJvbSByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IG9mIDEuIElmIGFueSBjb21wb25lbnQgaXMgb3V0IG9mIHJhbmdlLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcblx0XHRcdGdyb3VwOiBcIkNvbG9yXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZ2JhOiB7XG5cdFx0XHRkb2M6IFwiQ3JlYXRlcyBhIGNvbG9yIHZhbHVlIGZyb20gcmVkLCBncmVlbiwgYmx1ZSBjb21wb25lbnRzLCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMjU1LCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLiBJZiBhbnkgY29tcG9uZW50IGlzIG91dCBvZiByYW5nZSwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG5cdFx0XHRncm91cDogXCJDb2xvclwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0OiB7XG5cdFx0XHRkb2M6IFwiUmV0cmlldmVzIGEgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBmZWF0dXJlJ3MgcHJvcGVydGllcywgb3IgZnJvbSBhbm90aGVyIG9iamVjdCBpZiBhIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZC4gUmV0dXJucyBgbnVsbGAgaWYgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBtaXNzaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoYXM6IHtcblx0XHRcdGRvYzogXCJUZXN0cyBmb3IgdGhlIHByZXNlbmNlIG9mIGFuIHByb3BlcnR5IHZhbHVlIGluIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsZW5ndGg6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBsZW5ndGggb2YgYW4gYXJyYXkgb3Igc3RyaW5nLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTG9va3VwXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgZmVhdHVyZSBwcm9wZXJ0aWVzIG9iamVjdC4gIE5vdGUgdGhhdCBpbiBzb21lIGNhc2VzLCBpdCBtYXkgYmUgbW9yZSBlZmZpY2llbnQgdG8gdXNlIGBbXFxcImdldFxcXCIsIFxcXCJwcm9wZXJ0eV9uYW1lXFxcIl1gIGRpcmVjdGx5LlwiLFxuXHRcdFx0Z3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImZlYXR1cmUtc3RhdGVcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHJpZXZlcyBhIHByb3BlcnR5IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgZmVhdHVyZSdzIHN0YXRlLiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgcmVxdWVzdGVkIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBmZWF0dXJlJ3Mgc3RhdGUuIEEgZmVhdHVyZSdzIHN0YXRlIGlzIG5vdCBwYXJ0IG9mIHRoZSBHZW9KU09OIG9yIHZlY3RvciB0aWxlIGRhdGEsIGFuZCBtdXN0IGJlIHNldCBwcm9ncmFtbWF0aWNhbGx5IG9uIGVhY2ggZmVhdHVyZS4gRmVhdHVyZXMgYXJlIGlkZW50aWZpZWQgYnkgdGhlaXIgYGlkYCBhdHRyaWJ1dGUsIHdoaWNoIG11c3QgYmUgYW4gaW50ZWdlciBvciBhIHN0cmluZyB0aGF0IGNhbiBiZSBjYXN0IHRvIGFuIGludGVnZXIuIE5vdGUgdGhhdCBbXFxcImZlYXR1cmUtc3RhdGVcXFwiXSBjYW4gb25seSBiZSB1c2VkIHdpdGggcGFpbnQgcHJvcGVydGllcyB0aGF0IHN1cHBvcnQgZGF0YS1kcml2ZW4gc3R5bGluZy5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40Ni4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJnZW9tZXRyeS10eXBlXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkgdHlwZTogYFBvaW50YCwgYE11bHRpUG9pbnRgLCBgTGluZVN0cmluZ2AsIGBNdWx0aUxpbmVTdHJpbmdgLCBgUG9seWdvbmAsIGBNdWx0aVBvbHlnb25gLiBgTXVsdGkqYCBmZWF0dXJlIHR5cGVzIGFyZSBvbmx5IHJldHVybmVkIGluIEdlb0pTT04gc291cmNlcy4gV2hlbiB3b3JraW5nIHdpdGggdmVjdG9yIHRpbGUgc291cmNlcywgdXNlIHRoZSBzaW5ndWxhciBmb3Jtcy5cIixcblx0XHRcdGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aWQ6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBmZWF0dXJlJ3MgaWQsIGlmIGl0IGhhcyBvbmUuXCIsXG5cdFx0XHRncm91cDogXCJGZWF0dXJlIGRhdGFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHpvb206IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuICBOb3RlIHRoYXQgaW4gc3R5bGUgbGF5b3V0IGFuZCBwYWludCBwcm9wZXJ0aWVzLCBbXFxcInpvb21cXFwiXSBtYXkgb25seSBhcHBlYXIgYXMgdGhlIGlucHV0IHRvIGEgdG9wLWxldmVsIFxcXCJzdGVwXFxcIiBvciBcXFwiaW50ZXJwb2xhdGVcXFwiIGV4cHJlc3Npb24uXCIsXG5cdFx0XHRncm91cDogXCJDYW1lcmFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHBpdGNoOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgY3VycmVudCBwaXRjaCBpbiBkZWdyZWVzLiBgW1xcXCJwaXRjaFxcXCJdYCBtYXkgb25seSBiZSB1c2VkIGluIHRoZSBgZmlsdGVyYCBleHByZXNzaW9uIGZvciBhIGBzeW1ib2xgIGxheWVyLlwiLFxuXHRcdFx0Z3JvdXA6IFwiQ2FtZXJhXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIyLjYuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGlzdGFuY2UtZnJvbS1jZW50ZXJcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGRpc3RhbmNlIG9mIGEgYHN5bWJvbGAgaW5zdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBtYXAuIFRoZSBkaXN0YW5jZSBpcyBtZWFzdXJlZCBpbiBwaXhlbHMgZGl2aWRlZCBieSB0aGUgaGVpZ2h0IG9mIHRoZSBtYXAgY29udGFpbmVyLiBJdCBtZWFzdXJlcyAwIGF0IHRoZSBjZW50ZXIsIGRlY3JlYXNlcyB0b3dhcmRzIHRoZSBjYW1lcmEgYW5kIGluY3JlYXNlIGF3YXkgZnJvbSB0aGUgY2FtZXJhLiBGb3IgZXhhbXBsZSwgaWYgdGhlIGhlaWdodCBvZiB0aGUgbWFwIGlzIDEwMDBweCwgYSB2YWx1ZSBvZiAtMSBtZWFucyAxMDAwcHggYXdheSBmcm9tIHRoZSBjZW50ZXIgdG93YXJkcyB0aGUgY2FtZXJhLCBhbmQgYSB2YWx1ZSBvZiAxIG1lYW5zIGEgZGlzdGFuY2Ugb2YgMTAwMHB4IGF3YXkgZnJvbSB0aGUgY2FtZXJhIGZyb20gdGhlIGNlbnRlci4gYFtcXFwiZGlzdGFuY2UtZnJvbS1jZW50ZXJcXFwiXWAgbWF5IG9ubHkgYmUgdXNlZCBpbiB0aGUgYGZpbHRlcmAgZXhwcmVzc2lvbiBmb3IgYSBgc3ltYm9sYCBsYXllci5cIixcblx0XHRcdGdyb3VwOiBcIkNhbWVyYVwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMi42LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImhlYXRtYXAtZGVuc2l0eVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUga2VybmVsIGRlbnNpdHkgZXN0aW1hdGlvbiBvZiBhIHBpeGVsIGluIGEgaGVhdG1hcCBsYXllciwgd2hpY2ggaXMgYSByZWxhdGl2ZSBtZWFzdXJlIG9mIGhvdyBtYW55IGRhdGEgcG9pbnRzIGFyZSBjcm93ZGVkIGFyb3VuZCBhIHBhcnRpY3VsYXIgcGl4ZWwuIENhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBoZWF0bWFwLWNvbG9yYCBwcm9wZXJ0eS5cIixcblx0XHRcdGdyb3VwOiBcIkhlYXRtYXBcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwibGluZS1wcm9ncmVzc1wiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgcHJvZ3Jlc3MgYWxvbmcgYSBncmFkaWVudCBsaW5lLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgbGluZS1ncmFkaWVudGAgcHJvcGVydHkuXCIsXG5cdFx0XHRncm91cDogXCJGZWF0dXJlIGRhdGFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC42LjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjEyLjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInNreS1yYWRpYWwtcHJvZ3Jlc3NcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGRpc3RhbmNlIG9mIGEgcG9pbnQgb24gdGhlIHNreSBmcm9tIHRoZSBzdW4gcG9zaXRpb24uIFJldHVybnMgMCBhdCBzdW4gcG9zaXRpb24gYW5kIDEgd2hlbiB0aGUgZGlzdGFuY2UgcmVhY2hlcyBgc2t5LWdyYWRpZW50LXJhZGl1c2AuIENhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBza3ktZ3JhZGllbnRgIHByb3BlcnR5LlwiLFxuXHRcdFx0Z3JvdXA6IFwic2t5XCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIyLjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCIxMC4wLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjEwLjAuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFjY3VtdWxhdGVkOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBjbHVzdGVyIHByb3BlcnR5IGFjY3VtdWxhdGVkIHNvIGZhci4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGNsdXN0ZXJQcm9wZXJ0aWVzYCBvcHRpb24gb2YgYSBjbHVzdGVyZWQgR2VvSlNPTiBzb3VyY2UuXCIsXG5cdFx0XHRncm91cDogXCJGZWF0dXJlIGRhdGFcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNTMuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiOC40LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNS41LjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjE1LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIitcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHN1bSBvZiB0aGUgaW5wdXRzLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIqXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoZSBpbnB1dHMuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIi1cIjoge1xuXHRcdFx0ZG9jOiBcIkZvciB0d28gaW5wdXRzLCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgdGhlIHNlY29uZCBpbnB1dCBmcm9tIHRoZSBmaXJzdC4gRm9yIGEgc2luZ2xlIGlucHV0LCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgaXQgZnJvbSAwLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIvXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSByZXN1bHQgb2YgZmxvYXRpbmcgcG9pbnQgZGl2aXNpb24gb2YgdGhlIGZpcnN0IGlucHV0IGJ5IHRoZSBzZWNvbmQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIiVcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHJlbWFpbmRlciBhZnRlciBpbnRlZ2VyIGRpdmlzaW9uIG9mIHRoZSBmaXJzdCBpbnB1dCBieSB0aGUgc2Vjb25kLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJeXCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSByZXN1bHQgb2YgcmFpc2luZyB0aGUgZmlyc3QgaW5wdXQgdG8gdGhlIHBvd2VyIHNwZWNpZmllZCBieSB0aGUgc2Vjb25kLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3FydDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDIuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGxvZzEwOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYmFzZS10ZW4gbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGxuOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bG9nMjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGJhc2UtdHdvIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaW46IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzaW5lIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvczoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGNvc2luZSBvZiB0aGUgaW5wdXQuXCIsXG5cdFx0XHRncm91cDogXCJNYXRoXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0YW46IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSB0YW5nZW50IG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFzaW46IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBhcmNzaW5lIG9mIHRoZSBpbnB1dC5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFjb3M6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBhcmNjb3NpbmUgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXRhbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGFyY3RhbmdlbnQgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWluOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgaW5wdXRzLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWF4OiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgaW5wdXRzLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cm91bmQ6IHtcblx0XHRcdGRvYzogXCJSb3VuZHMgdGhlIGlucHV0IHRvIHRoZSBuZWFyZXN0IGludGVnZXIuIEhhbGZ3YXkgdmFsdWVzIGFyZSByb3VuZGVkIGF3YXkgZnJvbSB6ZXJvLiBGb3IgZXhhbXBsZSwgYFtcXFwicm91bmRcXFwiLCAtMS41XWAgZXZhbHVhdGVzIHRvIC0yLlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWJzOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2VpbDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIHNtYWxsZXN0IGludGVnZXIgdGhhdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zmxvb3I6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBsYXJnZXN0IGludGVnZXIgdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGlucHV0LlwiLFxuXHRcdFx0Z3JvdXA6IFwiTWF0aFwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGlzdGFuY2U6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBpbiBtZXRlcnMgYmV0d2VlbiB0aGUgZXZhbHVhdGVkIGZlYXR1cmUgYW5kIHRoZSBpbnB1dCBnZW9tZXRyeS4gVGhlIGlucHV0IHZhbHVlIGNhbiBiZSBhIHZhbGlkIEdlb0pTT04gb2YgdHlwZSBgUG9pbnRgLCBgTXVsdGlQb2ludGAsIGBMaW5lU3RyaW5nYCwgYE11bHRpTGluZVN0cmluZ2AsIGBQb2x5Z29uYCwgYE11bHRpUG9seWdvbmAsIGBGZWF0dXJlYCwgb3IgYEZlYXR1cmVDb2xsZWN0aW9uYC4gRGlzdGFuY2UgdmFsdWVzIHJldHVybmVkIG1heSB2YXJ5IGluIHByZWNpc2lvbiBkdWUgdG8gbG9zcyBpbiBwcmVjaXNpb24gZnJvbSBlbmNvZGluZyBnZW9tZXRyaWVzLCBwYXJ0aWN1bGFybHkgYmVsb3cgem9vbSBsZXZlbCAxMy5cIixcblx0XHRcdGdyb3VwOiBcIk1hdGhcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiOS4yLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNS45LjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjE2LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIj09XCI6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBjb21wYXJpc29uIGlzIHN0cmljdGx5IHR5cGVkOiB2YWx1ZXMgb2YgZGlmZmVyZW50IHJ1bnRpbWUgdHlwZXMgYXJlIGFsd2F5cyBjb25zaWRlcmVkIHVuZXF1YWwuIENhc2VzIHdoZXJlIHRoZSB0eXBlcyBhcmUga25vd24gdG8gYmUgZGlmZmVyZW50IGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW52YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCIhPVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgbm90IGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG5cdFx0XHRncm91cDogXCJEZWNpc2lvblwiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29sbGF0b3I6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIj5cIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBpbnB1dCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBhcmd1bWVudHMgYXJlIHJlcXVpcmVkIHRvIGJlIGVpdGhlciBib3RoIHN0cmluZ3Mgb3IgYm90aCBudW1iZXJzOyBpZiBkdXJpbmcgZXZhbHVhdGlvbiB0aGV5IGFyZSBub3QsIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBwcm9kdWNlcyBhbiBlcnJvci4gQ2FzZXMgd2hlcmUgdGhpcyBjb25zdHJhaW50IGlzIGtub3duIG5vdCB0byBob2xkIGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW4gdmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb2xsYXRvcjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDUuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4yLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjkuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiPFwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGxlc3MgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI+PVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCI8PVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbGxhdG9yOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjIuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWxsOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIHRoZSBpbnB1dHMgYXJlIGB0cnVlYCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBpbnB1dHMgYXJlIGV2YWx1YXRlZCBpbiBvcmRlciwgYW5kIGV2YWx1YXRpb24gaXMgc2hvcnQtY2lyY3VpdGluZzogb25jZSBhbiBpbnB1dCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBgZmFsc2VgLCB0aGUgcmVzdWx0IGlzIGBmYWxzZWAgYW5kIG5vIGZ1cnRoZXIgaW5wdXQgZXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZC5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbnk6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0cyBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLCBhbmQgZXZhbHVhdGlvbiBpcyBzaG9ydC1jaXJjdWl0aW5nOiBvbmNlIGFuIGlucHV0IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGB0cnVlYCwgdGhlIHJlc3VsdCBpcyBgdHJ1ZWAgYW5kIG5vIGZ1cnRoZXIgaW5wdXQgZXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZC5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIiFcIjoge1xuXHRcdFx0ZG9jOiBcIkxvZ2ljYWwgbmVnYXRpb24uIFJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBpcyBgZmFsc2VgLCBhbmQgYGZhbHNlYCBpZiB0aGUgaW5wdXQgaXMgYHRydWVgLlwiLFxuXHRcdFx0Z3JvdXA6IFwiRGVjaXNpb25cIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHdpdGhpbjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBldmFsdWF0ZWQgZmVhdHVyZSBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIGEgYm91bmRhcnkgb2YgdGhlIGlucHV0IGdlb21ldHJ5LCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0IHZhbHVlIGNhbiBiZSBhIHZhbGlkIEdlb0pTT04gb2YgdHlwZSBgUG9seWdvbmAsIGBNdWx0aVBvbHlnb25gLCBgRmVhdHVyZWAsIG9yIGBGZWF0dXJlQ29sbGVjdGlvbmAuIFN1cHBvcnRlZCBmZWF0dXJlcyBmb3IgZXZhbHVhdGlvbjpcXG4tIGBQb2ludGA6IFJldHVybnMgYGZhbHNlYCBpZiBhIHBvaW50IGlzIG9uIHRoZSBib3VuZGFyeSBvciBmYWxscyBvdXRzaWRlIHRoZSBib3VuZGFyeS5cXG4tIGBMaW5lU3RyaW5nYDogUmV0dXJucyBgZmFsc2VgIGlmIGFueSBwYXJ0IG9mIGEgbGluZSBmYWxscyBvdXRzaWRlIHRoZSBib3VuZGFyeSwgdGhlIGxpbmUgaW50ZXJzZWN0cyB0aGUgYm91bmRhcnksIG9yIGEgbGluZSdzIGVuZHBvaW50IGlzIG9uIHRoZSBib3VuZGFyeS5cIixcblx0XHRcdGdyb3VwOiBcIkRlY2lzaW9uXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIxLjkuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiOS4xLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNS44LjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjE1LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImlzLXN1cHBvcnRlZC1zY3JpcHRcIjoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyIGxlZ2libHkuIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgaW5wdXQgc3RyaW5nIGNvbnRhaW5zIHNlY3Rpb25zIHRoYXQgY2Fubm90IGJlIHJlbmRlcmVkIHdpdGhvdXQgcG90ZW50aWFsIGxvc3Mgb2YgbWVhbmluZyAoZS5nLiBJbmRpYyBzY3JpcHRzIHRoYXQgcmVxdWlyZSBjb21wbGV4IHRleHQgc2hhcGluZywgb3IgcmlnaHQtdG8tbGVmdCBzY3JpcHRzIGlmIHRoZSB0aGUgYG1hcGJveC1nbC1ydGwtdGV4dGAgcGx1Z2luIGlzIG5vdCBpbiB1c2UgaW4gTWFwYm94IEdMIEpTKS5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjYuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHVwY2FzZToge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgdGhlIGlucHV0IHN0cmluZyBjb252ZXJ0ZWQgdG8gdXBwZXJjYXNlLiBGb2xsb3dzIHRoZSBVbmljb2RlIERlZmF1bHQgQ2FzZSBDb252ZXJzaW9uIGFsZ29yaXRobSBhbmQgdGhlIGxvY2FsZS1pbnNlbnNpdGl2ZSBjYXNlIG1hcHBpbmdzIGluIHRoZSBVbmljb2RlIENoYXJhY3RlciBEYXRhYmFzZS5cIixcblx0XHRcdGdyb3VwOiBcIlN0cmluZ1wiLFxuXHRcdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG93bmNhc2U6IHtcblx0XHRcdGRvYzogXCJSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgY29udmVydGVkIHRvIGxvd2VyY2FzZS4gRm9sbG93cyB0aGUgVW5pY29kZSBEZWZhdWx0IENhc2UgQ29udmVyc2lvbiBhbGdvcml0aG0gYW5kIHRoZSBsb2NhbGUtaW5zZW5zaXRpdmUgY2FzZSBtYXBwaW5ncyBpbiB0aGUgVW5pY29kZSBDaGFyYWN0ZXIgRGF0YWJhc2UuXCIsXG5cdFx0XHRncm91cDogXCJTdHJpbmdcIixcblx0XHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbmNhdDoge1xuXHRcdFx0ZG9jOiBcIlJldHVybnMgYSBgc3RyaW5nYCBjb25zaXN0aW5nIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBpbnB1dHMuIEVhY2ggaW5wdXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGFzIGlmIGJ5IGB0by1zdHJpbmdgLlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInJlc29sdmVkLWxvY2FsZVwiOiB7XG5cdFx0XHRkb2M6IFwiUmV0dXJucyB0aGUgSUVURiBsYW5ndWFnZSB0YWcgb2YgdGhlIGxvY2FsZSBiZWluZyB1c2VkIGJ5IHRoZSBwcm92aWRlZCBgY29sbGF0b3JgLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbG9jYWxlLCBvciB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0ZWQgbG9jYWxlIHdhcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlwiLFxuXHRcdFx0Z3JvdXA6IFwiU3RyaW5nXCIsXG5cdFx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0XHRqczogXCIwLjQ1LjBcIixcblx0XHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdFx0bWFjb3M6IFwiMC45LjBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIGZvZyA9IHtcblx0cmFuZ2U6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAuNSxcblx0XHRcdDEwXG5cdFx0XSxcblx0XHRtaW5pbXVtOiAtMjAsXG5cdFx0bWF4aW11bTogMjAsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgc3RhcnQgYW5kIGVuZCBkaXN0YW5jZSByYW5nZSBpbiB3aGljaCBmb2cgZmFkZXMgZnJvbSBmdWxseSB0cmFuc3BhcmVudCB0byBmdWxseSBvcGFxdWUuIFRoZSBkaXN0YW5jZSB0byB0aGUgcG9pbnQgYXQgdGhlIGNlbnRlciBvZiB0aGUgbWFwIGlzIGRlZmluZWQgYXMgemVybywgc28gdGhhdCBuZWdhdGl2ZSByYW5nZSB2YWx1ZXMgYXJlIGNsb3NlciB0byB0aGUgY2FtZXJhLCBhbmQgcG9zaXRpdmUgdmFsdWVzIGFyZSBmYXJ0aGVyIGF3YXkuXCIsXG5cdFx0ZXhhbXBsZTogW1xuXHRcdFx0MC41LFxuXHRcdFx0MTBcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMi4zLjBcIlxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0Y29sb3I6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiNmZmZmZmZcIixcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGZvZy4gVXNpbmcgb3BhY2l0eSBpcyByZWNvbW1lbmRlZCBvbmx5IGZvciBzbW9vdGhseSB0cmFuc2l0aW9uaW5nIGZvZyBvbi9vZmYgYXMgYW55dGhpbmcgbGVzcyB0aGFuIDEwMCUgb3BhY2l0eSByZXN1bHRzIGluIG1vcmUgdGlsZXMgbG9hZGVkIGFuZCBkcmF3bi5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjIuMy4wXCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFwiaG9yaXpvbi1ibGVuZFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAuMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiSG9yaXpvbiBibGVuZCBhcHBsaWVzIGEgc21vb3RoIGZhZGUgZnJvbSB0aGUgY29sb3Igb2YgdGhlIGZvZyB0byB0aGUgY29sb3Igb2YgdGhlIHNreS4gQSB2YWx1ZSBvZiB6ZXJvIGxlYXZlcyBhIHNoYXJwIHRyYW5zaXRpb24gZnJvbSBmb2cgdG8gc2t5LiBJbmNyZWFzaW5nIHRoZSB2YWx1ZSBibGVuZHMgdGhlIGNvbG9yIG9mIGZvZyBpbnRvIGluY3JlYXNpbmdseSBoaWdoIGFuZ2xlcyBvZiB0aGUgc2t5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMi4zLjBcIlxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbnZhciBsaWdodCA9IHtcblx0YW5jaG9yOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgaXMgYWxpZ25lZCB0byB0aGUgcm90YXRpb24gb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0ZG9jOiBcIldoZXRoZXIgZXh0cnVkZWQgZ2VvbWV0cmllcyBhcmUgbGl0IHJlbGF0aXZlIHRvIHRoZSBtYXAgb3Igdmlld3BvcnQuXCIsXG5cdFx0ZXhhbXBsZTogXCJtYXBcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRwb3NpdGlvbjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MS4xNSxcblx0XHRcdDIxMCxcblx0XHRcdDMwXG5cdFx0XSxcblx0XHRsZW5ndGg6IDMsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0ZG9jOiBcIlBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgcmVsYXRpdmUgdG8gbGl0IChleHRydWRlZCkgZ2VvbWV0cmllcywgaW4gW3IgcmFkaWFsIGNvb3JkaW5hdGUsIGEgYXppbXV0aGFsIGFuZ2xlLCBwIHBvbGFyIGFuZ2xlXSB3aGVyZSByIGluZGljYXRlcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBiYXNlIG9mIGFuIG9iamVjdCB0byBpdHMgbGlnaHQsIGEgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlnaHQgcmVsYXRpdmUgdG8gMMKwICgwwrAgd2hlbiBgbGlnaHQuYW5jaG9yYCBpcyBzZXQgdG8gYHZpZXdwb3J0YCBjb3JyZXNwb25kcyB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydCwgb3IgMMKwIHdoZW4gYGxpZ2h0LmFuY2hvcmAgaXMgc2V0IHRvIGBtYXBgIGNvcnJlc3BvbmRzIHRvIGR1ZSBub3J0aCwgYW5kIGRlZ3JlZXMgcHJvY2VlZCBjbG9ja3dpc2UpLCBhbmQgcCBpbmRpY2F0ZXMgdGhlIGhlaWdodCBvZiB0aGUgbGlnaHQgKGZyb20gMMKwLCBkaXJlY3RseSBhYm92ZSwgdG8gMTgwwrAsIGRpcmVjdGx5IGJlbG93KS5cIixcblx0XHRleGFtcGxlOiBbXG5cdFx0XHQxLjUsXG5cdFx0XHQ5MCxcblx0XHRcdDgwXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRjb2xvcjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiI2ZmZmZmZlwiLFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIkNvbG9yIHRpbnQgZm9yIGxpZ2h0aW5nIGV4dHJ1ZGVkIGdlb21ldHJpZXMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aW50ZW5zaXR5OiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAuNSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiSW50ZW5zaXR5IG9mIGxpZ2h0aW5nIChvbiBhIHNjYWxlIGZyb20gMCB0byAxKS4gSGlnaGVyIG51bWJlcnMgd2lsbCBwcmVzZW50IGFzIG1vcmUgZXh0cmVtZSBjb250cmFzdC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIHByb2plY3Rpb24gPSB7XG5cdG5hbWU6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGFsYmVyczoge1xuXHRcdFx0XHRkb2M6IFwiQW4gQWxiZXJzIGVxdWFsLWFyZWEgcHJvamVjdGlvbiBjZW50ZXJlZCBvbiB0aGUgY29udGluZW50YWwgVW5pdGVkIFN0YXRlcy4gWW91IGNhbiBjb25maWd1cmUgdGhlIHByb2plY3Rpb24gZm9yIGEgZGlmZmVyZW50IHJlZ2lvbiBieSBzZXR0aW5nIGBjZW50ZXJgIGFuZCBgcGFyYWxsZWxzYCBwcm9wZXJ0aWVzLiBZb3UgbWF5IHdhbnQgdG8gc2V0IG1heCBib3VuZHMgdG8gY29uc3RyYWluIHRoZSBtYXAgdG8gdGhlIHJlbGV2YW50IHJlZ2lvbi5cIlxuXHRcdFx0fSxcblx0XHRcdGVxdWFsRWFydGg6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIEVxdWFsIEVhcnRoIHByb2plY3Rpb24uXCJcblx0XHRcdH0sXG5cdFx0XHRlcXVpcmVjdGFuZ3VsYXI6IHtcblx0XHRcdFx0ZG9jOiBcIkFuIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLiBUaGlzIHByb2plY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBQbGF0ZSBDYXJyw6llIHByb2plY3Rpb24uXCJcblx0XHRcdH0sXG5cdFx0XHRsYW1iZXJ0Q29uZm9ybWFsQ29uaWM6IHtcblx0XHRcdFx0ZG9jOiBcIkEgTGFtYmVydCBjb25mb3JtYWwgY29uaWMgcHJvamVjdGlvbi4gWW91IGNhbiBjb25maWd1cmUgdGhlIHByb2plY3Rpb24gZm9yIGEgcmVnaW9uIGJ5IHNldHRpbmcgYGNlbnRlcmAgYW5kIGBwYXJhbGxlbHNgIHByb3BlcnRpZXMuIFlvdSBtYXkgd2FudCB0byBzZXQgbWF4IGJvdW5kcyB0byBjb25zdHJhaW4gdGhlIG1hcCB0byB0aGUgcmVsZXZhbnQgcmVnaW9uLlwiXG5cdFx0XHR9LFxuXHRcdFx0bWVyY2F0b3I6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBNZXJjYXRvciBwcm9qZWN0aW9uIGlzIHRoZSBkZWZhdWx0IHByb2plY3Rpb24uXCJcblx0XHRcdH0sXG5cdFx0XHRuYXR1cmFsRWFydGg6IHtcblx0XHRcdFx0ZG9jOiBcIkEgTmF0dXJhbCBFYXJ0aCBwcm9qZWN0aW9uLlwiXG5cdFx0XHR9LFxuXHRcdFx0d2lua2VsVHJpcGVsOiB7XG5cdFx0XHRcdGRvYzogXCJBIFdpbmtlbCBUcmlwZWwgcHJvamVjdGlvbi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwibWVyY2F0b3JcIixcblx0XHRkb2M6IFwiVGhlIG5hbWUgb2YgdGhlIHByb2plY3Rpb24gdG8gYmUgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBtYXAuXCIsXG5cdFx0cmVxdWlyZWQ6IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIyLjYuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRjZW50ZXI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRkb2M6IFwiVGhlIHJlZmVyZW5jZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBwcm9qZWN0aW9uLiBgY2VudGVyYCB0YWtlcyB0aGUgZm9ybSBvZiBbbG5nLCBsYXRdLiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgY29uZmlndXJhYmxlIGZvciBjb25pYyBwcm9qZWN0aW9ucyAoQWxiZXJzIGFuZCBMYW1iZXJ0IENvbmZvcm1hbCBDb25pYykuIEFsbCBvdGhlciBwcm9qZWN0aW9ucyBhcmUgY2VudGVyZWQgb24gWzAsIDBdLlwiLFxuXHRcdGV4YW1wbGU6IFtcblx0XHRcdC05Nixcblx0XHRcdDM3LjVcblx0XHRdLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFtcblx0XHRcdFx0XHRcImFsYmVyc1wiLFxuXHRcdFx0XHRcdFwibGFtYmVydENvbmZvcm1hbENvbmljXCJcblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIyLjYuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRwYXJhbGxlbHM6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRkb2M6IFwiVGhlIHN0YW5kYXJkIHBhcmFsbGVscyBvZiB0aGUgcHJvamVjdGlvbiwgZGVub3RpbmcgdGhlIGRlc2lyZWQgbGF0aXR1ZGUgcmFuZ2Ugd2l0aCBtaW5pbWFsIGRpc3RvcnRpb24uIGBwYXJhbGxlbHNgIHRha2VzIHRoZSBmb3JtIG9mIFtsYXQwLCBsYXQxXS4gVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGNvbmZpZ3VyYWJsZSBmb3IgY29uaWMgcHJvamVjdGlvbnMgKEFsYmVycyBhbmQgTGFtYmVydCBDb25mb3JtYWwgQ29uaWMpLlwiLFxuXHRcdGV4YW1wbGU6IFtcblx0XHRcdDI5LjUsXG5cdFx0XHQ0NS41XG5cdFx0XSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBbXG5cdFx0XHRcdFx0XCJhbGJlcnNcIixcblx0XHRcdFx0XHRcImxhbWJlcnRDb25mb3JtYWxDb25pY1wiXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMi42LjBcIlxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbnZhciB0ZXJyYWluID0ge1xuXHRzb3VyY2U6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJOYW1lIG9mIGEgc291cmNlIG9mIGByYXN0ZXJfZGVtYCB0eXBlIHRvIGJlIHVzZWQgZm9yIHRlcnJhaW4gZWxldmF0aW9uLlwiLFxuXHRcdHJlcXVpcmVkOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjEwLjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjEwLjAuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRleGFnZ2VyYXRpb246IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEwMDAsXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiRXhhZ2dlcmF0ZXMgdGhlIGVsZXZhdGlvbiBvZiB0aGUgdGVycmFpbiBieSBtdWx0aXBseWluZyB0aGUgZGF0YSBmcm9tIHRoZSBERU0gd2l0aCB0aGlzIHZhbHVlLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjEwLjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjEwLjAuMFwiXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIHBhaW50ID0gW1xuXHRcInBhaW50X2ZpbGxcIixcblx0XCJwYWludF9saW5lXCIsXG5cdFwicGFpbnRfY2lyY2xlXCIsXG5cdFwicGFpbnRfaGVhdG1hcFwiLFxuXHRcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCIsXG5cdFwicGFpbnRfc3ltYm9sXCIsXG5cdFwicGFpbnRfcmFzdGVyXCIsXG5cdFwicGFpbnRfaGlsbHNoYWRlXCIsXG5cdFwicGFpbnRfYmFja2dyb3VuZFwiLFxuXHRcInBhaW50X3NreVwiXG5dO1xudmFyIHBhaW50X2ZpbGwgPSB7XG5cdFwiZmlsbC1hbnRpYWxpYXNcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdGRvYzogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgZmlsbCBsYXllci4gSW4gY29udHJhc3QgdG8gdGhlIGBmaWxsLWNvbG9yYCwgdGhpcyB2YWx1ZSB3aWxsIGFsc28gYWZmZWN0IHRoZSAxcHggc3Ryb2tlIGFyb3VuZCB0aGUgZmlsbCwgaWYgdGhlIHN0cm9rZSBpcyB1c2VkLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGZpbGxlZCBwYXJ0IG9mIHRoaXMgbGF5ZXIuIFRoaXMgY29sb3IgY2FuIGJlIHNwZWNpZmllZCBhcyBgcmdiYWAgd2l0aCBhbiBhbHBoYSBjb21wb25lbnQgYW5kIHRoZSBjb2xvcidzIG9wYWNpdHkgd2lsbCBub3QgYWZmZWN0IHRoZSBvcGFjaXR5IG9mIHRoZSAxcHggc3Ryb2tlLCBpZiBpdCBpcyB1c2VkLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIlRoZSBvdXRsaW5lIGNvbG9yIG9mIHRoZSBmaWxsLiBNYXRjaGVzIHRoZSB2YWx1ZSBvZiBgZmlsbC1jb2xvcmAgaWYgdW5zcGVjaWZpZWQuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0XCJmaWxsLWFudGlhbGlhc1wiOiB0cnVlXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4xOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtdHJhbnNsYXRlXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGZpbGwgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImZpbGwtdHJhbnNsYXRlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLXBhdHRlcm5cIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBmaWxscy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG5cdH1cbn07XG52YXIgcGFpbnRfbGluZSA9IHtcblx0XCJsaW5lLW9wYWNpdHlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjIzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBsaW5lIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgbGluZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBsaW5lLXRyYW5zbGF0ZWAuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwibWFwXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwibGluZS10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImxpbmUtd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJTdHJva2UgdGhpY2tuZXNzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjM5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1nYXAtd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtb2Zmc2V0XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdGRvYzogXCJUaGUgbGluZSdzIG9mZnNldC4gRm9yIGxpbmVhciBmZWF0dXJlcywgYSBwb3NpdGl2ZSB2YWx1ZSBvZmZzZXRzIHRoZSBsaW5lIHRvIHRoZSByaWdodCwgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZSwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgdG8gdGhlIGxlZnQuIEZvciBwb2x5Z29uIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gaW5zZXQsIGFuZCBhIG5lZ2F0aXZlIHZhbHVlIHJlc3VsdHMgaW4gYW4gb3V0c2V0LlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEyLjFcIixcblx0XHRcdFx0YW5kcm9pZDogXCIzLjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy4xLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWJsdXJcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJCbHVyIGFwcGxpZWQgdG8gdGhlIGxpbmUsIGluIHBpeGVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImxpbmUtZGFzaGFycmF5XCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0ZG9jOiBcIlNwZWNpZmllcyB0aGUgbGVuZ3RocyBvZiB0aGUgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzIHRoYXQgZm9ybSB0aGUgZGFzaCBwYXR0ZXJuLiBUaGUgbGVuZ3RocyBhcmUgbGF0ZXIgc2NhbGVkIGJ5IHRoZSBsaW5lIHdpZHRoLiBUbyBjb252ZXJ0IGEgZGFzaCBsZW5ndGggdG8gcGl4ZWxzLCBtdWx0aXBseSB0aGUgbGVuZ3RoIGJ5IHRoZSBjdXJyZW50IGxpbmUgd2lkdGguIE5vdGUgdGhhdCBHZW9KU09OIHNvdXJjZXMgd2l0aCBgbGluZU1ldHJpY3M6IHRydWVgIHNwZWNpZmllZCB3b24ndCByZW5kZXIgZGFzaGVkIGxpbmVzIHRvIHRoZSBleHBlY3RlZCBzY2FsZS4gQWxzbyBub3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJsaW5lIHdpZHRoc1wiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMi4zLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwibGluZS1wYXR0ZXJuXCI6IHtcblx0XHR0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgbGluZXMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC40OS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMS4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJsaW5lLWdyYWRpZW50XCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0ZG9jOiBcIkRlZmluZXMgYSBncmFkaWVudCB3aXRoIHdoaWNoIHRvIGNvbG9yIGEgbGluZSBmZWF0dXJlLiBDYW4gb25seSBiZSB1c2VkIHdpdGggR2VvSlNPTiBzb3VyY2VzIHRoYXQgc3BlY2lmeSBgXFxcImxpbmVNZXRyaWNzXFxcIjogdHJ1ZWAuXCIsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHNvdXJjZTogXCJnZW9qc29uXCIsXG5cdFx0XHRcdGhhczoge1xuXHRcdFx0XHRcdGxpbmVNZXRyaWNzOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40NS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi41LjBcIixcblx0XHRcdFx0aW9zOiBcIjQuNC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMTEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJsaW5lLXByb2dyZXNzXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuXHR9XG59O1xudmFyIHBhaW50X2NpcmNsZSA9IHtcblx0XCJjaXJjbGUtcmFkaXVzXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiA1LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiQ2lyY2xlIHJhZGl1cy5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4xOC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImNpcmNsZS1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIGZpbGwgY29sb3Igb2YgdGhlIGNpcmNsZS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjE4LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLWJsdXJcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0ZG9jOiBcIkFtb3VudCB0byBibHVyIHRoZSBjaXJjbGUuIDEgYmx1cnMgdGhlIGNpcmNsZSBzdWNoIHRoYXQgb25seSB0aGUgY2VudGVycG9pbnQgaXMgZnVsbCBvcGFjaXR5LlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJjaXJjbGUtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGNpcmNsZSB3aWxsIGJlIGRyYXduLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjIwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLXRyYW5zbGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2lyY2xlIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2lyY2xlIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGNpcmNsZS10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImNpcmNsZS10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImNpcmNsZS1waXRjaC1zY2FsZVwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIkNpcmNsZXMgYXJlIHNjYWxlZCBhY2NvcmRpbmcgdG8gdGhlaXIgYXBwYXJlbnQgZGlzdGFuY2UgdG8gdGhlIGNhbWVyYS5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJDaXJjbGVzIGFyZSBub3Qgc2NhbGVkLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJtYXBcIixcblx0XHRkb2M6IFwiQ29udHJvbHMgdGhlIHNjYWxpbmcgYmVoYXZpb3Igb2YgdGhlIGNpcmNsZSB3aGVuIHRoZSBtYXAgaXMgcGl0Y2hlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjQuMi4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjQuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjIuMVwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBjaXJjbGUgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgY2lyY2xlIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSB2aWV3cG9ydC5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcblx0XHRkb2M6IFwiT3JpZW50YXRpb24gb2YgY2lyY2xlIHdoZW4gbWFwIGlzIHBpdGNoZWQuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjM5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjIuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC42LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImNpcmNsZS1zdHJva2Utd2lkdGhcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgd2lkdGggb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS4gU3Ryb2tlcyBhcmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGBjaXJjbGUtcmFkaXVzYC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjkuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImNpcmNsZS1zdHJva2UtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBzdHJva2UgY29sb3Igb2YgdGhlIGNpcmNsZS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJUaGUgb3BhY2l0eSBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yOS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH1cbn07XG52YXIgcGFpbnRfaGVhdG1hcCA9IHtcblx0XCJoZWF0bWFwLXJhZGl1c1wiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzAsXG5cdFx0bWluaW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJSYWRpdXMgb2YgaW5mbHVlbmNlIG9mIG9uZSBoZWF0bWFwIHBvaW50IGluIHBpeGVscy4gSW5jcmVhc2luZyB0aGUgdmFsdWUgbWFrZXMgdGhlIGhlYXRtYXAgc21vb3RoZXIsIGJ1dCBsZXNzIGRldGFpbGVkLiBgcXVlcnlSZW5kZXJlZEZlYXR1cmVzYCBvbiBoZWF0bWFwIGxheWVycyB3aWxsIHJldHVybiBwb2ludHMgd2l0aGluIHRoaXMgcmFkaXVzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaGVhdG1hcC13ZWlnaHRcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRkb2M6IFwiQSBtZWFzdXJlIG9mIGhvdyBtdWNoIGFuIGluZGl2aWR1YWwgcG9pbnQgY29udHJpYnV0ZXMgdG8gdGhlIGhlYXRtYXAuIEEgdmFsdWUgb2YgMTAgd291bGQgYmUgZXF1aXZhbGVudCB0byBoYXZpbmcgMTAgcG9pbnRzIG9mIHdlaWdodCAxIGluIHRoZSBzYW1lIHNwb3QuIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBjbHVzdGVyaW5nLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40MS4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaGVhdG1hcC1pbnRlbnNpdHlcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJTaW1pbGFyIHRvIGBoZWF0bWFwLXdlaWdodGAgYnV0IGNvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIGhlYXRtYXAgZ2xvYmFsbHkuIFByaW1hcmlseSB1c2VkIGZvciBhZGp1c3RpbmcgdGhlIGhlYXRtYXAgYmFzZWQgb24gem9vbSBsZXZlbC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDEuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoZWF0bWFwLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdFwiaW50ZXJwb2xhdGVcIixcblx0XHRcdFtcblx0XHRcdFx0XCJsaW5lYXJcIlxuXHRcdFx0XSxcblx0XHRcdFtcblx0XHRcdFx0XCJoZWF0bWFwLWRlbnNpdHlcIlxuXHRcdFx0XSxcblx0XHRcdDAsXG5cdFx0XHRcInJnYmEoMCwgMCwgMjU1LCAwKVwiLFxuXHRcdFx0MC4xLFxuXHRcdFx0XCJyb3lhbGJsdWVcIixcblx0XHRcdDAuMyxcblx0XHRcdFwiY3lhblwiLFxuXHRcdFx0MC41LFxuXHRcdFx0XCJsaW1lXCIsXG5cdFx0XHQwLjcsXG5cdFx0XHRcInllbGxvd1wiLFxuXHRcdFx0MSxcblx0XHRcdFwicmVkXCJcblx0XHRdLFxuXHRcdGRvYzogXCJEZWZpbmVzIHRoZSBjb2xvciBvZiBlYWNoIHBpeGVsIGJhc2VkIG9uIGl0cyBkZW5zaXR5IHZhbHVlIGluIGEgaGVhdG1hcC4gIFNob3VsZCBiZSBhbiBleHByZXNzaW9uIHRoYXQgdXNlcyBgW1xcXCJoZWF0bWFwLWRlbnNpdHlcXFwiXWAgYXMgaW5wdXQuXCIsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiaGVhdG1hcC1kZW5zaXR5XCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuXHR9LFxuXHRcImhlYXRtYXAtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIGdsb2JhbCBvcGFjaXR5IGF0IHdoaWNoIHRoZSBoZWF0bWFwIGxheWVyIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQxLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH1cbn07XG52YXIgcGFpbnRfc3ltYm9sID0ge1xuXHRcImljb24tb3BhY2l0eVwiOiB7XG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpY29uIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFtTREYgaWNvbnNdKC9oZWxwL3Ryb3VibGVzaG9vdGluZy91c2luZy1yZWNvbG9yYWJsZS1pbWFnZXMtaW4tbWFwYm94LW1hcHMvKS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgaWNvbidzIGhhbG8uIEljb24gaGFsb3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFtTREYgaWNvbnNdKC9oZWxwL3Ryb3VibGVzaG9vdGluZy91c2luZy1yZWNvbG9yYWJsZS1pbWFnZXMtaW4tbWFwYm94LW1hcHMvKS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJpY29uLWltYWdlXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgaWNvbiBvdXRsaW5lLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJpY29uLWhhbG8tYmx1clwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiaWNvbi1pbWFnZVwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImljb24tdHJhbnNsYXRlXCI6IHtcblx0XHR0eXBlOiBcImFycmF5XCIsXG5cdFx0dmFsdWU6IFwibnVtYmVyXCIsXG5cdFx0bGVuZ3RoOiAyLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHQwLFxuXHRcdFx0MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJwaXhlbHNcIixcblx0XHRkb2M6IFwiRGlzdGFuY2UgdGhhdCB0aGUgaWNvbidzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiSWNvbnMgYXJlIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgaWNvbi10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcImljb24taW1hZ2VcIixcblx0XHRcdFwiaWNvbi10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInRleHQtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdGRvYzogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdG92ZXJyaWRhYmxlOiB0cnVlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMzMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjQuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJ0ZXh0LWhhbG8tY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRkb2M6IFwiVGhlIGNvbG9yIG9mIHRoZSB0ZXh0J3MgaGFsbywgd2hpY2ggaGVscHMgaXQgc3RhbmQgb3V0IGZyb20gYmFja2dyb3VuZHMuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4zMy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNS4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcInRleHQtaGFsby13aWR0aFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC1oYWxvLWJsdXJcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJUaGUgaGFsbydzIGZhZGVvdXQgZGlzdGFuY2UgdG93YXJkcyB0aGUgb3V0c2lkZS5cIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJ0ZXh0LWZpZWxkXCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjMzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy41LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC40LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwidGV4dC10cmFuc2xhdGVcIjoge1xuXHRcdHR5cGU6IFwiYXJyYXlcIixcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRsZW5ndGg6IDIsXG5cdFx0XCJkZWZhdWx0XCI6IFtcblx0XHRcdDAsXG5cdFx0XHQwXG5cdFx0XSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdHVuaXRzOiBcInBpeGVsc1wiLFxuXHRcdGRvYzogXCJEaXN0YW5jZSB0aGF0IHRoZSB0ZXh0J3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwidGV4dC1maWVsZFwiXG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIHRleHQgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgdGV4dC10cmFuc2xhdGVgLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHRcInRleHQtZmllbGRcIixcblx0XHRcdFwidGV4dC10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHBhaW50X3Jhc3RlciA9IHtcblx0XCJyYXN0ZXItb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGltYWdlIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0cGVyaW9kOiAzNjAsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0ZG9jOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIGJyaWdodG5lc3MuXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDAsXG5cdFx0bWluaW11bTogMCxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWJyaWdodG5lc3MtbWF4XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1heGltdW0gYnJpZ2h0bmVzcy5cIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAtMSxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS5cIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAtMSxcblx0XHRtYXhpbXVtOiAxLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwicmFzdGVyLXJlc2FtcGxpbmdcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdGRvYzogXCJUaGUgcmVzYW1wbGluZy9pbnRlcnBvbGF0aW9uIG1ldGhvZCB0byB1c2UgZm9yIG92ZXJzY2FsaW5nLCBhbHNvIGtub3duIGFzIHRleHR1cmUgbWFnbmlmaWNhdGlvbiBmaWx0ZXJcIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGxpbmVhcjoge1xuXHRcdFx0XHRkb2M6IFwiKEJpKWxpbmVhciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciBjbG9zZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbHMgY3JlYXRpbmcgYSBzbW9vdGggYnV0IGJsdXJyeSBsb29rIHdoZW4gb3ZlcnNjYWxlZFwiXG5cdFx0XHR9LFxuXHRcdFx0bmVhcmVzdDoge1xuXHRcdFx0XHRkb2M6IFwiTmVhcmVzdCBuZWlnaGJvciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgbmVhcmVzdCBvcmlnaW5hbCBzb3VyY2UgcGl4ZWwgY3JlYXRpbmcgYSBzaGFycCBidXQgcGl4ZWxhdGVkIGxvb2sgd2hlbiBvdmVyc2NhbGVkXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcImxpbmVhclwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40Ny4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4zLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuOS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0dW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG5cdFx0ZG9jOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4xMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMi4wLjFcIixcblx0XHRcdFx0aW9zOiBcIjIuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuMS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHBhaW50X2hpbGxzaGFkZSA9IHtcblx0XCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzM1LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMzU5LFxuXHRcdGRvYzogXCJUaGUgZGlyZWN0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgaGlsbHNoYWRpbmcgd2l0aCAwIGFzIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGB2aWV3cG9ydGAgYW5kIGR1ZSBub3J0aCBpZiBgaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1hbmNob3JgIGlzIHNldCB0byBgbWFwYC5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiOiB7XG5cdFx0dHlwZTogXCJlbnVtXCIsXG5cdFx0dmFsdWVzOiB7XG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0ZG9jOiBcIlRoZSBoaWxsc2hhZGUgaWxsdW1pbmF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBub3J0aCBkaXJlY3Rpb24uXCJcblx0XHRcdH0sXG5cdFx0XHR2aWV3cG9ydDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG5cdFx0ZG9jOiBcIkRpcmVjdGlvbiBvZiBsaWdodCBzb3VyY2Ugd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLWV4YWdnZXJhdGlvblwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRkb2M6IFwiSW50ZW5zaXR5IG9mIHRoZSBoaWxsc2hhZGVcIixcblx0XHRcImRlZmF1bHRcIjogMC41LFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBzaGFkaW5nIGNvbG9yIG9mIGFyZWFzIHRoYXQgZmFjZSBhd2F5IGZyb20gdGhlIGxpZ2h0IHNvdXJjZS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC40My4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuMC4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjRkZGRkZGXCIsXG5cdFx0ZG9jOiBcIlRoZSBzaGFkaW5nIGNvbG9yIG9mIGFyZWFzIHRoYXQgZmFjZXMgdG93YXJkcyB0aGUgbGlnaHQgc291cmNlLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjQzLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC43LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiaGlsbHNoYWRlLWFjY2VudC1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcblx0XHRkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3IgdXNlZCB0byBhY2NlbnR1YXRlIHJ1Z2dlZCB0ZXJyYWluIGxpa2Ugc2hhcnAgY2xpZmZzIGFuZCBnb3JnZXMuXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuNDMuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjYuMC4wXCIsXG5cdFx0XHRcdGlvczogXCI0LjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjcuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufTtcbnZhciBwYWludF9iYWNrZ3JvdW5kID0ge1xuXHRcImJhY2tncm91bmQtY29sb3JcIjoge1xuXHRcdHR5cGU6IFwiY29sb3JcIixcblx0XHRcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG5cdFx0ZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIiFcIjogXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IHtcblx0XHR0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjEwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIyLjAuMVwiLFxuXHRcdFx0XHRpb3M6IFwiMi4wLjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xLjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWRcIlxuXHR9LFxuXHRcImJhY2tncm91bmQtb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG5cdFx0dHJhbnNpdGlvbjogdHJ1ZSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMTAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjIuMC4xXCIsXG5cdFx0XHRcdGlvczogXCIyLjAuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjEuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufTtcbnZhciBwYWludF9za3kgPSB7XG5cdFwic2t5LXR5cGVcIjoge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0Z3JhZGllbnQ6IHtcblx0XHRcdFx0ZG9jOiBcIlJlbmRlcnMgdGhlIHNreSB3aXRoIGEgZ3JhZGllbnQgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB3aXRoIGBza3ktZ3JhZGllbnQtcmFkaXVzYCBhbmQgYHNreS1ncmFkaWVudGAuXCJcblx0XHRcdH0sXG5cdFx0XHRhdG1vc3BoZXJlOiB7XG5cdFx0XHRcdGRvYzogXCJSZW5kZXJzIHRoZSBza3kgd2l0aCBhIHNpbXVsYXRlZCBhdG1vc3BoZXJpYyBzY2F0dGVyaW5nIGFsZ29yaXRobSwgdGhlIHN1biBkaXJlY3Rpb24gY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBsaWdodCBwb3NpdGlvbiBvciBleHBsaWNpdGx5IHNldCB0aHJvdWdoIGBza3ktYXRtb3NwaGVyZS1zdW5gLlwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImRlZmF1bHRcIjogXCJhdG1vc3BoZXJlXCIsXG5cdFx0ZG9jOiBcIlRoZSB0eXBlIG9mIHRoZSBza3lcIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjIuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIxMC4wLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIxMC4wLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInNreS1hdG1vc3BoZXJlLXN1blwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0bWluaW11bTogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdG1heGltdW06IFtcblx0XHRcdDM2MCxcblx0XHRcdDE4MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0ZG9jOiBcIlBvc2l0aW9uIG9mIHRoZSBzdW4gY2VudGVyIFthIGF6aW11dGhhbCBhbmdsZSwgcCBwb2xhciBhbmdsZV0uIFRoZSBhemltdXRoYWwgYW5nbGUgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VuIHJlbGF0aXZlIHRvIDDCsCBub3J0aCwgd2hlcmUgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZS4gVGhlIHBvbGFyIGFuZ2xlIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBzdW4sIHdoZXJlIDDCsCBpcyBkaXJlY3RseSBhYm92ZSwgYXQgemVuaXRoLCBhbmQgOTDCsCBhdCB0aGUgaG9yaXpvbi4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIG9tbWl0dGVkLCB0aGUgc3VuIGNlbnRlciBpcyBkaXJlY3RseSBpbmhlcml0ZWQgZnJvbSB0aGUgbGlnaHQgcG9zaXRpb24uXCIsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIyLjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMTAuMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMTAuMC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwic2t5LXR5cGVcIjogXCJhdG1vc3BoZXJlXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJza3ktYXRtb3NwaGVyZS1zdW4taW50ZW5zaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwic2t5LXR5cGVcIjogXCJhdG1vc3BoZXJlXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwiZGVmYXVsdFwiOiAxMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEwMCxcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRkb2M6IFwiSW50ZW5zaXR5IG9mIHRoZSBzdW4gYXMgYSBsaWdodCBzb3VyY2UgaW4gdGhlIGF0bW9zcGhlcmUgKG9uIGEgc2NhbGUgZnJvbSAwIHRvIGEgMTAwKS4gU2V0dGluZyBoaWdoZXIgdmFsdWVzIHdpbGwgYnJpZ2h0ZW4gdXAgdGhlIHNreS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjIuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIxMC4wLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIxMC4wLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwic2t5LWdyYWRpZW50LWNlbnRlclwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwic2t5LXR5cGVcIjogXCJncmFkaWVudFwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHR2YWx1ZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdGxlbmd0aDogMixcblx0XHR1bml0czogXCJkZWdyZWVzXCIsXG5cdFx0bWluaW11bTogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdG1heGltdW06IFtcblx0XHRcdDM2MCxcblx0XHRcdDE4MFxuXHRcdF0sXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0ZG9jOiBcIlBvc2l0aW9uIG9mIHRoZSBncmFkaWVudCBjZW50ZXIgW2EgYXppbXV0aGFsIGFuZ2xlLCBwIHBvbGFyIGFuZ2xlXS4gVGhlIGF6aW11dGhhbCBhbmdsZSBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBncmFkaWVudCBjZW50ZXIgcmVsYXRpdmUgdG8gMMKwIG5vcnRoLCB3aGVyZSBkZWdyZWVzIHByb2NlZWQgY2xvY2t3aXNlLiBUaGUgcG9sYXIgYW5nbGUgaW5kaWNhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGdyYWRpZW50IGNlbnRlciwgd2hlcmUgMMKwIGlzIGRpcmVjdGx5IGFib3ZlLCBhdCB6ZW5pdGgsIGFuZCA5MMKwIGF0IHRoZSBob3Jpem9uLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjEwLjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjEwLjAuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG5cdH0sXG5cdFwic2t5LWdyYWRpZW50LXJhZGl1c1wiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcInNreS10eXBlXCI6IFwiZ3JhZGllbnRcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJkZWZhdWx0XCI6IDkwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMTgwLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdGRvYzogXCJUaGUgYW5ndWxhciBkaXN0YW5jZSAobWVhc3VyZWQgaW4gZGVncmVlcykgZnJvbSBgc2t5LWdyYWRpZW50LWNlbnRlcmAgdXAgdG8gd2hpY2ggdGhlIGdyYWRpZW50IGV4dGVuZHMuIEEgdmFsdWUgb2YgMTgwIGNhdXNlcyB0aGUgZ3JhZGllbnQgdG8gd3JhcCBhcm91bmQgdG8gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBmcm9tIGBza3ktZ3JhZGllbnQtY2VudGVyYC5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjIuMC4wXCIsXG5cdFx0XHRcdGlvczogXCIxMC4wLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCIxMC4wLjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInNreS1ncmFkaWVudFwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBbXG5cdFx0XHRcImludGVycG9sYXRlXCIsXG5cdFx0XHRbXG5cdFx0XHRcdFwibGluZWFyXCJcblx0XHRcdF0sXG5cdFx0XHRbXG5cdFx0XHRcdFwic2t5LXJhZGlhbC1wcm9ncmVzc1wiXG5cdFx0XHRdLFxuXHRcdFx0MC44LFxuXHRcdFx0XCIjODdjZWViXCIsXG5cdFx0XHQxLFxuXHRcdFx0XCJ3aGl0ZVwiXG5cdFx0XSxcblx0XHRkb2M6IFwiRGVmaW5lcyBhIHJhZGlhbCBjb2xvciBncmFkaWVudCB3aXRoIHdoaWNoIHRvIGNvbG9yIHRoZSBza3kuIFRoZSBjb2xvciB2YWx1ZXMgY2FuIGJlIGludGVycG9sYXRlZCB3aXRoIGFuIGV4cHJlc3Npb24gdXNpbmcgYHNreS1yYWRpYWwtcHJvZ3Jlc3NgLiBUaGUgcmFuZ2UgWzAsIDFdIGZvciB0aGUgaW50ZXJwb2xhbnQgY292ZXJzIGEgcmFkaWFsIGRpc3RhbmNlIChpbiBkZWdyZWVzKSBvZiBbMCwgYHNreS1ncmFkaWVudC1yYWRpdXNgXSBjZW50ZXJlZCBhdCB0aGUgcG9zaXRpb24gc3BlY2lmaWVkIGJ5IGBza3ktZ3JhZGllbnQtY2VudGVyYC5cIixcblx0XHR0cmFuc2l0aW9uOiBmYWxzZSxcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0e1xuXHRcdFx0XHRcInNreS10eXBlXCI6IFwiZ3JhZGllbnRcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIyLjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMTAuMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMTAuMC4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInNreS1yYWRpYWwtcHJvZ3Jlc3NcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG5cdH0sXG5cdFwic2t5LWF0bW9zcGhlcmUtaGFsby1jb2xvclwiOiB7XG5cdFx0dHlwZTogXCJjb2xvclwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcIndoaXRlXCIsXG5cdFx0ZG9jOiBcIkEgY29sb3IgYXBwbGllZCB0byB0aGUgYXRtb3NwaGVyZSBzdW4gaGFsby4gVGhlIGFscGhhIGNoYW5uZWwgZGVzY3JpYmVzIGhvdyBzdHJvbmdseSB0aGUgc3VuIGhhbG8gaXMgcmVwcmVzZW50ZWQgaW4gYW4gYXRtb3NwaGVyZSBza3kgbGF5ZXIuXCIsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCJza3ktdHlwZVwiOiBcImF0bW9zcGhlcmVcIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIyLjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMTAuMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMTAuMC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcInNreS1hdG1vc3BoZXJlLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwid2hpdGVcIixcblx0XHRkb2M6IFwiQSBjb2xvciB1c2VkIHRvIHR3ZWFrIHRoZSBtYWluIGF0bW9zcGhlcmljIHNjYXR0ZXJpbmcgY29lZmZpY2llbnRzLiBVc2luZyB3aGl0ZSBhcHBsaWVzIHRoZSBkZWZhdWx0IGNvZWZmaWNpZW50cyBnaXZpbmcgdGhlIG5hdHVyYWwgYmx1ZSBjb2xvciB0byB0aGUgYXRtb3NwaGVyZS4gVGhpcyBjb2xvciBhZmZlY3RzIGhvdyBoZWF2aWx5IHRoZSBjb3JyZXNwb25kaW5nIHdhdmVsZW5ndGggaXMgcmVwcmVzZW50ZWQgZHVyaW5nIHNjYXR0ZXJpbmcuIFRoZSBhbHBoYSBjaGFubmVsIGRlc2NyaWJlcyB0aGUgZGVuc2l0eSBvZiB0aGUgYXRtb3NwaGVyZSwgd2l0aCAxIG1heGltdW0gZGVuc2l0eSBhbmQgMCBubyBkZW5zaXR5LlwiLFxuXHRcdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcdHJlcXVpcmVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdFwic2t5LXR5cGVcIjogXCJhdG1vc3BoZXJlXCJcblx0XHRcdH1cblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMi4wLjBcIixcblx0XHRcdFx0aW9zOiBcIjEwLjAuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjEwLjAuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJza3ktb3BhY2l0eVwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMSxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdG1heGltdW06IDEsXG5cdFx0ZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgc2t5IGxheWVyLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIyLjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMTAuMC4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiMTAuMC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9XG59O1xudmFyIHRyYW5zaXRpb24gPSB7XG5cdGR1cmF0aW9uOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMzAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG5cdFx0ZG9jOiBcIlRpbWUgYWxsb3R0ZWQgZm9yIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlLlwiXG5cdH0sXG5cdGRlbGF5OiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuXHRcdGRvYzogXCJMZW5ndGggb2YgdGltZSBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuXHR9XG59O1xudmFyIHByb21vdGVJZCA9IHtcblx0XCIqXCI6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJBIG5hbWUgb2YgYSBmZWF0dXJlIHByb3BlcnR5IHRvIHVzZSBhcyBJRCBmb3IgZmVhdHVyZSBzdGF0ZS5cIlxuXHR9XG59O1xudmFyIHY4ID0ge1xuXHQkdmVyc2lvbjogJHZlcnNpb24sXG5cdCRyb290OiAkcm9vdCxcblx0c291cmNlczogc291cmNlcyxcblx0c291cmNlOiBzb3VyY2UsXG5cdHNvdXJjZV92ZWN0b3I6IHNvdXJjZV92ZWN0b3IsXG5cdHNvdXJjZV9yYXN0ZXI6IHNvdXJjZV9yYXN0ZXIsXG5cdHNvdXJjZV9yYXN0ZXJfZGVtOiBzb3VyY2VfcmFzdGVyX2RlbSxcblx0c291cmNlX2dlb2pzb246IHNvdXJjZV9nZW9qc29uLFxuXHRzb3VyY2VfdmlkZW86IHNvdXJjZV92aWRlbyxcblx0c291cmNlX2ltYWdlOiBzb3VyY2VfaW1hZ2UsXG5cdGxheWVyOiBsYXllcixcblx0bGF5b3V0OiBsYXlvdXQsXG5cdGxheW91dF9iYWNrZ3JvdW5kOiBsYXlvdXRfYmFja2dyb3VuZCxcblx0bGF5b3V0X3NreTogbGF5b3V0X3NreSxcblx0bGF5b3V0X2ZpbGw6IGxheW91dF9maWxsLFxuXHRsYXlvdXRfY2lyY2xlOiBsYXlvdXRfY2lyY2xlLFxuXHRsYXlvdXRfaGVhdG1hcDogbGF5b3V0X2hlYXRtYXAsXG5cdFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCI6IHtcblx0dmlzaWJpbGl0eToge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczoge1xuXHRcdFx0dmlzaWJsZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG5cdFx0XHR9LFxuXHRcdFx0bm9uZToge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcblx0fVxufSxcblx0bGF5b3V0X2xpbmU6IGxheW91dF9saW5lLFxuXHRsYXlvdXRfc3ltYm9sOiBsYXlvdXRfc3ltYm9sLFxuXHRsYXlvdXRfcmFzdGVyOiBsYXlvdXRfcmFzdGVyLFxuXHRsYXlvdXRfaGlsbHNoYWRlOiBsYXlvdXRfaGlsbHNoYWRlLFxuXHRmaWx0ZXI6IGZpbHRlcixcblx0ZmlsdGVyX3N5bWJvbDogZmlsdGVyX3N5bWJvbCxcblx0ZmlsdGVyX2ZpbGw6IGZpbHRlcl9maWxsLFxuXHRmaWx0ZXJfbGluZTogZmlsdGVyX2xpbmUsXG5cdGZpbHRlcl9jaXJjbGU6IGZpbHRlcl9jaXJjbGUsXG5cdFwiZmlsdGVyX2ZpbGwtZXh0cnVzaW9uXCI6IHtcblx0dHlwZTogXCJib29sZWFuXCIsXG5cdGRvYzogXCJFeHByZXNzaW9uIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSBhIFBvbHlnb24uIEZpbGwtZXh0cnVzaW9uIGxheWVyIGRvZXMgTk9UIHN1cHBvcnQgZHluYW1pYyBmaWx0ZXJpbmcsIG1lYW5pbmcgdGhpcyBleHByZXNzaW9uIGNhbiBOT1QgdXNlIHRoZSBgW1xcXCJwaXRjaFxcXCJdYCBhbmQgYFtcXFwiZGlzdGFuY2UtZnJvbS1jZW50ZXJcXFwiXWAgZXhwcmVzc2lvbnMgdG8gcmVmZXJlbmNlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB2aWV3LlwiLFxuXHRcImRlZmF1bHRcIjogZmFsc2UsXG5cdHRyYW5zaXRpb246IGZhbHNlLFxuXHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiLFxuXHRleHByZXNzaW9uOiB7XG5cdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcInpvb21cIixcblx0XHRcdFwiZmVhdHVyZVwiXG5cdFx0XVxuXHR9XG59LFxuXHRmaWx0ZXJfaGVhdG1hcDogZmlsdGVyX2hlYXRtYXAsXG5cdGZpbHRlcl9vcGVyYXRvcjogZmlsdGVyX29wZXJhdG9yLFxuXHRnZW9tZXRyeV90eXBlOiBnZW9tZXRyeV90eXBlLFxuXHRcImZ1bmN0aW9uXCI6IHtcblx0ZXhwcmVzc2lvbjoge1xuXHRcdHR5cGU6IFwiZXhwcmVzc2lvblwiLFxuXHRcdGRvYzogXCJBbiBleHByZXNzaW9uLlwiXG5cdH0sXG5cdHN0b3BzOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdGRvYzogXCJBbiBhcnJheSBvZiBzdG9wcy5cIixcblx0XHR2YWx1ZTogXCJmdW5jdGlvbl9zdG9wXCJcblx0fSxcblx0YmFzZToge1xuXHRcdHR5cGU6IFwibnVtYmVyXCIsXG5cdFx0XCJkZWZhdWx0XCI6IDEsXG5cdFx0bWluaW11bTogMCxcblx0XHRkb2M6IFwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJcblx0fSxcblx0cHJvcGVydHk6IHtcblx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdGRvYzogXCJUaGUgbmFtZSBvZiBhIGZlYXR1cmUgcHJvcGVydHkgdG8gdXNlIGFzIHRoZSBmdW5jdGlvbiBpbnB1dC5cIixcblx0XHRcImRlZmF1bHRcIjogXCIkem9vbVwiXG5cdH0sXG5cdHR5cGU6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGlkZW50aXR5OiB7XG5cdFx0XHRcdGRvYzogXCJSZXR1cm4gdGhlIGlucHV0IHZhbHVlIGFzIHRoZSBvdXRwdXQgdmFsdWUuXCJcblx0XHRcdH0sXG5cdFx0XHRleHBvbmVudGlhbDoge1xuXHRcdFx0XHRkb2M6IFwiR2VuZXJhdGUgYW4gb3V0cHV0IGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGZ1bmN0aW9uIGlucHV0LlwiXG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJ2YWw6IHtcblx0XHRcdFx0ZG9jOiBcIlJldHVybiB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoZSBzdG9wIGp1c3QgbGVzcyB0aGFuIHRoZSBmdW5jdGlvbiBpbnB1dC5cIlxuXHRcdFx0fSxcblx0XHRcdGNhdGVnb3JpY2FsOiB7XG5cdFx0XHRcdGRvYzogXCJSZXR1cm4gdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBlcXVhbCB0byB0aGUgZnVuY3Rpb24gaW5wdXQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgaW50ZXJwb2xhdGlvbiBzdHJhdGVneSB0byB1c2UgaW4gZnVuY3Rpb24gZXZhbHVhdGlvbi5cIixcblx0XHRcImRlZmF1bHRcIjogXCJleHBvbmVudGlhbFwiXG5cdH0sXG5cdGNvbG9yU3BhY2U6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdHJnYjoge1xuXHRcdFx0XHRkb2M6IFwiVXNlIHRoZSBSR0IgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzXCJcblx0XHRcdH0sXG5cdFx0XHRsYWI6IHtcblx0XHRcdFx0ZG9jOiBcIlVzZSB0aGUgTEFCIGNvbG9yIHNwYWNlIHRvIGludGVycG9sYXRlIGNvbG9yIHZhbHVlcy5cIlxuXHRcdFx0fSxcblx0XHRcdGhjbDoge1xuXHRcdFx0XHRkb2M6IFwiVXNlIHRoZSBIQ0wgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzLCBpbnRlcnBvbGF0aW5nIHRoZSBIdWUsIENocm9tYSwgYW5kIEx1bWluYW5jZSBjaGFubmVscyBpbmRpdmlkdWFsbHkuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJUaGUgY29sb3Igc3BhY2UgaW4gd2hpY2ggY29sb3JzIGludGVycG9sYXRlZC4gSW50ZXJwb2xhdGluZyBjb2xvcnMgaW4gcGVyY2VwdHVhbCBjb2xvciBzcGFjZXMgbGlrZSBMQUIgYW5kIEhDTCB0ZW5kIHRvIHByb2R1Y2UgY29sb3IgcmFtcHMgdGhhdCBsb29rIG1vcmUgY29uc2lzdGVudCBhbmQgcHJvZHVjZSBjb2xvcnMgdGhhdCBjYW4gYmUgZGlmZmVyZW50aWF0ZWQgbW9yZSBlYXNpbHkgdGhhbiB0aG9zZSBpbnRlcnBvbGF0ZWQgaW4gUkdCIHNwYWNlLlwiLFxuXHRcdFwiZGVmYXVsdFwiOiBcInJnYlwiXG5cdH0sXG5cdFwiZGVmYXVsdFwiOiB7XG5cdFx0dHlwZTogXCIqXCIsXG5cdFx0cmVxdWlyZWQ6IGZhbHNlLFxuXHRcdGRvYzogXCJBIHZhbHVlIHRvIHNlcnZlIGFzIGEgZmFsbGJhY2sgZnVuY3Rpb24gcmVzdWx0IHdoZW4gYSB2YWx1ZSBpc24ndCBvdGhlcndpc2UgYXZhaWxhYmxlLiBJdCBpcyB1c2VkIGluIHRoZSBmb2xsb3dpbmcgY2lyY3Vtc3RhbmNlczpcXG4qIEluIGNhdGVnb3JpY2FsIGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHN0b3AgZG9tYWluIHZhbHVlcy5cXG4qIEluIHByb3BlcnR5IGFuZCB6b29tLWFuZC1wcm9wZXJ0eSBmdW5jdGlvbnMsIHdoZW4gYSBmZWF0dXJlIGRvZXMgbm90IGNvbnRhaW4gYSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cXG4qIEluIGlkZW50aXR5IGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBzdHlsZSBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGlmIHRoZSBmdW5jdGlvbiBpcyBiZWluZyB1c2VkIGZvciBhIGBjaXJjbGUtY29sb3JgIHByb3BlcnR5IGJ1dCB0aGUgZmVhdHVyZSBwcm9wZXJ0eSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcgb3Igbm90IGEgdmFsaWQgY29sb3IpLlxcbiogSW4gaW50ZXJ2YWwgb3IgZXhwb25lbnRpYWwgcHJvcGVydHkgYW5kIHpvb20tYW5kLXByb3BlcnR5IGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBpcyBub3QgbnVtZXJpYy5cXG5JZiBubyBkZWZhdWx0IGlzIHByb3ZpZGVkLCB0aGUgc3R5bGUgcHJvcGVydHkncyBkZWZhdWx0IGlzIHVzZWQgaW4gdGhlc2UgY2lyY3Vtc3RhbmNlcy5cIlxuXHR9XG59LFxuXHRmdW5jdGlvbl9zdG9wOiBmdW5jdGlvbl9zdG9wLFxuXHRleHByZXNzaW9uOiBleHByZXNzaW9uLFxuXHRleHByZXNzaW9uX25hbWU6IGV4cHJlc3Npb25fbmFtZSxcblx0Zm9nOiBmb2csXG5cdGxpZ2h0OiBsaWdodCxcblx0cHJvamVjdGlvbjogcHJvamVjdGlvbixcblx0dGVycmFpbjogdGVycmFpbixcblx0cGFpbnQ6IHBhaW50LFxuXHRwYWludF9maWxsOiBwYWludF9maWxsLFxuXHRcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCI6IHtcblx0XCJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5XCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAxLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0bWF4aW11bTogMSxcblx0XHRkb2M6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGV4dHJ1c2lvbiBsYXllci4gVGhpcyBpcyByZW5kZXJlZCBvbiBhIHBlci1sYXllciwgbm90IHBlci1mZWF0dXJlLCBiYXNpcywgYW5kIGRhdGEtZHJpdmVuIHN0eWxpbmcgaXMgbm90IGF2YWlsYWJsZS5cIixcblx0XHR0cmFuc2l0aW9uOiB0cnVlLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLWNvbG9yXCI6IHtcblx0XHR0eXBlOiBcImNvbG9yXCIsXG5cdFx0XCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuXHRcdGRvYzogXCJUaGUgYmFzZSBjb2xvciBvZiB0aGUgZXh0cnVkZWQgZmlsbC4gVGhlIGV4dHJ1c2lvbidzIHN1cmZhY2VzIHdpbGwgYmUgc2hhZGVkIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoaXMgY29sb3IgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgcm9vdCBgbGlnaHRgIHNldHRpbmdzLiBJZiB0aGlzIGNvbG9yIGlzIHNwZWNpZmllZCBhcyBgcmdiYWAgd2l0aCBhbiBhbHBoYSBjb21wb25lbnQsIHRoZSBhbHBoYSBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkOyB1c2UgYGZpbGwtZXh0cnVzaW9uLW9wYWNpdHlgIHRvIHNldCBsYXllciBvcGFjaXR5LlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0XCIhXCI6IFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogdHJ1ZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCIsXG5cdFx0XHRcdFwiZmVhdHVyZVwiLFxuXHRcdFx0XHRcImZlYXR1cmUtc3RhdGVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiOiB7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdHZhbHVlOiBcIm51bWJlclwiLFxuXHRcdGxlbmd0aDogMixcblx0XHRcImRlZmF1bHRcIjogW1xuXHRcdFx0MCxcblx0XHRcdDBcblx0XHRdLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0dW5pdHM6IFwicGl4ZWxzXCIsXG5cdFx0ZG9jOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwIChvbiB0aGUgZmxhdCBwbGFuZSksIHJlc3BlY3RpdmVseS5cIixcblx0XHRcInNkay1zdXBwb3J0XCI6IHtcblx0XHRcdFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcblx0XHR0eXBlOiBcImVudW1cIixcblx0XHR2YWx1ZXM6IHtcblx0XHRcdG1hcDoge1xuXHRcdFx0XHRkb2M6IFwiVGhlIGZpbGwgZXh0cnVzaW9uIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuXHRcdFx0fSxcblx0XHRcdHZpZXdwb3J0OiB7XG5cdFx0XHRcdGRvYzogXCJUaGUgZmlsbCBleHRydXNpb24gaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC1leHRydXNpb24tdHJhbnNsYXRlYC5cIixcblx0XHRcImRlZmF1bHRcIjogXCJtYXBcIixcblx0XHRyZXF1aXJlczogW1xuXHRcdFx0XCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIlxuXHRcdF0sXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiBmYWxzZSxcblx0XHRcdHBhcmFtZXRlcnM6IFtcblx0XHRcdFx0XCJ6b29tXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIjoge1xuXHRcdHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0ZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZXMgb24gZXh0cnVkZWQgZmlsbHMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjQ5LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI2LjUuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjExLjBcIixcblx0XHRcdFx0aW9zOiBcIjQuNC4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIlxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuXHR9LFxuXHRcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiOiB7XG5cdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcImRlZmF1bHRcIjogMCxcblx0XHRtaW5pbXVtOiAwLFxuXHRcdHVuaXRzOiBcIm1ldGVyc1wiLFxuXHRcdGRvYzogXCJUaGUgaGVpZ2h0IHdpdGggd2hpY2ggdG8gZXh0cnVkZSB0aGlzIGxheWVyLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fSxcblx0XHRcdFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG5cdFx0XHRcdGpzOiBcIjAuMjcuMFwiLFxuXHRcdFx0XHRhbmRyb2lkOiBcIjUuMS4wXCIsXG5cdFx0XHRcdGlvczogXCIzLjYuMFwiLFxuXHRcdFx0XHRtYWNvczogXCIwLjUuMFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHByZXNzaW9uOiB7XG5cdFx0XHRpbnRlcnBvbGF0ZWQ6IHRydWUsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiLFxuXHRcdFx0XHRcImZlYXR1cmVcIixcblx0XHRcdFx0XCJmZWF0dXJlLXN0YXRlXCJcblx0XHRcdF1cblx0XHR9LFxuXHRcdFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcblx0fSxcblx0XCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IHtcblx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFwiZGVmYXVsdFwiOiAwLFxuXHRcdG1pbmltdW06IDAsXG5cdFx0dW5pdHM6IFwibWV0ZXJzXCIsXG5cdFx0ZG9jOiBcIlRoZSBoZWlnaHQgd2l0aCB3aGljaCB0byBleHRydWRlIHRoZSBiYXNlIG9mIHRoaXMgbGF5ZXIuIE11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBmaWxsLWV4dHJ1c2lvbi1oZWlnaHRgLlwiLFxuXHRcdHRyYW5zaXRpb246IHRydWUsXG5cdFx0cmVxdWlyZXM6IFtcblx0XHRcdFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCJcblx0XHRdLFxuXHRcdFwic2RrLXN1cHBvcnRcIjoge1xuXHRcdFx0XCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcblx0XHRcdFx0anM6IFwiMC4yNy4wXCIsXG5cdFx0XHRcdGFuZHJvaWQ6IFwiNS4xLjBcIixcblx0XHRcdFx0aW9zOiBcIjMuNi4wXCIsXG5cdFx0XHRcdG1hY29zOiBcIjAuNS4wXCJcblx0XHRcdH0sXG5cdFx0XHRcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuXHRcdFx0XHRqczogXCIwLjI3LjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI1LjEuMFwiLFxuXHRcdFx0XHRpb3M6IFwiMy42LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC41LjBcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwcmVzc2lvbjoge1xuXHRcdFx0aW50ZXJwb2xhdGVkOiB0cnVlLFxuXHRcdFx0cGFyYW1ldGVyczogW1xuXHRcdFx0XHRcInpvb21cIixcblx0XHRcdFx0XCJmZWF0dXJlXCIsXG5cdFx0XHRcdFwiZmVhdHVyZS1zdGF0ZVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG5cdH0sXG5cdFwiZmlsbC1leHRydXNpb24tdmVydGljYWwtZ3JhZGllbnRcIjoge1xuXHRcdHR5cGU6IFwiYm9vbGVhblwiLFxuXHRcdFwiZGVmYXVsdFwiOiB0cnVlLFxuXHRcdGRvYzogXCJXaGV0aGVyIHRvIGFwcGx5IGEgdmVydGljYWwgZ3JhZGllbnQgdG8gdGhlIHNpZGVzIG9mIGEgZmlsbC1leHRydXNpb24gbGF5ZXIuIElmIHRydWUsIHNpZGVzIHdpbGwgYmUgc2hhZGVkIHNsaWdodGx5IGRhcmtlciBmYXJ0aGVyIGRvd24uXCIsXG5cdFx0dHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0XCJzZGstc3VwcG9ydFwiOiB7XG5cdFx0XHRcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuXHRcdFx0XHRqczogXCIwLjUwLjBcIixcblx0XHRcdFx0YW5kcm9pZDogXCI3LjAuMFwiLFxuXHRcdFx0XHRpb3M6IFwiNC43LjBcIixcblx0XHRcdFx0bWFjb3M6IFwiMC4xMy4wXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV4cHJlc3Npb246IHtcblx0XHRcdGludGVycG9sYXRlZDogZmFsc2UsXG5cdFx0XHRwYXJhbWV0ZXJzOiBbXG5cdFx0XHRcdFwiem9vbVwiXG5cdFx0XHRdXG5cdFx0fSxcblx0XHRcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcblx0fVxufSxcblx0cGFpbnRfbGluZTogcGFpbnRfbGluZSxcblx0cGFpbnRfY2lyY2xlOiBwYWludF9jaXJjbGUsXG5cdHBhaW50X2hlYXRtYXA6IHBhaW50X2hlYXRtYXAsXG5cdHBhaW50X3N5bWJvbDogcGFpbnRfc3ltYm9sLFxuXHRwYWludF9yYXN0ZXI6IHBhaW50X3Jhc3Rlcixcblx0cGFpbnRfaGlsbHNoYWRlOiBwYWludF9oaWxsc2hhZGUsXG5cdHBhaW50X2JhY2tncm91bmQ6IHBhaW50X2JhY2tncm91bmQsXG5cdHBhaW50X3NreTogcGFpbnRfc2t5LFxuXHR0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuXHRcInByb3BlcnR5LXR5cGVcIjoge1xuXHRcImRhdGEtZHJpdmVuXCI6IHtcblx0XHR0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcblx0XHRkb2M6IFwiUHJvcGVydHkgaXMgaW50ZXJwb2xhYmxlIGFuZCBjYW4gYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLlwiXG5cdH0sXG5cdFwiY3Jvc3MtZmFkZWRcIjoge1xuXHRcdHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuXHRcdGRvYzogXCJQcm9wZXJ0eSBpcyBub24taW50ZXJwb2xhYmxlOyByYXRoZXIsIGl0cyB2YWx1ZXMgd2lsbCBiZSBjcm9zcy1mYWRlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gaW50ZWdlciB6b29tcy5cIlxuXHR9LFxuXHRcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCI6IHtcblx0XHR0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcblx0XHRkb2M6IFwiUHJvcGVydHkgaXMgbm9uLWludGVycG9sYWJsZTsgcmF0aGVyLCBpdHMgdmFsdWVzIHdpbGwgYmUgY3Jvc3MtZmFkZWQgdG8gc21vb3RobHkgdHJhbnNpdGlvbiBiZXR3ZWVuIGludGVnZXIgem9vbXMuIEl0IGNhbiBiZSByZXByZXNlbnRlZCB1c2luZyBhIHByb3BlcnR5IGV4cHJlc3Npb24uXCJcblx0fSxcblx0XCJjb2xvci1yYW1wXCI6IHtcblx0XHR0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcblx0XHRkb2M6IFwiUHJvcGVydHkgc2hvdWxkIGJlIHNwZWNpZmllZCB1c2luZyBhIGNvbG9yIHJhbXAgZnJvbSB3aGljaCB0aGUgb3V0cHV0IGNvbG9yIGNhbiBiZSBzYW1wbGVkIGJhc2VkIG9uIGEgcHJvcGVydHkgY2FsY3VsYXRpb24uXCJcblx0fSxcblx0XCJkYXRhLWNvbnN0YW50XCI6IHtcblx0XHR0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcblx0XHRkb2M6IFwiUHJvcGVydHkgaXMgaW50ZXJwb2xhYmxlIGJ1dCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLlwiXG5cdH0sXG5cdGNvbnN0YW50OiB7XG5cdFx0dHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG5cdFx0ZG9jOiBcIlByb3BlcnR5IGlzIGNvbnN0YW50IGFjcm9zcyBhbGwgem9vbSBsZXZlbHMgYW5kIHByb3BlcnR5IHZhbHVlcy5cIlxuXHR9XG59LFxuXHRwcm9tb3RlSWQ6IHByb21vdGVJZFxufTtcblxuLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG52YXIgc3RyaW5nT3JDaGFyID0gLyhcIig/OlteXFxcXFwiXXxcXFxcLikqXCIpfFs6LF0vZztcblxudmFyIGpzb25TdHJpbmdpZnlQcmV0dHlDb21wYWN0ID0gZnVuY3Rpb24gc3RyaW5naWZ5KHBhc3NlZE9iaiwgb3B0aW9ucykge1xuICB2YXIgaW5kZW50LCBtYXhMZW5ndGgsIHJlcGxhY2VyO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpbmRlbnQgPSBKU09OLnN0cmluZ2lmeShcbiAgICBbMV0sXG4gICAgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnMuaW5kZW50ID09PSB1bmRlZmluZWQgPyAyIDogb3B0aW9ucy5pbmRlbnRcbiAgKS5zbGljZSgyLCAtMyk7XG4gIG1heExlbmd0aCA9XG4gICAgaW5kZW50ID09PSBcIlwiXG4gICAgICA/IEluZmluaXR5XG4gICAgICA6IG9wdGlvbnMubWF4TGVuZ3RoID09PSB1bmRlZmluZWRcbiAgICAgID8gODBcbiAgICAgIDogb3B0aW9ucy5tYXhMZW5ndGg7XG4gIHJlcGxhY2VyID0gb3B0aW9ucy5yZXBsYWNlcjtcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkob2JqLCBjdXJyZW50SW5kZW50LCByZXNlcnZlZCkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHZhciBlbmQsIGluZGV4LCBpdGVtcywga2V5LCBrZXlQYXJ0LCBrZXlzLCBsZW5ndGgsIG5leHRJbmRlbnQsIHByZXR0aWZpZWQsIHN0YXJ0LCBzdHJpbmcsIHZhbHVlO1xuXG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuXG4gICAgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlcik7XG5cbiAgICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoIC0gY3VycmVudEluZGVudC5sZW5ndGggLSByZXNlcnZlZDtcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgcHJldHRpZmllZCA9IHN0cmluZy5yZXBsYWNlKHN0cmluZ09yQ2hhciwgZnVuY3Rpb24obWF0Y2gsIHN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ0xpdGVyYWwgfHwgbWF0Y2ggKyBcIiBcIjtcbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXR0aWZpZWQubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcHJldHRpZmllZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZXIgIT0gbnVsbCkge1xuICAgICAgb2JqID0gSlNPTi5wYXJzZShzdHJpbmcpO1xuICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICBuZXh0SW5kZW50ID0gY3VycmVudEluZGVudCArIGluZGVudDtcbiAgICAgIGl0ZW1zID0gW107XG4gICAgICBpbmRleCA9IDA7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgc3RhcnQgPSBcIltcIjtcbiAgICAgICAgZW5kID0gXCJdXCI7XG4gICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGl0ZW1zLnB1c2goXG4gICAgICAgICAgICBfc3RyaW5naWZ5KG9ialtpbmRleF0sIG5leHRJbmRlbnQsIGluZGV4ID09PSBsZW5ndGggLSAxID8gMCA6IDEpIHx8XG4gICAgICAgICAgICAgIFwibnVsbFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBcIntcIjtcbiAgICAgICAgZW5kID0gXCJ9XCI7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgICAga2V5UGFydCA9IEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjogXCI7XG4gICAgICAgICAgdmFsdWUgPSBfc3RyaW5naWZ5KFxuICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICBuZXh0SW5kZW50LFxuICAgICAgICAgICAga2V5UGFydC5sZW5ndGggKyAoaW5kZXggPT09IGxlbmd0aCAtIDEgPyAwIDogMSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGtleVBhcnQgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGluZGVudCArIGl0ZW1zLmpvaW4oXCIsXFxuXCIgKyBuZXh0SW5kZW50KSwgZW5kXS5qb2luKFxuICAgICAgICAgIFwiXFxuXCIgKyBjdXJyZW50SW5kZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfSkocGFzc2VkT2JqLCBcIlwiLCAwKTtcbn07XG5cbmZ1bmN0aW9uIHNvcnRLZXlzQnkob2JqLCByZWZlcmVuY2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JtYXQoc3R5bGUsIHNwYWNlID0gMikge1xuICAgIHN0eWxlID0gc29ydEtleXNCeShzdHlsZSwgdjguJHJvb3QpO1xuICAgIGlmIChzdHlsZS5sYXllcnMpIHtcbiAgICAgICAgc3R5bGUubGF5ZXJzID0gc3R5bGUubGF5ZXJzLm1hcChsYXllciA9PiBzb3J0S2V5c0J5KGxheWVyLCB2OC5sYXllcikpO1xuICAgIH1cbiAgICByZXR1cm4ganNvblN0cmluZ2lmeVByZXR0eUNvbXBhY3Qoc3R5bGUsIHsgaW5kZW50OiBzcGFjZSB9KTtcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuKSB7XG4gIHZhciBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH07XG5cdHJldHVybiBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAodGFyZ2V0KSB7XG5cdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgXCInICsgdGFyZ2V0ICsgJ1wiLiBQbGVhc2UgY29uZmlndXJlIHRoZSBkeW5hbWljUmVxdWlyZVRhcmdldHMgb3B0aW9uIG9mIEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgcmVxdWlyZSBjYWxsIHRvIGJlaGF2ZSBwcm9wZXJseS4nKTtcbn1cblxuLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cblxudmFyIHB1bnljb2RlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuKGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0oY29tbW9uanNHbG9iYWwpKTtcbn0pO1xuXG52YXIgdXRpbCA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxudmFyIGVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBxdWVyeXN0cmluZyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gZGVjb2RlO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGVuY29kZTtcbn0pO1xuXG52YXIgcGFyc2UgPSB1cmxQYXJzZTtcbnZhciByZXNvbHZlID0gdXJsUmVzb2x2ZTtcbnZhciByZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbnZhciBmb3JtYXQkMSA9IHVybEZvcm1hdDtcblxudmFyIFVybF8xID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxudmFyIHVybCA9IHtcblx0cGFyc2U6IHBhcnNlLFxuXHRyZXNvbHZlOiByZXNvbHZlLFxuXHRyZXNvbHZlT2JqZWN0OiByZXNvbHZlT2JqZWN0LFxuXHRmb3JtYXQ6IGZvcm1hdCQxLFxuXHRVcmw6IFVybF8xXG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eU5hbWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHY4LmxheW91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2OFt2OC5sYXlvdXRbaV1dKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY4W3Y4LmxheW91dFtpXV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHY4LnBhaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHY4W3Y4LnBhaW50W2ldXSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB2OFt2OC5wYWludFtpXV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVhY2hTb3VyY2Uoc3R5bGUsIGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBrIGluIHN0eWxlLnNvdXJjZXMpIHtcbiAgICAgICAgY2FsbGJhY2soc3R5bGUuc291cmNlc1trXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWFjaExheWVyKHN0eWxlLCBjYWxsYmFjaykge1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2Ygc3R5bGUubGF5ZXJzKSB7XG4gICAgICAgIGNhbGxiYWNrKGxheWVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlYWNoUHJvcGVydHkoc3R5bGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gaW5uZXIobGF5ZXIsIHByb3BlcnR5VHlwZSkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gbGF5ZXJbcHJvcGVydHlUeXBlXTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgICAgICBsYXllci5pZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlUeXBlLFxuICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcGVydGllc1trZXldLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogZ2V0UHJvcGVydHlSZWZlcmVuY2Uoa2V5KSxcbiAgICAgICAgICAgICAgICBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWFjaExheWVyKHN0eWxlLCBsYXllciA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhaW50KSB7XG4gICAgICAgICAgICBpbm5lcihsYXllciwgJ3BhaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubGF5b3V0KSB7XG4gICAgICAgICAgICBpbm5lcihsYXllciwgJ2xheW91dCcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2hMYXlvdXQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrLmluZGV4T2YoJ2xheW91dCcpID09PSAwKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhsYXllcltrXSwgayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBlYWNoUGFpbnQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrLmluZGV4T2YoJ3BhaW50JykgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyW2tdLCBrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDb25zdGFudChzdHlsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHN0eWxlLmNvbnN0YW50c1t2YWx1ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUuc3RvcHMpO1xufVxuZnVuY3Rpb24gcmVuYW1lUHJvcGVydHkob2JqLCBmcm9tLCB0bykge1xuICAgIG9ialt0b10gPSBvYmpbZnJvbV07XG4gICAgZGVsZXRlIG9ialtmcm9tXTtcbn1cbmZ1bmN0aW9uIG1pZ3JhdGVUb1Y4IChzdHlsZSkge1xuICAgIHN0eWxlLnZlcnNpb24gPSA4O1xuICAgIGVhY2hTb3VyY2Uoc3R5bGUsIHNvdXJjZSA9PiB7XG4gICAgICAgIGlmIChzb3VyY2UudHlwZSA9PT0gJ3ZpZGVvJyAmJiBzb3VyY2UudXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHNvdXJjZSwgJ3VybCcsICd1cmxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBzb3VyY2UuY29vcmRpbmF0ZXMuZm9yRWFjaChjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWFjaExheWVyKHN0eWxlLCBsYXllciA9PiB7XG4gICAgICAgIGVhY2hMYXlvdXQobGF5ZXIsIGxheW91dCA9PiB7XG4gICAgICAgICAgICBpZiAobGF5b3V0WydzeW1ib2wtbWluLWRpc3RhbmNlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KGxheW91dCwgJ3N5bWJvbC1taW4tZGlzdGFuY2UnLCAnc3ltYm9sLXNwYWNpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hQYWludChsYXllciwgcGFpbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLWltYWdlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnYmFja2dyb3VuZC1pbWFnZScsICdiYWNrZ3JvdW5kLXBhdHRlcm4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1pbWFnZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2xpbmUtaW1hZ2UnLCAnbGluZS1wYXR0ZXJuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFpbnRbJ2ZpbGwtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdmaWxsLWltYWdlJywgJ2ZpbGwtcGF0dGVybicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBlYWNoUHJvcGVydHkoc3R5bGUsIHtcbiAgICAgICAgcGFpbnQ6IHRydWUsXG4gICAgICAgIGxheW91dDogdHJ1ZVxuICAgIH0sIHByb3BlcnR5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHByb3BlcnR5LnZhbHVlKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5zdG9wcy5mb3JFYWNoKHN0b3AgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3BbMV0gPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHN0b3BbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydHkuc2V0KHZhbHVlKTtcbiAgICB9KTtcbiAgICBkZWxldGUgc3R5bGUuY29uc3RhbnRzO1xuICAgIGVhY2hMYXllcihzdHlsZSwgbGF5ZXIgPT4ge1xuICAgICAgICBlYWNoTGF5b3V0KGxheWVyLCBsYXlvdXQgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGxheW91dFsndGV4dC1tYXgtc2l6ZSddO1xuICAgICAgICAgICAgZGVsZXRlIGxheW91dFsnaWNvbi1tYXgtc2l6ZSddO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaFBhaW50KGxheWVyLCBwYWludCA9PiB7XG4gICAgICAgICAgICBpZiAocGFpbnRbJ3RleHQtc2l6ZSddKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5sYXlvdXQpXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmxheW91dCA9IHt9O1xuICAgICAgICAgICAgICAgIGxheWVyLmxheW91dFsndGV4dC1zaXplJ10gPSBwYWludFsndGV4dC1zaXplJ107XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhaW50Wyd0ZXh0LXNpemUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWludFsnaWNvbi1zaXplJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmxheW91dClcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0ID0ge307XG4gICAgICAgICAgICAgICAgbGF5ZXIubGF5b3V0WydpY29uLXNpemUnXSA9IHBhaW50WydpY29uLXNpemUnXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFpbnRbJ2ljb24tc2l6ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtaWdyYXRlRm9udHN0YWNrVVJMKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGlucHV0UGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgaW5wdXRQYXRobmFtZVBhcnRzID0gaW5wdXRQYXJzZWQucGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKGlucHV0UGFyc2VkLnByb3RvY29sICE9PSAnbWFwYm94OicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFBhcnNlZC5ob3N0bmFtZSA9PT0gJ2ZvbnRzdGFjaycpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFwYm94Oi8vZm9udHMvbWFwYm94L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmJztcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFBhcnNlZC5ob3N0bmFtZSA9PT0gJ2ZvbnRzJykge1xuICAgICAgICAgICAgcmV0dXJuIGBtYXBib3g6Ly9mb250cy8keyBpbnB1dFBhdGhuYW1lUGFydHNbMl0gfS97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZmA7XG4gICAgICAgIH0gZWxzZSA7XG4gICAgfVxuICAgIGlmIChzdHlsZS5nbHlwaHMpIHtcbiAgICAgICAgc3R5bGUuZ2x5cGhzID0gbWlncmF0ZUZvbnRzdGFja1VSTChzdHlsZS5nbHlwaHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaWdyYXRlRm9udFN0YWNrKGZvbnQpIHtcbiAgICAgICAgZnVuY3Rpb24gc3BsaXRBbmRUcmltKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnLCcpLm1hcChzID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy50cmltKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmb250KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRBbmRUcmltKGZvbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb250ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9udC5zdG9wcy5mb3JFYWNoKHN0b3AgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3BbMV0gPSBzcGxpdEFuZFRyaW0oc3RvcFsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb250O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGZvbnQgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlYWNoTGF5ZXIoc3R5bGUsIGxheWVyID0+IHtcbiAgICAgICAgZWFjaExheW91dChsYXllciwgbGF5b3V0ID0+IHtcbiAgICAgICAgICAgIGlmIChsYXlvdXRbJ3RleHQtZm9udCddKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Wyd0ZXh0LWZvbnQnXSA9IG1pZ3JhdGVGb250U3RhY2sobGF5b3V0Wyd0ZXh0LWZvbnQnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxldCBmaXJzdFN5bWJvbExheWVyID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3R5bGUubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gc3R5bGUubGF5ZXJzW2ldO1xuICAgICAgICBpZiAobGF5ZXIudHlwZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGZpcnN0U3ltYm9sTGF5ZXIgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbExheWVycyA9IHN0eWxlLmxheWVycy5zcGxpY2UoZmlyc3RTeW1ib2xMYXllcik7XG4gICAgc3ltYm9sTGF5ZXJzLnJldmVyc2UoKTtcbiAgICBzdHlsZS5sYXllcnMgPSBzdHlsZS5sYXllcnMuY29uY2F0KHN5bWJvbExheWVycyk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQgKG91dHB1dCwgLi4uaW5wdXRzKSB7XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIGlucHV0KSB7XG4gICAgICAgICAgICBvdXRwdXRba10gPSBpbnB1dFtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5jbGFzcyBQYXJzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG59XG5cbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJpbmRpbmdzID0gW10pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZXhwcmVzc2lvbl0gb2YgYmluZGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbbmFtZV0gPSBleHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbmNhdChiaW5kaW5ncykge1xuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMsIGJpbmRpbmdzKTtcbiAgICB9XG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IG5hbWUgfSBub3QgZm91bmQgaW4gc2NvcGUuYCk7XG4gICAgfVxuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW25hbWVdKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmhhcyhuYW1lKSA6IGZhbHNlO1xuICAgIH1cbn1cblxuY29uc3QgTnVsbFR5cGUgPSB7IGtpbmQ6ICdudWxsJyB9O1xuY29uc3QgTnVtYmVyVHlwZSA9IHsga2luZDogJ251bWJlcicgfTtcbmNvbnN0IFN0cmluZ1R5cGUgPSB7IGtpbmQ6ICdzdHJpbmcnIH07XG5jb25zdCBCb29sZWFuVHlwZSA9IHsga2luZDogJ2Jvb2xlYW4nIH07XG5jb25zdCBDb2xvclR5cGUgPSB7IGtpbmQ6ICdjb2xvcicgfTtcbmNvbnN0IE9iamVjdFR5cGUgPSB7IGtpbmQ6ICdvYmplY3QnIH07XG5jb25zdCBWYWx1ZVR5cGUgPSB7IGtpbmQ6ICd2YWx1ZScgfTtcbmNvbnN0IEVycm9yVHlwZSA9IHsga2luZDogJ2Vycm9yJyB9O1xuY29uc3QgQ29sbGF0b3JUeXBlID0geyBraW5kOiAnY29sbGF0b3InIH07XG5jb25zdCBGb3JtYXR0ZWRUeXBlID0geyBraW5kOiAnZm9ybWF0dGVkJyB9O1xuY29uc3QgUmVzb2x2ZWRJbWFnZVR5cGUgPSB7IGtpbmQ6ICdyZXNvbHZlZEltYWdlJyB9O1xuZnVuY3Rpb24gYXJyYXkoaXRlbVR5cGUsIE4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiAnYXJyYXknLFxuICAgICAgICBpdGVtVHlwZSxcbiAgICAgICAgTlxuICAgIH07XG59XG5mdW5jdGlvbiB0b1N0cmluZyh0eXBlKSB7XG4gICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHRvU3RyaW5nKHR5cGUuaXRlbVR5cGUpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUuTiA9PT0gJ251bWJlcicgPyBgYXJyYXk8JHsgaXRlbVR5cGUgfSwgJHsgdHlwZS5OIH0+YCA6IHR5cGUuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyA/ICdhcnJheScgOiBgYXJyYXk8JHsgaXRlbVR5cGUgfT5gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlLmtpbmQ7XG4gICAgfVxufVxuY29uc3QgdmFsdWVNZW1iZXJUeXBlcyA9IFtcbiAgICBOdWxsVHlwZSxcbiAgICBOdW1iZXJUeXBlLFxuICAgIFN0cmluZ1R5cGUsXG4gICAgQm9vbGVhblR5cGUsXG4gICAgQ29sb3JUeXBlLFxuICAgIEZvcm1hdHRlZFR5cGUsXG4gICAgT2JqZWN0VHlwZSxcbiAgICBhcnJheShWYWx1ZVR5cGUpLFxuICAgIFJlc29sdmVkSW1hZ2VUeXBlXG5dO1xuZnVuY3Rpb24gY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCB0KSB7XG4gICAgaWYgKHQua2luZCA9PT0gJ2Vycm9yJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICAgICAgaWYgKHQua2luZCA9PT0gJ2FycmF5JyAmJiAodC5OID09PSAwICYmIHQuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCAhY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLml0ZW1UeXBlLCB0Lml0ZW1UeXBlKSkgJiYgKHR5cGVvZiBleHBlY3RlZC5OICE9PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5OID09PSB0Lk4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQua2luZCA9PT0gdC5raW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlclR5cGUgb2YgdmFsdWVNZW1iZXJUeXBlcykge1xuICAgICAgICAgICAgaWYgKCFjaGVja1N1YnR5cGUobWVtYmVyVHlwZSwgdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYEV4cGVjdGVkICR7IHRvU3RyaW5nKGV4cGVjdGVkKSB9IGJ1dCBmb3VuZCAkeyB0b1N0cmluZyh0KSB9IGluc3RlYWQuYDtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHtcbiAgICByZXR1cm4gYWxsb3dlZFR5cGVzLnNvbWUodCA9PiB0LmtpbmQgPT09IHByb3ZpZGVkLmtpbmQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZE5hdGl2ZVR5cGUocHJvdmlkZWQsIGFsbG93ZWRUeXBlcykge1xuICAgIHJldHVybiBhbGxvd2VkVHlwZXMuc29tZSh0ID0+IHtcbiAgICAgICAgaWYgKHQgPT09ICdudWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkID09PSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ZpZGVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVkICYmICFBcnJheS5pc0FycmF5KHByb3ZpZGVkKSAmJiB0eXBlb2YgcHJvdmlkZWQgPT09ICdvYmplY3QnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHQgPT09IHR5cGVvZiBwcm92aWRlZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG52YXIgY3NzY29sb3JwYXJzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICBcInRyYW5zcGFyZW50XCI6IFswLDAsMCwwXSwgXCJhbGljZWJsdWVcIjogWzI0MCwyNDgsMjU1LDFdLFxuICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLDIzNSwyMTUsMV0sIFwiYXF1YVwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyLDFdLCBcImF6dXJlXCI6IFsyNDAsMjU1LDI1NSwxXSxcbiAgXCJiZWlnZVwiOiBbMjQ1LDI0NSwyMjAsMV0sIFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5NiwxXSxcbiAgXCJibGFja1wiOiBbMCwwLDAsMV0sIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwyMzUsMjA1LDFdLFxuICBcImJsdWVcIjogWzAsMCwyNTUsMV0sIFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNiwxXSxcbiAgXCJicm93blwiOiBbMTY1LDQyLDQyLDFdLCBcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzUsMV0sXG4gIFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwLDFdLCBcImNoYXJ0cmV1c2VcIjogWzEyNywyNTUsMCwxXSxcbiAgXCJjaG9jb2xhdGVcIjogWzIxMCwxMDUsMzAsMV0sIFwiY29yYWxcIjogWzI1NSwxMjcsODAsMV0sXG4gIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwxNDksMjM3LDFdLCBcImNvcm5zaWxrXCI6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgXCJjcmltc29uXCI6IFsyMjAsMjAsNjAsMV0sIFwiY3lhblwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImRhcmtibHVlXCI6IFswLDAsMTM5LDFdLCBcImRhcmtjeWFuXCI6IFswLDEzOSwxMzksMV0sXG4gIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMSwxXSwgXCJkYXJrZ3JheVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2dyZWVuXCI6IFswLDEwMCwwLDFdLCBcImRhcmtncmV5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3LDFdLCBcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzksMV0sXG4gIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LDEwNyw0NywxXSwgXCJkYXJrb3JhbmdlXCI6IFsyNTUsMTQwLDAsMV0sXG4gIFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNCwxXSwgXCJkYXJrcmVkXCI6IFsxMzksMCwwLDFdLFxuICBcImRhcmtzYWxtb25cIjogWzIzMywxNTAsMTIyLDFdLCBcImRhcmtzZWFncmVlblwiOiBbMTQzLDE4OCwxNDMsMV0sXG4gIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5LDFdLCBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LDc5LDc5LDFdLFxuICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LDc5LDc5LDFdLCBcImRhcmt0dXJxdW9pc2VcIjogWzAsMjA2LDIwOSwxXSxcbiAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsMCwyMTEsMV0sIFwiZGVlcHBpbmtcIjogWzI1NSwyMCwxNDcsMV0sXG4gIFwiZGVlcHNreWJsdWVcIjogWzAsMTkxLDI1NSwxXSwgXCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNSwxXSxcbiAgXCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNSwxXSwgXCJkb2RnZXJibHVlXCI6IFszMCwxNDQsMjU1LDFdLFxuICBcImZpcmVicmlja1wiOiBbMTc4LDM0LDM0LDFdLCBcImZsb3JhbHdoaXRlXCI6IFsyNTUsMjUwLDI0MCwxXSxcbiAgXCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0LDFdLCBcImZ1Y2hzaWFcIjogWzI1NSwwLDI1NSwxXSxcbiAgXCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwLDFdLCBcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1LDFdLFxuICBcImdvbGRcIjogWzI1NSwyMTUsMCwxXSwgXCJnb2xkZW5yb2RcIjogWzIxOCwxNjUsMzIsMV0sXG4gIFwiZ3JheVwiOiBbMTI4LDEyOCwxMjgsMV0sIFwiZ3JlZW5cIjogWzAsMTI4LDAsMV0sXG4gIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywyNTUsNDcsMV0sIFwiZ3JleVwiOiBbMTI4LDEyOCwxMjgsMV0sXG4gIFwiaG9uZXlkZXdcIjogWzI0MCwyNTUsMjQwLDFdLCBcImhvdHBpbmtcIjogWzI1NSwxMDUsMTgwLDFdLFxuICBcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyLDFdLCBcImluZGlnb1wiOiBbNzUsMCwxMzAsMV0sXG4gIFwiaXZvcnlcIjogWzI1NSwyNTUsMjQwLDFdLCBcImtoYWtpXCI6IFsyNDAsMjMwLDE0MCwxXSxcbiAgXCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTAsMV0sIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LDI0MCwyNDUsMV0sXG4gIFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDAsMV0sIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsMjUwLDIwNSwxXSxcbiAgXCJsaWdodGJsdWVcIjogWzE3MywyMTYsMjMwLDFdLCBcImxpZ2h0Y29yYWxcIjogWzI0MCwxMjgsMTI4LDFdLFxuICBcImxpZ2h0Y3lhblwiOiBbMjI0LDI1NSwyNTUsMV0sIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwLDFdLFxuICBcImxpZ2h0Z3JheVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRncmVlblwiOiBbMTQ0LDIzOCwxNDQsMV0sXG4gIFwibGlnaHRncmV5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzLDFdLFxuICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMiwxXSwgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwxNzgsMTcwLDFdLFxuICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTAsMV0sIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwxMzYsMTUzLDFdLFxuICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksMTM2LDE1MywxXSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjIsMV0sXG4gIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwyNTUsMjI0LDFdLCBcImxpbWVcIjogWzAsMjU1LDAsMV0sXG4gIFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTAsMV0sIFwibGluZW5cIjogWzI1MCwyNDAsMjMwLDFdLFxuICBcIm1hZ2VudGFcIjogWzI1NSwwLDI1NSwxXSwgXCJtYXJvb25cIjogWzEyOCwwLDAsMV0sXG4gIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLDIwNSwxNzAsMV0sIFwibWVkaXVtYmx1ZVwiOiBbMCwwLDIwNSwxXSxcbiAgXCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTEsMV0sIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsMTEyLDIxOSwxXSxcbiAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsMTc5LDExMywxXSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywxMDQsMjM4LDFdLFxuICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTQsMV0sIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwyMDksMjA0LDFdLFxuICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LDIxLDEzMywxXSwgXCJtaWRuaWdodGJsdWVcIjogWzI1LDI1LDExMiwxXSxcbiAgXCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwLDFdLCBcIm1pc3R5cm9zZVwiOiBbMjU1LDIyOCwyMjUsMV0sXG4gIFwibW9jY2FzaW5cIjogWzI1NSwyMjgsMTgxLDFdLCBcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3MywxXSxcbiAgXCJuYXZ5XCI6IFswLDAsMTI4LDFdLCBcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwLDFdLFxuICBcIm9saXZlXCI6IFsxMjgsMTI4LDAsMV0sIFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1LDFdLFxuICBcIm9yYW5nZVwiOiBbMjU1LDE2NSwwLDFdLCBcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDAsMV0sXG4gIFwib3JjaGlkXCI6IFsyMTgsMTEyLDIxNCwxXSwgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MCwxXSxcbiAgXCJwYWxlZ3JlZW5cIjogWzE1MiwyNTEsMTUyLDFdLCBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwyMzgsMjM4LDFdLFxuICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwxMTIsMTQ3LDFdLCBcInBhcGF5YXdoaXBcIjogWzI1NSwyMzksMjEzLDFdLFxuICBcInBlYWNocHVmZlwiOiBbMjU1LDIxOCwxODUsMV0sIFwicGVydVwiOiBbMjA1LDEzMyw2MywxXSxcbiAgXCJwaW5rXCI6IFsyNTUsMTkyLDIwMywxXSwgXCJwbHVtXCI6IFsyMjEsMTYwLDIyMSwxXSxcbiAgXCJwb3dkZXJibHVlXCI6IFsxNzYsMjI0LDIzMCwxXSwgXCJwdXJwbGVcIjogWzEyOCwwLDEyOCwxXSxcbiAgXCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsNTEsMTUzLDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX07XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUludChzdHIpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkgaCArPSAxO1xuICBlbHNlIGlmIChoID4gMSkgaCAtPSAxO1xuXG4gIGlmIChoICogNiA8IDEpIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICBpZiAoaCAqIDIgPCAxKSByZXR1cm4gbTI7XG4gIGlmIChoICogMyA8IDIpIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDU1NDb2xvcihjc3Nfc3RyKSB7XG4gIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICB2YXIgc3RyID0gY3NzX3N0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cblxuICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgIDFdO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCsxLCBlcC0ob3ArMSkpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gW3BhcnNlX2Nzc19pbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KHBhcmFtc1swXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzJdKTtcbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gICAgICAgIHJldHVybiBbY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKzEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaC0xLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudHJ5IHsgZXhwb3J0cy5wYXJzZUNTU0NvbG9yID0gcGFyc2VDU1NDb2xvcjsgfSBjYXRjaChlKSB7IH1cbn0pO1xuXG5jbGFzcyBDb2xvciB7XG4gICAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZ2JhID0gY3NzY29sb3JwYXJzZXIucGFyc2VDU1NDb2xvcihpbnB1dCk7XG4gICAgICAgIGlmICghcmdiYSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJnYmFbMF0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzFdIC8gMjU1ICogcmdiYVszXSwgcmdiYVsyXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbM10pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBgcmdiYSgkeyBNYXRoLnJvdW5kKHIpIH0sJHsgTWF0aC5yb3VuZChnKSB9LCR7IE1hdGgucm91bmQoYikgfSwkeyBhIH0pYDtcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3Qge3IsIGcsIGIsIGF9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGEgPT09IDAgPyBbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXG4gICAgICAgIF0gOiBbXG4gICAgICAgICAgICByICogMjU1IC8gYSxcbiAgICAgICAgICAgIGcgKiAyNTUgLyBhLFxuICAgICAgICAgICAgYiAqIDI1NSAvIGEsXG4gICAgICAgICAgICBhXG4gICAgICAgIF07XG4gICAgfVxufVxuQ29sb3IuYmxhY2sgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XG5Db2xvci53aGl0ZSA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKTtcbkNvbG9yLnRyYW5zcGFyZW50ID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuQ29sb3IucmVkID0gbmV3IENvbG9yKDEsIDAsIDAsIDEpO1xuQ29sb3IuYmx1ZSA9IG5ldyBDb2xvcigwLCAwLCAxLCAxKTtcblxuY2xhc3MgQ29sbGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhc2VTZW5zaXRpdmUsIGRpYWNyaXRpY1NlbnNpdGl2ZSwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChjYXNlU2Vuc2l0aXZlKVxuICAgICAgICAgICAgdGhpcy5zZW5zaXRpdml0eSA9IGRpYWNyaXRpY1NlbnNpdGl2ZSA/ICd2YXJpYW50JyA6ICdjYXNlJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zZW5zaXRpdml0eSA9IGRpYWNyaXRpY1NlbnNpdGl2ZSA/ICdhY2NlbnQnIDogJ2Jhc2UnO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgdGhpcy5jb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSwge1xuICAgICAgICAgICAgc2Vuc2l0aXZpdHk6IHRoaXMuc2Vuc2l0aXZpdHksXG4gICAgICAgICAgICB1c2FnZTogJ3NlYXJjaCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBhcmUobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGF0b3IuY29tcGFyZShsaHMsIHJocyk7XG4gICAgfVxuICAgIHJlc29sdmVkTG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgfVxufVxuXG5jbGFzcyBGb3JtYXR0ZWRTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBpbWFnZSwgc2NhbGUsIGZvbnRTdGFjaywgdGV4dENvbG9yKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLmZvbnRTdGFjayA9IGZvbnRTdGFjaztcbiAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSB0ZXh0Q29sb3I7XG4gICAgfVxufVxuY2xhc3MgRm9ybWF0dGVkIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHVuZm9ybWF0dGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKFtuZXcgRm9ybWF0dGVkU2VjdGlvbih1bmZvcm1hdHRlZCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCldKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAhdGhpcy5zZWN0aW9ucy5zb21lKHNlY3Rpb24gPT4gc2VjdGlvbi50ZXh0Lmxlbmd0aCAhPT0gMCB8fCBzZWN0aW9uLmltYWdlICYmIHNlY3Rpb24uaW1hZ2UubmFtZS5sZW5ndGggIT09IDApO1xuICAgIH1cbiAgICBzdGF0aWMgZmFjdG9yeSh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0IGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWN0aW9ucy5tYXAoc2VjdGlvbiA9PiBzZWN0aW9uLnRleHQpLmpvaW4oJycpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuICAgICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5zZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24uaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmltYWdlLm5hbWVcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChzZWN0aW9uLnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24uZm9udFN0YWNrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBbXG4gICAgICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5mb250U3RhY2suc3BsaXQoJywnKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBbJ3JnYmEnXS5jb25jYXQoc2VjdGlvbi50ZXh0Q29sb3IudG9BcnJheSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG59XG5cbmNsYXNzIFJlc29sdmVkSW1hZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZSA9IG9wdGlvbnMuYXZhaWxhYmxlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcobmFtZSkge1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZEltYWdlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdmFpbGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgdGhpcy5uYW1lXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJHQkEociwgZywgYiwgYSkge1xuICAgIGlmICghKHR5cGVvZiByID09PSAnbnVtYmVyJyAmJiByID49IDAgJiYgciA8PSAyNTUgJiYgdHlwZW9mIGcgPT09ICdudW1iZXInICYmIGcgPj0gMCAmJiBnIDw9IDI1NSAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicgJiYgYiA+PSAwICYmIGIgPD0gMjU1KSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGFcbiAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgYlxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYEludmFsaWQgcmdiYSB2YWx1ZSBbJHsgdmFsdWUuam9pbignLCAnKSB9XTogJ3InLCAnZycsIGFuZCAnYicgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS5gO1xuICAgIH1cbiAgICBpZiAoISh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIGEgPj0gMCAmJiBhIDw9IDEpKSB7XG4gICAgICAgIHJldHVybiBgSW52YWxpZCByZ2JhIHZhbHVlIFskeyBbXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBhXG4gICAgICAgIF0uam9pbignLCAnKSB9XTogJ2EnIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLmA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNWYWx1ZShtaXhlZCkge1xuICAgIGlmIChtaXhlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBDb2xsYXRvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXhlZCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG1peGVkKSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsdWUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1peGVkKSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsdWUobWl4ZWRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHR5cGVPZih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTnVsbFR5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmdUeXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW5UeXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gTnVtYmVyVHlwZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yVHlwZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sbGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIENvbGxhdG9yVHlwZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZWRUeXBlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlKSB7XG4gICAgICAgIHJldHVybiBSZXNvbHZlZEltYWdlVHlwZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1UeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0eXBlT2YoaXRlbSk7XG4gICAgICAgICAgICBpZiAoIWl0ZW1UeXBlKSB7XG4gICAgICAgICAgICAgICAgaXRlbVR5cGUgPSB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtVHlwZSA9PT0gdCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZSA9IFZhbHVlVHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXkoaXRlbVR5cGUgfHwgVmFsdWVUeXBlLCBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPYmplY3RUeXBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU3RyaW5nJDEodmFsdWUpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yIHx8IHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbn1cblxuY2xhc3MgTGl0ZXJhbCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgJ2xpdGVyYWwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCAkeyBhcmdzLmxlbmd0aCAtIDEgfSBpbnN0ZWFkLmApO1xuICAgICAgICBpZiAoIWlzVmFsdWUoYXJnc1sxXSkpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgaW52YWxpZCB2YWx1ZWApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMV07XG4gICAgICAgIGxldCB0eXBlID0gdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICAgICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5JyAmJiB0eXBlLk4gPT09IDAgJiYgZXhwZWN0ZWQgJiYgZXhwZWN0ZWQua2luZCA9PT0gJ2FycmF5JyAmJiAodHlwZW9mIGV4cGVjdGVkLk4gIT09ICdudW1iZXInIHx8IGV4cGVjdGVkLk4gPT09IDApKSB7XG4gICAgICAgICAgICB0eXBlID0gZXhwZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoKSB7XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2FycmF5JyB8fCB0aGlzLnR5cGUua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2xpdGVyYWwnLFxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gWydyZ2JhJ10uY29uY2F0KHRoaXMudmFsdWUudG9BcnJheSgpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5zZXJpYWxpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBSdW50aW1lRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0V4cHJlc3Npb25FdmFsdWF0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxufVxuXG5jb25zdCB0eXBlcyA9IHtcbiAgICBzdHJpbmc6IFN0cmluZ1R5cGUsXG4gICAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICAgIGJvb2xlYW46IEJvb2xlYW5UeXBlLFxuICAgIG9iamVjdDogT2JqZWN0VHlwZVxufTtcbmNsYXNzIEFzc2VydGlvbiB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYXJncykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5gKTtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChuYW1lID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBsZXQgaXRlbVR5cGU7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhKHR5cGUgaW4gdHlwZXMpIHx8IHR5cGUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignVGhlIGl0ZW0gdHlwZSBhcmd1bWVudCBvZiBcImFycmF5XCIgbXVzdCBiZSBvbmUgb2Ygc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4nLCAxKTtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZSA9IHR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbVR5cGUgPSBWYWx1ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgTjtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1syXSAhPT0gbnVsbCAmJiAodHlwZW9mIGFyZ3NbMl0gIT09ICdudW1iZXInIHx8IGFyZ3NbMl0gPCAwIHx8IGFyZ3NbMl0gIT09IE1hdGguZmxvb3IoYXJnc1syXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdUaGUgbGVuZ3RoIGFyZ3VtZW50IHRvIFwiYXJyYXlcIiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsaXRlcmFsJywgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE4gPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSBhcnJheShpdGVtVHlwZSwgTik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcGFyc2VkLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHR5cGUsIHBhcnNlZCk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmFyZ3NbaV0uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tTdWJ0eXBlKHRoaXMudHlwZSwgdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoYEV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJHsgdG9TdHJpbmcodGhpcy50eXBlKSB9LCBidXQgZm91bmQgJHsgdG9TdHJpbmcodHlwZU9mKHZhbHVlKSkgfSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGFyZyA9PiBhcmcub3V0cHV0RGVmaW5lZCgpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gW3R5cGUua2luZF07XG4gICAgICAgIGlmICh0eXBlLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gdHlwZS5pdGVtVHlwZTtcbiAgICAgICAgICAgIGlmIChpdGVtVHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCBpdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCBpdGVtVHlwZS5raW5kID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goaXRlbVR5cGUua2luZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgTiA9IHR5cGUuTjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIE4gPT09ICdudW1iZXInIHx8IHRoaXMuYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChOKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQuY29uY2F0KHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy5zZXJpYWxpemUoKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgRm9ybWF0RXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Ioc2VjdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gRm9ybWF0dGVkVHlwZTtcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0QXJnID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpcnN0QXJnKSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBpbWFnZSBvciB0ZXh0IHNlY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGFyZ3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgaWYgKG5leHRUb2tlbk1heUJlT2JqZWN0ICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICBuZXh0VG9rZW5NYXlCZU9iamVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ1snZm9udC1zY2FsZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlID0gY29udGV4dC5wYXJzZShhcmdbJ2ZvbnQtc2NhbGUnXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZvbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChhcmdbJ3RleHQtZm9udCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1mb250J10sIDEsIGFycmF5KFN0cmluZ1R5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb250KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0ZXh0Q29sb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChhcmdbJ3RleHQtY29sb3InXSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3IgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1jb2xvciddLCAxLCBDb2xvclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHRDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0RXhwcmVzc2lvbiA9IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxhc3RFeHByZXNzaW9uLnNjYWxlID0gc2NhbGU7XG4gICAgICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24uZm9udCA9IGZvbnQ7XG4gICAgICAgICAgICAgICAgbGFzdEV4cHJlc3Npb24udGV4dENvbG9yID0gdGV4dENvbG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IGNvbnRlbnQudHlwZS5raW5kO1xuICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnc3RyaW5nJyAmJiBraW5kICE9PSAndmFsdWUnICYmIGtpbmQgIT09ICdudWxsJyAmJiBraW5kICE9PSAncmVzb2x2ZWRJbWFnZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBGb3JtYXR0ZWQgdGV4dCB0eXBlIG11c3QgYmUgJ3N0cmluZycsICd2YWx1ZScsICdpbWFnZScgb3IgJ251bGwnLmApO1xuICAgICAgICAgICAgICAgIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhwcmVzc2lvbihzZWN0aW9ucyk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICBjb25zdCBldmFsdWF0ZVNlY3Rpb24gPSBzZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRlZENvbnRlbnQgPSBzZWN0aW9uLmNvbnRlbnQuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIGlmICh0eXBlT2YoZXZhbHVhdGVkQ29udGVudCkgPT09IFJlc29sdmVkSW1hZ2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWRTZWN0aW9uKCcnLCBldmFsdWF0ZWRDb250ZW50LCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkU2VjdGlvbih0b1N0cmluZyQxKGV2YWx1YXRlZENvbnRlbnQpLCBudWxsLCBzZWN0aW9uLnNjYWxlID8gc2VjdGlvbi5zY2FsZS5ldmFsdWF0ZShjdHgpIDogbnVsbCwgc2VjdGlvbi5mb250ID8gc2VjdGlvbi5mb250LmV2YWx1YXRlKGN0eCkuam9pbignLCcpIDogbnVsbCwgc2VjdGlvbi50ZXh0Q29sb3IgPyBzZWN0aW9uLnRleHRDb2xvci5ldmFsdWF0ZShjdHgpIDogbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKHRoaXMuc2VjdGlvbnMubWFwKGV2YWx1YXRlU2VjdGlvbikpO1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHRoaXMuc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIGZuKHNlY3Rpb24uY29udGVudCk7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgICAgIGZuKHNlY3Rpb24uc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlY3Rpb24uZm9udCkge1xuICAgICAgICAgICAgICAgIGZuKHNlY3Rpb24uZm9udCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICBmbihzZWN0aW9uLnRleHRDb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuICAgICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5zZWN0aW9ucykge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHNlY3Rpb24uY29udGVudC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5mb250KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBzZWN0aW9uLmZvbnQuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBzZWN0aW9uLnRleHRDb2xvci5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG59XG5cbmNsYXNzIEltYWdlRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gUmVzb2x2ZWRJbWFnZVR5cGU7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cy5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBTdHJpbmdUeXBlKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYE5vIGltYWdlIG5hbWUgcHJvdmlkZWQuYCk7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VFeHByZXNzaW9uKG5hbWUpO1xuICAgIH1cbiAgICBldmFsdWF0ZShjdHgpIHtcbiAgICAgICAgY29uc3QgZXZhbHVhdGVkSW1hZ2VOYW1lID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFJlc29sdmVkSW1hZ2UuZnJvbVN0cmluZyhldmFsdWF0ZWRJbWFnZU5hbWUpO1xuICAgICAgICBpZiAodmFsdWUgJiYgY3R4LmF2YWlsYWJsZUltYWdlcylcbiAgICAgICAgICAgIHZhbHVlLmF2YWlsYWJsZSA9IGN0eC5hdmFpbGFibGVJbWFnZXMuaW5kZXhPZihldmFsdWF0ZWRJbWFnZU5hbWUpID4gLTE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWFjaENoaWxkKGZuKSB7XG4gICAgICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5jb25zdCB0eXBlcyQxID0ge1xuICAgICd0by1ib29sZWFuJzogQm9vbGVhblR5cGUsXG4gICAgJ3RvLWNvbG9yJzogQ29sb3JUeXBlLFxuICAgICd0by1udW1iZXInOiBOdW1iZXJUeXBlLFxuICAgICd0by1zdHJpbmcnOiBTdHJpbmdUeXBlXG59O1xuY2xhc3MgQ29lcmNpb24ge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuYCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoKG5hbWUgPT09ICd0by1ib29sZWFuJyB8fCBuYW1lID09PSAndG8tc3RyaW5nJykgJiYgYXJncy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgb25lIGFyZ3VtZW50LmApO1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXMkMVtuYW1lXTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcGFyc2VkLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgcGFyc2VkKTtcbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dDtcbiAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGN0eC5wYXJzZUNvbG9yKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPCAzIHx8IGlucHV0Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gYEludmFsaWQgcmJnYSB2YWx1ZSAkeyBKU09OLnN0cmluZ2lmeShpbnB1dCkgfTogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy5gO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB2YWxpZGF0ZVJHQkEoaW5wdXRbMF0sIGlucHV0WzFdLCBpbnB1dFsyXSwgaW5wdXRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoaW5wdXRbMF0gLyAyNTUsIGlucHV0WzFdIC8gMjU1LCBpbnB1dFsyXSAvIDI1NSwgaW5wdXRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihlcnJvciB8fCBgQ291bGQgbm90IHBhcnNlIGNvbG9yIGZyb20gdmFsdWUgJyR7IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IFN0cmluZyhKU09OLnN0cmluZ2lmeShpbnB1dCkpIH0nYCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgdGhpcy5hcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGBDb3VsZCBub3QgY29udmVydCAkeyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgfSB0byBudW1iZXIuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdmb3JtYXR0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVkLmZyb21TdHJpbmcodG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5raW5kID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcodG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nJDEodGhpcy5hcmdzWzBdLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoYXJnID0+IGFyZy5vdXRwdXREZWZpbmVkKCkpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhwcmVzc2lvbihbe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgICAgICAgICAgICB9XSkuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VFeHByZXNzaW9uKHRoaXMuYXJnc1swXSkuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFtgdG8tJHsgdGhpcy50eXBlLmtpbmQgfWBdO1xuICAgICAgICB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuXG5jb25zdCBnZW9tZXRyeVR5cGVzID0gW1xuICAgICdVbmtub3duJyxcbiAgICAnUG9pbnQnLFxuICAgICdMaW5lU3RyaW5nJyxcbiAgICAnUG9seWdvbidcbl07XG5jbGFzcyBFdmFsdWF0aW9uQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IG51bGw7XG4gICAgICAgIHRoaXMuZmVhdHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmVhdHVyZVN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRTZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyc2VDb2xvckNhY2hlID0ge307XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlSW1hZ2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW5vbmljYWwgPSBudWxsO1xuICAgICAgICB0aGlzLmZlYXR1cmVUaWxlQ29vcmQgPSBudWxsO1xuICAgICAgICB0aGlzLmZlYXR1cmVEaXN0YW5jZURhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiAnaWQnIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5pZCA6IG51bGw7XG4gICAgfVxuICAgIGdlb21ldHJ5VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSA/IHR5cGVvZiB0aGlzLmZlYXR1cmUudHlwZSA9PT0gJ251bWJlcicgPyBnZW9tZXRyeVR5cGVzW3RoaXMuZmVhdHVyZS50eXBlXSA6IHRoaXMuZmVhdHVyZS50eXBlIDogbnVsbDtcbiAgICB9XG4gICAgZ2VvbWV0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgJ2dlb21ldHJ5JyBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgOiBudWxsO1xuICAgIH1cbiAgICBjYW5vbmljYWxJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsO1xuICAgIH1cbiAgICBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIH1cbiAgICBkaXN0YW5jZUZyb21DZW50ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVUaWxlQ29vcmQgJiYgdGhpcy5mZWF0dXJlRGlzdGFuY2VEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5mZWF0dXJlRGlzdGFuY2VEYXRhLmNlbnRlcjtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5mZWF0dXJlRGlzdGFuY2VEYXRhLnNjYWxlO1xuICAgICAgICAgICAgY29uc3Qge3gsIHl9ID0gdGhpcy5mZWF0dXJlVGlsZUNvb3JkO1xuICAgICAgICAgICAgY29uc3QgZFggPSB4ICogc2NhbGUgLSBjWzBdO1xuICAgICAgICAgICAgY29uc3QgZFkgPSB5ICogc2NhbGUgLSBjWzFdO1xuICAgICAgICAgICAgY29uc3QgYlggPSB0aGlzLmZlYXR1cmVEaXN0YW5jZURhdGEuYmVhcmluZ1swXTtcbiAgICAgICAgICAgIGNvbnN0IGJZID0gdGhpcy5mZWF0dXJlRGlzdGFuY2VEYXRhLmJlYXJpbmdbMV07XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gYlggKiBkWCArIGJZICogZFk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcGFyc2VDb2xvcihpbnB1dCkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XTtcbiAgICAgICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgICAgIGNhY2hlZCA9IHRoaXMuX3BhcnNlQ29sb3JDYWNoZVtpbnB1dF0gPSBDb2xvci5wYXJzZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG59XG5cbmNsYXNzIENvbXBvdW5kRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgZXZhbHVhdGUsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdGUgPSBldmFsdWF0ZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZShjdHgsIHRoaXMuYXJncyk7XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMubmFtZV0uY29uY2F0KHRoaXMuYXJncy5tYXAoYXJnID0+IGFyZy5zZXJpYWxpemUoKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBvcCA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnNbb3BdO1xuICAgICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBVbmtub3duIGV4cHJlc3Npb24gXCIkeyBvcCB9XCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uYCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBkZWZpbml0aW9uWzBdIDogZGVmaW5pdGlvbi50eXBlO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVPdmVybG9hZHMgPSBBcnJheS5pc0FycmF5KGRlZmluaXRpb24pID8gW1tcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uWzFdLFxuICAgICAgICAgICAgICAgIGRlZmluaXRpb25bMl1cbiAgICAgICAgICAgIF1dIDogZGVmaW5pdGlvbi5vdmVybG9hZHM7XG4gICAgICAgIGNvbnN0IG92ZXJsb2FkcyA9IGF2YWlsYWJsZU92ZXJsb2Fkcy5maWx0ZXIoKFtzaWduYXR1cmVdKSA9PiAhQXJyYXkuaXNBcnJheShzaWduYXR1cmUpIHx8IHNpZ25hdHVyZS5sZW5ndGggPT09IGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICAgIGxldCBzaWduYXR1cmVDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBbcGFyYW1zLCBldmFsdWF0ZV0gb2Ygb3ZlcmxvYWRzKSB7XG4gICAgICAgICAgICBzaWduYXR1cmVDb250ZXh0ID0gbmV3IFBhcnNpbmdDb250ZXh0KGNvbnRleHQucmVnaXN0cnksIGNvbnRleHQucGF0aCwgbnVsbCwgY29udGV4dC5zY29wZSk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gW107XG4gICAgICAgICAgICBsZXQgYXJnUGFyc2VGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gQXJyYXkuaXNBcnJheShwYXJhbXMpID8gcGFyYW1zW2kgLSAxXSA6IHBhcmFtcy50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHNpZ25hdHVyZUNvbnRleHQucGFyc2UoYXJnLCAxICsgcGFyc2VkQXJncy5sZW5ndGgsIGV4cGVjdGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnUGFyc2VGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkQXJncy5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnUGFyc2VGYWlsZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gcGFyc2VkQXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5lcnJvcihgRXhwZWN0ZWQgJHsgcGFyYW1zLmxlbmd0aCB9IGFyZ3VtZW50cywgYnV0IGZvdW5kICR7IHBhcnNlZEFyZ3MubGVuZ3RoIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRBcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBBcnJheS5pc0FycmF5KHBhcmFtcykgPyBwYXJhbXNbaV0gOiBwYXJhbXMudHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBwYXJzZWRBcmdzW2ldO1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuY29uY2F0KGkgKyAxKS5jaGVja1N1YnR5cGUoZXhwZWN0ZWQsIGFyZy50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWduYXR1cmVDb250ZXh0LmVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kRXhwcmVzc2lvbihvcCwgdHlwZSwgZXZhbHVhdGUsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVybG9hZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKC4uLnNpZ25hdHVyZUNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gb3ZlcmxvYWRzLmxlbmd0aCA/IG92ZXJsb2FkcyA6IGF2YWlsYWJsZU92ZXJsb2FkcztcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBleHBlY3RlZC5tYXAoKFtwYXJhbXNdKSA9PiBzdHJpbmdpZnlTaWduYXR1cmUocGFyYW1zKSkuam9pbignIHwgJyk7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxUeXBlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCAxICsgYWN0dWFsVHlwZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgYWN0dWFsVHlwZXMucHVzaCh0b1N0cmluZyhwYXJzZWQudHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXJndW1lbnRzIG9mIHR5cGUgJHsgc2lnbmF0dXJlcyB9LCBidXQgZm91bmQgKCR7IGFjdHVhbFR5cGVzLmpvaW4oJywgJykgfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIHJlZ2lzdGVyKHJlZ2lzdHJ5LCBkZWZpbml0aW9ucykge1xuICAgICAgICBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICByZWdpc3RyeVtuYW1lXSA9IENvbXBvdW5kRXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzaWduYXR1cmUpKSB7XG4gICAgICAgIHJldHVybiBgKCR7IHNpZ25hdHVyZS5tYXAodG9TdHJpbmcpLmpvaW4oJywgJykgfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgKCR7IHRvU3RyaW5nKHNpZ25hdHVyZS50eXBlKSB9Li4uKWA7XG4gICAgfVxufVxuXG5jbGFzcyBDb2xsYXRvckV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNhc2VTZW5zaXRpdmUsIGRpYWNyaXRpY1NlbnNpdGl2ZSwgbG9jYWxlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IENvbGxhdG9yVHlwZTtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9IGNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlID0gZGlhY3JpdGljU2Vuc2l0aXZlO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgb25lIGFyZ3VtZW50LmApO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYENvbGxhdG9yIG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICAgIGNvbnN0IGNhc2VTZW5zaXRpdmUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9uc1snY2FzZS1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpO1xuICAgICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgZGlhY3JpdGljU2Vuc2l0aXZlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydkaWFjcml0aWMtc2Vuc2l0aXZlJ10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9uc1snZGlhY3JpdGljLXNlbnNpdGl2ZSddLCAxLCBCb29sZWFuVHlwZSk7XG4gICAgICAgIGlmICghZGlhY3JpdGljU2Vuc2l0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBsb2NhbGUgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9uc1snbG9jYWxlJ10pIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbG9jYWxlJ10sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsYXRvckV4cHJlc3Npb24oY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpO1xuICAgIH1cbiAgICBldmFsdWF0ZShjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsYXRvcih0aGlzLmNhc2VTZW5zaXRpdmUuZXZhbHVhdGUoY3R4KSwgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUuZXZhbHVhdGUoY3R4KSwgdGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShjdHgpIDogbnVsbCk7XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICBmbih0aGlzLmNhc2VTZW5zaXRpdmUpO1xuICAgICAgICBmbih0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgZm4odGhpcy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10gPSB0aGlzLmNhc2VTZW5zaXRpdmUuc2VyaWFsaXplKCk7XG4gICAgICAgIG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSA9IHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpO1xuICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2xvY2FsZSddID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdjb2xsYXRvcicsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5jb25zdCBFWFRFTlQgPSA4MTkyO1xuZnVuY3Rpb24gdXBkYXRlQkJveChiYm94LCBjb29yZCkge1xuICAgIGJib3hbMF0gPSBNYXRoLm1pbihiYm94WzBdLCBjb29yZFswXSk7XG4gICAgYmJveFsxXSA9IE1hdGgubWluKGJib3hbMV0sIGNvb3JkWzFdKTtcbiAgICBiYm94WzJdID0gTWF0aC5tYXgoYmJveFsyXSwgY29vcmRbMF0pO1xuICAgIGJib3hbM10gPSBNYXRoLm1heChiYm94WzNdLCBjb29yZFsxXSk7XG59XG5mdW5jdGlvbiBtZXJjYXRvclhmcm9tTG5nKGxuZykge1xuICAgIHJldHVybiAoMTgwICsgbG5nKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIG1lcmNhdG9yWWZyb21MYXQobGF0KSB7XG4gICAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwO1xufVxuZnVuY3Rpb24gYm94V2l0aGluQm94KGJib3gxLCBiYm94Mikge1xuICAgIGlmIChiYm94MVswXSA8PSBiYm94MlswXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiYm94MVsyXSA+PSBiYm94MlsyXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiYm94MVsxXSA8PSBiYm94MlsxXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiYm94MVszXSA+PSBiYm94MlszXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGlsZUNvb3JkaW5hdGVzKHAsIGNhbm9uaWNhbCkge1xuICAgIGNvbnN0IHggPSBtZXJjYXRvclhmcm9tTG5nKHBbMF0pO1xuICAgIGNvbnN0IHkgPSBtZXJjYXRvcllmcm9tTGF0KHBbMV0pO1xuICAgIGNvbnN0IHRpbGVzQXRab29tID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopO1xuICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgucm91bmQoeCAqIHRpbGVzQXRab29tICogRVhURU5UKSxcbiAgICAgICAgTWF0aC5yb3VuZCh5ICogdGlsZXNBdFpvb20gKiBFWFRFTlQpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9uQm91bmRhcnkocCwgcDEsIHAyKSB7XG4gICAgY29uc3QgeDEgPSBwWzBdIC0gcDFbMF07XG4gICAgY29uc3QgeTEgPSBwWzFdIC0gcDFbMV07XG4gICAgY29uc3QgeDIgPSBwWzBdIC0gcDJbMF07XG4gICAgY29uc3QgeTIgPSBwWzFdIC0gcDJbMV07XG4gICAgcmV0dXJuIHgxICogeTIgLSB4MiAqIHkxID09PSAwICYmIHgxICogeDIgPD0gMCAmJiB5MSAqIHkyIDw9IDA7XG59XG5mdW5jdGlvbiByYXlJbnRlcnNlY3QocCwgcDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxWzFdID4gcFsxXSAhPT0gcDJbMV0gPiBwWzFdICYmIHBbMF0gPCAocDJbMF0gLSBwMVswXSkgKiAocFsxXSAtIHAxWzFdKSAvIChwMlsxXSAtIHAxWzFdKSArIHAxWzBdO1xufVxuZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCByaW5ncykge1xuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuMiA9IHJpbmcubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuICAgICAgICAgICAgaWYgKG9uQm91bmRhcnkocG9pbnQsIHJpbmdbal0sIHJpbmdbaiArIDFdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmF5SW50ZXJzZWN0KHBvaW50LCByaW5nW2pdLCByaW5nW2ogKyAxXSkpXG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29ucyhwb2ludCwgcG9seWdvbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHBvbHlnb25zW2ldKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwZXJwKHYxLCB2Mikge1xuICAgIHJldHVybiB2MVswXSAqIHYyWzFdIC0gdjFbMV0gKiB2MlswXTtcbn1cbmZ1bmN0aW9uIHR3b1NpZGVkKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgY29uc3QgeDEgPSBwMVswXSAtIHExWzBdO1xuICAgIGNvbnN0IHkxID0gcDFbMV0gLSBxMVsxXTtcbiAgICBjb25zdCB4MiA9IHAyWzBdIC0gcTFbMF07XG4gICAgY29uc3QgeTIgPSBwMlsxXSAtIHExWzFdO1xuICAgIGNvbnN0IHgzID0gcTJbMF0gLSBxMVswXTtcbiAgICBjb25zdCB5MyA9IHEyWzFdIC0gcTFbMV07XG4gICAgY29uc3QgZGV0MSA9IHgxICogeTMgLSB4MyAqIHkxO1xuICAgIGNvbnN0IGRldDIgPSB4MiAqIHkzIC0geDMgKiB5MjtcbiAgICBpZiAoZGV0MSA+IDAgJiYgZGV0MiA8IDAgfHwgZGV0MSA8IDAgJiYgZGV0MiA+IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RMaW5lKGEsIGIsIGMsIGQpIHtcbiAgICBjb25zdCB2ZWN0b3JQID0gW1xuICAgICAgICBiWzBdIC0gYVswXSxcbiAgICAgICAgYlsxXSAtIGFbMV1cbiAgICBdO1xuICAgIGNvbnN0IHZlY3RvclEgPSBbXG4gICAgICAgIGRbMF0gLSBjWzBdLFxuICAgICAgICBkWzFdIC0gY1sxXVxuICAgIF07XG4gICAgaWYgKHBlcnAodmVjdG9yUSwgdmVjdG9yUCkgPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHdvU2lkZWQoYSwgYiwgYywgZCkgJiYgdHdvU2lkZWQoYywgZCwgYSwgYikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RQb2x5Z29uKHAxLCBwMiwgcG9seWdvbikge1xuICAgIGZvciAoY29uc3QgcmluZyBvZiBwb2x5Z29uKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmluZy5sZW5ndGggLSAxOyArK2opIHtcbiAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0TGluZShwMSwgcDIsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb24pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24obGluZVtpXSwgcG9seWdvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGlmIChsaW5lSW50ZXJzZWN0UG9seWdvbihsaW5lW2ldLCBsaW5lW2kgKyAxXSwgcG9seWdvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29ucyhsaW5lLCBwb2x5Z29ucykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb25zW2ldKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUaWxlUG9seWdvbihjb29yZGluYXRlcywgYmJveCwgY2Fub25pY2FsKSB7XG4gICAgY29uc3QgcG9seWdvbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmluZyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvb3JkaW5hdGVzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZCA9IGdldFRpbGVDb29yZGluYXRlcyhjb29yZGluYXRlc1tpXVtqXSwgY2Fub25pY2FsKTtcbiAgICAgICAgICAgIHVwZGF0ZUJCb3goYmJveCwgY29vcmQpO1xuICAgICAgICAgICAgcmluZy5wdXNoKGNvb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgfVxuICAgIHJldHVybiBwb2x5Z29uO1xufVxuZnVuY3Rpb24gZ2V0VGlsZVBvbHlnb25zKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHtcbiAgICBjb25zdCBwb2x5Z29ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBiYm94LCBjYW5vbmljYWwpO1xuICAgICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgIH1cbiAgICByZXR1cm4gcG9seWdvbnM7XG59XG5mdW5jdGlvbiB1cGRhdGVQb2ludChwLCBiYm94LCBwb2x5QkJveCwgd29ybGRTaXplKSB7XG4gICAgaWYgKHBbMF0gPCBwb2x5QkJveFswXSB8fCBwWzBdID4gcG9seUJCb3hbMl0pIHtcbiAgICAgICAgY29uc3QgaGFsZldvcmxkU2l6ZSA9IHdvcmxkU2l6ZSAqIDAuNTtcbiAgICAgICAgbGV0IHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzBdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFswXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDtcbiAgICAgICAgaWYgKHNoaWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBzaGlmdCA9IHBbMF0gLSBwb2x5QkJveFsyXSA+IGhhbGZXb3JsZFNpemUgPyAtd29ybGRTaXplIDogcG9seUJCb3hbMl0gLSBwWzBdID4gaGFsZldvcmxkU2l6ZSA/IHdvcmxkU2l6ZSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcFswXSArPSBzaGlmdDtcbiAgICB9XG4gICAgdXBkYXRlQkJveChiYm94LCBwKTtcbn1cbmZ1bmN0aW9uIHJlc2V0QkJveChiYm94KSB7XG4gICAgYmJveFswXSA9IGJib3hbMV0gPSBJbmZpbml0eTtcbiAgICBiYm94WzJdID0gYmJveFszXSA9IC1JbmZpbml0eTtcbn1cbmZ1bmN0aW9uIGdldFRpbGVQb2ludHMoZ2VvbWV0cnksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCkge1xuICAgIGNvbnN0IHdvcmxkU2l6ZSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KSAqIEVYVEVOVDtcbiAgICBjb25zdCBzaGlmdHMgPSBbXG4gICAgICAgIGNhbm9uaWNhbC54ICogRVhURU5ULFxuICAgICAgICBjYW5vbmljYWwueSAqIEVYVEVOVFxuICAgIF07XG4gICAgY29uc3QgdGlsZVBvaW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIGdlb21ldHJ5KSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gW1xuICAgICAgICAgICAgICAgIHBvaW50LnggKyBzaGlmdHNbMF0sXG4gICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHVwZGF0ZVBvaW50KHAsIHBvaW50QkJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSk7XG4gICAgICAgICAgICB0aWxlUG9pbnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGVQb2ludHM7XG59XG5mdW5jdGlvbiBnZXRUaWxlTGluZXMoZ2VvbWV0cnksIGxpbmVCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKSB7XG4gICAgY29uc3Qgd29ybGRTaXplID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopICogRVhURU5UO1xuICAgIGNvbnN0IHNoaWZ0cyA9IFtcbiAgICAgICAgY2Fub25pY2FsLnggKiBFWFRFTlQsXG4gICAgICAgIGNhbm9uaWNhbC55ICogRVhURU5UXG4gICAgXTtcbiAgICBjb25zdCB0aWxlTGluZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgZ2VvbWV0cnkpIHtcbiAgICAgICAgY29uc3QgdGlsZUxpbmUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gW1xuICAgICAgICAgICAgICAgIHBvaW50LnggKyBzaGlmdHNbMF0sXG4gICAgICAgICAgICAgICAgcG9pbnQueSArIHNoaWZ0c1sxXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHVwZGF0ZUJCb3gobGluZUJCb3gsIHApO1xuICAgICAgICAgICAgdGlsZUxpbmUucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlTGluZXMucHVzaCh0aWxlTGluZSk7XG4gICAgfVxuICAgIGlmIChsaW5lQkJveFsyXSAtIGxpbmVCQm94WzBdIDw9IHdvcmxkU2l6ZSAvIDIpIHtcbiAgICAgICAgcmVzZXRCQm94KGxpbmVCQm94KTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRpbGVMaW5lcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIGxpbmUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVQb2ludChwLCBsaW5lQkJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGVMaW5lcztcbn1cbmZ1bmN0aW9uIHBvaW50c1dpdGhpblBvbHlnb25zKGN0eCwgcG9seWdvbkdlb21ldHJ5KSB7XG4gICAgY29uc3QgcG9pbnRCQm94ID0gW1xuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5XG4gICAgXTtcbiAgICBjb25zdCBwb2x5QkJveCA9IFtcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eVxuICAgIF07XG4gICAgY29uc3QgY2Fub25pY2FsID0gY3R4LmNhbm9uaWNhbElEKCk7XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgY29uc3QgdGlsZVBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICBjb25zdCB0aWxlUG9pbnRzID0gZ2V0VGlsZVBvaW50cyhjdHguZ2VvbWV0cnkoKSwgcG9pbnRCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgaWYgKCFib3hXaXRoaW5Cb3gocG9pbnRCQm94LCBwb2x5QkJveCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGlsZVBvaW50cykge1xuICAgICAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHRpbGVQb2x5Z29uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBjb25zdCB0aWxlUG9seWdvbnMgPSBnZXRUaWxlUG9seWdvbnMocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgY29uc3QgdGlsZVBvaW50cyA9IGdldFRpbGVQb2ludHMoY3R4Lmdlb21ldHJ5KCksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIGlmICghYm94V2l0aGluQm94KHBvaW50QkJveCwgcG9seUJCb3gpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRpbGVQb2ludHMpIHtcbiAgICAgICAgICAgIGlmICghcG9pbnRXaXRoaW5Qb2x5Z29ucyhwb2ludCwgdGlsZVBvbHlnb25zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaW5lc1dpdGhpblBvbHlnb25zKGN0eCwgcG9seWdvbkdlb21ldHJ5KSB7XG4gICAgY29uc3QgbGluZUJCb3ggPSBbXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5LFxuICAgICAgICAtSW5maW5pdHlcbiAgICBdO1xuICAgIGNvbnN0IHBvbHlCQm94ID0gW1xuICAgICAgICBJbmZpbml0eSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIC1JbmZpbml0eSxcbiAgICAgICAgLUluZmluaXR5XG4gICAgXTtcbiAgICBjb25zdCBjYW5vbmljYWwgPSBjdHguY2Fub25pY2FsSUQoKTtcbiAgICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBjb25zdCB0aWxlUG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIGNvbnN0IHRpbGVMaW5lcyA9IGdldFRpbGVMaW5lcyhjdHguZ2VvbWV0cnkoKSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgICAgICBpZiAoIWJveFdpdGhpbkJveChsaW5lQkJveCwgcG9seUJCb3gpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGlsZUxpbmVzKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHRpbGVQb2x5Z29uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBjb25zdCB0aWxlUG9seWdvbnMgPSBnZXRUaWxlUG9seWdvbnMocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICAgICAgY29uc3QgdGlsZUxpbmVzID0gZ2V0VGlsZUxpbmVzKGN0eC5nZW9tZXRyeSgpLCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgICAgIGlmICghYm94V2l0aGluQm94KGxpbmVCQm94LCBwb2x5QkJveCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aWxlTGluZXMpIHtcbiAgICAgICAgICAgIGlmICghbGluZVN0cmluZ1dpdGhpblBvbHlnb25zKGxpbmUsIHRpbGVQb2x5Z29ucykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgV2l0aGluIHtcbiAgICBjb25zdHJ1Y3RvcihnZW9qc29uLCBnZW9tZXRyaWVzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgICAgICB0aGlzLmdlb2pzb24gPSBnZW9qc29uO1xuICAgICAgICB0aGlzLmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgJ3dpdGhpbicgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICR7IGFyZ3MubGVuZ3RoIC0gMSB9IGluc3RlYWQuYCk7XG4gICAgICAgIGlmIChpc1ZhbHVlKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICBjb25zdCBnZW9qc29uID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb2pzb24uZmVhdHVyZXNbaV0uZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXaXRoaW4oZ2VvanNvbiwgZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb2pzb24uZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24uZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvanNvbi50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGAnd2l0aGluJyBleHByZXNzaW9uIHJlcXVpcmVzIHZhbGlkIGdlb2pzb24gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9seWdvbiBnZW9tZXRyeSB0eXBlLmApO1xuICAgIH1cbiAgICBldmFsdWF0ZShjdHgpIHtcbiAgICAgICAgaWYgKGN0eC5nZW9tZXRyeSgpICE9IG51bGwgJiYgY3R4LmNhbm9uaWNhbElEKCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzV2l0aGluUG9seWdvbnMoY3R4LCB0aGlzLmdlb21ldHJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWFjaENoaWxkKCkge1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ3dpdGhpbicsXG4gICAgICAgICAgICB0aGlzLmdlb2pzb25cbiAgICAgICAgXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRmVhdHVyZUNvbnN0YW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnZ2V0JyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnZmVhdHVyZS1zdGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdoYXMnICYmIGUuYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdwcm9wZXJ0aWVzJyB8fCBlLm5hbWUgPT09ICdnZW9tZXRyeS10eXBlJyB8fCBlLm5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICgvXmZpbHRlci0vLnRlc3QoZS5uYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgV2l0aGluKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgZS5lYWNoQ2hpbGQoYXJnID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNGZWF0dXJlQ29uc3RhbnQoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNTdGF0ZUNvbnN0YW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnZmVhdHVyZS1zdGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBlLmVhY2hDaGlsZChhcmcgPT4ge1xuICAgICAgICBpZiAocmVzdWx0ICYmICFpc1N0YXRlQ29uc3RhbnQoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGUsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBwcm9wZXJ0aWVzLmluZGV4T2YoZS5uYW1lKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgZS5lYWNoQ2hpbGQoYXJnID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGFyZywgcHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY2xhc3MgVmFyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBib3VuZEV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy50eXBlID0gYm91bmRFeHByZXNzaW9uLnR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYm91bmRFeHByZXNzaW9uID0gYm91bmRFeHByZXNzaW9uO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIgfHwgdHlwZW9mIGFyZ3NbMV0gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYCd2YXInIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuYCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhcmdzWzFdO1xuICAgICAgICBpZiAoIWNvbnRleHQuc2NvcGUuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgVW5rbm93biB2YXJpYWJsZSBcIiR7IG5hbWUgfVwiLiBNYWtlIHN1cmUgXCIkeyBuYW1lIH1cIiBoYXMgYmVlbiBib3VuZCBpbiBhbiBlbmNsb3NpbmcgXCJsZXRcIiBleHByZXNzaW9uIGJlZm9yZSB1c2luZyBpdC5gLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcihuYW1lLCBjb250ZXh0LnNjb3BlLmdldChuYW1lKSk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZEV4cHJlc3Npb24uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gICAgZWFjaENoaWxkKCkge1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICd2YXInLFxuICAgICAgICAgICAgdGhpcy5uYW1lXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5jbGFzcyBQYXJzaW5nQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocmVnaXN0cnksIHBhdGggPSBbXSwgZXhwZWN0ZWRUeXBlLCBzY29wZSA9IG5ldyBTY29wZSgpLCBlcnJvcnMgPSBbXSkge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMua2V5ID0gcGF0aC5tYXAocGFydCA9PiBgWyR7IHBhcnQgfV1gKS5qb2luKCcnKTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5leHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7XG4gICAgfVxuICAgIHBhcnNlKGV4cHIsIGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpLl9wYXJzZShleHByLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2UoZXhwciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9wYXJzZShleHByLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChleHByID09PSBudWxsIHx8IHR5cGVvZiBleHByID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXhwciA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBleHByID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZXhwciA9IFtcbiAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgZXhwclxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbm5vdGF0ZShwYXJzZWQsIHR5cGUsIHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZUFubm90YXRpb24gPT09ICdhc3NlcnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odHlwZSwgW3BhcnNlZF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2NvZXJjZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvZXJjaW9uKHR5cGUsIFtwYXJzZWRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHByKSkge1xuICAgICAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYEV4cGVjdGVkIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbXV0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcCA9IGV4cHJbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoYEV4cHJlc3Npb24gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZm91bmQgJHsgdHlwZW9mIG9wIH0gaW5zdGVhZC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS5gLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEV4cHIgPSB0aGlzLnJlZ2lzdHJ5W29wXTtcbiAgICAgICAgICAgIGlmIChFeHByKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZCA9IEV4cHIucGFyc2UoZXhwciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4cGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IHRoaXMuZXhwZWN0ZWRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWwgPSBwYXJzZWQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChleHBlY3RlZC5raW5kID09PSAnc3RyaW5nJyB8fCBleHBlY3RlZC5raW5kID09PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5raW5kID09PSAnYm9vbGVhbicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2FycmF5JykgJiYgYWN0dWFsLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGFubm90YXRlKHBhcnNlZCwgZXhwZWN0ZWQsIG9wdGlvbnMudHlwZUFubm90YXRpb24gfHwgJ2Fzc2VydCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChleHBlY3RlZC5raW5kID09PSAnY29sb3InIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdmb3JtYXR0ZWQnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykgJiYgKGFjdHVhbC5raW5kID09PSAndmFsdWUnIHx8IGFjdHVhbC5raW5kID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGFubm90YXRlKHBhcnNlZCwgZXhwZWN0ZWQsIG9wdGlvbnMudHlwZUFubm90YXRpb24gfHwgJ2NvZXJjZScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCBhY3R1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShwYXJzZWQgaW5zdGFuY2VvZiBMaXRlcmFsKSAmJiBwYXJzZWQudHlwZS5raW5kICE9PSAncmVzb2x2ZWRJbWFnZScgJiYgaXNDb25zdGFudChwYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjID0gbmV3IEV2YWx1YXRpb25Db250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBuZXcgTGl0ZXJhbChwYXJzZWQudHlwZSwgcGFyc2VkLmV2YWx1YXRlKGVjKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihgVW5rbm93biBleHByZXNzaW9uIFwiJHsgb3AgfVwiLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgWy4uLl1dLmAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYCd1bmRlZmluZWQnIHZhbHVlIGludmFsaWQuIFVzZSBudWxsIGluc3RlYWQuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihgQmFyZSBvYmplY3RzIGludmFsaWQuIFVzZSBbXCJsaXRlcmFsXCIsIHsuLi59XSBpbnN0ZWFkLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYEV4cGVjdGVkIGFuIGFycmF5LCBidXQgZm91bmQgJHsgdHlwZW9mIGV4cHIgfSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbmNhdChpbmRleCwgZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncykge1xuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJyA/IHRoaXMucGF0aC5jb25jYXQoaW5kZXgpIDogdGhpcy5wYXRoO1xuICAgICAgICBjb25zdCBzY29wZSA9IGJpbmRpbmdzID8gdGhpcy5zY29wZS5jb25jYXQoYmluZGluZ3MpIDogdGhpcy5zY29wZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzaW5nQ29udGV4dCh0aGlzLnJlZ2lzdHJ5LCBwYXRoLCBleHBlY3RlZFR5cGUgfHwgbnVsbCwgc2NvcGUsIHRoaXMuZXJyb3JzKTtcbiAgICB9XG4gICAgZXJyb3IoZXJyb3IsIC4uLmtleXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7IHRoaXMua2V5IH0keyBrZXlzLm1hcChrID0+IGBbJHsgayB9XWApLmpvaW4oJycpIH1gO1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzaW5nRXJyb3Ioa2V5LCBlcnJvcikpO1xuICAgIH1cbiAgICBjaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpO1xuICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29uc3RhbnQoZXhwcmVzc2lvbikge1xuICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgVmFyKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN0YW50KGV4cHJlc3Npb24uYm91bmRFeHByZXNzaW9uKTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24gJiYgZXhwcmVzc2lvbi5uYW1lID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2xsYXRvckV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFdpdGhpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlzVHlwZUFubm90YXRpb24gPSBleHByZXNzaW9uIGluc3RhbmNlb2YgQ29lcmNpb24gfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFzc2VydGlvbjtcbiAgICBsZXQgY2hpbGRyZW5Db25zdGFudCA9IHRydWU7XG4gICAgZXhwcmVzc2lvbi5lYWNoQ2hpbGQoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoaXNUeXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgY2hpbGRyZW5Db25zdGFudCA9IGNoaWxkcmVuQ29uc3RhbnQgJiYgaXNDb25zdGFudChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBjaGlsZCBpbnN0YW5jZW9mIExpdGVyYWw7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoaWxkcmVuQ29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNGZWF0dXJlQ29uc3RhbnQoZXhwcmVzc2lvbikgJiYgaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGV4cHJlc3Npb24sIFtcbiAgICAgICAgJ3pvb20nLFxuICAgICAgICAnaGVhdG1hcC1kZW5zaXR5JyxcbiAgICAgICAgJ2xpbmUtcHJvZ3Jlc3MnLFxuICAgICAgICAnc2t5LXJhZGlhbC1wcm9ncmVzcycsXG4gICAgICAgICdhY2N1bXVsYXRlZCcsXG4gICAgICAgICdpcy1zdXBwb3J0ZWQtc2NyaXB0JyxcbiAgICAgICAgJ3BpdGNoJyxcbiAgICAgICAgJ2Rpc3RhbmNlLWZyb20tY2VudGVyJ1xuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHN0b3BzLCBpbnB1dCkge1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHN0b3BzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGxvd2VySW5kZXggPSAwO1xuICAgIGxldCB1cHBlckluZGV4ID0gbGFzdEluZGV4O1xuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBjdXJyZW50VmFsdWUsIG5leHRWYWx1ZTtcbiAgICB3aGlsZSAobG93ZXJJbmRleCA8PSB1cHBlckluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IE1hdGguZmxvb3IoKGxvd2VySW5kZXggKyB1cHBlckluZGV4KSAvIDIpO1xuICAgICAgICBjdXJyZW50VmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICBuZXh0VmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXggKyAxXTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8PSBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gbGFzdEluZGV4IHx8IGlucHV0IDwgbmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvd2VySW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSA+IGlucHV0KSB7XG4gICAgICAgICAgICB1cHBlckluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoJ0lucHV0IGlzIG5vdCBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuY2xhc3MgU3RlcCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgaW5wdXQsIHN0b3BzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2xhYmVsLCBleHByZXNzaW9uXSBvZiBzdG9wcykge1xuICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dHMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggLSAxIDwgNCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAkeyBhcmdzLmxlbmd0aCAtIDEgfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGFyZ3MubGVuZ3RoIC0gMSkgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBzdG9wcyA9IFtdO1xuICAgICAgICBsZXQgb3V0cHV0VHlwZSA9IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGkgPT09IDEgPyAtSW5maW5pdHkgOiBhcmdzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsS2V5ID0gaTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gaSArIDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwic3RlcFwiIGV4cHJlc3Npb25zIG11c3QgYmUgZGVmaW5lZCB1c2luZyBsaXRlcmFsIG51bWVyaWMgdmFsdWVzIChub3QgY29tcHV0ZWQgZXhwcmVzc2lvbnMpIGZvciB0aGUgaW5wdXQgdmFsdWVzLicsIGxhYmVsS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9wcy5sZW5ndGggJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMF0gPj0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBsYWJlbEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICAgICAgc3RvcHMucHVzaChbXG4gICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgcGFyc2VkXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0ZXAob3V0cHV0VHlwZSwgaW5wdXQsIHN0b3BzKTtcbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gdGhpcy5vdXRwdXRzO1xuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgaWYgKHZhbHVlIDw9IGxhYmVsc1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdG9wQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuICAgICAgICBpZiAodmFsdWUgPj0gbGFiZWxzW3N0b3BDb3VudCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0c1tzdG9wQ291bnQgLSAxXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhsYWJlbHMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICBmbih0aGlzLmlucHV0KTtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgZm4oZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShvdXQgPT4gb3V0Lm91dHB1dERlZmluZWQoKSk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgICAgICdzdGVwJyxcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKClcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMubGFiZWxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbaV0uc2VyaWFsaXplKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbn1cblxuLypcbiAqIENvcHlyaWdodCAoQykgMjAwOCBBcHBsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgQVBQTEUgSU5DLiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFBvcnRlZCBmcm9tIFdlYmtpdFxuICogaHR0cDovL3N2bi53ZWJraXQub3JnL3JlcG9zaXRvcnkvd2Via2l0L3RydW5rL1NvdXJjZS9XZWJDb3JlL3BsYXRmb3JtL2dyYXBoaWNzL1VuaXRCZXppZXIuaFxuICovXG52YXIgdW5pdGJlemllciA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS5cbiAgICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4O1xuXG4gICAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5O1xuICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblxuICAgIHRoaXMucDF4ID0gcDF4O1xuICAgIHRoaXMucDF5ID0gcDJ5O1xuICAgIHRoaXMucDJ4ID0gcDJ4O1xuICAgIHRoaXMucDJ5ID0gcDJ5O1xufVxuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgZXBzaWxvbiA9IDFlLTY7XG5cbiAgICB2YXIgdDAsIHQxLCB0MiwgeDIsIGk7XG5cbiAgICAvLyBGaXJzdCB0cnkgYSBmZXcgaXRlcmF0aW9ucyBvZiBOZXd0b24ncyBtZXRob2QgLS0gbm9ybWFsbHkgdmVyeSBmYXN0LlxuICAgIGZvciAodDIgPSB4LCBpID0gMDsgaSA8IDg7IGkrKykge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpIC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICB2YXIgZDIgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikgYnJlYWs7XG5cbiAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cbiAgICB0MCA9IDAuMDtcbiAgICB0MSA9IDEuMDtcbiAgICB0MiA9IHg7XG5cbiAgICBpZiAodDIgPCB0MCkgcmV0dXJuIHQwO1xuICAgIGlmICh0MiA+IHQxKSByZXR1cm4gdDE7XG5cbiAgICB3aGlsZSAodDAgPCB0MSkge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZS5cbiAgICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG59O1xuXG5mdW5jdGlvbiBudW1iZXIoYSwgYiwgdCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xufVxuZnVuY3Rpb24gY29sb3IoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKG51bWJlcihmcm9tLnIsIHRvLnIsIHQpLCBudW1iZXIoZnJvbS5nLCB0by5nLCB0KSwgbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksIG51bWJlcihmcm9tLmEsIHRvLmEsIHQpKTtcbn1cbmZ1bmN0aW9uIGFycmF5JDEoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihkLCB0b1tpXSwgdCk7XG4gICAgfSk7XG59XG5cbnZhciBpbnRlcnBvbGF0ZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXI6IG51bWJlcixcbiAgY29sb3I6IGNvbG9yLFxuICBhcnJheTogYXJyYXkkMVxufSk7XG5cbmNvbnN0IFhuID0gMC45NTA0NywgWW4gPSAxLCBabiA9IDEuMDg4ODMsIHQwID0gNCAvIDI5LCB0MSA9IDYgLyAyOSwgdDIgPSAzICogdDEgKiB0MSwgdDMgPSB0MSAqIHQxICogdDEsIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwLCByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICAgIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICAgIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuZnVuY3Rpb24geHl6MnJnYih4KSB7XG4gICAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5mdW5jdGlvbiByZ2IyeHl6KHgpIHtcbiAgICB4IC89IDI1NTtcbiAgICByZXR1cm4geCA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cbmZ1bmN0aW9uIHJnYlRvTGFiKHJnYkNvbG9yKSB7XG4gICAgY29uc3QgYiA9IHJnYjJ4eXoocmdiQ29sb3IuciksIGEgPSByZ2IyeHl6KHJnYkNvbG9yLmcpLCBsID0gcmdiMnh5eihyZ2JDb2xvci5iKSwgeCA9IHh5ejJsYWIoKDAuNDEyNDU2NCAqIGIgKyAwLjM1NzU3NjEgKiBhICsgMC4xODA0Mzc1ICogbCkgLyBYbiksIHkgPSB4eXoybGFiKCgwLjIxMjY3MjkgKiBiICsgMC43MTUxNTIyICogYSArIDAuMDcyMTc1ICogbCkgLyBZbiksIHogPSB4eXoybGFiKCgwLjAxOTMzMzkgKiBiICsgMC4xMTkxOTIgKiBhICsgMC45NTAzMDQxICogbCkgLyBabik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbDogMTE2ICogeSAtIDE2LFxuICAgICAgICBhOiA1MDAgKiAoeCAtIHkpLFxuICAgICAgICBiOiAyMDAgKiAoeSAtIHopLFxuICAgICAgICBhbHBoYTogcmdiQ29sb3IuYVxuICAgIH07XG59XG5mdW5jdGlvbiBsYWJUb1JnYihsYWJDb2xvcikge1xuICAgIGxldCB5ID0gKGxhYkNvbG9yLmwgKyAxNikgLyAxMTYsIHggPSBpc05hTihsYWJDb2xvci5hKSA/IHkgOiB5ICsgbGFiQ29sb3IuYSAvIDUwMCwgeiA9IGlzTmFOKGxhYkNvbG9yLmIpID8geSA6IHkgLSBsYWJDb2xvci5iIC8gMjAwO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgQ29sb3IoeHl6MnJnYigzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIDAuNDk4NTMxNCAqIHopLCB4eXoycmdiKC0wLjk2OTI2NiAqIHggKyAxLjg3NjAxMDggKiB5ICsgMC4wNDE1NTYgKiB6KSwgeHl6MnJnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopLCBsYWJDb2xvci5hbHBoYSk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUxhYihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGw6IG51bWJlcihmcm9tLmwsIHRvLmwsIHQpLFxuICAgICAgICBhOiBudW1iZXIoZnJvbS5hLCB0by5hLCB0KSxcbiAgICAgICAgYjogbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksXG4gICAgICAgIGFscGhhOiBudW1iZXIoZnJvbS5hbHBoYSwgdG8uYWxwaGEsIHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJnYlRvSGNsKHJnYkNvbG9yKSB7XG4gICAgY29uc3Qge2wsIGEsIGJ9ID0gcmdiVG9MYWIocmdiQ29sb3IpO1xuICAgIGNvbnN0IGggPSBNYXRoLmF0YW4yKGIsIGEpICogcmFkMmRlZztcbiAgICByZXR1cm4ge1xuICAgICAgICBoOiBoIDwgMCA/IGggKyAzNjAgOiBoLFxuICAgICAgICBjOiBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiksXG4gICAgICAgIGwsXG4gICAgICAgIGFscGhhOiByZ2JDb2xvci5hXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhjbFRvUmdiKGhjbENvbG9yKSB7XG4gICAgY29uc3QgaCA9IGhjbENvbG9yLmggKiBkZWcycmFkLCBjID0gaGNsQ29sb3IuYywgbCA9IGhjbENvbG9yLmw7XG4gICAgcmV0dXJuIGxhYlRvUmdiKHtcbiAgICAgICAgbCxcbiAgICAgICAgYTogTWF0aC5jb3MoaCkgKiBjLFxuICAgICAgICBiOiBNYXRoLnNpbihoKSAqIGMsXG4gICAgICAgIGFscGhhOiBoY2xDb2xvci5hbHBoYVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVIdWUoYSwgYiwgdCkge1xuICAgIGNvbnN0IGQgPSBiIC0gYTtcbiAgICByZXR1cm4gYSArIHQgKiAoZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCk7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbChmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGg6IGludGVycG9sYXRlSHVlKGZyb20uaCwgdG8uaCwgdCksXG4gICAgICAgIGM6IG51bWJlcihmcm9tLmMsIHRvLmMsIHQpLFxuICAgICAgICBsOiBudW1iZXIoZnJvbS5sLCB0by5sLCB0KSxcbiAgICAgICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdClcbiAgICB9O1xufVxuY29uc3QgbGFiID0ge1xuICAgIGZvcndhcmQ6IHJnYlRvTGFiLFxuICAgIHJldmVyc2U6IGxhYlRvUmdiLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZUxhYlxufTtcbmNvbnN0IGhjbCA9IHtcbiAgICBmb3J3YXJkOiByZ2JUb0hjbCxcbiAgICByZXZlcnNlOiBoY2xUb1JnYixcbiAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGVIY2xcbn07XG5cbnZhciBjb2xvclNwYWNlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBsYWI6IGxhYixcbiAgaGNsOiBoY2xcbn0pO1xuXG5jbGFzcyBJbnRlcnBvbGF0ZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgb3BlcmF0b3IsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2xhYmVsLCBleHByZXNzaW9uXSBvZiBzdG9wcykge1xuICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dHMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaW50ZXJwb2xhdGlvbkZhY3RvcihpbnRlcnBvbGF0aW9uLCBpbnB1dCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICAgICAgdCA9IGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgaW50ZXJwb2xhdGlvbi5iYXNlLCBsb3dlciwgdXBwZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHQgPSBleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIDEsIGxvd2VyLCB1cHBlcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnY3ViaWMtYmV6aWVyJykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGludGVycG9sYXRpb24uY29udHJvbFBvaW50cztcbiAgICAgICAgICAgIGNvbnN0IHViID0gbmV3IHVuaXRiZXppZXIoY1swXSwgY1sxXSwgY1syXSwgY1szXSk7XG4gICAgICAgICAgICB0ID0gdWIuc29sdmUoZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCAxLCBsb3dlciwgdXBwZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IFtvcGVyYXRvciwgaW50ZXJwb2xhdGlvbiwgaW5wdXQsIC4uLnJlc3RdID0gYXJncztcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGludGVycG9sYXRpb24pIHx8IGludGVycG9sYXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gaW50ZXJwb2xhdGlvbiB0eXBlIGV4cHJlc3Npb24uYCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0geyBuYW1lOiAnbGluZWFyJyB9O1xuICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBpbnRlcnBvbGF0aW9uWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiYXNlICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS5gLCAxLCAxKTtcbiAgICAgICAgICAgIGludGVycG9sYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgICAgICBiYXNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdjdWJpYy1iZXppZXInKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sUG9pbnRzID0gaW50ZXJwb2xhdGlvbi5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCAhPT0gNCB8fCBjb250cm9sUG9pbnRzLnNvbWUodCA9PiB0eXBlb2YgdCAhPT0gJ251bWJlcicgfHwgdCA8IDAgfHwgdCA+IDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0N1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLicsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY3ViaWMtYmV6aWVyJyxcbiAgICAgICAgICAgICAgICBjb250cm9sUG9pbnRzOiBjb250cm9sUG9pbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYFVua25vd24gaW50ZXJwb2xhdGlvbiB0eXBlICR7IFN0cmluZyhpbnRlcnBvbGF0aW9uWzBdKSB9YCwgMSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHsgYXJncy5sZW5ndGggLSAxIH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChhcmdzLmxlbmd0aCAtIDEpICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5gKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGNvbnRleHQucGFyc2UoaW5wdXQsIDIsIE51bWJlclR5cGUpO1xuICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHN0b3BzID0gW107XG4gICAgICAgIGxldCBvdXRwdXRUeXBlID0gbnVsbDtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtaGNsJyB8fCBvcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWxhYicpIHtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBDb2xvclR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSByZXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0W2kgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsS2V5ID0gaSArIDM7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUtleSA9IGkgKyA0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgbGFiZWxLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBsYWJlbEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICAgICAgc3RvcHMucHVzaChbXG4gICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgcGFyc2VkXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0VHlwZS5raW5kICE9PSAnbnVtYmVyJyAmJiBvdXRwdXRUeXBlLmtpbmQgIT09ICdjb2xvcicgJiYgIShvdXRwdXRUeXBlLmtpbmQgPT09ICdhcnJheScgJiYgb3V0cHV0VHlwZS5pdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb3V0cHV0VHlwZS5OID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBUeXBlICR7IHRvU3RyaW5nKG91dHB1dFR5cGUpIH0gaXMgbm90IGludGVycG9sYXRhYmxlLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGUob3V0cHV0VHlwZSwgb3BlcmF0b3IsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wcyk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IHRoaXMub3V0cHV0cztcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIGlmICh2YWx1ZSA8PSBsYWJlbHNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcENvdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgaWYgKHZhbHVlID49IGxhYmVsc1tzdG9wQ291bnQgLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbc3RvcENvdW50IC0gMV0uZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8obGFiZWxzLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGxvd2VyID0gbGFiZWxzW2luZGV4XTtcbiAgICAgICAgY29uc3QgdXBwZXIgPSBsYWJlbHNbaW5kZXggKyAxXTtcbiAgICAgICAgY29uc3QgdCA9IEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uLCB2YWx1ZSwgbG93ZXIsIHVwcGVyKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0TG93ZXIgPSBvdXRwdXRzW2luZGV4XS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBjb25zdCBvdXRwdXRVcHBlciA9IG91dHB1dHNbaW5kZXggKyAxXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlW3RoaXMudHlwZS5raW5kLnRvTG93ZXJDYXNlKCldKG91dHB1dExvd2VyLCBvdXRwdXRVcHBlciwgdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWhjbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBoY2wucmV2ZXJzZShoY2wuaW50ZXJwb2xhdGUoaGNsLmZvcndhcmQob3V0cHV0TG93ZXIpLCBoY2wuZm9yd2FyZChvdXRwdXRVcHBlciksIHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsYWIucmV2ZXJzZShsYWIuaW50ZXJwb2xhdGUobGFiLmZvcndhcmQob3V0cHV0TG93ZXIpLCBsYWIuZm9yd2FyZChvdXRwdXRVcHBlciksIHQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgZm4odGhpcy5pbnB1dCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiB0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZuKGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkob3V0ID0+IG91dC5vdXRwdXREZWZpbmVkKCkpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGxldCBpbnRlcnBvbGF0aW9uO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydsaW5lYXInXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmludGVycG9sYXRpb24ubmFtZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFsnbGluZWFyJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbXG4gICAgICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBbJ2N1YmljLWJlemllciddLmNvbmNhdCh0aGlzLmludGVycG9sYXRpb24uY29udHJvbFBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5sYWJlbHNbaV0sIHRoaXMub3V0cHV0c1tpXS5zZXJpYWxpemUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlO1xuICAgIGNvbnN0IHByb2dyZXNzID0gaW5wdXQgLSBsb3dlclZhbHVlO1xuICAgIGlmIChkaWZmZXJlbmNlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoYmFzZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcHJvZ3Jlc3MgLyBkaWZmZXJlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5wb3coYmFzZSwgcHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgZGlmZmVyZW5jZSkgLSAxKTtcbiAgICB9XG59XG5cbmNsYXNzIENvYWxlc2NlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhcmdzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dFR5cGUgPSBudWxsO1xuICAgICAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICAgICAgaWYgKGV4cGVjdGVkVHlwZSAmJiBleHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3Muc2xpY2UoMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGNvbnRleHQucGFyc2UoYXJnLCAxICsgcGFyc2VkQXJncy5sZW5ndGgsIG91dHB1dFR5cGUsIHVuZGVmaW5lZCwgeyB0eXBlQW5ub3RhdGlvbjogJ29taXQnIH0pO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCBwYXJzZWQudHlwZTtcbiAgICAgICAgICAgIHBhcnNlZEFyZ3MucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRzQW5ub3RhdGlvbiA9IGV4cGVjdGVkVHlwZSAmJiBwYXJzZWRBcmdzLnNvbWUoYXJnID0+IGNoZWNrU3VidHlwZShleHBlY3RlZFR5cGUsIGFyZy50eXBlKSk7XG4gICAgICAgIHJldHVybiBuZWVkc0Fubm90YXRpb24gPyBuZXcgQ29hbGVzY2UoVmFsdWVUeXBlLCBwYXJzZWRBcmdzKSA6IG5ldyBDb2FsZXNjZShvdXRwdXRUeXBlLCBwYXJzZWRBcmdzKTtcbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBsZXQgYXJnQ291bnQgPSAwO1xuICAgICAgICBsZXQgcmVxdWVzdGVkSW1hZ2VOYW1lO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiB0aGlzLmFyZ3MpIHtcbiAgICAgICAgICAgIGFyZ0NvdW50Kys7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSAmJiAhcmVzdWx0LmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdGVkSW1hZ2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZEltYWdlTmFtZSA9IHJlc3VsdC5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChhcmdDb3VudCA9PT0gdGhpcy5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXF1ZXN0ZWRJbWFnZU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGFyZyA9PiBhcmcub3V0cHV0RGVmaW5lZCgpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gWydjb2FsZXNjZSddO1xuICAgICAgICB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuXG5jbGFzcyBMZXQge1xuICAgIGNvbnN0cnVjdG9yKGJpbmRpbmdzLCByZXN1bHQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gcmVzdWx0LnR5cGU7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBbXS5jb25jYXQoYmluZGluZ3MpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgIGZuKGJpbmRpbmdbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGZuKHRoaXMucmVzdWx0KTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNClcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kICR7IGFyZ3MubGVuZ3RoIC0gMSB9IGluc3RlYWQuYCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhcmdzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBzdHJpbmcsIGJ1dCBmb3VuZCAkeyB0eXBlb2YgbmFtZSB9IGluc3RlYWQuYCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL1teYS16QS1aMC05X10vLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgVmFyaWFibGUgbmFtZXMgbXVzdCBjb250YWluIG9ubHkgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb3IgJ18nLmAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSArIDFdLCBpICsgMSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgYmluZGluZ3MucHVzaChbXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgY29udGV4dC5leHBlY3RlZFR5cGUsIGJpbmRpbmdzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBMZXQoYmluZGluZ3MsIHJlc3VsdCk7XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFsnbGV0J107XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIGV4cHJdIG9mIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChuYW1lLCBleHByLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5yZXN1bHQuc2VyaWFsaXplKCkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG59XG5cbmNsYXNzIEF0IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBpbmRleCwgaW5wdXQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMylcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCAyIGFyZ3VtZW50cywgYnV0IGZvdW5kICR7IGFyZ3MubGVuZ3RoIC0gMSB9IGluc3RlYWQuYCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIGFycmF5KGNvbnRleHQuZXhwZWN0ZWRUeXBlIHx8IFZhbHVlVHlwZSkpO1xuICAgICAgICBpZiAoIWluZGV4IHx8ICFpbnB1dClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB0ID0gaW5wdXQudHlwZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdCh0Lml0ZW1UeXBlLCBpbmRleCwgaW5wdXQpO1xuICAgIH1cbiAgICBldmFsdWF0ZShjdHgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGBBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiAkeyBpbmRleCB9IDwgMC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKGBBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiAkeyBpbmRleCB9ID4gJHsgYXJyYXkubGVuZ3RoIC0gMSB9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gTWF0aC5mbG9vcihpbmRleCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoYEFycmF5IGluZGV4IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGZvdW5kICR7IGluZGV4IH0gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdO1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgZm4odGhpcy5pbmRleCk7XG4gICAgICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdhdCcsXG4gICAgICAgICAgICB0aGlzLmluZGV4LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuY2xhc3MgSW4ge1xuICAgIGNvbnN0cnVjdG9yKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICAgICAgdGhpcy50eXBlID0gQm9vbGVhblR5cGU7XG4gICAgICAgIHRoaXMubmVlZGxlID0gbmVlZGxlO1xuICAgICAgICB0aGlzLmhheXN0YWNrID0gaGF5c3RhY2s7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJHsgYXJncy5sZW5ndGggLSAxIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZWVkbGUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgIGNvbnN0IGhheXN0YWNrID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBWYWx1ZVR5cGUpO1xuICAgICAgICBpZiAoIW5lZWRsZSB8fCAhaGF5c3RhY2spXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShuZWVkbGUudHlwZSwgW1xuICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgICAgICBOdWxsVHlwZSxcbiAgICAgICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgICAgIF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJHsgdG9TdHJpbmcobmVlZGxlLnR5cGUpIH0gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW4obmVlZGxlLCBoYXlzdGFjayk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICBjb25zdCBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBjb25zdCBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgaWYgKCFoYXlzdGFjaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFtcbiAgICAgICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ251bGwnXG4gICAgICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJHsgdG9TdHJpbmcodHlwZU9mKG5lZWRsZSkpIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGhheXN0YWNrLCBbXG4gICAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ2FycmF5J1xuICAgICAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoYEV4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICR7IHRvU3RyaW5nKHR5cGVPZihoYXlzdGFjaykpIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID49IDA7XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICBmbih0aGlzLm5lZWRsZSk7XG4gICAgICAgIGZuKHRoaXMuaGF5c3RhY2spO1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2luJyxcbiAgICAgICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuY2xhc3MgSW5kZXhPZiB7XG4gICAgY29uc3RydWN0b3IobmVlZGxlLCBoYXlzdGFjaywgZnJvbUluZGV4KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IE51bWJlclR5cGU7XG4gICAgICAgIHRoaXMubmVlZGxlID0gbmVlZGxlO1xuICAgICAgICB0aGlzLmhheXN0YWNrID0gaGF5c3RhY2s7XG4gICAgICAgIHRoaXMuZnJvbUluZGV4ID0gZnJvbUluZGV4O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMiB8fCBhcmdzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kICR7IGFyZ3MubGVuZ3RoIC0gMSB9IGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVlZGxlID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgICBjb25zdCBoYXlzdGFjayA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgVmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKCFuZWVkbGUgfHwgIWhheXN0YWNrKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghaXNWYWxpZFR5cGUobmVlZGxlLnR5cGUsIFtcbiAgICAgICAgICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICAgICAgTnVsbFR5cGUsXG4gICAgICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgICAgICBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICR7IHRvU3RyaW5nKG5lZWRsZS50eXBlKSB9IGluc3RlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb21JbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgTnVtYmVyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWZyb21JbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrLCBmcm9tSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICBjb25zdCBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBjb25zdCBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFtcbiAgICAgICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ251bGwnXG4gICAgICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJHsgdG9TdHJpbmcodHlwZU9mKG5lZWRsZSkpIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGhheXN0YWNrLCBbXG4gICAgICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ2FycmF5J1xuICAgICAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoYEV4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICR7IHRvU3RyaW5nKHR5cGVPZihoYXlzdGFjaykpIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb21JbmRleCA9IHRoaXMuZnJvbUluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUsIGZyb21JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKTtcbiAgICB9XG4gICAgZWFjaENoaWxkKGZuKSB7XG4gICAgICAgIGZuKHRoaXMubmVlZGxlKTtcbiAgICAgICAgZm4odGhpcy5oYXlzdGFjayk7XG4gICAgICAgIGlmICh0aGlzLmZyb21JbmRleCkge1xuICAgICAgICAgICAgZm4odGhpcy5mcm9tSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tSW5kZXggIT0gbnVsbCAmJiB0aGlzLmZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2luZGV4LW9mJyxcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgICAgIGZyb21JbmRleFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2luZGV4LW9mJyxcbiAgICAgICAgICAgIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuY2xhc3MgTWF0Y2gge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpIHtcbiAgICAgICAgdGhpcy5pbnB1dFR5cGUgPSBpbnB1dFR5cGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNSlcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHsgYXJncy5sZW5ndGggLSAxIH0uYCk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAlIDIgIT09IDEpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLmApO1xuICAgICAgICBsZXQgaW5wdXRUeXBlO1xuICAgICAgICBsZXQgb3V0cHV0VHlwZTtcbiAgICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXNlcyA9IHt9O1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSBhcmdzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzID0gW2xhYmVsc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYWJlbENvbnRleHQgPSBjb250ZXh0LmNvbmNhdChpKTtcbiAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcignRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGJyYW5jaCBsYWJlbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKGBCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsID09PSAnbnVtYmVyJyAmJiBNYXRoLmFicyhsYWJlbCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKGBCcmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlcnMgbm8gbGFyZ2VyIHRoYW4gJHsgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfS5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihsYWJlbCkgIT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoYE51bWVyaWMgYnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXIgdmFsdWVzLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlucHV0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPSB0eXBlT2YobGFiZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb250ZXh0LmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIHR5cGVPZihsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhc2VzW1N0cmluZyhsYWJlbCldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdCcmFuY2ggbGFiZWxzIG11c3QgYmUgdW5pcXVlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlc1tTdHJpbmcobGFiZWwpXSA9IG91dHB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29udGV4dC5wYXJzZSh2YWx1ZSwgaSwgb3V0cHV0VHlwZSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlO1xuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgIGlmICghaW5wdXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghb3RoZXJ3aXNlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChpbnB1dC50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgY29udGV4dC5jb25jYXQoMSkuY2hlY2tTdWJ0eXBlKGlucHV0VHlwZSwgaW5wdXQudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWF0Y2goaW5wdXRUeXBlLCBvdXRwdXRUeXBlLCBpbnB1dCwgY2FzZXMsIG91dHB1dHMsIG90aGVyd2lzZSk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gdHlwZU9mKGlucHV0KSA9PT0gdGhpcy5pbnB1dFR5cGUgJiYgdGhpcy5vdXRwdXRzW3RoaXMuY2FzZXNbaW5wdXRdXSB8fCB0aGlzLm90aGVyd2lzZTtcbiAgICAgICAgcmV0dXJuIG91dHB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgZm4odGhpcy5pbnB1dCk7XG4gICAgICAgIHRoaXMub3V0cHV0cy5mb3JFYWNoKGZuKTtcbiAgICAgICAgZm4odGhpcy5vdGhlcndpc2UpO1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KG91dCA9PiBvdXQub3V0cHV0RGVmaW5lZCgpKSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgICAgICdtYXRjaCcsXG4gICAgICAgICAgICB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHNvcnRlZExhYmVscyA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTtcbiAgICAgICAgY29uc3QgZ3JvdXBlZEJ5T3V0cHV0ID0gW107XG4gICAgICAgIGNvbnN0IG91dHB1dExvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIHNvcnRlZExhYmVscykge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBvdXRwdXRMb29rdXBbdGhpcy5jYXNlc1tsYWJlbF1dO1xuICAgICAgICAgICAgaWYgKG91dHB1dEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRMb29rdXBbdGhpcy5jYXNlc1tsYWJlbF1dID0gZ3JvdXBlZEJ5T3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBncm91cGVkQnlPdXRwdXQucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FzZXNbbGFiZWxdLFxuICAgICAgICAgICAgICAgICAgICBbbGFiZWxdXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRCeU91dHB1dFtvdXRwdXRJbmRleF1bMV0ucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29lcmNlTGFiZWwgPSBsYWJlbCA9PiB0aGlzLmlucHV0VHlwZS5raW5kID09PSAnbnVtYmVyJyA/IE51bWJlcihsYWJlbCkgOiBsYWJlbDtcbiAgICAgICAgZm9yIChjb25zdCBbb3V0cHV0SW5kZXgsIGxhYmVsc10gb2YgZ3JvdXBlZEJ5T3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjb2VyY2VMYWJlbChsYWJlbHNbMF0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGxhYmVscy5tYXAoY29lcmNlTGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm91dHB1dHNbb3V0cHV0SW5kZXhdLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdGhlcndpc2Uuc2VyaWFsaXplKCkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG59XG5cbmNsYXNzIENhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5icmFuY2hlcyA9IGJyYW5jaGVzO1xuICAgICAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNClcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHsgYXJncy5sZW5ndGggLSAxIH0uYCk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYW4gb2RkIG51bWJlciBvZiBhcmd1bWVudHMuYCk7XG4gICAgICAgIGxldCBvdXRwdXRUeXBlO1xuICAgICAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyYW5jaGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIEJvb2xlYW5UeXBlKTtcbiAgICAgICAgICAgIGlmICghdGVzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpICsgMV0sIGkgKyAxLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgYnJhbmNoZXMucHVzaChbXG4gICAgICAgICAgICAgICAgdGVzdCxcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcmVzdWx0LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghb3RoZXJ3aXNlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQ2FzZShvdXRwdXRUeXBlLCBicmFuY2hlcywgb3RoZXJ3aXNlKTtcbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Rlc3QsIGV4cHJlc3Npb25dIG9mIHRoaXMuYnJhbmNoZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXN0LmV2YWx1YXRlKGN0eCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgICBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgZm9yIChjb25zdCBbdGVzdCwgZXhwcmVzc2lvbl0gb2YgdGhpcy5icmFuY2hlcykge1xuICAgICAgICAgICAgZm4odGVzdCk7XG4gICAgICAgICAgICBmbihleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmbih0aGlzLm90aGVyd2lzZSk7XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYW5jaGVzLmV2ZXJ5KChbXywgb3V0XSkgPT4gb3V0Lm91dHB1dERlZmluZWQoKSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2Nhc2UnXTtcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoY2hpbGQgPT4ge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbn1cblxuY2xhc3MgU2xpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGlucHV0LCBiZWdpbkluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuYmVnaW5JbmRleCA9IGJlZ2luSW5kZXg7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCAkeyBhcmdzLmxlbmd0aCAtIDEgfSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgICBjb25zdCBiZWdpbkluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dCB8fCAhYmVnaW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGlucHV0LnR5cGUsIFtcbiAgICAgICAgICAgICAgICBhcnJheShWYWx1ZVR5cGUpLFxuICAgICAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgICAgICBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJHsgdG9TdHJpbmcoaW5wdXQudHlwZSkgfSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgTnVtYmVyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWVuZEluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbGljZShpbnB1dC50eXBlLCBpbnB1dCwgYmVnaW5JbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbGljZShpbnB1dC50eXBlLCBpbnB1dCwgYmVnaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBjb25zdCBiZWdpbkluZGV4ID0gdGhpcy5iZWdpbkluZGV4LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIGlmICghaXNWYWxpZE5hdGl2ZVR5cGUoaW5wdXQsIFtcbiAgICAgICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAnYXJyYXknXG4gICAgICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAkeyB0b1N0cmluZyh0eXBlT2YoaW5wdXQpKSB9IGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoYmVnaW5JbmRleCk7XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICBmbih0aGlzLmlucHV0KTtcbiAgICAgICAgZm4odGhpcy5iZWdpbkluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGZuKHRoaXMuZW5kSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBpZiAodGhpcy5lbmRJbmRleCAhPSBudWxsICYmIHRoaXMuZW5kSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0aGlzLmVuZEluZGV4LnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnc2xpY2UnLFxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2VyaWFsaXplKCksXG4gICAgICAgICAgICAgICAgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgICAgIGVuZEluZGV4XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnc2xpY2UnLFxuICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNDb21wYXJhYmxlVHlwZShvcCwgdHlwZSkge1xuICAgIGlmIChvcCA9PT0gJz09JyB8fCBvcCA9PT0gJyE9Jykge1xuICAgICAgICByZXR1cm4gdHlwZS5raW5kID09PSAnYm9vbGVhbicgfHwgdHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCB0eXBlLmtpbmQgPT09ICdudW1iZXInIHx8IHR5cGUua2luZCA9PT0gJ251bGwnIHx8IHR5cGUua2luZCA9PT0gJ3ZhbHVlJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCB0eXBlLmtpbmQgPT09ICdudW1iZXInIHx8IHR5cGUua2luZCA9PT0gJ3ZhbHVlJztcbiAgICB9XG59XG5mdW5jdGlvbiBlcShjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIG5lcShjdHgsIGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGx0KGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhIDwgYjtcbn1cbmZ1bmN0aW9uIGd0KGN0eCwgYSwgYikge1xuICAgIHJldHVybiBhID4gYjtcbn1cbmZ1bmN0aW9uIGx0ZXEoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgPD0gYjtcbn1cbmZ1bmN0aW9uIGd0ZXEoY3R4LCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgPj0gYjtcbn1cbmZ1bmN0aW9uIGVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID09PSAwO1xufVxuZnVuY3Rpb24gbmVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgICByZXR1cm4gIWVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpO1xufVxuZnVuY3Rpb24gbHRDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPCAwO1xufVxuZnVuY3Rpb24gZ3RDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICAgIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPiAwO1xufVxuZnVuY3Rpb24gbHRlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA8PSAwO1xufVxuZnVuY3Rpb24gZ3RlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA+PSAwO1xufVxuZnVuY3Rpb24gbWFrZUNvbXBhcmlzb24ob3AsIGNvbXBhcmVCYXNpYywgY29tcGFyZVdpdGhDb2xsYXRvcikge1xuICAgIGNvbnN0IGlzT3JkZXJDb21wYXJpc29uID0gb3AgIT09ICc9PScgJiYgb3AgIT09ICchPSc7XG4gICAgcmV0dXJuIGNsYXNzIENvbXBhcmlzb24ge1xuICAgICAgICBjb25zdHJ1Y3RvcihsaHMsIHJocywgY29sbGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgICAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgICAgIHRoaXMuY29sbGF0b3IgPSBjb2xsYXRvcjtcbiAgICAgICAgICAgIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50ID0gbGhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCByaHMudHlwZS5raW5kID09PSAndmFsdWUnO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDMgJiYgYXJncy5sZW5ndGggIT09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIHR3byBvciB0aHJlZSBhcmd1bWVudHMuYCk7XG4gICAgICAgICAgICBjb25zdCBvcCA9IGFyZ3NbMF07XG4gICAgICAgICAgICBsZXQgbGhzID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgICAgICAgaWYgKCFsaHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoIWlzQ29tcGFyYWJsZVR5cGUob3AsIGxocy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmNhdCgxKS5lcnJvcihgXCIkeyBvcCB9XCIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgJyR7IHRvU3RyaW5nKGxocy50eXBlKSB9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIXJocylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICghaXNDb21wYXJhYmxlVHlwZShvcCwgcmhzLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KDIpLmVycm9yKGBcIiR7IG9wIH1cIiBjb21wYXJpc29ucyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAnJHsgdG9TdHJpbmcocmhzLnR5cGUpIH0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgIT09IHJocy50eXBlLmtpbmQgJiYgbGhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYENhbm5vdCBjb21wYXJlIHR5cGVzICckeyB0b1N0cmluZyhsaHMudHlwZSkgfScgYW5kICckeyB0b1N0cmluZyhyaHMudHlwZSkgfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNPcmRlckNvbXBhcmlzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAobGhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxocyA9IG5ldyBBc3NlcnRpb24ocmhzLnR5cGUsIFtsaHNdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICByaHMgPSBuZXcgQXNzZXJ0aW9uKGxocy50eXBlLCBbcmhzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbGxhdG9yID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChsaHMudHlwZS5raW5kICE9PSAnc3RyaW5nJyAmJiByaHMudHlwZS5raW5kICE9PSAnc3RyaW5nJyAmJiBsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYENhbm5vdCB1c2UgY29sbGF0b3IgdG8gY29tcGFyZSBub24tc3RyaW5nIHR5cGVzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsYXRvciA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgQ29sbGF0b3JUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbGxhdG9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGFyaXNvbihsaHMsIHJocywgY29sbGF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICAgICAgY29uc3QgbGhzID0gdGhpcy5saHMuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBpZiAoaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsdCA9IHR5cGVPZihsaHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ0ID0gdHlwZU9mKHJocyk7XG4gICAgICAgICAgICAgICAgaWYgKGx0LmtpbmQgIT09IHJ0LmtpbmQgfHwgIShsdC5raW5kID09PSAnc3RyaW5nJyB8fCBsdC5raW5kID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihgRXhwZWN0ZWQgYXJndW1lbnRzIGZvciBcIiR7IG9wIH1cIiB0byBiZSAoc3RyaW5nLCBzdHJpbmcpIG9yIChudW1iZXIsIG51bWJlciksIGJ1dCBmb3VuZCAoJHsgbHQua2luZCB9LCAkeyBydC5raW5kIH0pIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGF0b3IgJiYgIWlzT3JkZXJDb21wYXJpc29uICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbHQgPSB0eXBlT2YobGhzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBydCA9IHR5cGVPZihyaHMpO1xuICAgICAgICAgICAgICAgIGlmIChsdC5raW5kICE9PSAnc3RyaW5nJyB8fCBydC5raW5kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yID8gY29tcGFyZVdpdGhDb2xsYXRvcihjdHgsIGxocywgcmhzLCB0aGlzLmNvbGxhdG9yLmV2YWx1YXRlKGN0eCkpIDogY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICAgICAgZm4odGhpcy5saHMpO1xuICAgICAgICAgICAgZm4odGhpcy5yaHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGF0b3IpIHtcbiAgICAgICAgICAgICAgICBmbih0aGlzLmNvbGxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplKCkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFtvcF07XG4gICAgICAgICAgICB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgRXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJz09JywgZXEsIGVxQ29sbGF0ZSk7XG5jb25zdCBOb3RFcXVhbHMgPSBtYWtlQ29tcGFyaXNvbignIT0nLCBuZXEsIG5lcUNvbGxhdGUpO1xuY29uc3QgTGVzc1RoYW4gPSBtYWtlQ29tcGFyaXNvbignPCcsIGx0LCBsdENvbGxhdGUpO1xuY29uc3QgR3JlYXRlclRoYW4gPSBtYWtlQ29tcGFyaXNvbignPicsIGd0LCBndENvbGxhdGUpO1xuY29uc3QgTGVzc1RoYW5PckVxdWFsID0gbWFrZUNvbXBhcmlzb24oJzw9JywgbHRlcSwgbHRlcUNvbGxhdGUpO1xuY29uc3QgR3JlYXRlclRoYW5PckVxdWFsID0gbWFrZUNvbXBhcmlzb24oJz49JywgZ3RlcSwgZ3RlcUNvbGxhdGUpO1xuXG5jbGFzcyBOdW1iZXJGb3JtYXQge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlciwgbG9jYWxlLCBjdXJyZW5jeSwgbWluRnJhY3Rpb25EaWdpdHMsIG1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFN0cmluZ1R5cGU7XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgdGhpcy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgICAgICB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID0gbWluRnJhY3Rpb25EaWdpdHM7XG4gICAgICAgIHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgPSBtYXhGcmFjdGlvbkRpZ2l0cztcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoYEV4cGVjdGVkIHR3byBhcmd1bWVudHMuYCk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICAgIGlmICghbnVtYmVyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzJdO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgTnVtYmVyRm9ybWF0IG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICAgIGxldCBsb2NhbGUgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9uc1snbG9jYWxlJ10pIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbG9jYWxlJ10sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbmN5ID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2N1cnJlbmN5J10pIHtcbiAgICAgICAgICAgIGN1cnJlbmN5ID0gY29udGV4dC5wYXJzZShvcHRpb25zWydjdXJyZW5jeSddLCAxLCBTdHJpbmdUeXBlKTtcbiAgICAgICAgICAgIGlmICghY3VycmVuY3kpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1pbkZyYWN0aW9uRGlnaXRzID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSkge1xuICAgICAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1pbkZyYWN0aW9uRGlnaXRzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhGcmFjdGlvbkRpZ2l0cyA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10pIHtcbiAgICAgICAgICAgIG1heEZyYWN0aW9uRGlnaXRzID0gY29udGV4dC5wYXJzZShvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10sIDEsIE51bWJlclR5cGUpO1xuICAgICAgICAgICAgaWYgKCFtYXhGcmFjdGlvbkRpZ2l0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE51bWJlckZvcm1hdChudW1iZXIsIGxvY2FsZSwgY3VycmVuY3ksIG1pbkZyYWN0aW9uRGlnaXRzLCBtYXhGcmFjdGlvbkRpZ2l0cyk7XG4gICAgfVxuICAgIGV2YWx1YXRlKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUoY3R4KSA6IFtdLCB7XG4gICAgICAgICAgICBzdHlsZTogdGhpcy5jdXJyZW5jeSA/ICdjdXJyZW5jeScgOiAnZGVjaW1hbCcsXG4gICAgICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSA/IHRoaXMuY3VycmVuY3kuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZFxuICAgICAgICB9KS5mb3JtYXQodGhpcy5udW1iZXIuZXZhbHVhdGUoY3R4KSk7XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICBmbih0aGlzLm51bWJlcik7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgZm4odGhpcy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbmN5KSB7XG4gICAgICAgICAgICBmbih0aGlzLmN1cnJlbmN5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5GcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICAgICAgZm4odGhpcy5taW5GcmFjdGlvbkRpZ2l0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4RnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgICAgIGZuKHRoaXMubWF4RnJhY3Rpb25EaWdpdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgb3B0aW9uc1snbG9jYWxlJ10gPSB0aGlzLmxvY2FsZS5zZXJpYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW5jeSkge1xuICAgICAgICAgICAgb3B0aW9uc1snY3VycmVuY3knXSA9IHRoaXMuY3VycmVuY3kuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4RnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdudW1iZXItZm9ybWF0JyxcbiAgICAgICAgICAgIHRoaXMubnVtYmVyLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICBdO1xuICAgIH1cbn1cblxuY2xhc3MgTGVuZ3RoIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKGBFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgJHsgYXJncy5sZW5ndGggLSAxIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEpO1xuICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChpbnB1dC50eXBlLmtpbmQgIT09ICdhcnJheScgJiYgaW5wdXQudHlwZS5raW5kICE9PSAnc3RyaW5nJyAmJiBpbnB1dC50eXBlLmtpbmQgIT09ICd2YWx1ZScpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihgRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCAkeyB0b1N0cmluZyhpbnB1dC50eXBlKSB9IGluc3RlYWQuYCk7XG4gICAgICAgIHJldHVybiBuZXcgTGVuZ3RoKGlucHV0KTtcbiAgICB9XG4gICAgZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoYEV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgJHsgdG9TdHJpbmcodHlwZU9mKGlucHV0KSkgfSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVhY2hDaGlsZChmbikge1xuICAgICAgICBmbih0aGlzLmlucHV0KTtcbiAgICB9XG4gICAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbJ2xlbmd0aCddO1xuICAgICAgICB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuXG5jb25zdCBleHByZXNzaW9ucyA9IHtcbiAgICAnPT0nOiBFcXVhbHMsXG4gICAgJyE9JzogTm90RXF1YWxzLFxuICAgICc+JzogR3JlYXRlclRoYW4sXG4gICAgJzwnOiBMZXNzVGhhbixcbiAgICAnPj0nOiBHcmVhdGVyVGhhbk9yRXF1YWwsXG4gICAgJzw9JzogTGVzc1RoYW5PckVxdWFsLFxuICAgICdhcnJheSc6IEFzc2VydGlvbixcbiAgICAnYXQnOiBBdCxcbiAgICAnYm9vbGVhbic6IEFzc2VydGlvbixcbiAgICAnY2FzZSc6IENhc2UsXG4gICAgJ2NvYWxlc2NlJzogQ29hbGVzY2UsXG4gICAgJ2NvbGxhdG9yJzogQ29sbGF0b3JFeHByZXNzaW9uLFxuICAgICdmb3JtYXQnOiBGb3JtYXRFeHByZXNzaW9uLFxuICAgICdpbWFnZSc6IEltYWdlRXhwcmVzc2lvbixcbiAgICAnaW4nOiBJbixcbiAgICAnaW5kZXgtb2YnOiBJbmRleE9mLFxuICAgICdpbnRlcnBvbGF0ZSc6IEludGVycG9sYXRlLFxuICAgICdpbnRlcnBvbGF0ZS1oY2wnOiBJbnRlcnBvbGF0ZSxcbiAgICAnaW50ZXJwb2xhdGUtbGFiJzogSW50ZXJwb2xhdGUsXG4gICAgJ2xlbmd0aCc6IExlbmd0aCxcbiAgICAnbGV0JzogTGV0LFxuICAgICdsaXRlcmFsJzogTGl0ZXJhbCxcbiAgICAnbWF0Y2gnOiBNYXRjaCxcbiAgICAnbnVtYmVyJzogQXNzZXJ0aW9uLFxuICAgICdudW1iZXItZm9ybWF0JzogTnVtYmVyRm9ybWF0LFxuICAgICdvYmplY3QnOiBBc3NlcnRpb24sXG4gICAgJ3NsaWNlJzogU2xpY2UsXG4gICAgJ3N0ZXAnOiBTdGVwLFxuICAgICdzdHJpbmcnOiBBc3NlcnRpb24sXG4gICAgJ3RvLWJvb2xlYW4nOiBDb2VyY2lvbixcbiAgICAndG8tY29sb3InOiBDb2VyY2lvbixcbiAgICAndG8tbnVtYmVyJzogQ29lcmNpb24sXG4gICAgJ3RvLXN0cmluZyc6IENvZXJjaW9uLFxuICAgICd2YXInOiBWYXIsXG4gICAgJ3dpdGhpbic6IFdpdGhpblxufTtcbmZ1bmN0aW9uIHJnYmEoY3R4LCBbciwgZywgYiwgYV0pIHtcbiAgICByID0gci5ldmFsdWF0ZShjdHgpO1xuICAgIGcgPSBnLmV2YWx1YXRlKGN0eCk7XG4gICAgYiA9IGIuZXZhbHVhdGUoY3R4KTtcbiAgICBjb25zdCBhbHBoYSA9IGEgPyBhLmV2YWx1YXRlKGN0eCkgOiAxO1xuICAgIGNvbnN0IGVycm9yID0gdmFsaWRhdGVSR0JBKHIsIGcsIGIsIGFscGhhKTtcbiAgICBpZiAoZXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSAqIGFscGhhLCBnIC8gMjU1ICogYWxwaGEsIGIgLyAyNTUgKiBhbHBoYSwgYWxwaGEpO1xufVxuZnVuY3Rpb24gaGFzKGtleSwgb2JqKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmo7XG59XG5mdW5jdGlvbiBnZXQoa2V5LCBvYmopIHtcbiAgICBjb25zdCB2ID0gb2JqW2tleV07XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB2O1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKHYsIGEsIGksIGopIHtcbiAgICB3aGlsZSAoaSA8PSBqKSB7XG4gICAgICAgIGNvbnN0IG0gPSBpICsgaiA+PiAxO1xuICAgICAgICBpZiAoYVttXSA9PT0gdilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYVttXSA+IHYpXG4gICAgICAgICAgICBqID0gbSAtIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGkgPSBtICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdmFyYXJncyh0eXBlKSB7XG4gICAgcmV0dXJuIHsgdHlwZSB9O1xufVxuQ29tcG91bmRFeHByZXNzaW9uLnJlZ2lzdGVyKGV4cHJlc3Npb25zLCB7XG4gICAgJ2Vycm9yJzogW1xuICAgICAgICBFcnJvclR5cGUsXG4gICAgICAgIFtTdHJpbmdUeXBlXSxcbiAgICAgICAgKGN0eCwgW3ZdKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKHYuZXZhbHVhdGUoY3R4KSk7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd0eXBlb2YnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICAoY3R4LCBbdl0pID0+IHRvU3RyaW5nKHR5cGVPZih2LmV2YWx1YXRlKGN0eCkpKVxuICAgIF0sXG4gICAgJ3RvLXJnYmEnOiBbXG4gICAgICAgIGFycmF5KE51bWJlclR5cGUsIDQpLFxuICAgICAgICBbQ29sb3JUeXBlXSxcbiAgICAgICAgKGN0eCwgW3ZdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdi5ldmFsdWF0ZShjdHgpLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ3JnYic6IFtcbiAgICAgICAgQ29sb3JUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgcmdiYVxuICAgIF0sXG4gICAgJ3JnYmEnOiBbXG4gICAgICAgIENvbG9yVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICByZ2JhXG4gICAgXSxcbiAgICAnaGFzJzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAgICAgICAgIChjdHgsIFtrZXldKSA9PiBoYXMoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0VHlwZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgKGN0eCwgW2tleSwgb2JqXSkgPT4gaGFzKGtleS5ldmFsdWF0ZShjdHgpLCBvYmouZXZhbHVhdGUoY3R4KSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgJ2dldCc6IHtcbiAgICAgICAgdHlwZTogVmFsdWVUeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgICAgICAgICAgKGN0eCwgW2tleV0pID0+IGdldChrZXkuZXZhbHVhdGUoY3R4KSwgY3R4LnByb3BlcnRpZXMoKSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3RUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAoY3R4LCBba2V5LCBvYmpdKSA9PiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIG9iai5ldmFsdWF0ZShjdHgpKVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnZmVhdHVyZS1zdGF0ZSc6IFtcbiAgICAgICAgVmFsdWVUeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIChjdHgsIFtrZXldKSA9PiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5mZWF0dXJlU3RhdGUgfHwge30pXG4gICAgXSxcbiAgICAncHJvcGVydGllcyc6IFtcbiAgICAgICAgT2JqZWN0VHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGN0eCA9PiBjdHgucHJvcGVydGllcygpXG4gICAgXSxcbiAgICAnZ2VvbWV0cnktdHlwZSc6IFtcbiAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGN0eCA9PiBjdHguZ2VvbWV0cnlUeXBlKClcbiAgICBdLFxuICAgICdpZCc6IFtcbiAgICAgICAgVmFsdWVUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgY3R4ID0+IGN0eC5pZCgpXG4gICAgXSxcbiAgICAnem9vbSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGN0eCA9PiBjdHguZ2xvYmFscy56b29tXG4gICAgXSxcbiAgICAncGl0Y2gnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBjdHggPT4gY3R4Lmdsb2JhbHMucGl0Y2ggfHwgMFxuICAgIF0sXG4gICAgJ2Rpc3RhbmNlLWZyb20tY2VudGVyJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgY3R4ID0+IGN0eC5kaXN0YW5jZUZyb21DZW50ZXIoKVxuICAgIF0sXG4gICAgJ2hlYXRtYXAtZGVuc2l0eSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGN0eCA9PiBjdHguZ2xvYmFscy5oZWF0bWFwRGVuc2l0eSB8fCAwXG4gICAgXSxcbiAgICAnbGluZS1wcm9ncmVzcyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGN0eCA9PiBjdHguZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMFxuICAgIF0sXG4gICAgJ3NreS1yYWRpYWwtcHJvZ3Jlc3MnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBjdHggPT4gY3R4Lmdsb2JhbHMuc2t5UmFkaWFsUHJvZ3Jlc3MgfHwgMFxuICAgIF0sXG4gICAgJ2FjY3VtdWxhdGVkJzogW1xuICAgICAgICBWYWx1ZVR5cGUsXG4gICAgICAgIFtdLFxuICAgICAgICBjdHggPT4gY3R4Lmdsb2JhbHMuYWNjdW11bGF0ZWQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdHguZ2xvYmFscy5hY2N1bXVsYXRlZFxuICAgIF0sXG4gICAgJysnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIHZhcmFyZ3MoTnVtYmVyVHlwZSksXG4gICAgICAgIChjdHgsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICcqJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICAoY3R4LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKj0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnLSc6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAoY3R4LCBbYSwgYl0pID0+IGEuZXZhbHVhdGUoY3R4KSAtIGIuZXZhbHVhdGUoY3R4KVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgICAgICAgICAgKGN0eCwgW2FdKSA9PiAtYS5ldmFsdWF0ZShjdHgpXG4gICAgICAgICAgICBdXG4gICAgICAgIF1cbiAgICB9LFxuICAgICcvJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICAgICAgTnVtYmVyVHlwZVxuICAgICAgICBdLFxuICAgICAgICAoY3R4LCBbYSwgYl0pID0+IGEuZXZhbHVhdGUoY3R4KSAvIGIuZXZhbHVhdGUoY3R4KVxuICAgIF0sXG4gICAgJyUnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgICAgICBOdW1iZXJUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIChjdHgsIFthLCBiXSkgPT4gYS5ldmFsdWF0ZShjdHgpICUgYi5ldmFsdWF0ZShjdHgpXG4gICAgXSxcbiAgICAnbG4yJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgKCkgPT4gTWF0aC5MTjJcbiAgICBdLFxuICAgICdwaSc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgICgpID0+IE1hdGguUElcbiAgICBdLFxuICAgICdlJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbXSxcbiAgICAgICAgKCkgPT4gTWF0aC5FXG4gICAgXSxcbiAgICAnXic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgICAgIE51bWJlclR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgKGN0eCwgW2IsIGVdKSA9PiBNYXRoLnBvdyhiLmV2YWx1YXRlKGN0eCksIGUuZXZhbHVhdGUoY3R4KSlcbiAgICBdLFxuICAgICdzcXJ0JzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIChjdHgsIFt4XSkgPT4gTWF0aC5zcXJ0KHguZXZhbHVhdGUoY3R4KSlcbiAgICBdLFxuICAgICdsb2cxMCc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSkgLyBNYXRoLkxOMTBcbiAgICBdLFxuICAgICdsbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSlcbiAgICBdLFxuICAgICdsb2cyJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIChjdHgsIFtuXSkgPT4gTWF0aC5sb2cobi5ldmFsdWF0ZShjdHgpKSAvIE1hdGguTE4yXG4gICAgXSxcbiAgICAnc2luJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIChjdHgsIFtuXSkgPT4gTWF0aC5zaW4obi5ldmFsdWF0ZShjdHgpKVxuICAgIF0sXG4gICAgJ2Nvcyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguY29zKG4uZXZhbHVhdGUoY3R4KSlcbiAgICBdLFxuICAgICd0YW4nOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLnRhbihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnYXNpbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguYXNpbihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnYWNvcyc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguYWNvcyhuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnYXRhbic6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguYXRhbihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnbWluJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICB2YXJhcmdzKE51bWJlclR5cGUpLFxuICAgICAgICAoY3R4LCBhcmdzKSA9PiBNYXRoLm1pbiguLi5hcmdzLm1hcChhcmcgPT4gYXJnLmV2YWx1YXRlKGN0eCkpKVxuICAgIF0sXG4gICAgJ21heCc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgdmFyYXJncyhOdW1iZXJUeXBlKSxcbiAgICAgICAgKGN0eCwgYXJncykgPT4gTWF0aC5tYXgoLi4uYXJncy5tYXAoYXJnID0+IGFyZy5ldmFsdWF0ZShjdHgpKSlcbiAgICBdLFxuICAgICdhYnMnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgKGN0eCwgW25dKSA9PiBNYXRoLmFicyhuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAncm91bmQnOiBbXG4gICAgICAgIE51bWJlclR5cGUsXG4gICAgICAgIFtOdW1iZXJUeXBlXSxcbiAgICAgICAgKGN0eCwgW25dKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ID0gbi5ldmFsdWF0ZShjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHYgPCAwID8gLU1hdGgucm91bmQoLXYpIDogTWF0aC5yb3VuZCh2KTtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2Zsb29yJzogW1xuICAgICAgICBOdW1iZXJUeXBlLFxuICAgICAgICBbTnVtYmVyVHlwZV0sXG4gICAgICAgIChjdHgsIFtuXSkgPT4gTWF0aC5mbG9vcihuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnY2VpbCc6IFtcbiAgICAgICAgTnVtYmVyVHlwZSxcbiAgICAgICAgW051bWJlclR5cGVdLFxuICAgICAgICAoY3R4LCBbbl0pID0+IE1hdGguY2VpbChuLmV2YWx1YXRlKGN0eCkpXG4gICAgXSxcbiAgICAnZmlsdGVyLT09JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICAoY3R4LCBbaywgdl0pID0+IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0gPT09IHYudmFsdWVcbiAgICBdLFxuICAgICdmaWx0ZXItaWQtPT0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgKGN0eCwgW3ZdKSA9PiBjdHguaWQoKSA9PT0gdi52YWx1ZVxuICAgIF0sXG4gICAgJ2ZpbHRlci10eXBlLT09JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1N0cmluZ1R5cGVdLFxuICAgICAgICAoY3R4LCBbdl0pID0+IGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gdi52YWx1ZVxuICAgIF0sXG4gICAgJ2ZpbHRlci08JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICAoY3R4LCBbaywgdl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjdHgucHJvcGVydGllcygpW2sudmFsdWVdO1xuICAgICAgICAgICAgY29uc3QgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPCBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLTwnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgKGN0eCwgW3ZdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gY3R4LmlkKCk7XG4gICAgICAgICAgICBjb25zdCBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPic6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBWYWx1ZVR5cGVcbiAgICAgICAgXSxcbiAgICAgICAgKGN0eCwgW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID4gYjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pZC0+JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIChjdHgsIFt2XSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IGN0eC5pZCgpO1xuICAgICAgICAgICAgY29uc3QgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPiBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLTw9JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIFZhbHVlVHlwZVxuICAgICAgICBdLFxuICAgICAgICAoY3R4LCBbaywgdl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjdHgucHJvcGVydGllcygpW2sudmFsdWVdO1xuICAgICAgICAgICAgY29uc3QgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPD0gYjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1pZC08PSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtWYWx1ZVR5cGVdLFxuICAgICAgICAoY3R4LCBbdl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjdHguaWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSB2LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDw9IGI7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICdmaWx0ZXItPj0nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbXG4gICAgICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICAgICAgVmFsdWVUeXBlXG4gICAgICAgIF0sXG4gICAgICAgIChjdHgsIFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07XG4gICAgICAgICAgICBjb25zdCBiID0gdi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+PSBiO1xuICAgICAgICB9XG4gICAgXSxcbiAgICAnZmlsdGVyLWlkLT49JzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1ZhbHVlVHlwZV0sXG4gICAgICAgIChjdHgsIFt2XSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IGN0eC5pZCgpO1xuICAgICAgICAgICAgY29uc3QgYiA9IHYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPj0gYjtcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJ2ZpbHRlci1oYXMnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbVmFsdWVUeXBlXSxcbiAgICAgICAgKGN0eCwgW2tdKSA9PiBrLnZhbHVlIGluIGN0eC5wcm9wZXJ0aWVzKClcbiAgICBdLFxuICAgICdmaWx0ZXItaGFzLWlkJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW10sXG4gICAgICAgIGN0eCA9PiBjdHguaWQoKSAhPT0gbnVsbCAmJiBjdHguaWQoKSAhPT0gdW5kZWZpbmVkXG4gICAgXSxcbiAgICAnZmlsdGVyLXR5cGUtaW4nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbYXJyYXkoU3RyaW5nVHlwZSldLFxuICAgICAgICAoY3R4LCBbdl0pID0+IHYudmFsdWUuaW5kZXhPZihjdHguZ2VvbWV0cnlUeXBlKCkpID49IDBcbiAgICBdLFxuICAgICdmaWx0ZXItaWQtaW4nOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbYXJyYXkoVmFsdWVUeXBlKV0sXG4gICAgICAgIChjdHgsIFt2XSkgPT4gdi52YWx1ZS5pbmRleE9mKGN0eC5pZCgpKSA+PSAwXG4gICAgXSxcbiAgICAnZmlsdGVyLWluLXNtYWxsJzogW1xuICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgW1xuICAgICAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgICAgIGFycmF5KFZhbHVlVHlwZSlcbiAgICAgICAgXSxcbiAgICAgICAgKGN0eCwgW2ssIHZdKSA9PiB2LnZhbHVlLmluZGV4T2YoY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXSkgPj0gMFxuICAgIF0sXG4gICAgJ2ZpbHRlci1pbi1sYXJnZSc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtcbiAgICAgICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgICAgICBhcnJheShWYWx1ZVR5cGUpXG4gICAgICAgIF0sXG4gICAgICAgIChjdHgsIFtrLCB2XSkgPT4gYmluYXJ5U2VhcmNoKGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0sIHYudmFsdWUsIDAsIHYudmFsdWUubGVuZ3RoIC0gMSlcbiAgICBdLFxuICAgICdhbGwnOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgICAgICBvdmVybG9hZHM6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgKGN0eCwgW2EsIGJdKSA9PiBhLmV2YWx1YXRlKGN0eCkgJiYgYi5ldmFsdWF0ZShjdHgpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHZhcmFyZ3MoQm9vbGVhblR5cGUpLFxuICAgICAgICAgICAgICAgIChjdHgsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcuZXZhbHVhdGUoY3R4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnYW55Jzoge1xuICAgICAgICB0eXBlOiBCb29sZWFuVHlwZSxcbiAgICAgICAgb3ZlcmxvYWRzOiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBCb29sZWFuVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhblR5cGVcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIChjdHgsIFthLCBiXSkgPT4gYS5ldmFsdWF0ZShjdHgpIHx8IGIuZXZhbHVhdGUoY3R4KVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB2YXJhcmdzKEJvb2xlYW5UeXBlKSxcbiAgICAgICAgICAgICAgICAoY3R4LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcuZXZhbHVhdGUoY3R4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfSxcbiAgICAnISc6IFtcbiAgICAgICAgQm9vbGVhblR5cGUsXG4gICAgICAgIFtCb29sZWFuVHlwZV0sXG4gICAgICAgIChjdHgsIFtiXSkgPT4gIWIuZXZhbHVhdGUoY3R4KVxuICAgIF0sXG4gICAgJ2lzLXN1cHBvcnRlZC1zY3JpcHQnOiBbXG4gICAgICAgIEJvb2xlYW5UeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIChjdHgsIFtzXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNTdXBwb3J0ZWRTY3JpcHQgPSBjdHguZ2xvYmFscyAmJiBjdHguZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDtcbiAgICAgICAgICAgIGlmIChpc1N1cHBvcnRlZFNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZFNjcmlwdChzLmV2YWx1YXRlKGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICBdLFxuICAgICd1cGNhc2UnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIFtTdHJpbmdUeXBlXSxcbiAgICAgICAgKGN0eCwgW3NdKSA9PiBzLmV2YWx1YXRlKGN0eCkudG9VcHBlckNhc2UoKVxuICAgIF0sXG4gICAgJ2Rvd25jYXNlJzogW1xuICAgICAgICBTdHJpbmdUeXBlLFxuICAgICAgICBbU3RyaW5nVHlwZV0sXG4gICAgICAgIChjdHgsIFtzXSkgPT4gcy5ldmFsdWF0ZShjdHgpLnRvTG93ZXJDYXNlKClcbiAgICBdLFxuICAgICdjb25jYXQnOiBbXG4gICAgICAgIFN0cmluZ1R5cGUsXG4gICAgICAgIHZhcmFyZ3MoVmFsdWVUeXBlKSxcbiAgICAgICAgKGN0eCwgYXJncykgPT4gYXJncy5tYXAoYXJnID0+IHRvU3RyaW5nJDEoYXJnLmV2YWx1YXRlKGN0eCkpKS5qb2luKCcnKVxuICAgIF0sXG4gICAgJ3Jlc29sdmVkLWxvY2FsZSc6IFtcbiAgICAgICAgU3RyaW5nVHlwZSxcbiAgICAgICAgW0NvbGxhdG9yVHlwZV0sXG4gICAgICAgIChjdHgsIFtjb2xsYXRvcl0pID0+IGNvbGxhdG9yLmV2YWx1YXRlKGN0eCkucmVzb2x2ZWRMb2NhbGUoKVxuICAgIF1cbn0pO1xuXG5mdW5jdGlvbiBzdWNjZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiAnc3VjY2VzcycsXG4gICAgICAgIHZhbHVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiAnZXJyb3InLFxuICAgICAgICB2YWx1ZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHNwZWMpIHtcbiAgICByZXR1cm4gc3BlY1sncHJvcGVydHktdHlwZSddID09PSAnZGF0YS1kcml2ZW4nIHx8IHNwZWNbJ3Byb3BlcnR5LXR5cGUnXSA9PT0gJ2Nyb3NzLWZhZGVkLWRhdGEtZHJpdmVuJztcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzWm9vbUV4cHJlc3Npb24oc3BlYykge1xuICAgIHJldHVybiAhIXNwZWMuZXhwcmVzc2lvbiAmJiBzcGVjLmV4cHJlc3Npb24ucGFyYW1ldGVycy5pbmRleE9mKCd6b29tJykgPiAtMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJwb2xhdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuICEhc3BlYy5leHByZXNzaW9uICYmIHNwZWMuZXhwcmVzc2lvbi5pbnRlcnBvbGF0ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFR5cGUodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uJDEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICAgIGNvbnN0IGlzQ29sb3IgPSBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJztcbiAgICBjb25zdCB6b29tQW5kRmVhdHVyZURlcGVuZGVudCA9IHBhcmFtZXRlcnMuc3RvcHMgJiYgdHlwZW9mIHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0gPT09ICdvYmplY3QnO1xuICAgIGNvbnN0IGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICAgIGNvbnN0IHR5cGUgPSBwYXJhbWV0ZXJzLnR5cGUgfHwgKHN1cHBvcnRzSW50ZXJwb2xhdGlvbihwcm9wZXJ0eVNwZWMpID8gJ2V4cG9uZW50aWFsJyA6ICdpbnRlcnZhbCcpO1xuICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBleHRlbmQoe30sIHBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAocGFyYW1ldGVycy5zdG9wcykge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5zdG9wcyA9IHBhcmFtZXRlcnMuc3RvcHMubWFwKHN0b3AgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHN0b3BbMF0sXG4gICAgICAgICAgICAgICAgICAgIENvbG9yLnBhcnNlKHN0b3BbMV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdCA9IENvbG9yLnBhcnNlKHBhcmFtZXRlcnMuZGVmYXVsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBDb2xvci5wYXJzZShwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InICYmICFjb2xvclNwYWNlc1twYXJhbWV0ZXJzLmNvbG9yU3BhY2VdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb2xvciBzcGFjZTogJHsgcGFyYW1ldGVycy5jb2xvclNwYWNlIH1gKTtcbiAgICB9XG4gICAgbGV0IGlubmVyRnVuO1xuICAgIGxldCBoYXNoZWRTdG9wcztcbiAgICBsZXQgY2F0ZWdvcmljYWxLZXlUeXBlO1xuICAgIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIGlubmVyRnVuID0gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICBpbm5lckZ1biA9IGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXRlZ29yaWNhbCcpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb247XG4gICAgICAgIGhhc2hlZFN0b3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBzdG9wIG9mIHBhcmFtZXRlcnMuc3RvcHMpIHtcbiAgICAgICAgICAgIGhhc2hlZFN0b3BzW3N0b3BbMF1dID0gc3RvcFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRlZ29yaWNhbEtleVR5cGUgPSB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZ1bmN0aW9uIHR5cGUgXCIkeyB0eXBlIH1cImApO1xuICAgIH1cbiAgICBpZiAoem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZUZ1bmN0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCB6b29tU3RvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9wID0gcGFyYW1ldGVycy5zdG9wc1tzXTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBzdG9wWzBdLnpvb207XG4gICAgICAgICAgICBpZiAoZmVhdHVyZUZ1bmN0aW9uc1t6b29tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1t6b29tXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFyYW1ldGVycy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyYW1ldGVycy5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBzdG9wczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHpvb21TdG9wcy5wdXNoKHpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1t6b29tXS5zdG9wcy5wdXNoKFtcbiAgICAgICAgICAgICAgICBzdG9wWzBdLnZhbHVlLFxuICAgICAgICAgICAgICAgIHN0b3BbMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlYXR1cmVGdW5jdGlvblN0b3BzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeiBvZiB6b29tU3RvcHMpIHtcbiAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvblN0b3BzLnB1c2goW1xuICAgICAgICAgICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbel0uem9vbSxcbiAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25zW3pdLCBwcm9wZXJ0eVNwZWMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uVHlwZSA9IHsgbmFtZTogJ2xpbmVhcicgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjb21wb3NpdGUnLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGUsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uRmFjdG9yOiBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yLmJpbmQodW5kZWZpbmVkLCBpbnRlcnBvbGF0aW9uVHlwZSksXG4gICAgICAgICAgICB6b29tU3RvcHM6IGZlYXR1cmVGdW5jdGlvblN0b3BzLm1hcChzID0+IHNbMF0pLFxuICAgICAgICAgICAgZXZhbHVhdGUoe3pvb219LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BzOiBmZWF0dXJlRnVuY3Rpb25TdG9wcyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogcGFyYW1ldGVycy5iYXNlXG4gICAgICAgICAgICAgICAgfSwgcHJvcGVydHlTcGVjLCB6b29tKS5ldmFsdWF0ZSh6b29tLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHpvb21EZXBlbmRlbnQpIHtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvblR5cGUgPSB0eXBlID09PSAnZXhwb25lbnRpYWwnID8ge1xuICAgICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMVxuICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjYW1lcmEnLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGUsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uRmFjdG9yOiBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yLmJpbmQodW5kZWZpbmVkLCBpbnRlcnBvbGF0aW9uVHlwZSksXG4gICAgICAgICAgICB6b29tU3RvcHM6IHBhcmFtZXRlcnMuc3RvcHMubWFwKHMgPT4gc1swXSksXG4gICAgICAgICAgICBldmFsdWF0ZTogKHt6b29tfSkgPT4gaW5uZXJGdW4ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCB6b29tLCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnc291cmNlJyxcbiAgICAgICAgICAgIGV2YWx1YXRlKF8sIGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZlYXR1cmUgJiYgZmVhdHVyZS5wcm9wZXJ0aWVzID8gZmVhdHVyZS5wcm9wZXJ0aWVzW3BhcmFtZXRlcnMucHJvcGVydHldIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyRnVuKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgdmFsdWUsIGhhc2hlZFN0b3BzLCBjYXRlZ29yaWNhbEtleVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvYWxlc2NlKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAoYyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlQ2F0ZWdvcmljYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0LCBoYXNoZWRTdG9wcywga2V5VHlwZSkge1xuICAgIGNvbnN0IGV2YWx1YXRlZCA9IHR5cGVvZiBpbnB1dCA9PT0ga2V5VHlwZSA/IGhhc2hlZFN0b3BzW2lucHV0XSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gY29hbGVzY2UoZXZhbHVhdGVkLCBwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gICAgaWYgKGdldFR5cGUoaW5wdXQpICE9PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgIGNvbnN0IG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDtcbiAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gICAgaWYgKGlucHV0IDw9IHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0pXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICAgIGlmIChpbnB1dCA+PSBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVswXSlcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdO1xuICAgIGNvbnN0IGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhwYXJhbWV0ZXJzLnN0b3BzLm1hcChzdG9wID0+IHN0b3BbMF0pLCBpbnB1dCk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgICBjb25zdCBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxO1xuICAgIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICBjb25zdCBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7XG4gICAgaWYgKG4gPT09IDEpXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICAgIGlmIChpbnB1dCA8PSBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdKVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbiAgICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVsxXTtcbiAgICBjb25zdCBpbmRleCA9IGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8ocGFyYW1ldGVycy5zdG9wcy5tYXAoc3RvcCA9PiBzdG9wWzBdKSwgaW5wdXQpO1xuICAgIGNvbnN0IHQgPSBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBiYXNlLCBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVswXSwgcGFyYW1ldGVycy5zdG9wc1tpbmRleCArIDFdWzBdKTtcbiAgICBjb25zdCBvdXRwdXRMb3dlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xuICAgIGNvbnN0IG91dHB1dFVwcGVyID0gcGFyYW1ldGVycy5zdG9wc1tpbmRleCArIDFdWzFdO1xuICAgIGxldCBpbnRlcnAgPSBpbnRlcnBvbGF0ZVtwcm9wZXJ0eVNwZWMudHlwZV0gfHwgaWRlbnRpdHlGdW5jdGlvbjtcbiAgICBpZiAocGFyYW1ldGVycy5jb2xvclNwYWNlICYmIHBhcmFtZXRlcnMuY29sb3JTcGFjZSAhPT0gJ3JnYicpIHtcbiAgICAgICAgY29uc3QgY29sb3JzcGFjZSA9IGNvbG9yU3BhY2VzW3BhcmFtZXRlcnMuY29sb3JTcGFjZV07XG4gICAgICAgIGludGVycCA9IChhLCBiKSA9PiBjb2xvcnNwYWNlLnJldmVyc2UoY29sb3JzcGFjZS5pbnRlcnBvbGF0ZShjb2xvcnNwYWNlLmZvcndhcmQoYSksIGNvbG9yc3BhY2UuZm9yd2FyZChiKSwgdCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHB1dExvd2VyLmV2YWx1YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBldmFsdWF0ZSguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZhbHVhdGVkTG93ZXIgPSBvdXRwdXRMb3dlci5ldmFsdWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRlZFVwcGVyID0gb3V0cHV0VXBwZXIuZXZhbHVhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGVkTG93ZXIgPT09IHVuZGVmaW5lZCB8fCBldmFsdWF0ZWRVcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnAoZXZhbHVhdGVkTG93ZXIsIGV2YWx1YXRlZFVwcGVyLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVycChvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgaW5wdXQgPSBDb2xvci5wYXJzZShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICAgICAgaW5wdXQgPSBGb3JtYXR0ZWQuZnJvbVN0cmluZyhpbnB1dC50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgaW5wdXQgPSBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcoaW5wdXQudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gcHJvcGVydHlTcGVjLnR5cGUgJiYgKHByb3BlcnR5U3BlYy50eXBlICE9PSAnZW51bScgfHwgIXByb3BlcnR5U3BlYy52YWx1ZXNbaW5wdXRdKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNvYWxlc2NlKGlucHV0LCBwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGJhc2UsIGxvd2VyVmFsdWUsIHVwcGVyVmFsdWUpIHtcbiAgICBjb25zdCBkaWZmZXJlbmNlID0gdXBwZXJWYWx1ZSAtIGxvd2VyVmFsdWU7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBpbnB1dCAtIGxvd2VyVmFsdWU7XG4gICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhiYXNlLCBwcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkaWZmZXJlbmNlKSAtIDEpO1xuICAgIH1cbn1cblxuY2xhc3MgU3R5bGVFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5fd2FybmluZ0hpc3RvcnkgPSB7fTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yID0gbmV3IEV2YWx1YXRpb25Db250ZXh0KCk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IHByb3BlcnR5U3BlYyA/IGdldERlZmF1bHRWYWx1ZShwcm9wZXJ0eVNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy5fZW51bVZhbHVlcyA9IHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2VudW0nID8gcHJvcGVydHlTcGVjLnZhbHVlcyA6IG51bGw7XG4gICAgfVxuICAgIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbiwgZmVhdHVyZVRpbGVDb29yZCwgZmVhdHVyZURpc3RhbmNlRGF0YSkge1xuICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IGZlYXR1cmVTdGF0ZTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmNhbm9uaWNhbCA9IGNhbm9uaWNhbDtcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb247XG4gICAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlVGlsZUNvb3JkID0gZmVhdHVyZVRpbGVDb29yZCB8fCBudWxsO1xuICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZURpc3RhbmNlRGF0YSA9IGZlYXR1cmVEaXN0YW5jZURhdGEgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpO1xuICAgIH1cbiAgICBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uLCBmZWF0dXJlVGlsZUNvb3JkLCBmZWF0dXJlRGlzdGFuY2VEYXRhKSB7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRvci5nbG9iYWxzID0gZ2xvYmFscztcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlU3RhdGUgPSBmZWF0dXJlU3RhdGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmNhbm9uaWNhbCA9IGNhbm9uaWNhbDtcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb24gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVUaWxlQ29vcmQgPSBmZWF0dXJlVGlsZUNvb3JkIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlRGlzdGFuY2VEYXRhID0gZmVhdHVyZURpc3RhbmNlRGF0YSB8fCBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG4gICAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbnVtVmFsdWVzICYmICEodmFsIGluIHRoaXMuX2VudW1WYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mICR7IE9iamVjdC5rZXlzKHRoaXMuX2VudW1WYWx1ZXMpLm1hcCh2ID0+IEpTT04uc3RyaW5naWZ5KHYpKS5qb2luKCcsICcpIH0sIGJ1dCBmb3VuZCAkeyBKU09OLnN0cmluZ2lmeSh2YWwpIH0gaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2FybmluZ0hpc3RvcnlbZS5tZXNzYWdlXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikgJiYgZXhwcmVzc2lvbi5sZW5ndGggPiAwICYmIHR5cGVvZiBleHByZXNzaW9uWzBdID09PSAnc3RyaW5nJyAmJiBleHByZXNzaW9uWzBdIGluIGV4cHJlc3Npb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2luZ0NvbnRleHQoZXhwcmVzc2lvbnMsIFtdLCBwcm9wZXJ0eVNwZWMgPyBnZXRFeHBlY3RlZFR5cGUocHJvcGVydHlTcGVjKSA6IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlKGV4cHJlc3Npb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyB7IHR5cGVBbm5vdGF0aW9uOiAnY29lcmNlJyB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICByZXR1cm4gZXJyb3IocGFyc2VyLmVycm9ycyk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKG5ldyBTdHlsZUV4cHJlc3Npb24ocGFyc2VkLCBwcm9wZXJ0eVNwZWMpKTtcbn1cbmNsYXNzIFpvb21Db25zdGFudEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGtpbmQsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NvbnN0YW50JyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb24uZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG4gICAgfVxuICAgIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbiAgICB9XG59XG5jbGFzcyBab29tRGVwZW5kZW50RXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Ioa2luZCwgZXhwcmVzc2lvbiwgem9vbVN0b3BzLCBpbnRlcnBvbGF0aW9uVHlwZSkge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB0aGlzLnpvb21TdG9wcyA9IHpvb21TdG9wcztcbiAgICAgICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0ga2luZCAhPT0gJ2NhbWVyYScgJiYgIWlzU3RhdGVDb25zdGFudChleHByZXNzaW9uLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID0gaW50ZXJwb2xhdGlvblR5cGU7XG4gICAgfVxuICAgIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG4gICAgfVxuICAgIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKTtcbiAgICB9XG4gICAgaW50ZXJwb2xhdGlvbkZhY3RvcihpbnB1dCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb25UeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb25UeXBlLCBpbnB1dCwgbG93ZXIsIHVwcGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xuICAgIGV4cHJlc3Npb24gPSBjcmVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYyk7XG4gICAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBleHByZXNzaW9uLnZhbHVlLmV4cHJlc3Npb247XG4gICAgY29uc3QgaXNGZWF0dXJlQ29uc3RhbnQkMSA9IGlzRmVhdHVyZUNvbnN0YW50KHBhcnNlZCk7XG4gICAgaWYgKCFpc0ZlYXR1cmVDb25zdGFudCQxICYmICFzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihwcm9wZXJ0eVNwZWMpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ2RhdGEgZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZCcpXSk7XG4gICAgfVxuICAgIGNvbnN0IGlzWm9vbUNvbnN0YW50ID0gaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KHBhcnNlZCwgW1xuICAgICAgICAnem9vbScsXG4gICAgICAgICdwaXRjaCcsXG4gICAgICAgICdkaXN0YW5jZS1mcm9tLWNlbnRlcidcbiAgICBdKTtcbiAgICBpZiAoIWlzWm9vbUNvbnN0YW50ICYmICFzdXBwb3J0c1pvb21FeHByZXNzaW9uKHByb3BlcnR5U3BlYykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnem9vbSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkJyldKTtcbiAgICB9XG4gICAgY29uc3Qgem9vbUN1cnZlID0gZmluZFpvb21DdXJ2ZShwYXJzZWQpO1xuICAgIGlmICghem9vbUN1cnZlICYmICFpc1pvb21Db25zdGFudCkge1xuICAgICAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IoJycsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJyldKTtcbiAgICB9IGVsc2UgaWYgKHpvb21DdXJ2ZSBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IoW3pvb21DdXJ2ZV0pO1xuICAgIH0gZWxzZSBpZiAoem9vbUN1cnZlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGUgJiYgIXN1cHBvcnRzSW50ZXJwb2xhdGlvbihwcm9wZXJ0eVNwZWMpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ1wiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBjYW5ub3QgYmUgdXNlZCB3aXRoIHRoaXMgcHJvcGVydHknKV0pO1xuICAgIH1cbiAgICBpZiAoIXpvb21DdXJ2ZSkge1xuICAgICAgICByZXR1cm4gc3VjY2Vzcyhpc0ZlYXR1cmVDb25zdGFudCQxID8gbmV3IFpvb21Db25zdGFudEV4cHJlc3Npb24oJ2NvbnN0YW50JywgZXhwcmVzc2lvbi52YWx1ZSkgOiBuZXcgWm9vbUNvbnN0YW50RXhwcmVzc2lvbignc291cmNlJywgZXhwcmVzc2lvbi52YWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uVHlwZSA9IHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlID8gem9vbUN1cnZlLmludGVycG9sYXRpb24gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoaXNGZWF0dXJlQ29uc3RhbnQkMSA/IG5ldyBab29tRGVwZW5kZW50RXhwcmVzc2lvbignY2FtZXJhJywgZXhwcmVzc2lvbi52YWx1ZSwgem9vbUN1cnZlLmxhYmVscywgaW50ZXJwb2xhdGlvblR5cGUpIDogbmV3IFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKCdjb21wb3NpdGUnLCBleHByZXNzaW9uLnZhbHVlLCB6b29tQ3VydmUubGFiZWxzLCBpbnRlcnBvbGF0aW9uVHlwZSkpO1xufVxuY2xhc3MgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCBzcGVjaWZpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9zcGVjaWZpY2F0aW9uID0gc3BlY2lmaWNhdGlvbjtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGNyZWF0ZUZ1bmN0aW9uKHRoaXMuX3BhcmFtZXRlcnMsIHRoaXMuX3NwZWNpZmljYXRpb24pKTtcbiAgICB9XG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHlsZVByb3BlcnR5RnVuY3Rpb24oc2VyaWFsaXplZC5fcGFyYW1ldGVycywgc2VyaWFsaXplZC5fc3BlY2lmaWNhdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBzZXJpYWxpemUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzOiBpbnB1dC5fcGFyYW1ldGVycyxcbiAgICAgICAgICAgIF9zcGVjaWZpY2F0aW9uOiBpbnB1dC5fc3BlY2lmaWNhdGlvblxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbikge1xuICAgIGlmIChpc0Z1bmN0aW9uJDEodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cHJlc3Npb24udmFsdWUubWFwKGVyciA9PiBgJHsgZXJyLmtleSB9OiAkeyBlcnIubWVzc2FnZSB9YCkuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbnN0YW50ID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHNwZWNpZmljYXRpb24udHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgY29uc3RhbnQgPSBDb2xvci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdjb25zdGFudCcsXG4gICAgICAgICAgICBldmFsdWF0ZTogKCkgPT4gY29uc3RhbnRcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24pIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIExldCkge1xuICAgICAgICByZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24ucmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2FsZXNjZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBleHByZXNzaW9uLmFyZ3MpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbmRab29tQ3VydmUoYXJnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBTdGVwIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSkgJiYgZXhwcmVzc2lvbi5pbnB1dCBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBleHByZXNzaW9uLmlucHV0Lm5hbWUgPT09ICd6b29tJykge1xuICAgICAgICByZXN1bHQgPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGV4cHJlc3Npb24uZWFjaENoaWxkKGNoaWxkID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRSZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkUmVzdWx0IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjaGlsZFJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghcmVzdWx0ICYmIGNoaWxkUmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUGFyc2luZ0Vycm9yKCcnLCAnXCJ6b29tXCIgZXhwcmVzc2lvbiBtYXkgb25seSBiZSB1c2VkIGFzIGlucHV0IHRvIGEgdG9wLWxldmVsIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9uLicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiBjaGlsZFJlc3VsdCAmJiByZXN1bHQgIT09IGNoaWxkUmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUGFyc2luZ0Vycm9yKCcnLCAnT25seSBvbmUgem9vbS1iYXNlZCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgc3ViZXhwcmVzc2lvbiBtYXkgYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uLicpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEV4cGVjdGVkVHlwZShzcGVjKSB7XG4gICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgIGNvbG9yOiBDb2xvclR5cGUsXG4gICAgICAgIHN0cmluZzogU3RyaW5nVHlwZSxcbiAgICAgICAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICAgICAgICBlbnVtOiBTdHJpbmdUeXBlLFxuICAgICAgICBib29sZWFuOiBCb29sZWFuVHlwZSxcbiAgICAgICAgZm9ybWF0dGVkOiBGb3JtYXR0ZWRUeXBlLFxuICAgICAgICByZXNvbHZlZEltYWdlOiBSZXNvbHZlZEltYWdlVHlwZVxuICAgIH07XG4gICAgaWYgKHNwZWMudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gYXJyYXkodHlwZXNbc3BlYy52YWx1ZV0gfHwgVmFsdWVUeXBlLCBzcGVjLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlc1tzcGVjLnR5cGVdO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKHNwZWMpIHtcbiAgICBpZiAoc3BlYy50eXBlID09PSAnY29sb3InICYmIGlzRnVuY3Rpb24kMShzcGVjLmRlZmF1bHQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgfSBlbHNlIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yLnBhcnNlKHNwZWMuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICB9IGVsc2UgaWYgKHNwZWMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcGVjLmRlZmF1bHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gW1xuICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgIHZhbHVlXG4gICAgXSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gY29udmVydEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICAgIGxldCBzdG9wcyA9IHBhcmFtZXRlcnMuc3RvcHM7XG4gICAgaWYgKCFzdG9wcykge1xuICAgICAgICByZXR1cm4gY29udmVydElkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKTtcbiAgICB9XG4gICAgY29uc3Qgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSBzdG9wcyAmJiB0eXBlb2Ygc3RvcHNbMF1bMF0gPT09ICdvYmplY3QnO1xuICAgIGNvbnN0IGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICAgIHN0b3BzID0gc3RvcHMubWFwKHN0b3AgPT4ge1xuICAgICAgICBpZiAoIWZlYXR1cmVEZXBlbmRlbnQgJiYgcHJvcGVydHlTcGVjLnRva2VucyAmJiB0eXBlb2Ygc3RvcFsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc3RvcFswXSxcbiAgICAgICAgICAgICAgICBjb252ZXJ0VG9rZW5TdHJpbmcoc3RvcFsxXSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHN0b3BbMF0sXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChzdG9wWzFdKVxuICAgICAgICBdO1xuICAgIH0pO1xuICAgIGlmICh6b29tQW5kRmVhdHVyZURlcGVuZGVudCkge1xuICAgICAgICByZXR1cm4gY29udmVydFpvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpO1xuICAgIH0gZWxzZSBpZiAoem9vbURlcGVuZGVudCkge1xuICAgICAgICByZXR1cm4gY29udmVydFpvb21GdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udmVydFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydElkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKSB7XG4gICAgY29uc3QgZ2V0ID0gW1xuICAgICAgICAnZ2V0JyxcbiAgICAgICAgcGFyYW1ldGVycy5wcm9wZXJ0eVxuICAgIF07XG4gICAgaWYgKHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgIGdldFxuICAgICAgICBdIDogZ2V0O1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdlbnVtJykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ21hdGNoJyxcbiAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5U3BlYy52YWx1ZXMpLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgcGFyYW1ldGVycy5kZWZhdWx0XG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFtcbiAgICAgICAgICAgIHByb3BlcnR5U3BlYy50eXBlID09PSAnY29sb3InID8gJ3RvLWNvbG9yJyA6IHByb3BlcnR5U3BlYy50eXBlLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgY29udmVydExpdGVyYWwocGFyYW1ldGVycy5kZWZhdWx0KVxuICAgICAgICBdO1xuICAgICAgICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24uc3BsaWNlKDEsIDAsIHByb3BlcnR5U3BlYy52YWx1ZSwgcHJvcGVydHlTcGVjLmxlbmd0aCB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzd2l0Y2ggKHBhcmFtZXRlcnMuY29sb3JTcGFjZSkge1xuICAgIGNhc2UgJ2hjbCc6XG4gICAgICAgIHJldHVybiAnaW50ZXJwb2xhdGUtaGNsJztcbiAgICBjYXNlICdsYWInOlxuICAgICAgICByZXR1cm4gJ2ludGVycG9sYXRlLWxhYic7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdpbnRlcnBvbGF0ZSc7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFpvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpIHtcbiAgICBjb25zdCBmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzID0ge307XG4gICAgY29uc3QgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSB7fTtcbiAgICBjb25zdCB6b29tU3RvcHMgPSBbXTtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IHN0b3BzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIGNvbnN0IHN0b3AgPSBzdG9wc1tzXTtcbiAgICAgICAgY29uc3Qgem9vbSA9IHN0b3BbMF0uem9vbTtcbiAgICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbem9vbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6b29tXSA9IHtcbiAgICAgICAgICAgICAgICB6b29tLFxuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtZXRlcnMudHlwZSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyYW1ldGVycy5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBwYXJhbWV0ZXJzLmRlZmF1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6b29tXSA9IFtdO1xuICAgICAgICAgICAgem9vbVN0b3BzLnB1c2goem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbem9vbV0ucHVzaChbXG4gICAgICAgICAgICBzdG9wWzBdLnZhbHVlLFxuICAgICAgICAgICAgc3RvcFsxXVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY29uc3QgZnVuY3Rpb25UeXBlID0gZ2V0RnVuY3Rpb25UeXBlKHt9LCBwcm9wZXJ0eVNwZWMpO1xuICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFtcbiAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksXG4gICAgICAgICAgICBbJ2xpbmVhciddLFxuICAgICAgICAgICAgWyd6b29tJ11cbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCB6IG9mIHpvb21TdG9wcykge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gY29udmVydFByb3BlcnR5RnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6XSwgcHJvcGVydHlTcGVjLCBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6XSk7XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uLCB6LCBvdXRwdXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gW1xuICAgICAgICAgICAgJ3N0ZXAnLFxuICAgICAgICAgICAgWyd6b29tJ11cbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCB6IG9mIHpvb21TdG9wcykge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gY29udmVydFByb3BlcnR5RnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6XSwgcHJvcGVydHlTcGVjLCBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6XSk7XG4gICAgICAgICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uLCB6LCBvdXRwdXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxufVxuZnVuY3Rpb24gY29hbGVzY2UkMShhLCBiKSB7XG4gICAgaWYgKGEgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKGIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBjb252ZXJ0TGl0ZXJhbChjb2FsZXNjZSQxKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpKTtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQgJiYgcHJvcGVydHlTcGVjLnR5cGUgPT09ICdyZXNvbHZlZEltYWdlJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpO1xuICAgIGNvbnN0IGdldCA9IFtcbiAgICAgICAgJ2dldCcsXG4gICAgICAgIHBhcmFtZXRlcnMucHJvcGVydHlcbiAgICBdO1xuICAgIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGVvZiBzdG9wc1swXVswXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBbJ2Nhc2UnXTtcbiAgICAgICAgZm9yIChjb25zdCBzdG9wIG9mIHN0b3BzKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uLnB1c2goW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgICAgIHN0b3BbMF1cbiAgICAgICAgICAgIF0sIHN0b3BbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpKTtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICAnbWF0Y2gnLFxuICAgICAgICAgICAgZ2V0XG4gICAgICAgIF07XG4gICAgICAgIGZvciAoY29uc3Qgc3RvcCBvZiBzdG9wcykge1xuICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiwgc3RvcFswXSwgc3RvcFsxXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaChnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpKTtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICAnc3RlcCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgICAgIGZvciAoY29uc3Qgc3RvcCBvZiBzdG9wcykge1xuICAgICAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiwgc3RvcFswXSwgc3RvcFsxXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBleHByZXNzaW9uIDogW1xuICAgICAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAndHlwZW9mJyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnbnVtYmVyJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBbXG4gICAgICAgICAgICBnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yKHBhcmFtZXRlcnMpLFxuICAgICAgICAgICAgYmFzZSA9PT0gMSA/IFsnbGluZWFyJ10gOiBbXG4gICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICAgICAgICBiYXNlXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgICAgIGdldFxuICAgICAgICAgICAgXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IHN0b3Agb2Ygc3RvcHMpIHtcbiAgICAgICAgICAgIGFwcGVuZFN0b3BQYWlyKGV4cHJlc3Npb24sIHN0b3BbMF0sIHN0b3BbMV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBleHByZXNzaW9uIDogW1xuICAgICAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICc9PScsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAndHlwZW9mJyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnbnVtYmVyJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHByb3BlcnR5IGZ1bmN0aW9uIHR5cGUgJHsgdHlwZSB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFpvb21GdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzLCBpbnB1dCA9IFsnem9vbSddKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpO1xuICAgIGxldCBleHByZXNzaW9uO1xuICAgIGxldCBpc1N0ZXAgPSBmYWxzZTtcbiAgICBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICBleHByZXNzaW9uID0gW1xuICAgICAgICAgICAgJ3N0ZXAnLFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgXTtcbiAgICAgICAgaXNTdGVwID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IFtcbiAgICAgICAgICAgIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksXG4gICAgICAgICAgICBiYXNlID09PSAxID8gWydsaW5lYXInXSA6IFtcbiAgICAgICAgICAgICAgICAnZXhwb25lbnRpYWwnLFxuICAgICAgICAgICAgICAgIGJhc2VcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB6b29tIGZ1bmN0aW9uIHR5cGUgXCIkeyB0eXBlIH1cImApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN0b3Agb2Ygc3RvcHMpIHtcbiAgICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiwgc3RvcFswXSwgc3RvcFsxXSwgaXNTdGVwKTtcbiAgICB9XG4gICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24pO1xuICAgIHJldHVybiBleHByZXNzaW9uO1xufVxuZnVuY3Rpb24gZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoZXhwcmVzc2lvblswXSA9PT0gJ3N0ZXAnICYmIGV4cHJlc3Npb24ubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGV4cHJlc3Npb24ucHVzaCgwKTtcbiAgICAgICAgZXhwcmVzc2lvbi5wdXNoKGV4cHJlc3Npb25bM10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZFN0b3BQYWlyKGN1cnZlLCBpbnB1dCwgb3V0cHV0LCBpc1N0ZXApIHtcbiAgICBpZiAoY3VydmUubGVuZ3RoID4gMyAmJiBpbnB1dCA9PT0gY3VydmVbY3VydmUubGVuZ3RoIC0gMl0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIShpc1N0ZXAgJiYgY3VydmUubGVuZ3RoID09PSAyKSkge1xuICAgICAgICBjdXJ2ZS5wdXNoKGlucHV0KTtcbiAgICB9XG4gICAgY3VydmUucHVzaChvdXRwdXQpO1xufVxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICAgIGlmIChwYXJhbWV0ZXJzLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMudHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlTcGVjLmV4cHJlc3Npb24uaW50ZXJwb2xhdGVkID8gJ2V4cG9uZW50aWFsJyA6ICdpbnRlcnZhbCc7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFRva2VuU3RyaW5nKHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbJ2NvbmNhdCddO1xuICAgIGNvbnN0IHJlID0gL3soW157fV0rKX0vZztcbiAgICBsZXQgcG9zID0gMDtcbiAgICBmb3IgKGxldCBtYXRjaCA9IHJlLmV4ZWMocyk7IG1hdGNoICE9PSBudWxsOyBtYXRjaCA9IHJlLmV4ZWMocykpIHtcbiAgICAgICAgY29uc3QgbGl0ZXJhbCA9IHMuc2xpY2UocG9zLCByZS5sYXN0SW5kZXggLSBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICBwb3MgPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChsaXRlcmFsLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXN1bHQucHVzaChsaXRlcmFsKTtcbiAgICAgICAgcmVzdWx0LnB1c2goW1xuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICBtYXRjaFsxXVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChwb3MgPCBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChzLnNsaWNlKHBvcykpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ3RvLXN0cmluZycsXG4gICAgICAgICAgICByZXN1bHRbMV1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdW5idW5kbGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZXBVbmJ1bmRsZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGRlZXBVbmJ1bmRsZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikpIHtcbiAgICAgICAgY29uc3QgdW5idW5kbGVkVmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHVuYnVuZGxlZFZhbHVlW2tleV0gPSBkZWVwVW5idW5kbGUodmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuYnVuZGxlZFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5idW5kbGUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBmaWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSB8fCBmaWx0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChmaWx0ZXJbMF0pIHtcbiAgICBjYXNlICdoYXMnOlxuICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCA+PSAyICYmIGZpbHRlclsxXSAhPT0gJyRpZCcgJiYgZmlsdGVyWzFdICE9PSAnJHR5cGUnO1xuICAgIGNhc2UgJ2luJzpcbiAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMyAmJiAodHlwZW9mIGZpbHRlclsxXSAhPT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pKTtcbiAgICBjYXNlICchaW4nOlxuICAgIGNhc2UgJyFoYXMnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICBjYXNlICc+JzpcbiAgICBjYXNlICc+PSc6XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPD0nOlxuICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCAhPT0gMyB8fCAoQXJyYXkuaXNBcnJheShmaWx0ZXJbMV0pIHx8IEFycmF5LmlzQXJyYXkoZmlsdGVyWzJdKSk7XG4gICAgY2FzZSAnYW55JzpcbiAgICBjYXNlICdhbGwnOlxuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgZmlsdGVyLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXhwcmVzc2lvbkZpbHRlcihmKSAmJiB0eXBlb2YgZiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihmaWx0ZXIsIGxheWVyVHlwZSA9ICdmaWxsJykge1xuICAgIGlmIChmaWx0ZXIgPT09IG51bGwgfHwgZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbHRlcjogKCkgPT4gdHJ1ZSxcbiAgICAgICAgICAgIG5lZWRHZW9tZXRyeTogZmFsc2UsXG4gICAgICAgICAgICBuZWVkRmVhdHVyZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBjb252ZXJ0RmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckV4cCA9IGZpbHRlcjtcbiAgICBsZXQgc3RhdGljRmlsdGVyID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBzdGF0aWNGaWx0ZXIgPSBleHRyYWN0U3RhdGljRmlsdGVyKGZpbHRlckV4cCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBleHRyYWN0IHN0YXRpYyBmaWx0ZXIuIEZpbHRlciB3aWxsIGNvbnRpbnVlIHdvcmtpbmcsIGJ1dCBhdCBoaWdoZXIgbWVtb3J5IHVzYWdlIGFuZCBzbG93ZXIgZnJhbWVyYXRlLlxuVGhpcyBpcyBtb3N0IGxpa2VseSBhIGJ1ZywgcGxlYXNlIHJlcG9ydCB0aGlzIHZpYSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvbmV3P2Fzc2lnbmVlcz0mbGFiZWxzPSZ0ZW1wbGF0ZT1CdWdfcmVwb3J0Lm1kXG5hbmQgcGFzdGUgdGhlIGNvbnRlbnRzIG9mIHRoaXMgbWVzc2FnZSBpbiB0aGUgcmVwb3J0LlxuVGhhbmsgeW91IVxuRmlsdGVyIEV4cHJlc3Npb246XG4keyBKU09OLnN0cmluZ2lmeShmaWx0ZXJFeHAsIG51bGwsIDIpIH1cbiAgICAgICAgYCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclNwZWMgPSB2OFtgZmlsdGVyXyR7IGxheWVyVHlwZSB9YF07XG4gICAgY29uc3QgY29tcGlsZWRTdGF0aWNGaWx0ZXIgPSBjcmVhdGVFeHByZXNzaW9uKHN0YXRpY0ZpbHRlciwgZmlsdGVyU3BlYyk7XG4gICAgbGV0IGZpbHRlckZ1bmMgPSBudWxsO1xuICAgIGlmIChjb21waWxlZFN0YXRpY0ZpbHRlci5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXBpbGVkU3RhdGljRmlsdGVyLnZhbHVlLm1hcChlcnIgPT4gYCR7IGVyci5rZXkgfTogJHsgZXJyLm1lc3NhZ2UgfWApLmpvaW4oJywgJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlckZ1bmMgPSAoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZSwgY2Fub25pY2FsKSA9PiBjb21waWxlZFN0YXRpY0ZpbHRlci52YWx1ZS5ldmFsdWF0ZShnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlLCB7fSwgY2Fub25pY2FsKTtcbiAgICB9XG4gICAgbGV0IGR5bmFtaWNGaWx0ZXJGdW5jID0gbnVsbDtcbiAgICBsZXQgbmVlZEZlYXR1cmUgPSBudWxsO1xuICAgIGlmIChzdGF0aWNGaWx0ZXIgIT09IGZpbHRlckV4cCkge1xuICAgICAgICBjb25zdCBjb21waWxlZER5bmFtaWNGaWx0ZXIgPSBjcmVhdGVFeHByZXNzaW9uKGZpbHRlckV4cCwgZmlsdGVyU3BlYyk7XG4gICAgICAgIGlmIChjb21waWxlZER5bmFtaWNGaWx0ZXIucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcGlsZWREeW5hbWljRmlsdGVyLnZhbHVlLm1hcChlcnIgPT4gYCR7IGVyci5rZXkgfTogJHsgZXJyLm1lc3NhZ2UgfWApLmpvaW4oJywgJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZ1bmMgPSAoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZSwgY2Fub25pY2FsLCBmZWF0dXJlVGlsZUNvb3JkLCBmZWF0dXJlRGlzdGFuY2VEYXRhKSA9PiBjb21waWxlZER5bmFtaWNGaWx0ZXIudmFsdWUuZXZhbHVhdGUoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZSwge30sIGNhbm9uaWNhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZlYXR1cmVUaWxlQ29vcmQsIGZlYXR1cmVEaXN0YW5jZURhdGEpO1xuICAgICAgICAgICAgbmVlZEZlYXR1cmUgPSAhaXNGZWF0dXJlQ29uc3RhbnQoY29tcGlsZWREeW5hbWljRmlsdGVyLnZhbHVlLmV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbHRlckZ1bmMgPSBmaWx0ZXJGdW5jO1xuICAgIGNvbnN0IG5lZWRHZW9tZXRyeSA9IGdlb21ldHJ5TmVlZGVkKHN0YXRpY0ZpbHRlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXJGdW5jLFxuICAgICAgICBkeW5hbWljRmlsdGVyOiBkeW5hbWljRmlsdGVyRnVuYyA/IGR5bmFtaWNGaWx0ZXJGdW5jIDogdW5kZWZpbmVkLFxuICAgICAgICBuZWVkR2VvbWV0cnksXG4gICAgICAgIG5lZWRGZWF0dXJlOiAhIW5lZWRGZWF0dXJlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RTdGF0aWNGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKCFpc0R5bmFtaWNGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gZGVlcFVuYnVuZGxlKGZpbHRlcik7XG4gICAgdW5pb25EeW5hbWljQnJhbmNoZXMocmVzdWx0KTtcbiAgICByZXN1bHQgPSBjb2xsYXBzZUR5bmFtaWNCb29sZWFuRXhwcmVzc2lvbnMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29sbGFwc2VEeW5hbWljQm9vbGVhbkV4cHJlc3Npb25zKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxuICAgIGNvbnN0IGNvbGxhcHNlZCA9IGNvbGxhcHNlZEV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgaWYgKGNvbGxhcHNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gY29sbGFwc2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb2xsYXBzZWQubWFwKHN1YkV4cHJlc3Npb24gPT4gY29sbGFwc2VEeW5hbWljQm9vbGVhbkV4cHJlc3Npb25zKHN1YkV4cHJlc3Npb24pKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bmlvbkR5bmFtaWNCcmFuY2hlcyhmaWx0ZXIpIHtcbiAgICBsZXQgaXNCcmFuY2hpbmdEeW5hbWljYWxseSA9IGZhbHNlO1xuICAgIGNvbnN0IGJyYW5jaGVzID0gW107XG4gICAgaWYgKGZpbHRlclswXSA9PT0gJ2Nhc2UnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlsdGVyLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICAgICAgaXNCcmFuY2hpbmdEeW5hbWljYWxseSA9IGlzQnJhbmNoaW5nRHluYW1pY2FsbHkgfHwgaXNEeW5hbWljRmlsdGVyKGZpbHRlcltpXSk7XG4gICAgICAgICAgICBicmFuY2hlcy5wdXNoKGZpbHRlcltpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyYW5jaGVzLnB1c2goZmlsdGVyW2ZpbHRlci5sZW5ndGggLSAxXSk7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJbMF0gPT09ICdtYXRjaCcpIHtcbiAgICAgICAgaXNCcmFuY2hpbmdEeW5hbWljYWxseSA9IGlzQnJhbmNoaW5nRHluYW1pY2FsbHkgfHwgaXNEeW5hbWljRmlsdGVyKGZpbHRlclsxXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgZmlsdGVyLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICAgICAgYnJhbmNoZXMucHVzaChmaWx0ZXJbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBicmFuY2hlcy5wdXNoKGZpbHRlcltmaWx0ZXIubGVuZ3RoIC0gMV0pO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyWzBdID09PSAnc3RlcCcpIHtcbiAgICAgICAgaXNCcmFuY2hpbmdEeW5hbWljYWxseSA9IGlzQnJhbmNoaW5nRHluYW1pY2FsbHkgfHwgaXNEeW5hbWljRmlsdGVyKGZpbHRlclsxXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlsdGVyLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICAgICAgYnJhbmNoZXMucHVzaChmaWx0ZXJbaSArIDFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNCcmFuY2hpbmdEeW5hbWljYWxseSkge1xuICAgICAgICBmaWx0ZXIubGVuZ3RoID0gMDtcbiAgICAgICAgZmlsdGVyLnB1c2goJ2FueScsIC4uLmJyYW5jaGVzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdW5pb25EeW5hbWljQnJhbmNoZXMoZmlsdGVyW2ldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0R5bmFtaWNGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNSb290RXhwcmVzc2lvbkR5bmFtaWMoZmlsdGVyWzBdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBmaWx0ZXJbaV07XG4gICAgICAgIGlmIChpc0R5bmFtaWNGaWx0ZXIoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1Jvb3RFeHByZXNzaW9uRHluYW1pYyhleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24gPT09ICdwaXRjaCcgfHwgZXhwcmVzc2lvbiA9PT0gJ2Rpc3RhbmNlLWZyb20tY2VudGVyJztcbn1cbmNvbnN0IGR5bmFtaWNDb25kaXRpb25FeHByZXNzaW9ucyA9IG5ldyBTZXQoW1xuICAgICdpbicsXG4gICAgJz09JyxcbiAgICAnIT0nLFxuICAgICc+JyxcbiAgICAnPj0nLFxuICAgICc8JyxcbiAgICAnPD0nLFxuICAgICd0by1ib29sZWFuJ1xuXSk7XG5mdW5jdGlvbiBjb2xsYXBzZWRFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoZHluYW1pY0NvbmRpdGlvbkV4cHJlc3Npb25zLmhhcyhleHByZXNzaW9uWzBdKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgICAgIGlmIChpc0R5bmFtaWNGaWx0ZXIocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5mdW5jdGlvbiBnZW9tZXRyeU5lZWRlZChmaWx0ZXIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChmaWx0ZXJbMF0gPT09ICd3aXRoaW4nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgZmlsdGVyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoZ2VvbWV0cnlOZWVkZWQoZmlsdGVyW2luZGV4XSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29udmVydEZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoIWZpbHRlcilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qgb3AgPSBmaWx0ZXJbMF07XG4gICAgaWYgKGZpbHRlci5sZW5ndGggPD0gMSlcbiAgICAgICAgcmV0dXJuIG9wICE9PSAnYW55JztcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSBvcCA9PT0gJz09JyA/IGNvbnZlcnRDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sICc9PScpIDogb3AgPT09ICchPScgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJz09JykpIDogb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nID8gY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgb3ApIDogb3AgPT09ICdhbnknID8gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVyLnNsaWNlKDEpKSA6IG9wID09PSAnYWxsJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikpIDogb3AgPT09ICdub25lJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikubWFwKGNvbnZlcnROZWdhdGlvbikpIDogb3AgPT09ICdpbicgPyBjb252ZXJ0SW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkgOiBvcCA9PT0gJyFpbicgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydEluT3AoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpKSA6IG9wID09PSAnaGFzJyA/IGNvbnZlcnRIYXNPcChmaWx0ZXJbMV0pIDogb3AgPT09ICchaGFzJyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0SGFzT3AoZmlsdGVyWzFdKSkgOiBvcCA9PT0gJ3dpdGhpbicgPyBmaWx0ZXIgOiB0cnVlO1xuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29tcGFyaXNvbk9wKHByb3BlcnR5LCB2YWx1ZSwgb3ApIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYGZpbHRlci10eXBlLSR7IG9wIH1gLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICBjYXNlICckaWQnOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYGZpbHRlci1pZC0keyBvcCB9YCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGBmaWx0ZXItJHsgb3AgfWAsXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVycykge1xuICAgIHJldHVybiBbJ2FueSddLmNvbmNhdChmaWx0ZXJzLm1hcChjb252ZXJ0RmlsdGVyKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0SW5PcChwcm9wZXJ0eSwgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYGZpbHRlci10eXBlLWluYCxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgdmFsdWVzXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgY2FzZSAnJGlkJzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGBmaWx0ZXItaWQtaW5gLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDIwMCAmJiAhdmFsdWVzLnNvbWUodiA9PiB0eXBlb2YgdiAhPT0gdHlwZW9mIHZhbHVlc1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2ZpbHRlci1pbi1sYXJnZScsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zb3J0KGNvbXBhcmUpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2ZpbHRlci1pbi1zbWFsbCcsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0SGFzT3AocHJvcGVydHkpIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICckaWQnOlxuICAgICAgICByZXR1cm4gW2BmaWx0ZXItaGFzLWlkYF07XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGBmaWx0ZXItaGFzYCxcbiAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydE5lZ2F0aW9uKGZpbHRlcikge1xuICAgIHJldHVybiBbXG4gICAgICAgICchJyxcbiAgICAgICAgZmlsdGVyXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZpbHRlciQxKGZpbHRlcikge1xuICAgIHJldHVybiBfY29udmVydEZpbHRlcihmaWx0ZXIsIHt9KTtcbn1cbmZ1bmN0aW9uIF9jb252ZXJ0RmlsdGVyKGZpbHRlciwgZXhwZWN0ZWRUeXBlcykge1xuICAgIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICBpZiAoIWZpbHRlcilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qgb3AgPSBmaWx0ZXJbMF07XG4gICAgaWYgKGZpbHRlci5sZW5ndGggPD0gMSlcbiAgICAgICAgcmV0dXJuIG9wICE9PSAnYW55JztcbiAgICBsZXQgY29udmVydGVkO1xuICAgIGlmIChvcCA9PT0gJz09JyB8fCBvcCA9PT0gJyE9JyB8fCBvcCA9PT0gJzwnIHx8IG9wID09PSAnPicgfHwgb3AgPT09ICc8PScgfHwgb3AgPT09ICc+PScpIHtcbiAgICAgICAgY29uc3QgWywgcHJvcGVydHksIHZhbHVlXSA9IGZpbHRlcjtcbiAgICAgICAgY29udmVydGVkID0gY29udmVydENvbXBhcmlzb25PcCQxKHByb3BlcnR5LCB2YWx1ZSwgb3AsIGV4cGVjdGVkVHlwZXMpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdhbnknKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZmlsdGVyLnNsaWNlKDEpLm1hcChmID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0ge307XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IF9jb252ZXJ0RmlsdGVyKGYsIHR5cGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVjaGVja3MgPSBydW50aW1lVHlwZUNoZWNrcyh0eXBlcyk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZWNoZWNrcyA9PT0gdHJ1ZSA/IGNoaWxkIDogW1xuICAgICAgICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICAgICAgICB0eXBlY2hlY2tzLFxuICAgICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsnYW55J10uY29uY2F0KGNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnYWxsJykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGZpbHRlci5zbGljZSgxKS5tYXAoZiA9PiBfY29udmVydEZpbHRlcihmLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPiAxID8gWydhbGwnXS5jb25jYXQoY2hpbGRyZW4pIDogW10uY29uY2F0KC4uLmNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICchJyxcbiAgICAgICAgICAgIF9jb252ZXJ0RmlsdGVyKFsnYW55J10uY29uY2F0KGZpbHRlci5zbGljZSgxKSksIHt9KVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICdpbicpIHtcbiAgICAgICAgY29udmVydGVkID0gY29udmVydEluT3AkMShmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyFpbicpIHtcbiAgICAgICAgY29udmVydGVkID0gY29udmVydEluT3AkMShmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJ2hhcycpIHtcbiAgICAgICAgY29udmVydGVkID0gY29udmVydEhhc09wJDEoZmlsdGVyWzFdKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnIWhhcycpIHtcbiAgICAgICAgY29udmVydGVkID0gW1xuICAgICAgICAgICAgJyEnLFxuICAgICAgICAgICAgY29udmVydEhhc09wJDEoZmlsdGVyWzFdKVxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5mdW5jdGlvbiBydW50aW1lVHlwZUNoZWNrcyhleHBlY3RlZFR5cGVzKSB7XG4gICAgY29uc3QgY29uZGl0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gZXhwZWN0ZWRUeXBlcykge1xuICAgICAgICBjb25zdCBnZXQgPSBwcm9wZXJ0eSA9PT0gJyRpZCcgPyBbJ2lkJ10gOiBbXG4gICAgICAgICAgICAnZ2V0JyxcbiAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgIF07XG4gICAgICAgIGNvbmRpdGlvbnMucHVzaChbXG4gICAgICAgICAgICAnPT0nLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICd0eXBlb2YnLFxuICAgICAgICAgICAgICAgIGdldFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZXNbcHJvcGVydHldXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnNbMF07XG4gICAgcmV0dXJuIFsnYWxsJ10uY29uY2F0KGNvbmRpdGlvbnMpO1xufVxuZnVuY3Rpb24gY29udmVydENvbXBhcmlzb25PcCQxKHByb3BlcnR5LCB2YWx1ZSwgb3AsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBsZXQgZ2V0O1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb3AsXG4gICAgICAgICAgICBbJ2dlb21ldHJ5LXR5cGUnXSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHtcbiAgICAgICAgZ2V0ID0gWydpZCddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldCA9IFtcbiAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGV4cGVjdGVkVHlwZXMgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgZXhwZWN0ZWRUeXBlc1twcm9wZXJ0eV0gPSB0eXBlO1xuICAgIH1cbiAgICBpZiAob3AgPT09ICc9PScgJiYgcHJvcGVydHkgIT09ICckaWQnICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYWxsJyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnaGFzJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnPT0nLFxuICAgICAgICAgICAgICAgIGdldCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyE9JyAmJiBwcm9wZXJ0eSAhPT0gJyRpZCcgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdhbnknLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICchJyxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICdoYXMnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJyE9JyxcbiAgICAgICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBvcCxcbiAgICAgICAgZ2V0LFxuICAgICAgICB2YWx1ZVxuICAgIF07XG59XG5mdW5jdGlvbiBjb252ZXJ0SW5PcCQxKHByb3BlcnR5LCB2YWx1ZXMsIG5lZ2F0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBuZWdhdGU7XG4gICAgbGV0IGdldDtcbiAgICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICAgICAgZ2V0ID0gWydnZW9tZXRyeS10eXBlJ107XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHtcbiAgICAgICAgZ2V0ID0gWydpZCddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldCA9IFtcbiAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbGV0IHVuaWZvcm1UeXBlcyA9IHRydWU7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZXNbMF07XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdW5pZm9ybVR5cGVzID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodW5pZm9ybVR5cGVzICYmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gdmFsdWVzLnNvcnQoKS5maWx0ZXIoKHYsIGkpID0+IGkgPT09IDAgfHwgdmFsdWVzW2kgLSAxXSAhPT0gdik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnbWF0Y2gnLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgdW5pcXVlVmFsdWVzLFxuICAgICAgICAgICAgIW5lZ2F0ZSxcbiAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW25lZ2F0ZSA/ICdhbGwnIDogJ2FueSddLmNvbmNhdCh2YWx1ZXMubWFwKHYgPT4gW1xuICAgICAgICBuZWdhdGUgPyAnIT0nIDogJz09JyxcbiAgICAgICAgZ2V0LFxuICAgICAgICB2XG4gICAgXSkpO1xufVxuZnVuY3Rpb24gY29udmVydEhhc09wJDEocHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICchPScsXG4gICAgICAgICAgICBbJ2lkJ10sXG4gICAgICAgICAgICBudWxsXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdoYXMnLFxuICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGVUb0V4cHJlc3Npb25zIChzdHlsZSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IFtdO1xuICAgIGVhY2hMYXllcihzdHlsZSwgbGF5ZXIgPT4ge1xuICAgICAgICBpZiAobGF5ZXIuZmlsdGVyKSB7XG4gICAgICAgICAgICBsYXllci5maWx0ZXIgPSBjb252ZXJ0RmlsdGVyJDEobGF5ZXIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2hQcm9wZXJ0eShzdHlsZSwge1xuICAgICAgICBwYWludDogdHJ1ZSxcbiAgICAgICAgbGF5b3V0OiB0cnVlXG4gICAgfSwgKHtwYXRoLCB2YWx1ZSwgcmVmZXJlbmNlLCBzZXR9KSA9PiB7XG4gICAgICAgIGlmIChpc0V4cHJlc3Npb24odmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNldChjb252ZXJ0RnVuY3Rpb24odmFsdWUsIHJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgY29udmVydGVkLnB1c2gocGF0aC5qb2luKCcuJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVyZW5jZS50b2tlbnMgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0KGNvbnZlcnRUb2tlblN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBtaWdyYXRlIChzdHlsZSkge1xuICAgIGxldCBtaWdyYXRlZCA9IGZhbHNlO1xuICAgIGlmIChzdHlsZS52ZXJzaW9uID09PSA3KSB7XG4gICAgICAgIHN0eWxlID0gbWlncmF0ZVRvVjgoc3R5bGUpO1xuICAgICAgICBtaWdyYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzdHlsZS52ZXJzaW9uID09PSA4KSB7XG4gICAgICAgIG1pZ3JhdGVkID0gbWlncmF0ZVRvRXhwcmVzc2lvbnMoc3R5bGUpO1xuICAgICAgICBtaWdyYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICghbWlncmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgbWlncmF0ZSBmcm9tJywgc3R5bGUudmVyc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zaXRlIChzdHlsZSkge1xuICAgIGNvbnN0IHN0eWxlSURzID0gW107XG4gICAgY29uc3Qgc291cmNlSURzID0gW107XG4gICAgY29uc3QgY29tcG9zaXRlZFNvdXJjZUxheWVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgaWQgaW4gc3R5bGUuc291cmNlcykge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzdHlsZS5zb3VyY2VzW2lkXTtcbiAgICAgICAgaWYgKHNvdXJjZS50eXBlICE9PSAndmVjdG9yJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9ebWFwYm94OlxcL1xcLyguKikvLmV4ZWMoc291cmNlLnVybCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3R5bGVJRHMucHVzaChpZCk7XG4gICAgICAgIHNvdXJjZUlEcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlSURzLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICBzdHlsZUlEcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgZGVsZXRlIHN0eWxlLnNvdXJjZXNbaWRdO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBvc2l0ZUlEID0gc291cmNlSURzLmpvaW4oJywnKTtcbiAgICBzdHlsZS5zb3VyY2VzW2NvbXBvc2l0ZUlEXSA9IHtcbiAgICAgICAgJ3R5cGUnOiAndmVjdG9yJyxcbiAgICAgICAgJ3VybCc6IGBtYXBib3g6Ly8keyBjb21wb3NpdGVJRCB9YFxuICAgIH07XG4gICAgc3R5bGUubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICBpZiAoc3R5bGVJRHMuaW5kZXhPZihsYXllci5zb3VyY2UpID49IDApIHtcbiAgICAgICAgICAgIGxheWVyLnNvdXJjZSA9IGNvbXBvc2l0ZUlEO1xuICAgICAgICAgICAgaWYgKCdzb3VyY2UtbGF5ZXInIGluIGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0ZWRTb3VyY2VMYXllcnMuaW5kZXhPZihsYXllclsnc291cmNlLWxheWVyJ10pID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25mbGljdGluZyBzb3VyY2UgbGF5ZXIgbmFtZXMnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVkU291cmNlTGF5ZXJzLnB1c2gobGF5ZXJbJ3NvdXJjZS1sYXllciddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGU7XG59XG5cbnZhciByZWZQcm9wZXJ0aWVzID0gW1xuICAgICd0eXBlJyxcbiAgICAnc291cmNlJyxcbiAgICAnc291cmNlLWxheWVyJyxcbiAgICAnbWluem9vbScsXG4gICAgJ21heHpvb20nLFxuICAgICdmaWx0ZXInLFxuICAgICdsYXlvdXQnXG5dO1xuXG5mdW5jdGlvbiBkZXJlZihsYXllciwgcGFyZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIGxheWVyKSB7XG4gICAgICAgIGlmIChrICE9PSAncmVmJykge1xuICAgICAgICAgICAgcmVzdWx0W2tdID0gbGF5ZXJba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmUHJvcGVydGllcy5mb3JFYWNoKGsgPT4ge1xuICAgICAgICBpZiAoayBpbiBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHBhcmVudFtrXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZXJlZkxheWVycyhsYXllcnMpIHtcbiAgICBsYXllcnMgPSBsYXllcnMuc2xpY2UoKTtcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsYXllcnNbaV0uaWRdID0gbGF5ZXJzW2ldO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoJ3JlZicgaW4gbGF5ZXJzW2ldKSB7XG4gICAgICAgICAgICBsYXllcnNbaV0gPSBkZXJlZihsYXllcnNbaV0sIG1hcFtsYXllcnNbaV0ucmVmXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycztcbn1cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhICE9PSBudWxsICYmIGIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGIgPT09ICdvYmplY3QnKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5cbmNvbnN0IG9wZXJhdGlvbnMgPSB7XG4gICAgc2V0U3R5bGU6ICdzZXRTdHlsZScsXG4gICAgYWRkTGF5ZXI6ICdhZGRMYXllcicsXG4gICAgcmVtb3ZlTGF5ZXI6ICdyZW1vdmVMYXllcicsXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogJ3NldFBhaW50UHJvcGVydHknLFxuICAgIHNldExheW91dFByb3BlcnR5OiAnc2V0TGF5b3V0UHJvcGVydHknLFxuICAgIHNldEZpbHRlcjogJ3NldEZpbHRlcicsXG4gICAgYWRkU291cmNlOiAnYWRkU291cmNlJyxcbiAgICByZW1vdmVTb3VyY2U6ICdyZW1vdmVTb3VyY2UnLFxuICAgIHNldEdlb0pTT05Tb3VyY2VEYXRhOiAnc2V0R2VvSlNPTlNvdXJjZURhdGEnLFxuICAgIHNldExheWVyWm9vbVJhbmdlOiAnc2V0TGF5ZXJab29tUmFuZ2UnLFxuICAgIHNldExheWVyUHJvcGVydHk6ICdzZXRMYXllclByb3BlcnR5JyxcbiAgICBzZXRDZW50ZXI6ICdzZXRDZW50ZXInLFxuICAgIHNldFpvb206ICdzZXRab29tJyxcbiAgICBzZXRCZWFyaW5nOiAnc2V0QmVhcmluZycsXG4gICAgc2V0UGl0Y2g6ICdzZXRQaXRjaCcsXG4gICAgc2V0U3ByaXRlOiAnc2V0U3ByaXRlJyxcbiAgICBzZXRHbHlwaHM6ICdzZXRHbHlwaHMnLFxuICAgIHNldFRyYW5zaXRpb246ICdzZXRUcmFuc2l0aW9uJyxcbiAgICBzZXRMaWdodDogJ3NldExpZ2h0JyxcbiAgICBzZXRUZXJyYWluOiAnc2V0VGVycmFpbicsXG4gICAgc2V0Rm9nOiAnc2V0Rm9nJyxcbiAgICBzZXRQcm9qZWN0aW9uOiAnc2V0UHJvamVjdGlvbidcbn07XG5mdW5jdGlvbiBhZGRTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcykge1xuICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZFNvdXJjZSxcbiAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgc291cmNlSWQsXG4gICAgICAgICAgICBhZnRlcltzb3VyY2VJZF1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKHNvdXJjZUlkLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpIHtcbiAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVTb3VyY2UsXG4gICAgICAgIGFyZ3M6IFtzb3VyY2VJZF1cbiAgICB9KTtcbiAgICBzb3VyY2VzUmVtb3ZlZFtzb3VyY2VJZF0gPSB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7XG4gICAgcmVtb3ZlU291cmNlKHNvdXJjZUlkLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpIHtcbiAgICBsZXQgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gYmVmb3JlW3NvdXJjZUlkXSkge1xuICAgICAgICBpZiAoIWJlZm9yZVtzb3VyY2VJZF0uaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gYWZ0ZXJbc291cmNlSWRdKSB7XG4gICAgICAgIGlmICghYWZ0ZXJbc291cmNlSWRdLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChwcm9wICE9PSAnZGF0YScgJiYgIWRlZXBFcXVhbChiZWZvcmVbc291cmNlSWRdW3Byb3BdLCBhZnRlcltzb3VyY2VJZF1bcHJvcF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkaWZmU291cmNlcyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpIHtcbiAgICBiZWZvcmUgPSBiZWZvcmUgfHwge307XG4gICAgYWZ0ZXIgPSBhZnRlciB8fCB7fTtcbiAgICBsZXQgc291cmNlSWQ7XG4gICAgZm9yIChzb3VyY2VJZCBpbiBiZWZvcmUpIHtcbiAgICAgICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7XG4gICAgICAgICAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChzb3VyY2VJZCBpbiBhZnRlcikge1xuICAgICAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF0sIGFmdGVyW3NvdXJjZUlkXSkpIHtcbiAgICAgICAgICAgIGlmIChiZWZvcmVbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBhZnRlcltzb3VyY2VJZF0udHlwZSA9PT0gJ2dlb2pzb24nICYmIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0R2VvSlNPTlNvdXJjZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJbc291cmNlSWRdLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzLCBsYXllcklkLCBrbGFzcywgY29tbWFuZCkge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IHt9O1xuICAgIGxldCBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBiZWZvcmUpIHtcbiAgICAgICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlW3Byb3BdLCBhZnRlcltwcm9wXSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcltwcm9wXSxcbiAgICAgICAgICAgICAgICAgICAga2xhc3NcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gYWZ0ZXIpIHtcbiAgICAgICAgaWYgKCFhZnRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBiZWZvcmUuaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlW3Byb3BdLCBhZnRlcltwcm9wXSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcltwcm9wXSxcbiAgICAgICAgICAgICAgICAgICAga2xhc3NcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdWNrSWQobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIuaWQ7XG59XG5mdW5jdGlvbiBpbmRleEJ5SWQoZ3JvdXAsIGxheWVyKSB7XG4gICAgZ3JvdXBbbGF5ZXIuaWRdID0gbGF5ZXI7XG4gICAgcmV0dXJuIGdyb3VwO1xufVxuZnVuY3Rpb24gZGlmZkxheWVycyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcykge1xuICAgIGJlZm9yZSA9IGJlZm9yZSB8fCBbXTtcbiAgICBhZnRlciA9IGFmdGVyIHx8IFtdO1xuICAgIGNvbnN0IGJlZm9yZU9yZGVyID0gYmVmb3JlLm1hcChwbHVja0lkKTtcbiAgICBjb25zdCBhZnRlck9yZGVyID0gYWZ0ZXIubWFwKHBsdWNrSWQpO1xuICAgIGNvbnN0IGJlZm9yZUluZGV4ID0gYmVmb3JlLnJlZHVjZShpbmRleEJ5SWQsIHt9KTtcbiAgICBjb25zdCBhZnRlckluZGV4ID0gYWZ0ZXIucmVkdWNlKGluZGV4QnlJZCwge30pO1xuICAgIGNvbnN0IHRyYWNrZXIgPSBiZWZvcmVPcmRlci5zbGljZSgpO1xuICAgIGNvbnN0IGNsZWFuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaSwgZCwgbGF5ZXJJZCwgYmVmb3JlTGF5ZXIsIGFmdGVyTGF5ZXIsIGluc2VydEJlZm9yZUxheWVySWQsIHByb3A7XG4gICAgZm9yIChpID0gMCwgZCA9IDA7IGkgPCBiZWZvcmVPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllcklkID0gYmVmb3JlT3JkZXJbaV07XG4gICAgICAgIGlmICghYWZ0ZXJJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5pbmRleE9mKGxheWVySWQsIGQpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBkID0gMDsgaSA8IGFmdGVyT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGF5ZXJJZCA9IGFmdGVyT3JkZXJbYWZ0ZXJPcmRlci5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIGlmICh0cmFja2VyW3RyYWNrZXIubGVuZ3RoIC0gMSAtIGldID09PSBsYXllcklkKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChiZWZvcmVJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkLCB0cmFja2VyLmxlbmd0aCAtIGQpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQrKztcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxlbmd0aCAtIGldO1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkTGF5ZXIsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgYWZ0ZXJJbmRleFtsYXllcklkXSxcbiAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmxlbmd0aCAtIGksIDAsIGxheWVySWQpO1xuICAgICAgICBjbGVhbltsYXllcklkXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhZnRlck9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVySWQgPSBhZnRlck9yZGVyW2ldO1xuICAgICAgICBiZWZvcmVMYXllciA9IGJlZm9yZUluZGV4W2xheWVySWRdO1xuICAgICAgICBhZnRlckxheWVyID0gYWZ0ZXJJbmRleFtsYXllcklkXTtcbiAgICAgICAgaWYgKGNsZWFuW2xheWVySWRdIHx8IGRlZXBFcXVhbChiZWZvcmVMYXllciwgYWZ0ZXJMYXllcikpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIuc291cmNlLCBhZnRlckxheWVyLnNvdXJjZSkgfHwgIWRlZXBFcXVhbChiZWZvcmVMYXllclsnc291cmNlLWxheWVyJ10sIGFmdGVyTGF5ZXJbJ3NvdXJjZS1sYXllciddKSB8fCAhZGVlcEVxdWFsKGJlZm9yZUxheWVyLnR5cGUsIGFmdGVyTGF5ZXIudHlwZSkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW2xheWVySWRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZUxheWVySWQgPSB0cmFja2VyW3RyYWNrZXIubGFzdEluZGV4T2YobGF5ZXJJZCkgKyAxXTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkTGF5ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVMYXllcklkXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXIubGF5b3V0LCBhZnRlckxheWVyLmxheW91dCwgY29tbWFuZHMsIGxheWVySWQsIG51bGwsIG9wZXJhdGlvbnMuc2V0TGF5b3V0UHJvcGVydHkpO1xuICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXIucGFpbnQsIGFmdGVyTGF5ZXIucGFpbnQsIGNvbW1hbmRzLCBsYXllcklkLCBudWxsLCBvcGVyYXRpb25zLnNldFBhaW50UHJvcGVydHkpO1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllci5maWx0ZXIsIGFmdGVyTGF5ZXIuZmlsdGVyKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRGaWx0ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkLFxuICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyLmZpbHRlclxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyLm1pbnpvb20sIGFmdGVyTGF5ZXIubWluem9vbSkgfHwgIWRlZXBFcXVhbChiZWZvcmVMYXllci5tYXh6b29tLCBhZnRlckxheWVyLm1heHpvb20pKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExheWVyWm9vbVJhbmdlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllci5taW56b29tLFxuICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyLm1heHpvb21cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gYmVmb3JlTGF5ZXIpIHtcbiAgICAgICAgICAgIGlmICghYmVmb3JlTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2xheW91dCcgfHwgcHJvcCA9PT0gJ3BhaW50JyB8fCBwcm9wID09PSAnZmlsdGVyJyB8fCBwcm9wID09PSAnbWV0YWRhdGEnIHx8IHByb3AgPT09ICdtaW56b29tJyB8fCBwcm9wID09PSAnbWF4em9vbScpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocHJvcC5pbmRleE9mKCdwYWludC4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSwgY29tbWFuZHMsIGxheWVySWQsIHByb3Auc2xpY2UoNiksIG9wZXJhdGlvbnMuc2V0UGFpbnRQcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxheWVyW3Byb3BdXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gYWZ0ZXJMYXllcikge1xuICAgICAgICAgICAgaWYgKCFhZnRlckxheWVyLmhhc093blByb3BlcnR5KHByb3ApIHx8IGJlZm9yZUxheWVyLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdsYXlvdXQnIHx8IHByb3AgPT09ICdwYWludCcgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHwgcHJvcCA9PT0gJ21ldGFkYXRhJyB8fCBwcm9wID09PSAnbWluem9vbScgfHwgcHJvcCA9PT0gJ21heHpvb20nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByb3AuaW5kZXhPZigncGFpbnQuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0sIGNvbW1hbmRzLCBsYXllcklkLCBwcm9wLnNsaWNlKDYpLCBvcGVyYXRpb25zLnNldFBhaW50UHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExheWVyUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJMYXllcltwcm9wXVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkaWZmU3R5bGVzKGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgICAgICAgICB9XTtcbiAgICBsZXQgY29tbWFuZHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUudmVyc2lvbiwgYWZ0ZXIudmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmNlbnRlciwgYWZ0ZXIuY2VudGVyKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRDZW50ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmNlbnRlcl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS56b29tLCBhZnRlci56b29tKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRab29tLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci56b29tXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmJlYXJpbmcsIGFmdGVyLmJlYXJpbmcpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEJlYXJpbmcsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmJlYXJpbmddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUucGl0Y2gsIGFmdGVyLnBpdGNoKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRQaXRjaCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIucGl0Y2hdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuc3ByaXRlLCBhZnRlci5zcHJpdGUpKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFNwcml0ZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbYWZ0ZXIuc3ByaXRlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmdseXBocywgYWZ0ZXIuZ2x5cGhzKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRHbHlwaHMsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmdseXBoc11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS50cmFuc2l0aW9uLCBhZnRlci50cmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci50cmFuc2l0aW9uXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmxpZ2h0LCBhZnRlci5saWdodCkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGlnaHQsXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmxpZ2h0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmZvZywgYWZ0ZXIuZm9nKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRGb2csXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLmZvZ11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5wcm9qZWN0aW9uLCBhZnRlci5wcm9qZWN0aW9uKSkge1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRQcm9qZWN0aW9uLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlci5wcm9qZWN0aW9uXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlc1JlbW92ZWQgPSB7fTtcbiAgICAgICAgY29uc3QgcmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyA9IFtdO1xuICAgICAgICBkaWZmU291cmNlcyhiZWZvcmUuc291cmNlcywgYWZ0ZXIuc291cmNlcywgcmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgICAgICBjb25zdCBiZWZvcmVMYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKGJlZm9yZS5sYXllcnMpIHtcbiAgICAgICAgICAgIGJlZm9yZS5sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNSZW1vdmVkW2xheWVyLnNvdXJjZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xheWVyLmlkXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlZm9yZVRlcnJhaW4gPSBiZWZvcmUudGVycmFpbjtcbiAgICAgICAgaWYgKGJlZm9yZVRlcnJhaW4pIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VzUmVtb3ZlZFtiZWZvcmVUZXJyYWluLnNvdXJjZV0pIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRUZXJyYWluLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdW5kZWZpbmVkXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJlZm9yZVRlcnJhaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tbWFuZHMgPSBjb21tYW5kcy5jb25jYXQocmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyk7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZVRlcnJhaW4sIGFmdGVyLnRlcnJhaW4pKSB7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFRlcnJhaW4sXG4gICAgICAgICAgICAgICAgYXJnczogW2FmdGVyLnRlcnJhaW5dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmTGF5ZXJzKGJlZm9yZUxheWVycywgYWZ0ZXIubGF5ZXJzLCBjb21tYW5kcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBjb21wdXRlIHN0eWxlIGRpZmY6JywgZSk7XG4gICAgICAgIGNvbW1hbmRzID0gW3tcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZnRlcl1cbiAgICAgICAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHM7XG59XG5cbmNsYXNzIFZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgbWVzc2FnZSwgaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAoa2V5ID8gYCR7IGtleSB9OiBgIDogJycpICsgbWVzc2FnZTtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIpXG4gICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5fX2xpbmVfXykge1xuICAgICAgICAgICAgdGhpcy5saW5lID0gdmFsdWUuX19saW5lX187XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFBhcnNpbmdFcnJvciQxIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvbGluZSAoXFxkKykvKTtcbiAgICAgICAgdGhpcy5saW5lID0gbWF0Y2ggPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RhbnRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCBjb25zdGFudHMgPSBvcHRpb25zLnZhbHVlO1xuICAgIGlmIChjb25zdGFudHMpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgY29uc3RhbnRzLCAnY29uc3RhbnRzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHY4JyldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCBvYmplY3QgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGVsZW1lbnRTcGVjcyA9IG9wdGlvbnMudmFsdWVTcGVjIHx8IHt9O1xuICAgIGNvbnN0IGVsZW1lbnRWYWxpZGF0b3JzID0gb3B0aW9ucy5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fTtcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgY29uc3Qgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKG9iamVjdCk7XG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdCwgYG9iamVjdCBleHBlY3RlZCwgJHsgdHlwZSB9IGZvdW5kYCldO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9iamVjdEtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFNwZWNLZXkgPSBvYmplY3RLZXkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgY29uc3QgZWxlbWVudFNwZWMgPSBlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXldIHx8IGVsZW1lbnRTcGVjc1snKiddO1xuICAgICAgICBsZXQgdmFsaWRhdGVFbGVtZW50O1xuICAgICAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXldKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVsZW1lbnQgPSBlbGVtZW50VmFsaWRhdG9yc1tlbGVtZW50U3BlY0tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5XSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFZhbGlkYXRvcnNbJyonXSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gZWxlbWVudFZhbGlkYXRvcnNbJyonXTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50U3BlY3NbJyonXSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0W29iamVjdEtleV0sIGB1bmtub3duIHByb3BlcnR5IFwiJHsgb2JqZWN0S2V5IH1cImApKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbGVtZW50KHtcbiAgICAgICAgICAgIGtleTogKGtleSA/IGAkeyBrZXkgfS5gIDoga2V5KSArIG9iamVjdEtleSxcbiAgICAgICAgICAgIHZhbHVlOiBvYmplY3Rbb2JqZWN0S2V5XSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogZWxlbWVudFNwZWMsXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYyxcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIG9iamVjdEtleVxuICAgICAgICB9LCBvYmplY3QpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50U3BlY0tleSBpbiBlbGVtZW50U3BlY3MpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRWYWxpZGF0b3JzW2VsZW1lbnRTcGVjS2V5XSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0ucmVxdWlyZWQgJiYgZWxlbWVudFNwZWNzW2VsZW1lbnRTcGVjS2V5XVsnZGVmYXVsdCddID09PSB1bmRlZmluZWQgJiYgb2JqZWN0W2VsZW1lbnRTcGVjS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0LCBgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7IGVsZW1lbnRTcGVjS2V5IH1cImApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBhcnJheSA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3QgYXJyYXlTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHZhbGlkYXRlQXJyYXlFbGVtZW50ID0gb3B0aW9ucy5hcnJheUVsZW1lbnRWYWxpZGF0b3IgfHwgdmFsaWRhdGU7XG4gICAgaWYgKGdldFR5cGUoYXJyYXkpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCBgYXJyYXkgZXhwZWN0ZWQsICR7IGdldFR5cGUoYXJyYXkpIH0gZm91bmRgKV07XG4gICAgfVxuICAgIGlmIChhcnJheVNwZWMubGVuZ3RoICYmIGFycmF5Lmxlbmd0aCAhPT0gYXJyYXlTcGVjLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgYGFycmF5IGxlbmd0aCAkeyBhcnJheVNwZWMubGVuZ3RoIH0gZXhwZWN0ZWQsIGxlbmd0aCAkeyBhcnJheS5sZW5ndGggfSBmb3VuZGApXTtcbiAgICB9XG4gICAgaWYgKGFycmF5U3BlY1snbWluLWxlbmd0aCddICYmIGFycmF5Lmxlbmd0aCA8IGFycmF5U3BlY1snbWluLWxlbmd0aCddKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCBgYXJyYXkgbGVuZ3RoIGF0IGxlYXN0ICR7IGFycmF5U3BlY1snbWluLWxlbmd0aCddIH0gZXhwZWN0ZWQsIGxlbmd0aCAkeyBhcnJheS5sZW5ndGggfSBmb3VuZGApXTtcbiAgICB9XG4gICAgbGV0IGFycmF5RWxlbWVudFNwZWMgPSB7XG4gICAgICAgICd0eXBlJzogYXJyYXlTcGVjLnZhbHVlLFxuICAgICAgICAndmFsdWVzJzogYXJyYXlTcGVjLnZhbHVlcyxcbiAgICAgICAgJ21pbmltdW0nOiBhcnJheVNwZWMubWluaW11bSxcbiAgICAgICAgJ21heGltdW0nOiBhcnJheVNwZWMubWF4aW11bVxuICAgIH07XG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA8IDcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYy5mdW5jdGlvbiA9IGFycmF5U3BlYy5mdW5jdGlvbjtcbiAgICB9XG4gICAgaWYgKGdldFR5cGUoYXJyYXlTcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYyA9IGFycmF5U3BlYy52YWx1ZTtcbiAgICB9XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5RWxlbWVudCh7XG4gICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgIGFycmF5SW5kZXg6IGksXG4gICAgICAgICAgICB2YWx1ZTogYXJyYXlbaV0sXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IGFycmF5RWxlbWVudFNwZWMsXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYyxcbiAgICAgICAgICAgIGtleTogYCR7IGtleSB9WyR7IGkgfV1gXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICBsZXQgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHlwZSA9ICdOYU4nO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBudW1iZXIgZXhwZWN0ZWQsICR7IHR5cGUgfSBmb3VuZGApXTtcbiAgICB9XG4gICAgaWYgKCdtaW5pbXVtJyBpbiB2YWx1ZVNwZWMpIHtcbiAgICAgICAgbGV0IHNwZWNNaW4gPSB2YWx1ZVNwZWMubWluaW11bTtcbiAgICAgICAgaWYgKGdldFR5cGUodmFsdWVTcGVjLm1pbmltdW0pID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gb3B0aW9ucy5hcnJheUluZGV4O1xuICAgICAgICAgICAgc3BlY01pbiA9IHZhbHVlU3BlYy5taW5pbXVtW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IHNwZWNNaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBgJHsgdmFsdWUgfSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdmFsdWUgJHsgc3BlY01pbiB9YCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbWF4aW11bScgaW4gdmFsdWVTcGVjKSB7XG4gICAgICAgIGxldCBzcGVjTWF4ID0gdmFsdWVTcGVjLm1heGltdW07XG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlU3BlYy5tYXhpbXVtKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgY29uc3QgaSA9IG9wdGlvbnMuYXJyYXlJbmRleDtcbiAgICAgICAgICAgIHNwZWNNYXggPSB2YWx1ZVNwZWMubWF4aW11bVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPiBzcGVjTWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgYCR7IHZhbHVlIH0gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlICR7IHNwZWNNYXggfWApXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IGZ1bmN0aW9uVmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgY29uc3QgZnVuY3Rpb25UeXBlID0gdW5idW5kbGUob3B0aW9ucy52YWx1ZS50eXBlKTtcbiAgICBsZXQgc3RvcEtleVR5cGU7XG4gICAgbGV0IHN0b3BEb21haW5WYWx1ZXMgPSB7fTtcbiAgICBsZXQgcHJldmlvdXNTdG9wRG9tYWluVmFsdWU7XG4gICAgbGV0IHByZXZpb3VzU3RvcERvbWFpblpvb207XG4gICAgY29uc3QgaXNab29tRnVuY3Rpb24gPSBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlzUHJvcGVydHlGdW5jdGlvbiA9ICFpc1pvb21GdW5jdGlvbjtcbiAgICBjb25zdCBpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uID0gZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzKSA9PT0gJ2FycmF5JyAmJiBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHNbMF0pID09PSAnYXJyYXknICYmIGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wc1swXVswXSkgPT09ICdvYmplY3QnO1xuICAgIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMuZnVuY3Rpb24sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgc3RvcHM6IHZhbGlkYXRlRnVuY3Rpb25TdG9wcyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnaWRlbnRpdHknICYmIGlzWm9vbUZ1bmN0aW9uKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwicHJvcGVydHlcIicpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmN0aW9uVHlwZSAhPT0gJ2lkZW50aXR5JyAmJiAhb3B0aW9ucy52YWx1ZS5zdG9wcykge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInN0b3BzXCInKSk7XG4gICAgfVxuICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcgJiYgb3B0aW9ucy52YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnZXhwb25lbnRpYWwgZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0eWxlU3BlYy4kdmVyc2lvbiA+PSA4KSB7XG4gICAgICAgIGlmIChpc1Byb3BlcnR5RnVuY3Rpb24gJiYgIXN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3Byb3BlcnR5IGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWm9vbUZ1bmN0aW9uICYmICFzdXBwb3J0c1pvb21FeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3pvb20gZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgfHwgaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbikgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcInByb3BlcnR5XCIgcHJvcGVydHkgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3BzKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnaWRlbnRpdHkgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGEgXCJzdG9wc1wiIHByb3BlcnR5JyldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQXJyYXkoe1xuICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnZhbHVlU3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgIGFycmF5RWxlbWVudFZhbGlkYXRvcjogdmFsaWRhdGVGdW5jdGlvblN0b3BcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdhcnJheScgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCB2YWx1ZSwgJ2FycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3RvcCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcChvcHRpb25zKSB7XG4gICAgICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICAgICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgYGFycmF5IGV4cGVjdGVkLCAkeyBnZXRUeXBlKHZhbHVlKSB9IGZvdW5kYCldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBgYXJyYXkgbGVuZ3RoIDIgZXhwZWN0ZWQsIGxlbmd0aCAkeyB2YWx1ZS5sZW5ndGggfSBmb3VuZGApXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKGdldFR5cGUodmFsdWVbMF0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBgb2JqZWN0IGV4cGVjdGVkLCAkeyBnZXRUeXBlKHZhbHVlWzBdKSB9IGZvdW5kYCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlWzBdLnpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB6b29tJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlWzBdLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgdmFsdWUnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdG9wRG9tYWluWm9vbSAmJiBwcmV2aW91c1N0b3BEb21haW5ab29tID4gdW5idW5kbGUodmFsdWVbMF0uem9vbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZVswXS56b29tLCAnc3RvcCB6b29tIHZhbHVlcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXInKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5idW5kbGUodmFsdWVbMF0uem9vbSkgIT09IHByZXZpb3VzU3RvcERvbWFpblpvb20pIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N0b3BEb21haW5ab29tID0gdW5idW5kbGUodmFsdWVbMF0uem9vbSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RvcERvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAga2V5OiBgJHsga2V5IH1bMF1gLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHsgem9vbToge30gfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIHpvb206IHZhbGlkYXRlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsaWRhdGVTdG9wRG9tYWluVmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKHtcbiAgICAgICAgICAgICAgICBrZXk6IGAkeyBrZXkgfVswXWAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzoge30sXG4gICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFeHByZXNzaW9uKGRlZXBVbmJ1bmRsZSh2YWx1ZVsxXSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcihgJHsga2V5IH1bMV1gLCB2YWx1ZVsxXSwgJ2V4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiBzdG9wcy4nKV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleTogYCR7IGtleSB9WzFdYCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogZnVuY3Rpb25WYWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN0b3BEb21haW5WYWx1ZShvcHRpb25zLCBzdG9wKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKG9wdGlvbnMudmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuYnVuZGxlKG9wdGlvbnMudmFsdWUpO1xuICAgICAgICBjb25zdCByZXBvcnRWYWx1ZSA9IG9wdGlvbnMudmFsdWUgIT09IG51bGwgPyBvcHRpb25zLnZhbHVlIDogc3RvcDtcbiAgICAgICAgaWYgKCFzdG9wS2V5VHlwZSkge1xuICAgICAgICAgICAgc3RvcEtleVR5cGUgPSB0eXBlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHN0b3BLZXlUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCBgJHsgdHlwZSB9IHN0b3AgZG9tYWluIHR5cGUgbXVzdCBtYXRjaCBwcmV2aW91cyBzdG9wIGRvbWFpbiB0eXBlICR7IHN0b3BLZXlUeXBlIH1gKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIHN0cmluZywgb3IgYm9vbGVhbicpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiYgZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBudW1iZXIgZXhwZWN0ZWQsICR7IHR5cGUgfSBmb3VuZGA7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24oZnVuY3Rpb25WYWx1ZVNwZWMpICYmIGZ1bmN0aW9uVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnXFxuSWYgeW91IGludGVuZGVkIHRvIHVzZSBhIGNhdGVnb3JpY2FsIGZ1bmN0aW9uLCBzcGVjaWZ5IGBcInR5cGVcIjogXCJjYXRlZ29yaWNhbFwiYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgbWVzc2FnZSldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgJiYgdHlwZSA9PT0gJ251bWJlcicgJiYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgYGludGVnZXIgZXhwZWN0ZWQsIGZvdW5kICR7IHZhbHVlIH1gKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uVHlwZSAhPT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlID09PSAnbnVtYmVyJyAmJiBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyJyldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHZhbHVlIGluIHN0b3BEb21haW5WYWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUnKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9wRG9tYWluVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uRGVmYXVsdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IGZ1bmN0aW9uVmFsdWVTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBleHByZXNzaW9uID0gKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgPyBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24gOiBjcmVhdGVFeHByZXNzaW9uKShkZWVwVW5idW5kbGUob3B0aW9ucy52YWx1ZSksIG9wdGlvbnMudmFsdWVTcGVjKTtcbiAgICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWUubWFwKGVycm9yID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbkVycm9yKGAkeyBvcHRpb25zLmtleSB9JHsgZXJyb3Iua2V5IH1gLCBvcHRpb25zLnZhbHVlLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb25PYmogPSBleHByZXNzaW9uLnZhbHVlLmV4cHJlc3Npb24gfHwgZXhwcmVzc2lvbi52YWx1ZS5fc3R5bGVFeHByZXNzaW9uLmV4cHJlc3Npb247XG4gICAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgJiYgb3B0aW9ucy5wcm9wZXJ0eUtleSA9PT0gJ3RleHQtZm9udCcgJiYgIWV4cHJlc3Npb25PYmoub3V0cHV0RGVmaW5lZCgpKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgYEludmFsaWQgZGF0YSBleHByZXNzaW9uIGZvciBcIiR7IG9wdGlvbnMucHJvcGVydHlLZXkgfVwiLiBPdXRwdXQgdmFsdWVzIG11c3QgYmUgY29udGFpbmVkIGFzIGxpdGVyYWxzIHdpdGhpbiB0aGUgZXhwcmVzc2lvbi5gKV07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAncHJvcGVydHknICYmIG9wdGlvbnMucHJvcGVydHlUeXBlID09PSAnbGF5b3V0JyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBsYXlvdXQgcHJvcGVydGllcy4nKV07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAnZmlsdGVyJykge1xuICAgICAgICByZXR1cm4gZGlzYWxsb3dlZEZpbHRlclBhcmFtZXRlcnMoZXhwcmVzc2lvbk9iaiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ICYmIG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQuaW5kZXhPZignY2x1c3RlcicpID09PSAwKSB7XG4gICAgICAgIGlmICghaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGV4cHJlc3Npb25PYmosIFtcbiAgICAgICAgICAgICAgICAnem9vbScsXG4gICAgICAgICAgICAgICAgJ2ZlYXR1cmUtc3RhdGUnXG4gICAgICAgICAgICBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJ6b29tXCIgYW5kIFwiZmVhdHVyZS1zdGF0ZVwiIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggY2x1c3RlciBwcm9wZXJ0aWVzLicpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCA9PT0gJ2NsdXN0ZXItaW5pdGlhbCcgJiYgIWlzRmVhdHVyZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdGZWF0dXJlIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBpbml0aWFsIGV4cHJlc3Npb24gcGFydCBvZiBjbHVzdGVyIHByb3BlcnRpZXMuJyldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGRpc2FsbG93ZWRGaWx0ZXJQYXJhbWV0ZXJzKGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkaXNhbGxvd2VkUGFyYW1ldGVycyA9IG5ldyBTZXQoW1xuICAgICAgICAnem9vbScsXG4gICAgICAgICdmZWF0dXJlLXN0YXRlJyxcbiAgICAgICAgJ3BpdGNoJyxcbiAgICAgICAgJ2Rpc3RhbmNlLWZyb20tY2VudGVyJ1xuICAgIF0pO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2Ygb3B0aW9ucy52YWx1ZVNwZWMuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzKSB7XG4gICAgICAgIGRpc2FsbG93ZWRQYXJhbWV0ZXJzLmRlbGV0ZShwYXJhbSk7XG4gICAgfVxuICAgIGlmIChkaXNhbGxvd2VkUGFyYW1ldGVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGRpc2FsbG93ZWRQYXJhbWV0ZXJzLmhhcyhlLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsIGBbXCIkeyBlLm5hbWUgfVwiXSBleHByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYSBmaWx0ZXIgZm9yIGEgJHsgb3B0aW9ucy5vYmplY3QudHlwZSB9IGxheWVyIHdpdGggaWQ6ICR7IG9wdGlvbnMub2JqZWN0LmlkIH1gKV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZS5lYWNoQ2hpbGQoYXJnID0+IHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZGlzYWxsb3dlZEZpbHRlclBhcmFtZXRlcnMoYXJnLCBvcHRpb25zKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuKG9wdGlvbnMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgIGlmICh0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBib29sZWFuIGV4cGVjdGVkLCAkeyB0eXBlIH0gZm91bmRgKV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb2xvcihvcHRpb25zKSB7XG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBjb2xvciBleHBlY3RlZCwgJHsgdHlwZSB9IGZvdW5kYCldO1xuICAgIH1cbiAgICBpZiAoY3NzY29sb3JwYXJzZXIucGFyc2VDU1NDb2xvcih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBjb2xvciBleHBlY3RlZCwgXCIkeyB2YWx1ZSB9XCIgZm91bmRgKV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFbnVtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3QgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVTcGVjLnZhbHVlcykpIHtcbiAgICAgICAgaWYgKHZhbHVlU3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBgZXhwZWN0ZWQgb25lIG9mIFskeyB2YWx1ZVNwZWMudmFsdWVzLmpvaW4oJywgJykgfV0sICR7IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9IGZvdW5kYCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlU3BlYy52YWx1ZXMpLmluZGV4T2YodW5idW5kbGUodmFsdWUpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgYGV4cGVjdGVkIG9uZSBvZiBbJHsgT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuam9pbignLCAnKSB9XSwgJHsgSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0gZm91bmRgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGaWx0ZXIob3B0aW9ucykge1xuICAgIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZGVlcFVuYnVuZGxlKG9wdGlvbnMudmFsdWUpKSkge1xuICAgICAgICBjb25zdCBsYXllclR5cGUgPSBkZWVwVW5idW5kbGUob3B0aW9ucy5sYXllclR5cGUpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1tgZmlsdGVyXyR7IGxheWVyVHlwZSB8fCAnZmlsbCcgfWBdXG4gICAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcihvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgYGFycmF5IGV4cGVjdGVkLCAkeyBnZXRUeXBlKHZhbHVlKSB9IGZvdW5kYCldO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgZXJyb3JzID0gW107XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpXTtcbiAgICB9XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVudW0oe1xuICAgICAgICBrZXk6IGAkeyBrZXkgfVswXWAsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuZmlsdGVyX29wZXJhdG9yLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgIH0pKTtcbiAgICBzd2l0Y2ggKHVuYnVuZGxlKHZhbHVlWzBdKSkge1xuICAgIGNhc2UgJzwnOlxuICAgIGNhc2UgJzw9JzpcbiAgICBjYXNlICc+JzpcbiAgICBjYXNlICc+PSc6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMiAmJiB1bmJ1bmRsZSh2YWx1ZVsxXSkgPT09ICckdHlwZScpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgYFwiJHR5cGVcIiBjYW5ub3QgYmUgdXNlIHdpdGggb3BlcmF0b3IgXCIkeyB2YWx1ZVswXSB9XCJgKSk7XG4gICAgICAgIH1cbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnIT0nOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBmaWx0ZXIgYXJyYXkgZm9yIG9wZXJhdG9yIFwiJHsgdmFsdWVbMF0gfVwiIG11c3QgaGF2ZSAzIGVsZW1lbnRzYCkpO1xuICAgICAgICB9XG4gICAgY2FzZSAnaW4nOlxuICAgIGNhc2UgJyFpbic6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihgJHsga2V5IH1bMV1gLCB2YWx1ZVsxXSwgYHN0cmluZyBleHBlY3RlZCwgJHsgdHlwZSB9IGZvdW5kYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZSh2YWx1ZVsxXSkgPT09ICckdHlwZScpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRW51bSh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYCR7IGtleSB9WyR7IGkgfV1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGAkeyBrZXkgfVskeyBpIH1dYCwgdmFsdWVbaV0sIGBzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiBleHBlY3RlZCwgJHsgdHlwZSB9IGZvdW5kYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FueSc6XG4gICAgY2FzZSAnYWxsJzpcbiAgICBjYXNlICdub25lJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU5vbkV4cHJlc3Npb25GaWx0ZXIoe1xuICAgICAgICAgICAgICAgIGtleTogYCR7IGtleSB9WyR7IGkgfV1gLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaGFzJzpcbiAgICBjYXNlICchaGFzJzpcbiAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBmaWx0ZXIgYXJyYXkgZm9yIFwiJHsgdmFsdWVbMF0gfVwiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzYCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGAkeyBrZXkgfVsxXWAsIHZhbHVlWzFdLCBgc3RyaW5nIGV4cGVjdGVkLCAkeyB0eXBlIH0gZm91bmRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2l0aGluJzpcbiAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBmaWx0ZXIgYXJyYXkgZm9yIFwiJHsgdmFsdWVbMF0gfVwiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzYCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGAkeyBrZXkgfVsxXWAsIHZhbHVlWzFdLCBgb2JqZWN0IGV4cGVjdGVkLCAkeyB0eXBlIH0gZm91bmRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgcHJvcGVydHlUeXBlKSB7XG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCBwcm9wZXJ0eUtleSA9IG9wdGlvbnMub2JqZWN0S2V5O1xuICAgIGNvbnN0IGxheWVyU3BlYyA9IHN0eWxlU3BlY1tgJHsgcHJvcGVydHlUeXBlIH1fJHsgb3B0aW9ucy5sYXllclR5cGUgfWBdO1xuICAgIGlmICghbGF5ZXJTcGVjKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgdHJhbnNpdGlvbk1hdGNoID0gcHJvcGVydHlLZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gICAgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ3BhaW50JyAmJiB0cmFuc2l0aW9uTWF0Y2ggJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV07XG4gICAgaWYgKCF2YWx1ZVNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGB1bmtub3duIHByb3BlcnR5IFwiJHsgcHJvcGVydHlLZXkgfVwiYCldO1xuICAgIH1cbiAgICBsZXQgdG9rZW5NYXRjaDtcbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmIHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlU3BlYykgJiYgIXZhbHVlU3BlYy50b2tlbnMgJiYgKHRva2VuTWF0Y2ggPSAvXnsoW159XSspfSQvLmV4ZWModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgYFwiJHsgcHJvcGVydHlLZXkgfVwiIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJwb2xhdGlvbiBzeW50YXhcXG5gICsgYFVzZSBhbiBpZGVudGl0eSBwcm9wZXJ0eSBmdW5jdGlvbiBpbnN0ZWFkOiBcXGB7IFwidHlwZVwiOiBcImlkZW50aXR5XCIsIFwicHJvcGVydHlcIjogJHsgSlNPTi5zdHJpbmdpZnkodG9rZW5NYXRjaFsxXSkgfSB9XFxgLmApXTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgaWYgKG9wdGlvbnMubGF5ZXJUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAocHJvcGVydHlLZXkgPT09ICd0ZXh0LWZpZWxkJyAmJiBzdHlsZSAmJiAhc3R5bGUuZ2x5cGhzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1c2Ugb2YgXCJ0ZXh0LWZpZWxkXCIgcmVxdWlyZXMgYSBzdHlsZSBcImdseXBoc1wiIHByb3BlcnR5JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3RleHQtZm9udCcgJiYgaXNGdW5jdGlvbiQxKGRlZXBVbmJ1bmRsZSh2YWx1ZSkpICYmIHVuYnVuZGxlKHZhbHVlLnR5cGUpID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInRleHQtZm9udFwiIGRvZXMgbm90IHN1cHBvcnQgaWRlbnRpdHkgZnVuY3Rpb25zJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYyxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYyxcbiAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdwcm9wZXJ0eScsXG4gICAgICAgIHByb3BlcnR5VHlwZSxcbiAgICAgICAgcHJvcGVydHlLZXlcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFpbnRQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgJ3BhaW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkob3B0aW9ucykge1xuICAgIHJldHVybiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsICdsYXlvdXQnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMYXllcihvcHRpb25zKSB7XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IGxheWVyID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgY29uc3Qgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgaWYgKCFsYXllci50eXBlICYmICFsYXllci5yZWYpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnZWl0aGVyIFwidHlwZVwiIG9yIFwicmVmXCIgaXMgcmVxdWlyZWQnKSk7XG4gICAgfVxuICAgIGxldCB0eXBlID0gdW5idW5kbGUobGF5ZXIudHlwZSk7XG4gICAgY29uc3QgcmVmID0gdW5idW5kbGUobGF5ZXIucmVmKTtcbiAgICBpZiAobGF5ZXIuaWQpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJJZCA9IHVuYnVuZGxlKGxheWVyLmlkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmFycmF5SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJMYXllciA9IHN0eWxlLmxheWVyc1tpXTtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZShvdGhlckxheWVyLmlkKSA9PT0gbGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5pZCwgYGR1cGxpY2F0ZSBsYXllciBpZCBcIiR7IGxheWVyLmlkIH1cIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJHsgb3RoZXJMYXllci5pZC5fX2xpbmVfXyB9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgncmVmJyBpbiBsYXllcikge1xuICAgICAgICBbXG4gICAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgICAnc291cmNlJyxcbiAgICAgICAgICAgICdzb3VyY2UtbGF5ZXInLFxuICAgICAgICAgICAgJ2ZpbHRlcicsXG4gICAgICAgICAgICAnbGF5b3V0J1xuICAgICAgICBdLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICBpZiAocCBpbiBsYXllcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllcltwXSwgYFwiJHsgcCB9XCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVyc2ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgIHN0eWxlLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgIGlmICh1bmJ1bmRsZShsYXllci5pZCkgPT09IHJlZilcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBsYXllcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIucmVmLCBgcmVmIGxheWVyIFwiJHsgcmVmIH1cIiBub3QgZm91bmRgKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJlZikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBjYW5ub3QgcmVmZXJlbmNlIGFub3RoZXIgcmVmIGxheWVyJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IHVuYnVuZGxlKHBhcmVudC50eXBlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISh0eXBlID09PSAnYmFja2dyb3VuZCcgfHwgdHlwZSA9PT0gJ3NreScpKSB7XG4gICAgICAgIGlmICghbGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic291cmNlXCInKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzdHlsZS5zb3VyY2VzICYmIHN0eWxlLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVR5cGUgPSBzb3VyY2UgJiYgdW5idW5kbGUoc291cmNlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCBgc291cmNlIFwiJHsgbGF5ZXIuc291cmNlIH1cIiBub3QgZm91bmRgKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICd2ZWN0b3InICYmIHR5cGUgPT09ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgYGxheWVyIFwiJHsgbGF5ZXIuaWQgfVwiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZWApKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3RlcicgJiYgdHlwZSAhPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCBgbGF5ZXIgXCIkeyBsYXllci5pZCB9XCIgcmVxdWlyZXMgYSB2ZWN0b3Igc291cmNlYCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAndmVjdG9yJyAmJiAhbGF5ZXJbJ3NvdXJjZS1sYXllciddKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCBgbGF5ZXIgXCIkeyBsYXllci5pZCB9XCIgbXVzdCBzcGVjaWZ5IGEgXCJzb3VyY2UtbGF5ZXJcImApKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3Rlci1kZW0nICYmIHR5cGUgIT09ICdoaWxsc2hhZGUnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3Jhc3Rlci1kZW0gc291cmNlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBsYXllciB0eXBlIFxcJ2hpbGxzaGFkZVxcJy4nKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lJyAmJiBsYXllci5wYWludCAmJiBsYXllci5wYWludFsnbGluZS1ncmFkaWVudCddICYmIChzb3VyY2VUeXBlICE9PSAnZ2VvanNvbicgfHwgIXNvdXJjZS5saW5lTWV0cmljcykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsIGBsYXllciBcIiR7IGxheWVyLmlkIH1cIiBzcGVjaWZpZXMgYSBsaW5lLWdyYWRpZW50LCB3aGljaCByZXF1aXJlcyBhIEdlb0pTT04gc291cmNlIHdpdGggXFxgbGluZU1ldHJpY3NcXGAgZW5hYmxlZC5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWU6IGxheWVyLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5sYXllcixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAnKicoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBgJHsga2V5IH0udHlwZWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsYXllci50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5sYXllci50eXBlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0S2V5OiAndHlwZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWx0ZXIob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUZpbHRlcihleHRlbmQoeyBsYXllclR5cGU6IHR5cGUgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxheW91dChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcqJyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkoZXh0ZW5kKHsgbGF5ZXJUeXBlOiB0eXBlIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhaW50KG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyonKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQYWludFByb3BlcnR5KGV4dGVuZCh7IGxheWVyVHlwZTogdHlwZSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIGBzdHJpbmcgZXhwZWN0ZWQsICR7IHR5cGUgfSBmb3VuZGApXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5jb25zdCBvYmplY3RFbGVtZW50VmFsaWRhdG9ycyA9IHsgcHJvbW90ZUlkOiB2YWxpZGF0ZVByb21vdGVJZCB9O1xuZnVuY3Rpb24gdmFsaWRhdGVTb3VyY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcbiAgICBjb25zdCBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgaWYgKCF2YWx1ZS50eXBlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJ0eXBlXCIgaXMgcmVxdWlyZWQnKV07XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB1bmJ1bmRsZSh2YWx1ZS50eXBlKTtcbiAgICBsZXQgZXJyb3JzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3ZlY3Rvcic6XG4gICAgY2FzZSAncmFzdGVyJzpcbiAgICBjYXNlICdyYXN0ZXItZGVtJzpcbiAgICAgICAgZXJyb3JzID0gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlY1tgc291cmNlXyR7IHR5cGUucmVwbGFjZSgnLScsICdfJykgfWBdLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWMsXG4gICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICBjYXNlICdnZW9qc29uJzpcbiAgICAgICAgZXJyb3JzID0gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfZ2VvanNvbixcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjLFxuICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZS5jbHVzdGVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdmFsdWUuY2x1c3RlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbb3BlcmF0b3IsIG1hcEV4cHJdID0gdmFsdWUuY2x1c3RlclByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkdWNlRXhwciA9IHR5cGVvZiBvcGVyYXRvciA9PT0gJ3N0cmluZycgPyBbXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBbJ2FjY3VtdWxhdGVkJ10sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgXSA6IG9wZXJhdG9yO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnZhbGlkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIGtleTogYCR7IGtleSB9LiR7IHByb3AgfS5tYXBgLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFwRXhwcixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdjbHVzdGVyLW1hcCdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsaWRhdGVFeHByZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBgJHsga2V5IH0uJHsgcHJvcCB9LnJlZHVjZWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZWR1Y2VFeHByLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItcmVkdWNlJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX3ZpZGVvLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfaW1hZ2UsXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBudWxsLCBgUGxlYXNlIHVzZSBydW50aW1lIEFQSXMgdG8gYWRkIGNhbnZhcyBzb3VyY2VzLCByYXRoZXIgdGhhbiBpbmNsdWRpbmcgdGhlbSBpbiBzdHlsZXNoZWV0cy5gLCAnc291cmNlLmNhbnZhcycpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVFbnVtKHtcbiAgICAgICAgICAgIGtleTogYCR7IGtleSB9LnR5cGVgLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3ZlY3RvcicsXG4gICAgICAgICAgICAgICAgICAgICdyYXN0ZXInLFxuICAgICAgICAgICAgICAgICAgICAncmFzdGVyLWRlbScsXG4gICAgICAgICAgICAgICAgICAgICdnZW9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlY1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb21vdGVJZCh7a2V5LCB2YWx1ZX0pIHtcbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVN0cmluZyh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi52YWxpZGF0ZVN0cmluZyh7XG4gICAgICAgICAgICAgICAga2V5OiBgJHsga2V5IH0uJHsgcHJvcCB9YCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbcHJvcF1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMaWdodChvcHRpb25zKSB7XG4gICAgY29uc3QgbGlnaHQgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IGxpZ2h0U3BlYyA9IHN0eWxlU3BlYy5saWdodDtcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHJvb3RUeXBlID0gZ2V0VHlwZShsaWdodCk7XG4gICAgaWYgKGxpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9IGVsc2UgaWYgKHJvb3RUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCdsaWdodCcsIGxpZ2h0LCBgb2JqZWN0IGV4cGVjdGVkLCAkeyByb290VHlwZSB9IGZvdW5kYCldKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbGlnaHQpIHtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbk1hdGNoID0ga2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICAgICAgICBpZiAodHJhbnNpdGlvbk1hdGNoICYmIGxpZ2h0U3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dICYmIGxpZ2h0U3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGlnaHRba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpZ2h0U3BlY1trZXldKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpZ2h0W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBsaWdodFNwZWNba2V5XSxcbiAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsaWdodFtrZXldLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7IGtleSB9XCJgKV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGVycmFpbihvcHRpb25zKSB7XG4gICAgY29uc3QgdGVycmFpbiA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IHRlcnJhaW5TcGVjID0gc3R5bGVTcGVjLnRlcnJhaW47XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHJvb3RUeXBlID0gZ2V0VHlwZSh0ZXJyYWluKTtcbiAgICBpZiAodGVycmFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSBlbHNlIGlmIChyb290VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcigndGVycmFpbicsIHRlcnJhaW4sIGBvYmplY3QgZXhwZWN0ZWQsICR7IHJvb3RUeXBlIH0gZm91bmRgKV0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0ZXJyYWluKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25NYXRjaCA9IGtleS5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25NYXRjaCAmJiB0ZXJyYWluU3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dICYmIHRlcnJhaW5TcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXJyYWluW2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXJyYWluU3BlY1trZXldKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRlcnJhaW5ba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHRlcnJhaW5TcGVjW2tleV0sXG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdGVycmFpbltrZXldLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7IGtleSB9XCJgKV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdGVycmFpbi5zb3VyY2UpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHRlcnJhaW4sIGB0ZXJyYWluIGlzIG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzb3VyY2VcImApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzdHlsZS5zb3VyY2VzICYmIHN0eWxlLnNvdXJjZXNbdGVycmFpbi5zb3VyY2VdO1xuICAgICAgICBjb25zdCBzb3VyY2VUeXBlID0gc291cmNlICYmIHVuYnVuZGxlKHNvdXJjZS50eXBlKTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB0ZXJyYWluLnNvdXJjZSwgYHNvdXJjZSBcIiR7IHRlcnJhaW4uc291cmNlIH1cIiBub3QgZm91bmRgKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSAhPT0gJ3Jhc3Rlci1kZW0nKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdGVycmFpbi5zb3VyY2UsIGB0ZXJyYWluIGNhbm5vdCBiZSB1c2VkIHdpdGggYSBzb3VyY2Ugb2YgdHlwZSAkeyBzb3VyY2VUeXBlIH0sIGl0IG9ubHkgYmUgdXNlZCB3aXRoIGEgXCJyYXN0ZXItZGVtXCIgc291cmNlIHR5cGVgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGb2cob3B0aW9ucykge1xuICAgIGNvbnN0IGZvZyA9IG9wdGlvbnMudmFsdWU7XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IGZvZ1NwZWMgPSBzdHlsZVNwZWMuZm9nO1xuICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCByb290VHlwZSA9IGdldFR5cGUoZm9nKTtcbiAgICBpZiAoZm9nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9IGVsc2UgaWYgKHJvb3RUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCdmb2cnLCBmb2csIGBvYmplY3QgZXhwZWN0ZWQsICR7IHJvb3RUeXBlIH0gZm91bmRgKV0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb2cpIHtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbk1hdGNoID0ga2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICAgICAgICBpZiAodHJhbnNpdGlvbk1hdGNoICYmIGZvZ1NwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBmb2dTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmb2dba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvZ1NwZWNba2V5XSkge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmb2dba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IGZvZ1NwZWNba2V5XSxcbiAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBmb2dba2V5XSwgYHVua25vd24gcHJvcGVydHkgXCIkeyBrZXkgfVwiYCldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdHRlZChvcHRpb25zKSB7XG4gICAgaWYgKHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW1hZ2Uob3B0aW9ucykge1xuICAgIGlmICh2YWxpZGF0ZVN0cmluZyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb2plY3Rpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIGNvbnN0IHByb2plY3Rpb25TcGVjID0gc3R5bGVTcGVjLnByb2plY3Rpb247XG4gICAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCByb290VHlwZSA9IGdldFR5cGUocHJvamVjdGlvbik7XG4gICAgaWYgKHJvb3RUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2plY3Rpb25ba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHByb2plY3Rpb25TcGVjW2tleV0sXG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJvb3RUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCdwcm9qZWN0aW9uJywgcHJvamVjdGlvbiwgYG9iamVjdCBvciBzdHJpbmcgZXhwZWN0ZWQsICR7IHJvb3RUeXBlIH0gZm91bmRgKV0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5jb25zdCBWQUxJREFUT1JTID0ge1xuICAgICcqJygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgJ2FycmF5JzogdmFsaWRhdGVBcnJheSxcbiAgICAnYm9vbGVhbic6IHZhbGlkYXRlQm9vbGVhbixcbiAgICAnbnVtYmVyJzogdmFsaWRhdGVOdW1iZXIsXG4gICAgJ2NvbG9yJzogdmFsaWRhdGVDb2xvcixcbiAgICAnY29uc3RhbnRzJzogdmFsaWRhdGVDb25zdGFudHMsXG4gICAgJ2VudW0nOiB2YWxpZGF0ZUVudW0sXG4gICAgJ2ZpbHRlcic6IHZhbGlkYXRlRmlsdGVyLFxuICAgICdmdW5jdGlvbic6IHZhbGlkYXRlRnVuY3Rpb24sXG4gICAgJ2xheWVyJzogdmFsaWRhdGVMYXllcixcbiAgICAnb2JqZWN0JzogdmFsaWRhdGVPYmplY3QsXG4gICAgJ3NvdXJjZSc6IHZhbGlkYXRlU291cmNlLFxuICAgICdsaWdodCc6IHZhbGlkYXRlTGlnaHQsXG4gICAgJ3RlcnJhaW4nOiB2YWxpZGF0ZVRlcnJhaW4sXG4gICAgJ2ZvZyc6IHZhbGlkYXRlRm9nLFxuICAgICdzdHJpbmcnOiB2YWxpZGF0ZVN0cmluZyxcbiAgICAnZm9ybWF0dGVkJzogdmFsaWRhdGVGb3JtYXR0ZWQsXG4gICAgJ3Jlc29sdmVkSW1hZ2UnOiB2YWxpZGF0ZUltYWdlLFxuICAgICdwcm9qZWN0aW9uJzogdmFsaWRhdGVQcm9qZWN0aW9uXG59O1xuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICBjb25zdCBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICBpZiAodmFsdWVTcGVjLmV4cHJlc3Npb24gJiYgaXNGdW5jdGlvbiQxKHVuYnVuZGxlKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiBpc0V4cHJlc3Npb24oZGVlcFVuYnVuZGxlKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlU3BlYy50eXBlICYmIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKSB7XG4gICAgICAgIHJldHVybiBWQUxJREFUT1JTW3ZhbHVlU3BlYy50eXBlXShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWxpZCA9IHZhbGlkYXRlT2JqZWN0KGV4dGVuZCh7fSwgb3B0aW9ucywgeyB2YWx1ZVNwZWM6IHZhbHVlU3BlYy50eXBlID8gc3R5bGVTcGVjW3ZhbHVlU3BlYy50eXBlXSA6IHZhbHVlU3BlYyB9KSk7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlR2x5cGhzVVJMIChvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7Zm9udHN0YWNrfScpID09PSAtMSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntmb250c3RhY2t9XCIgdG9rZW4nKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7cmFuZ2V9JykgPT09IC0xKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlTWluKHN0eWxlLCBzdHlsZVNwZWMgPSB2OCkge1xuICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiAnJyxcbiAgICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy4kcm9vdCxcbiAgICAgICAgc3R5bGVTcGVjLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIGdseXBoczogdmFsaWRhdGVHbHlwaHNVUkwsXG4gICAgICAgICAgICAnKicoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChzdHlsZS5jb25zdGFudHMpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUNvbnN0YW50cyh7XG4gICAgICAgICAgICBrZXk6ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgdmFsdWU6IHN0eWxlLmNvbnN0YW50cyxcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRFcnJvcnMoZXJyb3JzKTtcbn1cbnZhbGlkYXRlU3R5bGVNaW4uc291cmNlID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlU291cmNlKTtcbnZhbGlkYXRlU3R5bGVNaW4ubGlnaHQgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVMaWdodCk7XG52YWxpZGF0ZVN0eWxlTWluLnRlcnJhaW4gPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVUZXJyYWluKTtcbnZhbGlkYXRlU3R5bGVNaW4uZm9nID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlRm9nKTtcbnZhbGlkYXRlU3R5bGVNaW4ubGF5ZXIgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVMYXllcik7XG52YWxpZGF0ZVN0eWxlTWluLmZpbHRlciA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUZpbHRlcik7XG52YWxpZGF0ZVN0eWxlTWluLnBhaW50UHJvcGVydHkgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVQYWludFByb3BlcnR5KTtcbnZhbGlkYXRlU3R5bGVNaW4ubGF5b3V0UHJvcGVydHkgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVMYXlvdXRQcm9wZXJ0eSk7XG5mdW5jdGlvbiBzb3J0RXJyb3JzKGVycm9ycykge1xuICAgIHJldHVybiBbXS5jb25jYXQoZXJyb3JzKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiBhLmxpbmUgLSBiLmxpbmU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB3cmFwQ2xlYW5FcnJvcnMoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRFcnJvcnMoaW5uZXIuYXBwbHkodGhpcywgYXJncykpO1xuICAgIH07XG59XG5cbi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC40LjE1ICovXG5cbnZhciBqc29ubGludCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbi8qXG4gIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXG4gIFBhcnNlcjoge1xuICAgIHl5OiB7fVxuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZToge1xuICAgIHl5OiB7fSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSxcbiAgICB0YWJsZTogWy4uLl0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcblxuICAgIGxleGVyOiB7XG4gICAgICAgIEVPRjogMSxcbiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSxcbiAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmFuZ2VzOiBib29sZWFuICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyKVxuICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICBydWxlczogWy4uLl0sXG4gICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgIH1cbiAgfVxuXG5cbiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoQCQsIF8kLCBldGMuKToge1xuICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgbGFzdF9saW5lOiBuLFxuICAgIGZpcnN0X2NvbHVtbjogbixcbiAgICBsYXN0X2NvbHVtbjogbixcbiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICB9XG5cblxuICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczoge1xuICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAgfVxuICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgfVxuKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSwxMl0sJFYxPVsxLDEzXSwkVjI9WzEsOV0sJFYzPVsxLDEwXSwkVjQ9WzEsMTFdLCRWNT1bMSwxNF0sJFY2PVsxLDE1XSwkVjc9WzE0LDE4LDIyLDI0XSwkVjg9WzE4LDIyXSwkVjk9WzIyLDI0XTtcbnZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LFxueXk6IHt9LFxuc3ltYm9sc186IHtcImVycm9yXCI6MixcIkpTT05TdHJpbmdcIjozLFwiU1RSSU5HXCI6NCxcIkpTT05OdW1iZXJcIjo1LFwiTlVNQkVSXCI6NixcIkpTT05OdWxsTGl0ZXJhbFwiOjcsXCJOVUxMXCI6OCxcIkpTT05Cb29sZWFuTGl0ZXJhbFwiOjksXCJUUlVFXCI6MTAsXCJGQUxTRVwiOjExLFwiSlNPTlRleHRcIjoxMixcIkpTT05WYWx1ZVwiOjEzLFwiRU9GXCI6MTQsXCJKU09OT2JqZWN0XCI6MTUsXCJKU09OQXJyYXlcIjoxNixcIntcIjoxNyxcIn1cIjoxOCxcIkpTT05NZW1iZXJMaXN0XCI6MTksXCJKU09OTWVtYmVyXCI6MjAsXCI6XCI6MjEsXCIsXCI6MjIsXCJbXCI6MjMsXCJdXCI6MjQsXCJKU09ORWxlbWVudExpc3RcIjoyNSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDQ6XCJTVFJJTkdcIiw2OlwiTlVNQkVSXCIsODpcIk5VTExcIiwxMDpcIlRSVUVcIiwxMTpcIkZBTFNFXCIsMTQ6XCJFT0ZcIiwxNzpcIntcIiwxODpcIn1cIiwyMTpcIjpcIiwyMjpcIixcIiwyMzpcIltcIiwyNDpcIl1cIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDFdLFs1LDFdLFs3LDFdLFs5LDFdLFs5LDFdLFsxMiwyXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTUsMl0sWzE1LDNdLFsyMCwzXSxbMTksMV0sWzE5LDNdLFsxNiwyXSxbMTYsM10sWzI1LDFdLFsyNSwzXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcbiAvLyByZXBsYWNlIGVzY2FwZWQgY2hhcmFjdGVycyB3aXRoIGFjdHVhbCBjaGFyYWN0ZXJcbiAgICAgICAgICB0aGlzLiQgPSBuZXcgU3RyaW5nKHl5dGV4dC5yZXBsYWNlKC9cXFxcKFxcXFx8XCIpL2csIFwiJFwiK1wiMVwiKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxuL2csJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHIvZywnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdC9nLCdcXHQnKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx2L2csJ1xcdicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXGYvZywnXFxmJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcYi9nLCdcXGInKSk7XG4gICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gIHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgMjpcblxuICAgICAgICAgICAgdGhpcy4kID0gbmV3IE51bWJlcih5eXRleHQpO1xuICAgICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gIHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgMzpcblxuICAgICAgICAgICAgdGhpcy4kID0gbnVsbDtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgNDpcblxuICAgICAgICAgICAgdGhpcy4kID0gbmV3IEJvb2xlYW4odHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDU6XG5cbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBCb29sZWFuKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9IHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgXG5icmVhaztcbmNhc2UgNjpcbnJldHVybiB0aGlzLiQgPSAkJFskMC0xXTtcbmNhc2UgMTM6XG50aGlzLiQgPSB7fTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuJCwgJ19fbGluZV9fJywge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuXyQuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuYnJlYWs7XG5jYXNlIDE0OiBjYXNlIDE5OlxudGhpcy4kID0gJCRbJDAtMV07IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbmJyZWFrO1xuY2FzZSAxNTpcbnRoaXMuJCA9IFskJFskMC0yXSwgJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAxNjpcbnRoaXMuJCA9IHt9OyB0aGlzLiRbJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcbmJyZWFrO1xuY2FzZSAxNzpcbnRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXVskJFskMF1bMF1dID0gJCRbJDBdWzFdO1xuYnJlYWs7XG5jYXNlIDE4OlxudGhpcy4kID0gW107IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbmJyZWFrO1xuY2FzZSAyMDpcbnRoaXMuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDIxOlxudGhpcy4kID0gJCRbJDAtMl07ICQkWyQwLTJdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEyOjEsMTM6MiwxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNn0sezE6WzNdfSx7MTQ6WzEsMTZdfSxvKCRWNyxbMiw3XSksbygkVjcsWzIsOF0pLG8oJFY3LFsyLDldKSxvKCRWNyxbMiwxMF0pLG8oJFY3LFsyLDExXSksbygkVjcsWzIsMTJdKSxvKCRWNyxbMiwzXSksbygkVjcsWzIsNF0pLG8oJFY3LFsyLDVdKSxvKFsxNCwxOCwyMSwyMiwyNF0sWzIsMV0pLG8oJFY3LFsyLDJdKSx7MzoyMCw0OiRWMCwxODpbMSwxN10sMTk6MTgsMjA6MTl9LHszOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMzoyMywxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNiwyNDpbMSwyMV0sMjU6MjJ9LHsxOlsyLDZdfSxvKCRWNyxbMiwxM10pLHsxODpbMSwyNF0sMjI6WzEsMjVdfSxvKCRWOCxbMiwxNl0pLHsyMTpbMSwyNl19LG8oJFY3LFsyLDE4XSksezIyOlsxLDI4XSwyNDpbMSwyN119LG8oJFY5LFsyLDIwXSksbygkVjcsWzIsMTRdKSx7MzoyMCw0OiRWMCwyMDoyOX0sezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjMwLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSxvKCRWNyxbMiwxOV0pLHszOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMzozMSwxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNn0sbygkVjgsWzIsMTddKSxvKCRWOCxbMiwxNV0pLG8oJFY5LFsyLDIxXSldLFxuZGVmYXVsdEFjdGlvbnM6IHsxNjpbMiw2XX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICB9XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBzdGFjayA9IFswXSwgdnN0YWNrID0gW251bGxdLCBsc3RhY2sgPSBbXSwgdGFibGUgPSB0aGlzLnRhYmxlLCB5eXRleHQgPSAnJywgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCBURVJST1IgPSAyLCBFT0YgPSAxO1xuICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciBzaGFyZWRTdGF0ZSA9IHsgeXk6IHt9IH07XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLnl5KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy55eSwgaykpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5W2tdID0gdGhpcy55eVtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXhlci5zZXRJbnB1dChpbnB1dCwgc2hhcmVkU3RhdGUueXkpO1xuICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXI7XG4gICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGxleGVyLnl5bGxvYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsZXhlci55eWxsb2MgPSB7fTtcbiAgICB9XG4gICAgdmFyIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcbiAgICB2YXIgcmFuZ2VzID0gbGV4ZXIub3B0aW9ucyAmJiBsZXhlci5vcHRpb25zLnJhbmdlcztcbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykucGFyc2VFcnJvcjtcbiAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgdmFyIHN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goJ1xcJycgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxleGVyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOlxcbicgKyBsZXhlci5zaG93UG9zaXRpb24oKSArICdcXG5FeHBlY3RpbmcgJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnLCBnb3QgXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzogVW5leHBlY3RlZCAnICsgKHN5bWJvbCA9PSBFT0YgPyAnZW5kIG9mIGlucHV0JyA6ICdcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbGV4ZXIubWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHl5bG9jLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnICsgc3RhdGUgKyAnLCB0b2tlbjogJyArIHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHl5bGVuZyA9IGxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5hcHBseSh5eXZhbCwgW1xuICAgICAgICAgICAgICAgIHl5dGV4dCxcbiAgICAgICAgICAgICAgICB5eWxlbmcsXG4gICAgICAgICAgICAgICAgeXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgc2hhcmVkU3RhdGUueXksXG4gICAgICAgICAgICAgICAgYWN0aW9uWzFdLFxuICAgICAgICAgICAgICAgIHZzdGFjayxcbiAgICAgICAgICAgICAgICBsc3RhY2tcbiAgICAgICAgICAgIF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XG4gICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgICAgICBsc3RhY2sgPSBsc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xuICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGggLSAyXV1bc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59fTtcbi8qIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC4zLjQgKi9cbnZhciBsZXhlciA9IChmdW5jdGlvbigpe1xudmFyIGxleGVyID0gKHtcblxuRU9GOjEsXG5cbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQsIHl5KSB7XG4gICAgICAgIHRoaXMueXkgPSB5eSB8fCB0aGlzLnl5IHx8IHt9O1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fYmFja3RyYWNrID0gdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gPSB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLDBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbmlucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcblxuLy8gdW5zaGlmdHMgb25lIGNoYXIgKG9yIGEgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxudW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG5cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKVxuICAgICAgICAgICAgICAgICArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIC0gbGVuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uXG5tb3JlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBzaWduYWxzIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZSBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG5yZWplY3Q6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaFxubGVzczpmdW5jdGlvbiAobikge1xuICAgICAgICB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnBhc3RJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHBhc3QubGVuZ3RoID4gMjAgPyAnLi4uJzonJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnVwY29taW5nSW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMC1uZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuZXh0LnN1YnN0cigwLDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5zaG93UG9zaXRpb246ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xuICAgIH0sXG5cbi8vIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlblxudGVzdF9tYXRjaDpmdW5jdGlvbiAobWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGJhY2t1cDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5uZXh0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKVxuYmVnaW46ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uIHN0YWNrXG5wb3BTdGF0ZTpmdW5jdGlvbiBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbXCJJTklUSUFMXCJdLnJ1bGVzO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleCBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsIGlmIGF2YWlsYWJsZVxudG9wU3RhdGU6ZnVuY3Rpb24gdG9wU3RhdGUobikge1xuICAgICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcbiAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJTklUSUFMXCI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKVxucHVzaFN0YXRlOmZ1bmN0aW9uIHB1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG5zdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5vcHRpb25zOiB7fSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkge1xuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDovKiBza2lwIHdoaXRlc3BhY2UgKi9cbmJyZWFrO1xuY2FzZSAxOnJldHVybiA2XG5jYXNlIDI6eXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDEseXlfLnl5bGVuZy0yKTsgcmV0dXJuIDRcbmNhc2UgMzpyZXR1cm4gMTdcbmNhc2UgNDpyZXR1cm4gMThcbmNhc2UgNTpyZXR1cm4gMjNcbmNhc2UgNjpyZXR1cm4gMjRcbmNhc2UgNzpyZXR1cm4gMjJcbmNhc2UgODpyZXR1cm4gMjFcbmNhc2UgOTpyZXR1cm4gMTBcbmNhc2UgMTA6cmV0dXJuIDExXG5jYXNlIDExOnJldHVybiA4XG5jYXNlIDEyOnJldHVybiAxNFxuY2FzZSAxMzpyZXR1cm4gJ0lOVkFMSUQnXG59XG59LFxucnVsZXM6IFsvXig/OlxccyspLywvXig/OigtPyhbMC05XXxbMS05XVswLTldKykpKFxcLlswLTldKyk/KFtlRV1bLStdP1swLTldKyk/XFxiKS8sL14oPzpcIig/OlxcXFxbXFxcXFwiYmZucnQvXXxcXFxcdVthLWZBLUYwLTldezR9fFteXFxcXFxcMC1cXHgwOVxceDBhLVxceDFmXCJdKSpcIikvLC9eKD86XFx7KS8sL14oPzpcXH0pLywvXig/OlxcWykvLC9eKD86XFxdKS8sL14oPzosKS8sL14oPzo6KS8sL14oPzp0cnVlXFxiKS8sL14oPzpmYWxzZVxcYikvLC9eKD86bnVsbFxcYikvLC9eKD86JCkvLC9eKD86LikvXSxcbmNvbmRpdGlvbnM6IHtcIklOSVRJQUxcIjp7XCJydWxlc1wiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzXSxcImluY2x1c2l2ZVwiOnRydWV9fVxufSk7XG5yZXR1cm4gbGV4ZXI7XG59KSgpO1xucGFyc2VyLmxleGVyID0gbGV4ZXI7XG5mdW5jdGlvbiBQYXJzZXIgKCkge1xuICB0aGlzLnl5ID0ge307XG59XG5QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO3BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG5yZXR1cm4gbmV3IFBhcnNlcjtcbn0pKCk7XG5cblxuaWYgKHR5cGVvZiBjb21tb25qc1JlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmICdvYmplY3QnICE9PSAndW5kZWZpbmVkJykge1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTsgfTtcbn1cbn0pO1xuXG5mdW5jdGlvbiByZWFkU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyB8fCBzdHlsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb25saW50LnBhcnNlKHN0eWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yJDEoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlKHN0eWxlLCBzdHlsZVNwZWMgPSB2OCkge1xuICAgIGxldCBzID0gc3R5bGU7XG4gICAgdHJ5IHtcbiAgICAgICAgcyA9IHJlYWRTdHlsZShzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBbZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVN0eWxlTWluKHMsIHN0eWxlU3BlYyk7XG59XG5cbmNvbnN0IFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04gPSA4O1xuY29uc3QgTUFYX1NPVVJDRVNfSU5fU1RZTEUgPSAxNTtcbmZ1bmN0aW9uIGlzVmFsaWQodmFsdWUsIHJlZ2V4KSB7XG4gICAgaWYgKCF2YWx1ZSB8fCBnZXRUeXBlKHZhbHVlKSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAhIXZhbHVlLm1hdGNoKHJlZ2V4KTtcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZUNvdW50KHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UudXJsKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UudXJsLnNwbGl0KCcsJykubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFsbG93ZWRLZXlFcnJvcnMob2JqLCBrZXlzLCBwYXRoKSB7XG4gICAgY29uc3QgYWxsb3dlZCA9IG5ldyBTZXQoa2V5cyk7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICBpZiAoIWFsbG93ZWQuaGFzKGspKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gcGF0aCA/IGAkeyBwYXRoIH0uJHsgayB9YCA6IG51bGw7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKHByb3AsIG9ialtrXSwgYFVuc3VwcG9ydGVkIHByb3BlcnR5IFwiJHsgayB9XCJgKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuY29uc3QgYWNjZXB0ZWRTb3VyY2VUeXBlcyA9IG5ldyBTZXQoW1xuICAgICd2ZWN0b3InLFxuICAgICdyYXN0ZXInLFxuICAgICdyYXN0ZXItZGVtJ1xuXSk7XG5mdW5jdGlvbiBnZXRTb3VyY2VFcnJvcnMoc291cmNlLCBpKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3Qgc291cmNlS2V5cyA9IFtcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAndXJsJyxcbiAgICAgICAgJ3RpbGVTaXplJ1xuICAgIF07XG4gICAgZXJyb3JzLnB1c2goLi4uZ2V0QWxsb3dlZEtleUVycm9ycyhzb3VyY2UsIHNvdXJjZUtleXMsICdzb3VyY2UnKSk7XG4gICAgaWYgKCFhY2NlcHRlZFNvdXJjZVR5cGVzLmhhcyhTdHJpbmcoc291cmNlLnR5cGUpKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGBzb3VyY2VzWyR7IGkgfV0udHlwZWAsIHNvdXJjZS50eXBlLCBgRXhwZWN0ZWQgb25lIG9mIFskeyBBcnJheS5mcm9tKGFjY2VwdGVkU291cmNlVHlwZXMpLmpvaW4oJywgJykgfV1gKSk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC8oW14vXSopJC87XG4gICAgaWYgKCFzb3VyY2UudXJsIHx8ICFpc1ZhbGlkKHNvdXJjZS51cmwsIHNvdXJjZVVybFBhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoYHNvdXJjZXNbJHsgaSB9XS51cmxgLCBzb3VyY2UudXJsLCAnRXhwZWN0ZWQgYSB2YWxpZCBNYXBib3ggdGlsZXNldCB1cmwnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRTb3VyY2VzRXJyb3JzKHNvdXJjZXMpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZXMpLmZvckVhY2goKHMsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc291cmNlRXJyb3JzID0gZ2V0U291cmNlRXJyb3JzKHNvdXJjZXNbc10sIGkpO1xuICAgICAgICBpZiAoIXNvdXJjZUVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQgKyBnZXRTb3VyY2VDb3VudChzb3VyY2VzW3NdKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMucHVzaCguLi5zb3VyY2VFcnJvcnMpO1xuICAgIH0pO1xuICAgIGlmIChjb3VudCA+IE1BWF9TT1VSQ0VTX0lOX1NUWUxFKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3NvdXJjZXMnLCBudWxsLCBgU3R5bGVzIG11c3QgY29udGFpbiAkeyBNQVhfU09VUkNFU19JTl9TVFlMRSB9IG9yIGZld2VyIHNvdXJjZXNgKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBnZXRSb290RXJyb3JzKHN0eWxlLCBzcGVjS2V5cykge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IG9wdGlvbmFsUm9vdFByb3BlcnRpZXMgPSBbXG4gICAgICAgICdvd25lcicsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdjYWNoZUNvbnRyb2wnLFxuICAgICAgICAnZHJhZnQnLFxuICAgICAgICAnY3JlYXRlZCcsXG4gICAgICAgICdtb2RpZmllZCcsXG4gICAgICAgICd2aXNpYmlsaXR5JyxcbiAgICAgICAgJ3Byb3RlY3RlZCdcbiAgICBdO1xuICAgIGNvbnN0IGFsbG93ZWRLZXlFcnJvcnMgPSBnZXRBbGxvd2VkS2V5RXJyb3JzKHN0eWxlLCBbXG4gICAgICAgIC4uLnNwZWNLZXlzLFxuICAgICAgICAuLi5vcHRpb25hbFJvb3RQcm9wZXJ0aWVzXG4gICAgXSk7XG4gICAgZXJyb3JzLnB1c2goLi4uYWxsb3dlZEtleUVycm9ycyk7XG4gICAgaWYgKHN0eWxlLnZlcnNpb24gPiBTVVBQT1JURURfU1BFQ19WRVJTSU9OIHx8IHN0eWxlLnZlcnNpb24gPCBTVVBQT1JURURfU1BFQ19WRVJTSU9OKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3ZlcnNpb24nLCBzdHlsZS52ZXJzaW9uLCBgU3R5bGUgdmVyc2lvbiBtdXN0IGJlICR7IFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04gfWApKTtcbiAgICB9XG4gICAgY29uc3QgZ2x5cGhVcmxQYXR0ZXJuID0gL15tYXBib3g6XFwvXFwvZm9udHNcXC8oW14vXSopXFwve2ZvbnRzdGFja31cXC97cmFuZ2V9LnBiZiQvO1xuICAgIGlmICghaXNWYWxpZChzdHlsZS5nbHlwaHMsIGdseXBoVXJsUGF0dGVybikpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignZ2x5cGhzJywgc3R5bGUuZ2x5cGhzLCAnU3R5bGVzIG11c3QgcmVmZXJlbmNlIGdseXBocyBob3N0ZWQgYnkgTWFwYm94JykpO1xuICAgIH1cbiAgICBjb25zdCBzcHJpdGVVcmxQYXR0ZXJuID0gL15tYXBib3g6XFwvXFwvc3ByaXRlc1xcLyhbXi9dKilcXC8oW14vXSopXFwvPyhbXi9dKik/JC87XG4gICAgaWYgKCFpc1ZhbGlkKHN0eWxlLnNwcml0ZSwgc3ByaXRlVXJsUGF0dGVybikpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignc3ByaXRlJywgc3R5bGUuc3ByaXRlLCAnU3R5bGVzIG11c3QgcmVmZXJlbmNlIHNwcml0ZXMgaG9zdGVkIGJ5IE1hcGJveCcpKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJpbGl0eVBhdHRlcm4gPSAvXihwdWJsaWN8cHJpdmF0ZSkkLztcbiAgICBpZiAoIWlzVmFsaWQoc3R5bGUudmlzaWJpbGl0eSwgdmlzaWJpbGl0eVBhdHRlcm4pKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Zpc2liaWxpdHknLCBzdHlsZS52aXNpYmlsaXR5LCAnU3R5bGUgdmlzaWJpbGl0eSBtdXN0IGJlIHB1YmxpYyBvciBwcml2YXRlJykpO1xuICAgIH1cbiAgICBpZiAoc3R5bGUucHJvdGVjdGVkICE9PSB1bmRlZmluZWQgJiYgZ2V0VHlwZShzdHlsZS5wcm90ZWN0ZWQpICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcigncHJvdGVjdGVkJywgc3R5bGUucHJvdGVjdGVkLCAnU3R5bGUgcHJvdGVjdGlvbiBtdXN0IGJlIHRydWUgb3IgZmFsc2UnKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1hcGJveEFwaVN1cHBvcnRlZChzdHlsZSkge1xuICAgIGxldCBzID0gc3R5bGU7XG4gICAgdHJ5IHtcbiAgICAgICAgcyA9IHJlYWRTdHlsZShzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBbZV07XG4gICAgfVxuICAgIGxldCBlcnJvcnMgPSB2YWxpZGF0ZVN0eWxlTWluKHMsIHY4KS5jb25jYXQoZ2V0Um9vdEVycm9ycyhzLCBPYmplY3Qua2V5cyh2OC4kcm9vdCkpKTtcbiAgICBpZiAocy5zb3VyY2VzKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZ2V0U291cmNlc0Vycm9ycyhzLnNvdXJjZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cblxuY29uc3QgZXhwcmVzc2lvbiQxID0ge1xuICAgIFN0eWxlRXhwcmVzc2lvbixcbiAgICBpc0V4cHJlc3Npb24sXG4gICAgaXNFeHByZXNzaW9uRmlsdGVyLFxuICAgIGNyZWF0ZUV4cHJlc3Npb24sXG4gICAgY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uLFxuICAgIG5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbixcbiAgICBab29tQ29uc3RhbnRFeHByZXNzaW9uLFxuICAgIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uLFxuICAgIFN0eWxlUHJvcGVydHlGdW5jdGlvblxufTtcbmNvbnN0IHN0eWxlRnVuY3Rpb24gPSB7XG4gICAgY29udmVydEZ1bmN0aW9uLFxuICAgIGNyZWF0ZUZ1bmN0aW9uLFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24kMVxufTtcbmNvbnN0IHZpc2l0ID0ge1xuICAgIGVhY2hTb3VyY2UsXG4gICAgZWFjaExheWVyLFxuICAgIGVhY2hQcm9wZXJ0eVxufTtcbnZhbGlkYXRlU3R5bGUucGFyc2VkID0gdmFsaWRhdGVTdHlsZTtcbnZhbGlkYXRlU3R5bGUubGF0ZXN0ID0gdmFsaWRhdGVTdHlsZTtcblxuZXhwb3J0IHsgQ29sb3IsIFBhcnNpbmdFcnJvciQxIGFzIFBhcnNpbmdFcnJvciwgVmFsaWRhdGlvbkVycm9yLCBjb21wb3NpdGUsIGNvbnZlcnRGaWx0ZXIkMSBhcyBjb252ZXJ0RmlsdGVyLCBkZXJlZkxheWVycywgZGlmZlN0eWxlcyBhcyBkaWZmLCBleHByZXNzaW9uJDEgYXMgZXhwcmVzc2lvbiwgY3JlYXRlRmlsdGVyIGFzIGZlYXR1cmVGaWx0ZXIsIGZvcm1hdCwgc3R5bGVGdW5jdGlvbiBhcyBmdW5jdGlvbiwgdjggYXMgbGF0ZXN0LCBtaWdyYXRlLCB2OCwgdmFsaWRhdGVTdHlsZSBhcyB2YWxpZGF0ZSwgdmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQsIHZpc2l0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsInZhciBmb250V2VpZ2h0cyA9IHtcbiAgdGhpbjogMTAwLFxuICBoYWlybGluZTogMTAwLFxuICAndWx0cmEtbGlnaHQnOiAxMDAsXG4gICdleHRyYS1saWdodCc6IDEwMCxcbiAgbGlnaHQ6IDIwMCxcbiAgYm9vazogMzAwLFxuICByZWd1bGFyOiA0MDAsXG4gIG5vcm1hbDogNDAwLFxuICBwbGFpbjogNDAwLFxuICByb21hbjogNDAwLFxuICBzdGFuZGFyZDogNDAwLFxuICBtZWRpdW06IDUwMCxcbiAgJ3NlbWktYm9sZCc6IDYwMCxcbiAgJ2RlbWktYm9sZCc6IDYwMCxcbiAgYm9sZDogNzAwLFxuICBoZWF2eTogODAwLFxuICBibGFjazogODAwLFxuICAnZXh0cmEtYm9sZCc6IDgwMCxcbiAgJ3VsdHJhLWJsYWNrJzogOTAwLFxuICAnZXh0cmEtYmxhY2snOiA5MDAsXG4gICd1bHRyYS1ib2xkJzogOTAwLFxuICAnaGVhdnktYmxhY2snOiA5MDAsXG4gIGZhdDogOTAwLFxuICBwb3N0ZXI6IDkwMFxufTtcbnZhciBzcCA9ICcgJztcbnZhciBpdGFsaWNSRSA9IC8oaXRhbGljfG9ibGlxdWUpJC9pO1xuXG52YXIgZm9udENhY2hlID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm9udHMsIHNpemUsIGxpbmVIZWlnaHQpIHtcbiAgdmFyIGNzc0RhdGEgPSBmb250Q2FjaGVbZm9udHNdO1xuICBpZiAoIWNzc0RhdGEpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZm9udHMpKSB7XG4gICAgICBmb250cyA9IFtmb250c107XG4gICAgfVxuICAgIHZhciB3ZWlnaHQgPSA0MDA7XG4gICAgdmFyIHN0eWxlID0gJ25vcm1hbCc7XG4gICAgdmFyIGZvbnRGYW1pbGllcyA9IFtdO1xuICAgIHZhciBoYXZlV2VpZ2h0LCBoYXZlU3R5bGU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZm9udHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGZvbnQgPSBmb250c1tpXTtcbiAgICAgIHZhciBwYXJ0cyA9IGZvbnQuc3BsaXQoJyAnKTtcbiAgICAgIHZhciBtYXliZVdlaWdodCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobWF5YmVXZWlnaHQgPT0gJ25vcm1hbCcgfHwgbWF5YmVXZWlnaHQgPT0gJ2l0YWxpYycgfHwgbWF5YmVXZWlnaHQgPT0gJ29ibGlxdWUnKSB7XG4gICAgICAgIHN0eWxlID0gaGF2ZVN0eWxlID8gc3R5bGUgOiBtYXliZVdlaWdodDtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgIG1heWJlV2VpZ2h0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRhbGljUkUudGVzdChtYXliZVdlaWdodCkpIHtcbiAgICAgICAgbWF5YmVXZWlnaHQgPSBtYXliZVdlaWdodC5yZXBsYWNlKGl0YWxpY1JFLCAnJyk7XG4gICAgICAgIHN0eWxlID0gaGF2ZVN0eWxlID8gc3R5bGUgOiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5yZXBsYWNlKG1heWJlV2VpZ2h0LCAnJyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB3IGluIGZvbnRXZWlnaHRzKSB7XG4gICAgICAgIGlmIChtYXliZVdlaWdodCA9PSB3IHx8IG1heWJlV2VpZ2h0ID09IHcucmVwbGFjZSgnLScsICcnKSB8fCBtYXliZVdlaWdodCA9PSB3LnJlcGxhY2UoJy0nLCBzcCkpIHtcbiAgICAgICAgICB3ZWlnaHQgPSBoYXZlV2VpZ2h0ID8gd2VpZ2h0IDogZm9udFdlaWdodHNbd107XG4gICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGF2ZVdlaWdodCAmJiB0eXBlb2YgbWF5YmVXZWlnaHQgPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2VpZ2h0ID0gbWF5YmVXZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHBhcnRzLmpvaW4oc3ApXG4gICAgICAgIC5yZXBsYWNlKCdLbG9rYW50ZWNoIE5vdG8gU2FucycsICdOb3RvIFNhbnMnKTtcbiAgICAgIGlmIChmb250RmFtaWx5LmluZGV4T2Yoc3ApICE9PSAtMSkge1xuICAgICAgICBmb250RmFtaWx5ID0gJ1wiJyArIGZvbnRGYW1pbHkgKyAnXCInO1xuICAgICAgfVxuICAgICAgZm9udEZhbWlsaWVzLnB1c2goZm9udEZhbWlseSk7XG4gICAgfVxuICAgIC8vIENTUyBmb250IHByb3BlcnR5OiBmb250LXN0eWxlIGZvbnQtd2VpZ2h0IGZvbnQtc2l6ZS9saW5lLWhlaWdodCBmb250LWZhbWlseVxuICAgIGNzc0RhdGEgPSBmb250Q2FjaGVbZm9udHNdID0gW3N0eWxlLCB3ZWlnaHQsIGZvbnRGYW1pbGllc107XG4gIH1cbiAgcmV0dXJuIGNzc0RhdGFbMF0gKyBzcCArIGNzc0RhdGFbMV0gKyBzcCArIHNpemUgKyAncHgnICsgKGxpbmVIZWlnaHQgPyAnLycgKyBsaW5lSGVpZ2h0IDogJycpICsgc3AgKyBjc3NEYXRhWzJdO1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9Bc3NlcnRpb25FcnJvclxuICovXG5pbXBvcnQge1ZFUlNJT04sIGluaGVyaXRzfSBmcm9tICcuL2luZGV4LmpzJztcblxuLyoqXG4gKiBFcnJvciBvYmplY3QgdGhyb3duIHdoZW4gYW4gYXNzZXJ0aW9uIGZhaWxlZC4gVGhpcyBpcyBhbiBFQ01BLTI2MiBFcnJvcixcbiAqIGV4dGVuZGVkIHdpdGggYSBgY29kZWAgcHJvcGVydHkuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvcn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgRXJyb3IgY29kZS5cbiAqL1xuY29uc3QgQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbihjb2RlKSB7XG5cbiAgY29uc3QgcGF0aCA9IFZFUlNJT04gPyBWRVJTSU9OLnNwbGl0KCctJylbMF0gOiAnbGF0ZXN0JztcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMubWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLiBTZWUgaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi8nICsgcGF0aCArXG4gICAgICAnL2RvYy9lcnJvcnMvIycgKyBjb2RlICsgJyBmb3IgZGV0YWlscy4nO1xuXG4gIC8qKlxuICAgKiBFcnJvciBjb2RlLiBUaGUgbWVhbmluZyBvZiB0aGUgY29kZSBjYW4gYmUgZm91bmQgb25cbiAgICoge0BsaW5rIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2RvYy9lcnJvcnMvfSAocmVwbGFjZSBgbGF0ZXN0YCB3aXRoXG4gICAqIHRoZSB2ZXJzaW9uIGZvdW5kIGluIHRoZSBPcGVuTGF5ZXJzIHNjcmlwdCdzIGhlYWRlciBjb21tZW50IGlmIGEgdmVyc2lvblxuICAgKiBvdGhlciB0aGFuIHRoZSBsYXRlc3QgaXMgdXNlZCkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMuY29kZSA9IGNvZGU7XG5cbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcblxufTtcblxuaW5oZXJpdHMoQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZXhwb3J0IGRlZmF1bHQgQXNzZXJ0aW9uRXJyb3I7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvRGlzcG9zYWJsZVxuICovXG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqIE9iamVjdHMgdGhhdCBuZWVkIHRvIGNsZWFuIHVwIGFmdGVyIHRoZW1zZWx2ZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY29uc3QgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogVGhlIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5EaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlZF8gPSBmYWxzZTtcblxuLyoqXG4gKiBDbGVhbiB1cC5cbiAqL1xuRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG4gICAgdGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuICAgIHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXh0ZW5zaW9uIHBvaW50IGZvciBkaXNwb3NhYmxlIG9iamVjdHMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IFVOREVGSU5FRDtcbmV4cG9ydCBkZWZhdWx0IERpc3Bvc2FibGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VUaWxlXG4gKi9cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJy4vaW5kZXguanMnO1xuaW1wb3J0IFRpbGUgZnJvbSAnLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuT25jZSwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihuZXc6IG1vZHVsZTpvbC9JbWFnZVRpbGUsIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkLFxuICogbW9kdWxlOm9sL1RpbGVTdGF0ZSwgc3RyaW5nLCA/c3RyaW5nLCBtb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb24pfSBUaWxlQ2xhc3NcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTpvbC9UaWxlfVxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIEltYWdlIHNvdXJjZSBVUkkuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGUgbG9hZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGV+T3B0aW9ucz19IG9wdF9vcHRpb25zIFRpbGUgb3B0aW9ucy5cbiAqL1xuY29uc3QgSW1hZ2VUaWxlID0gZnVuY3Rpb24odGlsZUNvb3JkLCBzdGF0ZSwgc3JjLCBjcm9zc09yaWdpbiwgdGlsZUxvYWRGdW5jdGlvbiwgb3B0X29wdGlvbnMpIHtcblxuICBUaWxlLmNhbGwodGhpcywgdGlsZUNvb3JkLCBzdGF0ZSwgb3B0X29wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICovXG4gIHRoaXMuY3Jvc3NPcmlnaW5fID0gY3Jvc3NPcmlnaW47XG5cbiAgLyoqXG4gICAqIEltYWdlIFVSSVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5zcmNfID0gc3JjO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7SW1hZ2V8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqL1xuICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICBpZiAoY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICB0aGlzLmltYWdlXy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+fVxuICAgKi9cbiAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufVxuICAgKi9cbiAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyA9IHRpbGVMb2FkRnVuY3Rpb247XG5cbn07XG5cbmluaGVyaXRzKEltYWdlVGlsZSwgVGlsZSk7XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5JbWFnZVRpbGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmltYWdlXyA9IGdldEJsYW5rSW1hZ2UoKTtcbiAgfVxuICBpZiAodGhpcy5pbnRlcmltVGlsZSkge1xuICAgIHRoaXMuaW50ZXJpbVRpbGUuZGlzcG9zZSgpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuQUJPUlQ7XG4gIHRoaXMuY2hhbmdlZCgpO1xuICBUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIEhUTUwgaW1hZ2UgZWxlbWVudCBmb3IgdGhpcyB0aWxlIChtYXkgYmUgYSBDYW52YXMsIEltYWdlLCBvciBWaWRlbykuXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IEltYWdlLlxuICogQGFwaVxuICovXG5JbWFnZVRpbGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmltYWdlXztcbn07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5JbWFnZVRpbGUucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zcmNfO1xufTtcblxuXG4vKipcbiAqIFRyYWNrcyBsb2FkaW5nIG9yIHJlYWQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkltYWdlVGlsZS5wcm90b3R5cGUuaGFuZGxlSW1hZ2VFcnJvcl8gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICB0aGlzLmltYWdlXyA9IGdldEJsYW5rSW1hZ2UoKTtcbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5cbi8qKlxuICogVHJhY2tzIHN1Y2Nlc3NmdWwgaW1hZ2UgbG9hZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5JbWFnZVRpbGUucHJvdG90eXBlLmhhbmRsZUltYWdlTG9hZF8gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaW1hZ2VfLm5hdHVyYWxXaWR0aCAmJiB0aGlzLmltYWdlXy5uYXR1cmFsSGVpZ2h0KSB7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FERUQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgfVxuICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKiBAYXBpXG4gKi9cbkltYWdlVGlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLklETEU7XG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FESU5HO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gW1xuICAgICAgbGlzdGVuT25jZSh0aGlzLmltYWdlXywgRXZlbnRUeXBlLkVSUk9SLFxuICAgICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfLCB0aGlzKSxcbiAgICAgIGxpc3Rlbk9uY2UodGhpcy5pbWFnZV8sIEV2ZW50VHlwZS5MT0FELFxuICAgICAgICB0aGlzLmhhbmRsZUltYWdlTG9hZF8sIHRoaXMpXG4gICAgXTtcbiAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb25fKHRoaXMsIHRoaXMuc3JjXyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBEaXNjYXJkcyBldmVudCBoYW5kbGVycyB3aGljaCBsaXN0ZW4gZm9yIGxvYWQgY29tcGxldGlvbiBvciBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuSW1hZ2VUaWxlLnByb3RvdHlwZS51bmxpc3RlbkltYWdlXyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogR2V0IGEgMS1waXhlbCBibGFuayBpbWFnZS5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBCbGFuayBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxhbmtJbWFnZSgpIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gIHJldHVybiBjdHguY2FudmFzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0XG4gKi9cbmltcG9ydCB7Z2V0VWlkLCBpbmhlcml0c30gZnJvbSAnLi9pbmRleC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4vb2JqLmpzJztcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mXG4gKiB0aGlzIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIGZvciBga2V5YC5cbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNvbnN0IE9iamVjdEV2ZW50ID0gZnVuY3Rpb24odHlwZSwga2V5LCBvbGRWYWx1ZSkge1xuICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgY2hhbmdpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMua2V5ID0ga2V5O1xuXG4gIC8qKlxuICAgKiBUaGUgb2xkIHZhbHVlLiBUbyBnZXQgdGhlIG5ldyB2YWx1ZSB1c2UgYGUudGFyZ2V0LmdldChlLmtleSlgIHdoZXJlXG4gICAqIGBlYCBpcyB0aGUgZXZlbnQgb2JqZWN0LlxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGFwaVxuICAgKi9cbiAgdGhpcy5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuXG59O1xuaW5oZXJpdHMoT2JqZWN0RXZlbnQsIEV2ZW50KTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIE1vc3Qgbm9uLXRyaXZpYWwgY2xhc3NlcyBpbmhlcml0IGZyb20gdGhpcy5cbiAqXG4gKiBUaGlzIGV4dGVuZHMge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfSB3aXRoIG9ic2VydmFibGVcbiAqIHByb3BlcnRpZXMsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgb2JzZXJ2YWJsZSBhcyB3ZWxsIGFzIHRoZSBvYmplY3QgYXMgYVxuICogd2hvbGUuXG4gKlxuICogQ2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIGhhdmUgcHJlLWRlZmluZWQgcHJvcGVydGllcywgdG8gd2hpY2ggeW91IGNhblxuICogYWRkIHlvdXIgb3ducy4gVGhlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMgYXJlIGxpc3RlZCBpbiB0aGlzIGRvY3VtZW50YXRpb24gYXNcbiAqICdPYnNlcnZhYmxlIFByb3BlcnRpZXMnLCBhbmQgaGF2ZSB0aGVpciBvd24gYWNjZXNzb3JzOyBmb3IgZXhhbXBsZSxcbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gaGFzIGEgYHRhcmdldGAgcHJvcGVydHksIGFjY2Vzc2VkIHdpdGhcbiAqIGBnZXRUYXJnZXQoKWAgYW5kIGNoYW5nZWQgd2l0aCBgc2V0VGFyZ2V0KClgLiBOb3QgYWxsIHByb3BlcnRpZXMgYXJlIGhvd2V2ZXJcbiAqIHNldHRhYmxlLiBUaGVyZSBhcmUgYWxzbyBnZW5lcmFsLXB1cnBvc2UgYWNjZXNzb3JzIGBnZXQoKWAgYW5kIGBzZXQoKWAuIEZvclxuICogZXhhbXBsZSwgYGdldCgndGFyZ2V0JylgIGlzIGVxdWl2YWxlbnQgdG8gYGdldFRhcmdldCgpYC5cbiAqXG4gKiBUaGUgYHNldGAgYWNjZXNzb3JzIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIGFuZCB5b3UgY2FuIG1vbml0b3IgdGhpcyBieVxuICogcmVnaXN0ZXJpbmcgYSBsaXN0ZW5lci4gRm9yIGV4YW1wbGUsIHtAbGluayBtb2R1bGU6b2wvVmlld35WaWV3fSBoYXMgYVxuICogYGNlbnRlcmAgcHJvcGVydHksIHNvIGB2aWV3Lm9uKCdjaGFuZ2U6Y2VudGVyJywgZnVuY3Rpb24oZXZ0KSB7Li4ufSk7YCB3b3VsZFxuICogY2FsbCB0aGUgZnVuY3Rpb24gd2hlbmV2ZXIgdGhlIHZhbHVlIG9mIHRoZSBjZW50ZXIgcHJvcGVydHkgY2hhbmdlcy4gV2l0aGluXG4gKiB0aGUgZnVuY3Rpb24sIGBldnQudGFyZ2V0YCB3b3VsZCBiZSB0aGUgdmlldywgc28gYGV2dC50YXJnZXQuZ2V0Q2VudGVyKClgXG4gKiB3b3VsZCByZXR1cm4gdGhlIG5ldyBjZW50ZXIuXG4gKlxuICogWW91IGNhbiBhZGQgeW91ciBvd24gb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIHdpdGhcbiAqIGBvYmplY3Quc2V0KCdwcm9wJywgJ3ZhbHVlJylgLCBhbmQgcmV0cmlldmUgdGhhdCB3aXRoIGBvYmplY3QuZ2V0KCdwcm9wJylgLlxuICogWW91IGNhbiBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhhdCBwcm9wZXJ0eSB2YWx1ZSB3aXRoXG4gKiBgb2JqZWN0Lm9uKCdjaGFuZ2U6cHJvcCcsIGxpc3RlbmVyKWAuIFlvdSBjYW4gZ2V0IGEgbGlzdCBvZiBhbGxcbiAqIHByb3BlcnRpZXMgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0I2dldFByb3BlcnRpZXN9LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIGFyZSBzZXBhcmF0ZSBmcm9tIHN0YW5kYXJkIEpTIHByb3BlcnRpZXMuXG4gKiBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgZ2l2ZSB5b3VyIG1hcCBvYmplY3QgYSB0aXRsZSB3aXRoXG4gKiBgbWFwLnRpdGxlPSdOZXcgdGl0bGUnYCBhbmQgd2l0aCBgbWFwLnNldCgndGl0bGUnLCAnQW5vdGhlciB0aXRsZScpYC4gVGhlXG4gKiBmaXJzdCB3aWxsIGJlIGEgYGhhc093blByb3BlcnR5YDsgdGhlIHNlY29uZCB3aWxsIGFwcGVhciBpblxuICogYGdldFByb3BlcnRpZXMoKWAuIE9ubHkgdGhlIHNlY29uZCBpcyBvYnNlcnZhYmxlLlxuICpcbiAqIFByb3BlcnRpZXMgY2FuIGJlIGRlbGV0ZWQgYnkgdXNpbmcgdGhlIHVuc2V0IG1ldGhvZC4gRS5nLlxuICogb2JqZWN0LnVuc2V0KCdmb28nKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvT2JzZXJ2YWJsZX1cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+PX0gb3B0X3ZhbHVlcyBBbiBvYmplY3Qgd2l0aCBrZXktdmFsdWUgcGFpcnMuXG4gKiBAZmlyZXMgbW9kdWxlOm9sL09iamVjdH5PYmplY3RFdmVudFxuICogQGFwaVxuICovXG5jb25zdCBCYXNlT2JqZWN0ID0gZnVuY3Rpb24ob3B0X3ZhbHVlcykge1xuICBPYnNlcnZhYmxlLmNhbGwodGhpcyk7XG5cbiAgLy8gQ2FsbCB7QGxpbmsgbW9kdWxlOm9sfmdldFVpZH0gdG8gZW5zdXJlIHRoYXQgdGhlIG9yZGVyIG9mIG9iamVjdHMnIGlkcyBpc1xuICAvLyB0aGUgc2FtZSBhcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGNyZWF0ZWQuICBUaGlzIGFsc28gaGVscHMgdG9cbiAgLy8gZW5zdXJlIHRoYXQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIGFsd2F5cyBhZGRlZCBpbiB0aGUgc2FtZSBvcmRlciwgd2hpY2hcbiAgLy8gaGVscHMgbWFueSBKYXZhU2NyaXB0IGVuZ2luZXMgZ2VuZXJhdGUgZmFzdGVyIGNvZGUuXG4gIGdldFVpZCh0aGlzKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgKj59XG4gICAqL1xuICB0aGlzLnZhbHVlc18gPSB7fTtcblxuICBpZiAob3B0X3ZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRQcm9wZXJ0aWVzKG9wdF92YWx1ZXMpO1xuICB9XG59O1xuXG5pbmhlcml0cyhCYXNlT2JqZWN0LCBPYnNlcnZhYmxlKTtcblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgY2hhbmdlRXZlbnRUeXBlQ2FjaGUgPSB7fTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENoYW5nZSBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbmdlRXZlbnRUeXBlKGtleSkge1xuICByZXR1cm4gY2hhbmdlRXZlbnRUeXBlQ2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSA/XG4gICAgY2hhbmdlRXZlbnRUeXBlQ2FjaGVba2V5XSA6XG4gICAgKGNoYW5nZUV2ZW50VHlwZUNhY2hlW2tleV0gPSAnY2hhbmdlOicgKyBrZXkpO1xufVxuXG5cbi8qKlxuICogR2V0cyBhIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAqIEByZXR1cm4geyp9IFZhbHVlLlxuICogQGFwaVxuICovXG5CYXNlT2JqZWN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgbGV0IHZhbHVlO1xuICBpZiAodGhpcy52YWx1ZXNfLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICB2YWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIG9iamVjdCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBMaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGFwaVxuICovXG5CYXNlT2JqZWN0LnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlc18pO1xufTtcblxuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgb2YgYWxsIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgKj59IE9iamVjdC5cbiAqIEBhcGlcbiAqL1xuQmFzZU9iamVjdC5wcm90b3R5cGUuZ2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLnZhbHVlc18pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIE9sZCB2YWx1ZS5cbiAqL1xuQmFzZU9iamVjdC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24oa2V5LCBvbGRWYWx1ZSkge1xuICBsZXQgZXZlbnRUeXBlO1xuICBldmVudFR5cGUgPSBnZXRDaGFuZ2VFdmVudFR5cGUoa2V5KTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBPYmplY3RFdmVudChldmVudFR5cGUsIGtleSwgb2xkVmFsdWUpKTtcbiAgZXZlbnRUeXBlID0gT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE9iamVjdEV2ZW50KGV2ZW50VHlwZSwga2V5LCBvbGRWYWx1ZSkpO1xufTtcblxuXG4vKipcbiAqIFNldHMgYSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpbGVudCBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICogQGFwaVxuICovXG5CYXNlT2JqZWN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBvcHRfc2lsZW50KSB7XG4gIGlmIChvcHRfc2lsZW50KSB7XG4gICAgdGhpcy52YWx1ZXNfW2tleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgIHRoaXMudmFsdWVzX1trZXldID0gdmFsdWU7XG4gICAgaWYgKG9sZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyBhIGNvbGxlY3Rpb24gb2Yga2V5LXZhbHVlIHBhaXJzLiAgTm90ZSB0aGF0IHRoaXMgY2hhbmdlcyBhbnkgZXhpc3RpbmdcbiAqIHByb3BlcnRpZXMgYW5kIGFkZHMgbmV3IG9uZXMgKGl0IGRvZXMgbm90IHJlbW92ZSBhbnkgZXhpc3RpbmcgcHJvcGVydGllcykuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPn0gdmFsdWVzIFZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaWxlbnQgVXBkYXRlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudC5cbiAqIEBhcGlcbiAqL1xuQmFzZU9iamVjdC5wcm90b3R5cGUuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uKHZhbHVlcywgb3B0X3NpbGVudCkge1xuICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICB0aGlzLnNldChrZXksIHZhbHVlc1trZXldLCBvcHRfc2lsZW50KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFVuc2V0cyBhIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaWxlbnQgVW5zZXQgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICogQGFwaVxuICovXG5CYXNlT2JqZWN0LnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGtleSwgb3B0X3NpbGVudCkge1xuICBpZiAoa2V5IGluIHRoaXMudmFsdWVzXykge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZXNfW2tleV07XG4gICAgZGVsZXRlIHRoaXMudmFsdWVzX1trZXldO1xuICAgIGlmICghb3B0X3NpbGVudCkge1xuICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0RXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvT2JqZWN0fk9iamVjdEV2ZW50I3Byb3BlcnR5Y2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIFBST1BFUlRZQ0hBTkdFOiAncHJvcGVydHljaGFuZ2UnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09ic2VydmFibGVcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi9pbmRleC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleSwgdW5saXN0ZW4sIGxpc3Rlbk9uY2V9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9FdmVudFRhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQW4gZXZlbnQgdGFyZ2V0IHByb3ZpZGluZyBjb252ZW5pZW50IG1ldGhvZHMgZm9yIGxpc3RlbmVyIHJlZ2lzdHJhdGlvblxuICogYW5kIHVucmVnaXN0cmF0aW9uLiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgYWx3YXlzIGF2YWlsYWJsZSB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSNjaGFuZ2VkfS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fVxuICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+RXZlbnRcbiAqIEBzdHJ1Y3RcbiAqIEBhcGlcbiAqL1xuY29uc3QgT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uKCkge1xuXG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnJldmlzaW9uXyA9IDA7XG5cbn07XG5cbmluaGVyaXRzKE9ic2VydmFibGUsIEV2ZW50VGFyZ2V0KTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgdXNpbmcgdGhlIGtleSByZXR1cm5lZCBieSBgb24oKWAgb3IgYG9uY2UoKWAuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fEFycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59IGtleSBUaGUga2V5IHJldHVybmVkIGJ5IGBvbigpYFxuICogICAgIG9yIGBvbmNlKClgIChvciBhbiBhcnJheSBvZiBrZXlzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuQnlLZXkoa2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBrZXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdW5saXN0ZW5CeUtleShrZXlbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1bmxpc3RlbkJ5S2V5KC8qKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9ICovIChrZXkpKTtcbiAgfVxufVxuXG5cbi8qKlxuICogSW5jcmVhc2VzIHRoZSByZXZpc2lvbiBjb3VudGVyIGFuZCBkaXNwYXRjaGVzIGEgJ2NoYW5nZScgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbk9ic2VydmFibGUucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgKyt0aGlzLnJldmlzaW9uXztcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50VHlwZS5DSEFOR0UpO1xufTtcblxuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIGNhbGxzIGFsbCBsaXN0ZW5lcnMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAqIG9mIHRoaXMgdHlwZS4gVGhlIGV2ZW50IHBhcmFtZXRlciBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nIG9yIGFuXG4gKiBPYmplY3Qgd2l0aCBhIGB0eXBlYCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3t0eXBlOiBzdHJpbmcsXG4gKiAgICAgdGFyZ2V0OiAoRXZlbnRUYXJnZXR8bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldHx1bmRlZmluZWQpfXxcbiAqICAgICBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fHN0cmluZ30gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICogQGZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cbk9ic2VydmFibGUucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQ7XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZlcnNpb24gbnVtYmVyIGZvciB0aGlzIG9iamVjdC4gIEVhY2ggdGltZSB0aGUgb2JqZWN0IGlzIG1vZGlmaWVkLFxuICogaXRzIHZlcnNpb24gbnVtYmVyIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldmlzaW9uLlxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRSZXZpc2lvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZXZpc2lvbl87XG59O1xuXG5cbi8qKlxuICogTGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbig/KTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl8QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICogICAgIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIHJldHVyblxuICogICAgIHdpbGwgYmUgYW4gYXJyYXkgb2Yga2V5cy5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIGNvbnN0IGxlbiA9IHR5cGUubGVuZ3RoO1xuICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBrZXlzW2ldID0gbGlzdGVuKHRoaXMsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3Rlbih0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaXN0ZW4gb25jZSBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fEFycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci4gSWZcbiAqICAgICBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCB0eXBlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSByZXR1cm5cbiAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gKiBAYXBpXG4gKi9cbk9ic2VydmFibGUucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIGNvbnN0IGxlbiA9IHR5cGUubGVuZ3RoO1xuICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBrZXlzW2ldID0gbGlzdGVuT25jZSh0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5PbmNlKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFVubGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbig/KTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS51biA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdHlwZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3Rlbih0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB1bmxpc3Rlbih0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBPYnNlcnZhYmxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi9pbmRleC5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7ZWFzZUlufSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvVGlsZX0gZm9yIHRoZSB0aWxlIGFuZCBhXG4gKiBge3N0cmluZ31gIGZvciB0aGUgdXJsIGFzIGFyZ3VtZW50cy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obW9kdWxlOm9sL1RpbGUsIHN0cmluZyl9IExvYWRGdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0byBnZXRcbiAqIHRoZSB1cmwgdGhhdCBwcm92aWRlcyBhIHRpbGUgZm9yIGEgZ2l2ZW4gdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBmb3IgdGhlIHRpbGVcbiAqIGNvb3JkaW5hdGUsIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHBpeGVsIHJhdGlvIGFuZCBhXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhcyBhcmd1bWVudHNcbiAqIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIHRpbGUgVVJMLCBvciB1bmRlZmluZWQgaWYgbm8gdGlsZVxuICogc2hvdWxkIGJlIHJlcXVlc3RlZCBmb3IgdGhlIHBhc3NlZCB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkLCBudW1iZXIsXG4gKiAgICAgICAgICAgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbik6IChzdHJpbmd8dW5kZWZpbmVkKX0gVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gQSBkdXJhdGlvbiBmb3IgdGlsZSBvcGFjaXR5XG4gKiB0cmFuc2l0aW9ucyBpbiBtaWxsaXNlY29uZHMuIEEgZHVyYXRpb24gb2YgMCBkaXNhYmxlcyB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciB0aWxlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhYnN0cmFjdFxuICogQGV4dGVuZHMge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR9XG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGV+T3B0aW9ucz19IG9wdF9vcHRpb25zIFRpbGUgb3B0aW9ucy5cbiAqL1xuY29uc3QgVGlsZSA9IGZ1bmN0aW9uKHRpbGVDb29yZCwgc3RhdGUsIG9wdF9vcHRpb25zKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfVxuICAgKi9cbiAgdGhpcy50aWxlQ29vcmQgPSB0aWxlQ29vcmQ7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlU3RhdGV9XG4gICAqL1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgLyoqXG4gICAqIEFuIFwiaW50ZXJpbVwiIHRpbGUgZm9yIHRoaXMgdGlsZS4gVGhlIGludGVyaW0gdGlsZSBtYXkgYmUgdXNlZCB3aGlsZSB0aGlzXG4gICAqIG9uZSBpcyBsb2FkaW5nLCBmb3IgXCJzbW9vdGhcIiB0cmFuc2l0aW9ucyB3aGVuIGNoYW5naW5nIHBhcmFtcy9kaW1lbnNpb25zXG4gICAqIG9uIHRoZSBzb3VyY2UuXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX1cbiAgICovXG4gIHRoaXMuaW50ZXJpbVRpbGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGtleSBhc3NpZ25lZCB0byB0aGUgdGlsZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSB0aWxlIHNvdXJjZSB0byBkZXRlcm1pbmVcbiAgICogaWYgdGhpcyB0aWxlIGNhbiBlZmZlY3RpdmVseSBiZSB1c2VkLCBvciBpZiBhIG5ldyB0aWxlIHNob3VsZCBiZSBjcmVhdGVkXG4gICAqIGFuZCB0aGlzIG9uZSBiZSB1c2VkIGFzIGFuIGludGVyaW0gdGlsZSBmb3IgdGhpcyBuZXcgdGlsZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMua2V5ID0gJyc7XG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBmb3IgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbi5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMudHJhbnNpdGlvbl8gPSBvcHRpb25zLnRyYW5zaXRpb24gPT09IHVuZGVmaW5lZCA/IDI1MCA6IG9wdGlvbnMudHJhbnNpdGlvbjtcblxuICAvKipcbiAgICogTG9va3VwIG9mIHN0YXJ0IHRpbWVzIGZvciByZW5kZXJpbmcgdHJhbnNpdGlvbnMuICBJZiB0aGUgc3RhcnQgdGltZSBpc1xuICAgKiBlcXVhbCB0byAtMSwgdGhlIHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAqIEB0eXBlIHtPYmplY3QuPG51bWJlciwgbnVtYmVyPn1cbiAgICovXG4gIHRoaXMudHJhbnNpdGlvblN0YXJ0c18gPSB7fTtcblxufTtcblxuaW5oZXJpdHMoVGlsZSwgRXZlbnRUYXJnZXQpO1xuXG5cbi8qKlxuICogQHByb3RlY3RlZFxuICovXG5UaWxlLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuVGlsZS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmtleSArICcvJyArIHRoaXMudGlsZUNvb3JkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGludGVyaW0gdGlsZSBtb3N0IHN1aXRhYmxlIGZvciByZW5kZXJpbmcgdXNpbmcgdGhlIGNoYWluIG9mIGludGVyaW1cbiAqIHRpbGVzLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSAgbW9zdCByZWNlbnQgdGlsZSB0aGF0IGhhcyBiZWVuIGxvYWRlZCwgaWYgbm9cbiAqIHN1Y2ggdGlsZSBleGlzdHMsIHRoZSBvcmlnaW5hbCB0aWxlIGlzIHJldHVybmVkLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC9UaWxlfSBCZXN0IHRpbGUgZm9yIHJlbmRlcmluZy5cbiAqL1xuVGlsZS5wcm90b3R5cGUuZ2V0SW50ZXJpbVRpbGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmludGVyaW1UaWxlKSB7XG4gICAgLy9lbXB0eSBjaGFpblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxldCB0aWxlID0gdGhpcy5pbnRlcmltVGlsZTtcblxuICAvLyBmaW5kIHRoZSBmaXJzdCBsb2FkZWQgdGlsZSBhbmQgcmV0dXJuIGl0LiBTaW5jZSB0aGUgY2hhaW4gaXMgc29ydGVkIGluXG4gIC8vIGRlY3JlYXNpbmcgb3JkZXIgb2YgY3JlYXRpb24gdGltZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBzZWFyY2ggdGhlIHJlbWFpbmRlclxuICAvLyBvZiB0aGUgbGlzdCAoYWxsIHRob3NlIHRpbGVzIGNvcnJlc3BvbmQgdG8gb2xkZXIgcmVxdWVzdHMgYW5kIHdpbGwgYmVcbiAgLy8gY2xlYW5lZCB1cCBieSByZWZyZXNoSW50ZXJpbUNoYWluKVxuICBkbyB7XG4gICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm4gdGlsZTtcbiAgICB9XG4gICAgdGlsZSA9IHRpbGUuaW50ZXJpbVRpbGU7XG4gIH0gd2hpbGUgKHRpbGUpO1xuXG4gIC8vIHdlIGNhbiBub3QgZmluZCBhIGJldHRlciB0aWxlXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHb2VzIHRocm91Z2ggdGhlIGNoYWluIG9mIGludGVyaW0gdGlsZXMgYW5kIGRpc2NhcmRzIHNlY3Rpb25zIG9mIHRoZSBjaGFpblxuICogdGhhdCBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICovXG5UaWxlLnByb3RvdHlwZS5yZWZyZXNoSW50ZXJpbUNoYWluID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pbnRlcmltVGlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCB0aWxlID0gdGhpcy5pbnRlcmltVGlsZTtcbiAgbGV0IHByZXYgPSB0aGlzO1xuXG4gIGRvIHtcbiAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgIC8vd2UgaGF2ZSBhIGxvYWRlZCB0aWxlLCB3ZSBjYW4gZGlzY2FyZCB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgICAgLy93ZSB3b3VsZCBjb3VsZCBhYm9ydCBhbnkgTE9BRElORyB0aWxlIHJlcXVlc3RcbiAgICAgIC8vb2xkZXIgdGhhbiB0aGlzIHRpbGUgKGkuZS4gYW55IExPQURJTkcgdGlsZSBmb2xsb3dpbmcgdGhpcyBlbnRyeSBpbiB0aGUgY2hhaW4pXG4gICAgICB0aWxlLmludGVyaW1UaWxlID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAvL2tlZXAgdGhpcyBMT0FESU5HIHRpbGUgYW55IGxvYWRlZCB0aWxlcyBsYXRlciBpbiB0aGUgY2hhaW4gYXJlXG4gICAgICAvL29sZGVyIHRoYW4gdGhpcyB0aWxlLCBzbyB3ZSdyZSBzdGlsbCBpbnRlcmVzdGVkIGluIHRoZSByZXF1ZXN0XG4gICAgICBwcmV2ID0gdGlsZTtcbiAgICB9IGVsc2UgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgLy90aGUgaGVhZCBvZiB0aGUgbGlzdCBpcyB0aGUgbW9zdCBjdXJyZW50IHRpbGUsIHdlIGRvbid0IG5lZWRcbiAgICAgIC8vdG8gc3RhcnQgYW55IG90aGVyIHJlcXVlc3RzIGZvciB0aGlzIGNoYWluXG4gICAgICBwcmV2LmludGVyaW1UaWxlID0gdGlsZS5pbnRlcmltVGlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldiA9IHRpbGU7XG4gICAgfVxuICAgIHRpbGUgPSBwcmV2LmludGVyaW1UaWxlO1xuICB9IHdoaWxlICh0aWxlKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoaXMgdGlsZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5UaWxlLnByb3RvdHlwZS5nZXRUaWxlQ29vcmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGlsZUNvb3JkO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlU3RhdGV9IFN0YXRlLlxuICovXG5UaWxlLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zdGF0ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAqL1xuVGlsZS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuLyoqXG4gKiBMb2FkIHRoZSBpbWFnZSBvciByZXRyeSBpZiBsb2FkaW5nIHByZXZpb3VzbHkgZmFpbGVkLlxuICogTG9hZGluZyBpcyB0YWtlbiBjYXJlIG9mIGJ5IHRoZSB0aWxlIHF1ZXVlLCBhbmQgY2FsbGluZyB0aGlzIG1ldGhvZCBpc1xuICogb25seSBuZWVkZWQgZm9yIHByZWxvYWRpbmcgb3IgZm9yIHJlbG9hZGluZyBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cblRpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEdldCB0aGUgYWxwaGEgdmFsdWUgZm9yIHJlbmRlcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGhlIHJlbmRlciBmcmFtZSB0aW1lLlxuICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gKi9cblRpbGUucHJvdG90eXBlLmdldEFscGhhID0gZnVuY3Rpb24oaWQsIHRpbWUpIHtcbiAgaWYgKCF0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBsZXQgc3RhcnQgPSB0aGlzLnRyYW5zaXRpb25TdGFydHNfW2lkXTtcbiAgaWYgKCFzdGFydCkge1xuICAgIHN0YXJ0ID0gdGltZTtcbiAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfW2lkXSA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgY29uc3QgZGVsdGEgPSB0aW1lIC0gc3RhcnQgKyAoMTAwMCAvIDYwKTsgLy8gYXZvaWQgcmVuZGVyaW5nIGF0IDBcbiAgaWYgKGRlbHRhID49IHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gZWFzZUluKGRlbHRhIC8gdGhpcy50cmFuc2l0aW9uXyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHRpbGUgaXMgaW4gYW4gYWxwaGEgdHJhbnNpdGlvbi4gIEEgdGlsZSBpcyBjb25zaWRlcmVkIGluXG4gKiB0cmFuc2l0aW9uIGlmIHRpbGUuZ2V0QWxwaGEoKSBoYXMgbm90IHlldCBiZWVuIGNhbGxlZCBvciBoYXMgYmVlbiBjYWxsZWRcbiAqIGFuZCByZXR1cm5lZCAxLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSBpcyBpbiB0cmFuc2l0aW9uLlxuICovXG5UaWxlLnByb3RvdHlwZS5pblRyYW5zaXRpb24gPSBmdW5jdGlvbihpZCkge1xuICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdICE9PSAtMTtcbn07XG5cbi8qKlxuICogTWFyayBhIHRyYW5zaXRpb24gYXMgY29tcGxldGUuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAqL1xuVGlsZS5wcm90b3R5cGUuZW5kVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGlkKSB7XG4gIGlmICh0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gPSAtMTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IFRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZUNhY2hlXG4gKi9cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJy4vaW5kZXguanMnO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4vc3RydWN0cy9MUlVDYWNoZS5qcyc7XG5pbXBvcnQge2Zyb21LZXksIGdldEtleX0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlLjxtb2R1bGU6b2wvVGlsZT59XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9oaWdoV2F0ZXJNYXJrIEhpZ2ggd2F0ZXIgbWFyay5cbiAqIEBzdHJ1Y3RcbiAqL1xuY29uc3QgVGlsZUNhY2hlID0gZnVuY3Rpb24ob3B0X2hpZ2hXYXRlck1hcmspIHtcblxuICBMUlVDYWNoZS5jYWxsKHRoaXMsIG9wdF9oaWdoV2F0ZXJNYXJrKTtcblxufTtcblxuaW5oZXJpdHMoVGlsZUNhY2hlLCBMUlVDYWNoZSk7XG5cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL1RpbGVSYW5nZT59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICovXG5UaWxlQ2FjaGUucHJvdG90eXBlLmV4cGlyZUNhY2hlID0gZnVuY3Rpb24odXNlZFRpbGVzKSB7XG4gIHdoaWxlICh0aGlzLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICBjb25zdCB0aWxlID0gdGhpcy5wZWVrTGFzdCgpO1xuICAgIGNvbnN0IHpLZXkgPSB0aWxlLnRpbGVDb29yZFswXS50b1N0cmluZygpO1xuICAgIGlmICh6S2V5IGluIHVzZWRUaWxlcyAmJiB1c2VkVGlsZXNbektleV0uY29udGFpbnModGlsZS50aWxlQ29vcmQpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3AoKS5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUHJ1bmUgYWxsIHRpbGVzIGZyb20gdGhlIGNhY2hlIHRoYXQgZG9uJ3QgaGF2ZSB0aGUgc2FtZSB6IGFzIHRoZSBuZXdlc3QgdGlsZS5cbiAqL1xuVGlsZUNhY2hlLnByb3RvdHlwZS5wcnVuZUV4Y2VwdE5ld2VzdFogPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZ2V0Q291bnQoKSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBrZXkgPSB0aGlzLnBlZWtGaXJzdEtleSgpO1xuICBjb25zdCB0aWxlQ29vcmQgPSBmcm9tS2V5KGtleSk7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKHRpbGUudGlsZUNvb3JkWzBdICE9PSB6KSB7XG4gICAgICB0aGlzLnJlbW92ZShnZXRLZXkodGlsZS50aWxlQ29vcmQpKTtcbiAgICAgIHRpbGUuZGlzcG9zZSgpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG59O1xuZXhwb3J0IGRlZmF1bHQgVGlsZUNhY2hlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVSYW5nZVxuICovXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBjb250aWd1b3VzIGJsb2NrIG9mIHRpbGVzLiAgQSB0aWxlIHJhbmdlIGlzIHNwZWNpZmllZFxuICogYnkgaXRzIG1pbi9tYXggdGlsZSBjb29yZGluYXRlcyBhbmQgaXMgaW5jbHVzaXZlIG9mIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHN0cnVjdFxuICovXG5jb25zdCBUaWxlUmFuZ2UgPSBmdW5jdGlvbihtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblggPSBtaW5YO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5tYXhYID0gbWF4WDtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWluWSA9IG1pblk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1heFkgPSBtYXhZO1xuXG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlPX0gdGlsZVJhbmdlIFRpbGVSYW5nZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IFRpbGUgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCB0aWxlUmFuZ2UpIHtcbiAgaWYgKHRpbGVSYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGlsZVJhbmdlLm1pblggPSBtaW5YO1xuICAgIHRpbGVSYW5nZS5tYXhYID0gbWF4WDtcbiAgICB0aWxlUmFuZ2UubWluWSA9IG1pblk7XG4gICAgdGlsZVJhbmdlLm1heFkgPSBtYXhZO1xuICAgIHJldHVybiB0aWxlUmFuZ2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBUaWxlUmFuZ2UobWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyB0aWxlIGNvb3JkaW5hdGUuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuY29udGFpbnNYWSh0aWxlQ29vcmRbMV0sIHRpbGVDb29yZFsyXSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zVGlsZVJhbmdlID0gZnVuY3Rpb24odGlsZVJhbmdlKSB7XG4gIHJldHVybiB0aGlzLm1pblggPD0gdGlsZVJhbmdlLm1pblggJiYgdGlsZVJhbmdlLm1heFggPD0gdGhpcy5tYXhYICYmXG4gICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1pblkgJiYgdGlsZVJhbmdlLm1heFkgPD0gdGhpcy5tYXhZO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBjb29yZGluYXRlLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zWFkgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB0aGlzLm1pblggPD0geCAmJiB4IDw9IHRoaXMubWF4WCAmJiB0aGlzLm1pblkgPD0geSAmJiB5IDw9IHRoaXMubWF4WTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRXF1YWxzLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YID09IHRpbGVSYW5nZS5taW5YICYmIHRoaXMubWluWSA9PSB0aWxlUmFuZ2UubWluWSAmJlxuICAgICAgdGhpcy5tYXhYID09IHRpbGVSYW5nZS5tYXhYICYmIHRoaXMubWF4WSA9PSB0aWxlUmFuZ2UubWF4WTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKHRpbGVSYW5nZSkge1xuICBpZiAodGlsZVJhbmdlLm1pblggPCB0aGlzLm1pblgpIHtcbiAgICB0aGlzLm1pblggPSB0aWxlUmFuZ2UubWluWDtcbiAgfVxuICBpZiAodGlsZVJhbmdlLm1heFggPiB0aGlzLm1heFgpIHtcbiAgICB0aGlzLm1heFggPSB0aWxlUmFuZ2UubWF4WDtcbiAgfVxuICBpZiAodGlsZVJhbmdlLm1pblkgPCB0aGlzLm1pblkpIHtcbiAgICB0aGlzLm1pblkgPSB0aWxlUmFuZ2UubWluWTtcbiAgfVxuICBpZiAodGlsZVJhbmdlLm1heFkgPiB0aGlzLm1heFkpIHtcbiAgICB0aGlzLm1heFkgPSB0aWxlUmFuZ2UubWF4WTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0LlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZICsgMTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBTaXplLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWCArIDE7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEludGVyc2VjdHMuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YIDw9IHRpbGVSYW5nZS5tYXhYICYmXG4gICAgICB0aGlzLm1heFggPj0gdGlsZVJhbmdlLm1pblggJiZcbiAgICAgIHRoaXMubWluWSA8PSB0aWxlUmFuZ2UubWF4WSAmJlxuICAgICAgdGhpcy5tYXhZID49IHRpbGVSYW5nZS5taW5ZO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRpbGVSYW5nZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSURMRTogMCxcbiAgTE9BRElORzogMSxcbiAgTE9BREVEOiAyLFxuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG4gIEFCT1JUOiA1XG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2FycmF5XG4gKi9cblxuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcHJvdmlkZWQgc29ydGVkIGxpc3QgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLiBJZiBpdCBjYW4ndCBiZSBmb3VuZCBpdCdsbCByZXR1cm4gLTEuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9iaW5hcnktc2VhcmNoXG4gKlxuICogQHBhcmFtIHtBcnJheS48Kj59IGhheXN0YWNrIEl0ZW1zIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHsqfSBuZWVkbGUgVGhlIGl0ZW0gdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X2NvbXBhcmF0b3IgQ29tcGFyYXRvciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLCAtMSBpZiBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgb3B0X2NvbXBhcmF0b3IpIHtcbiAgbGV0IG1pZCwgY21wO1xuICBjb25zdCBjb21wYXJhdG9yID0gb3B0X2NvbXBhcmF0b3IgfHwgbnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbjtcbiAgbGV0IGxvdyA9IDA7XG4gIGxldCBoaWdoID0gaGF5c3RhY2subGVuZ3RoO1xuICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgIC8qIE5vdGUgdGhhdCBcIihsb3cgKyBoaWdoKSA+Pj4gMVwiIG1heSBvdmVyZmxvdywgYW5kIHJlc3VsdHMgaW4gYSB0eXBlY2FzdFxuICAgICAqIHRvIGRvdWJsZSAod2hpY2ggZ2l2ZXMgdGhlIHdyb25nIHJlc3VsdHMpLiAqL1xuICAgIG1pZCA9IGxvdyArIChoaWdoIC0gbG93ID4+IDEpO1xuICAgIGNtcCA9ICtjb21wYXJhdG9yKGhheXN0YWNrW21pZF0sIG5lZWRsZSk7XG5cbiAgICBpZiAoY21wIDwgMC4wKSB7IC8qIFRvbyBsb3cuICovXG4gICAgICBsb3cgID0gbWlkICsgMTtcblxuICAgIH0gZWxzZSB7IC8qIEtleSBmb3VuZCBvciB0b28gaGlnaCAqL1xuICAgICAgaGlnaCA9IG1pZDtcbiAgICAgIGZvdW5kID0gIWNtcDtcbiAgICB9XG4gIH1cblxuICAvKiBLZXkgbm90IGZvdW5kLiAqL1xuICByZXR1cm4gZm91bmQgPyBsb3cgOiB+bG93O1xufVxuXG5cbi8qKlxuICogQ29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydCB0aGF0IGlzIHNhZmUgZm9yIG51bWJlcnMuXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGFzIHRoZSBmaXJzdFxuICogICAgIGFyZ3VtZW50IGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5IGNvbnRhaW5zIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyIFRoZSBhcnJheSB0byB0ZXN0IGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgb2JqZWN0IGZvciB3aGljaCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG9iamVjdCBpcyBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhhcnIsIG9iaikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yob2JqKSA+PSAwO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyIEFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIDAgbWVhbnMgcmV0dXJuIHRoZSBuZWFyZXN0LCA+IDBcbiAqICAgIG1lYW5zIHJldHVybiB0aGUgbGFyZ2VzdCBuZWFyZXN0LCA8IDAgbWVhbnMgcmV0dXJuIHRoZVxuICogICAgc21hbGxlc3QgbmVhcmVzdC5cbiAqIEByZXR1cm4ge251bWJlcn0gSW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJGaW5kTmVhcmVzdChhcnIsIHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICBpZiAoYXJyWzBdIDw9IHRhcmdldCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKHRhcmdldCA8PSBhcnJbbiAtIDFdKSB7XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9IGVsc2Uge1xuICAgIGxldCBpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA8PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyW2ldIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKGFycltpIC0gMV0gLSB0YXJnZXQgPCB0YXJnZXQgLSBhcnJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuIC0gMTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFyciBBcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbiBCZWdpbiBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVN1YkFycmF5KGFyciwgYmVnaW4sIGVuZCkge1xuICB3aGlsZSAoYmVnaW4gPCBlbmQpIHtcbiAgICBjb25zdCB0bXAgPSBhcnJbYmVnaW5dO1xuICAgIGFycltiZWdpbl0gPSBhcnJbZW5kXTtcbiAgICBhcnJbZW5kXSA9IHRtcDtcbiAgICArK2JlZ2luO1xuICAgIC0tZW5kO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHshQXJyYXkuPFZBTFVFPnxWQUxVRX0gZGF0YSBUaGUgZWxlbWVudHMgb3IgYXJyYXlzIG9mIGVsZW1lbnRzIHRvIGFkZCB0byBhcnIuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChhcnIsIGRhdGEpIHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XG4gIGNvbnN0IGxlbmd0aCA9IGV4dGVuc2lvbi5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbYXJyLmxlbmd0aF0gPSBleHRlbnNpb25baV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPFZBTFVFPn0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge1ZBTFVFfSBvYmogVGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2Yob2JqKTtcbiAgY29uc3QgZm91bmQgPSBpID4gLTE7XG4gIGlmIChmb3VuZCkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVkFMVUUsIG51bWJlciwgPykgOiBib29sZWFufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb21wYXJlLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKiBAcmV0dXJuIHtWQUxVRXxudWxsfSBUaGUgZWxlbWVudCBmb3VuZCBvciBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZChhcnIsIGZ1bmMpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aCA+Pj4gMDtcbiAgbGV0IHZhbHVlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycltpXTtcbiAgICBpZiAoZnVuYyh2YWx1ZSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhDbGFtcGVkQXJyYXl9IGFycjEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGFycjEsIGFycjIpIHtcbiAgY29uc3QgbGVuMSA9IGFycjEubGVuZ3RoO1xuICBpZiAobGVuMSAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnIgVGhlIGFycmF5IHRvIHNvcnQgKG1vZGlmaWVzIG9yaWdpbmFsKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVGbmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWJsZVNvcnQoYXJyLCBjb21wYXJlRm5jKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IHRtcCA9IEFycmF5KGFyci5sZW5ndGgpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG1wW2ldID0ge2luZGV4OiBpLCB2YWx1ZTogYXJyW2ldfTtcbiAgfVxuICB0bXAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVGbmMoYS52YWx1ZSwgYi52YWx1ZSkgfHwgYS5pbmRleCAtIGIuaW5kZXg7XG4gIH0pO1xuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0gdG1wW2ldLnZhbHVlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGZ1bmMpIHtcbiAgbGV0IGluZGV4O1xuICBjb25zdCBmb3VuZCA9ICFhcnIuZXZlcnkoZnVuY3Rpb24oZWwsIGlkeCkge1xuICAgIGluZGV4ID0gaWR4O1xuICAgIHJldHVybiAhZnVuYyhlbCwgaWR4LCBhcnIpO1xuICB9KTtcbiAgcmV0dXJuIGZvdW5kID8gaW5kZXggOiAtMTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnIgVGhlIGFycmF5IHRvIHRlc3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X2Z1bmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zdHJpY3QgU3RyaWN0bHkgc29ydGVkIChkZWZhdWx0IGZhbHNlKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU29ydGVkKGFyciwgb3B0X2Z1bmMsIG9wdF9zdHJpY3QpIHtcbiAgY29uc3QgY29tcGFyZSA9IG9wdF9mdW5jIHx8IG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb247XG4gIHJldHVybiBhcnIuZXZlcnkoZnVuY3Rpb24oY3VycmVudFZhbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBjb21wYXJlKGFycltpbmRleCAtIDFdLCBjdXJyZW50VmFsKTtcbiAgICByZXR1cm4gIShyZXMgPiAwIHx8IG9wdF9zdHJpY3QgJiYgcmVzID09PSAwKTtcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvYXNzZXJ0c1xuICovXG5pbXBvcnQgQXNzZXJ0aW9uRXJyb3IgZnJvbSAnLi9Bc3NlcnRpb25FcnJvci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBhc3NlcnRpb24gQXNzZXJ0aW9uIHdlIGV4cGVjdGVkIHRvIGJlIHRydXRoeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvckNvZGUgRXJyb3IgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb24sIGVycm9yQ29kZSkge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvckNvZGUpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZG9tXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBodG1sIGNhbnZhcyBlbGVtZW50IGFuZCByZXR1cm5zIGl0cyAyZCBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfd2lkdGggQ2FudmFzIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGVpZ2h0IENhbnZhcyBoZWlnaHQuXG4gKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dDJEKG9wdF93aWR0aCwgb3B0X2hlaWdodCkge1xuICBjb25zdCBjYW52YXMgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ0FOVkFTJykpO1xuICBpZiAob3B0X3dpZHRoKSB7XG4gICAgY2FudmFzLndpZHRoID0gb3B0X3dpZHRoO1xuICB9XG4gIGlmIChvcHRfaGVpZ2h0KSB7XG4gICAgY2FudmFzLmhlaWdodCA9IG9wdF9oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoY2FudmFzLmdldENvbnRleHQoJzJkJykpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIHdpZHRoIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBpbmNsdWRpbmcgbWFyZ2luLFxuICogcGFkZGluZyBhbmQgYm9yZGVyLlxuICogRXF1aXZhbGVudCB0byBqUXVlcnkncyBgJChlbCkub3V0ZXJXaWR0aCh0cnVlKWAuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVyV2lkdGgoZWxlbWVudCkge1xuICBsZXQgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHdpZHRoICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0LCAxMCk7XG5cbiAgcmV0dXJuIHdpZHRoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIGhlaWdodCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVySGVpZ2h0KHRydWUpYC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsZW1lbnQpIHtcbiAgbGV0IGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGhlaWdodCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5Ub3AsIDEwKSArIHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApO1xuXG4gIHJldHVybiBoZWlnaHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIE5vZGUgdG8gcmVwbGFjZSBvbGQgbm9kZVxuICogQHBhcmFtIHtOb2RlfSBvbGROb2RlIFRoZSBub2RlIHRvIGJlIHJlcGxhY2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlTm9kZShuZXdOb2RlLCBvbGROb2RlKSB7XG4gIGNvbnN0IHBhcmVudCA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgb2xkTm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge05vZGV9IFRoZSBub2RlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgPyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmUgdGhlIGNoaWxkcmVuIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKSB7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZWFzaW5nXG4gKi9cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3cgYW5kIHNwZWVkIHVwLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZUluKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDMpO1xufVxuXG5cbi8qKlxuICogU3RhcnQgZmFzdCBhbmQgc2xvdyBkb3duLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZU91dCh0KSB7XG4gIHJldHVybiAxIC0gZWFzZUluKDEgLSB0KTtcbn1cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgdGhlbiBzbG93IGRvd24gYWdhaW4uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbkFuZE91dCh0KSB7XG4gIHJldHVybiAzICogdCAqIHQgLSAyICogdCAqIHQgKiB0O1xufVxuXG5cbi8qKlxuICogTWFpbnRhaW4gYSBjb25zdGFudCBzcGVlZCBvdmVyIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXIodCkge1xuICByZXR1cm4gdDtcbn1cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgYXQgdGhlIHZlcnkgZW5kIHNsb3cgZG93biBhZ2Fpbi4gIFRoaXMgaGFzIHRoZVxuICogc2FtZSBnZW5lcmFsIGJlaGF2aW9yIGFzIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfmluQW5kT3V0fSwgYnV0IHRoZSBmaW5hbFxuICogc2xvd2Rvd24gaXMgZGVsYXllZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwQW5kRG93bih0KSB7XG4gIGlmICh0IDwgMC41KSB7XG4gICAgcmV0dXJuIGluQW5kT3V0KDIgKiB0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSAtIGluQW5kT3V0KDIgKiAodCAtIDAuNSkpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzXG4gKi9cbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4vb2JqLmpzJztcblxuXG4vKipcbiAqIEtleSB0byB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSN1bkJ5S2V5fS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50c0tleVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtiaW5kVG9dXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbn0gW2JvdW5kTGlzdGVuZXJdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbGxPbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbGV0ZUluZGV4XVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fG1vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogTGlzdGVuZXIgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYW4gZXZlbnQgb2JqZWN0IGFzIGFyZ3VtZW50LlxuICogV2hlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCBldmVudCBwcm9wYWdhdGlvbiB3aWxsIHN0b3AuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC9ldmVudHMvRXZlbnQpfGZ1bmN0aW9uKG1vZHVsZTpvbC9ldmVudHMvRXZlbnQpOiBib29sZWFufSBMaXN0ZW5lckZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IGxpc3RlbmVyT2JqIExpc3RlbmVyIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbn0gQm91bmQgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kTGlzdGVuZXIobGlzdGVuZXJPYmopIHtcbiAgY29uc3QgYm91bmRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbGlzdGVuZXJPYmoubGlzdGVuZXI7XG4gICAgY29uc3QgYmluZFRvID0gbGlzdGVuZXJPYmouYmluZFRvIHx8IGxpc3RlbmVyT2JqLnRhcmdldDtcbiAgICBpZiAobGlzdGVuZXJPYmouY2FsbE9uY2UpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkobGlzdGVuZXJPYmopO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXIuY2FsbChiaW5kVG8sIGV2dCk7XG4gIH07XG4gIGxpc3RlbmVyT2JqLmJvdW5kTGlzdGVuZXIgPSBib3VuZExpc3RlbmVyO1xuICByZXR1cm4gYm91bmRMaXN0ZW5lcjtcbn1cblxuXG4vKipcbiAqIEZpbmRzIHRoZSBtYXRjaGluZyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IGluIHRoZSBnaXZlbiBsaXN0ZW5lclxuICogYXJyYXkuXG4gKlxuICogQHBhcmFtIHshQXJyYXk8IW1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF90aGlzIFRoZSBgdGhpc2AgdmFsdWUgaW5zaWRlIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zZXREZWxldGVJbmRleCBTZXQgdGhlIGRlbGV0ZUluZGV4IG9uIHRoZSBtYXRjaGluZ1xuICogICAgIGxpc3RlbmVyLCBmb3Ige0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+dW5saXN0ZW5CeUtleX0uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleXx1bmRlZmluZWR9IFRoZSBtYXRjaGluZyBsaXN0ZW5lciBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIG9wdF9zZXREZWxldGVJbmRleCkge1xuICBsZXQgbGlzdGVuZXJPYmo7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgbGlzdGVuZXJPYmogPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKGxpc3RlbmVyT2JqLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICBsaXN0ZW5lck9iai5iaW5kVG8gPT09IG9wdF90aGlzKSB7XG4gICAgICBpZiAob3B0X3NldERlbGV0ZUluZGV4KSB7XG4gICAgICAgIGxpc3RlbmVyT2JqLmRlbGV0ZUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lck9iajtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pnx1bmRlZmluZWR9IExpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExpc3RlbmVycyh0YXJnZXQsIHR5cGUpIHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSB0YXJnZXQub2xfbG07XG4gIHJldHVybiBsaXN0ZW5lck1hcCA/IGxpc3RlbmVyTWFwW3R5cGVdIDogdW5kZWZpbmVkO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBsb29rdXAgb2YgbGlzdGVuZXJzLiAgSWYgb25lIGRvZXMgbm90IGV4aXN0IG9uIHRoZSB0YXJnZXQsIGl0IGlzXG4gKiBjcmVhdGVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqIEByZXR1cm4geyFPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pj59IE1hcCBvZlxuICogICAgIGxpc3RlbmVycyBieSBldmVudCB0eXBlLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lck1hcCh0YXJnZXQpIHtcbiAgbGV0IGxpc3RlbmVyTWFwID0gdGFyZ2V0Lm9sX2xtO1xuICBpZiAoIWxpc3RlbmVyTWFwKSB7XG4gICAgbGlzdGVuZXJNYXAgPSB0YXJnZXQub2xfbG0gPSB7fTtcbiAgfVxuICByZXR1cm4gbGlzdGVuZXJNYXA7XG59XG5cblxuLyoqXG4gKiBDbGVhbiB1cCBhbGwgbGlzdGVuZXIgb2JqZWN0cyBvZiB0aGUgZ2l2ZW4gdHlwZS4gIEFsbCBwcm9wZXJ0aWVzIG9uIHRoZVxuICogbGlzdGVuZXIgb2JqZWN0cyB3aWxsIGJlIHJlbW92ZWQsIGFuZCBpZiBubyBsaXN0ZW5lcnMgcmVtYWluIGluIHRoZSBsaXN0ZW5lclxuICogbWFwLCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyh0YXJnZXQsIHR5cGUpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldLmJvdW5kTGlzdGVuZXIpO1xuICAgICAgY2xlYXIobGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgbGlzdGVuZXJNYXAgPSB0YXJnZXQub2xfbG07XG4gICAgaWYgKGxpc3RlbmVyTWFwKSB7XG4gICAgICBkZWxldGUgbGlzdGVuZXJNYXBbdHlwZV07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0Lm9sX2xtO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIHtAbGluayBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWx9XG4gKlxuICogVGhpcyBmdW5jdGlvbiBlZmZpY2llbnRseSBiaW5kcyBhIGBsaXN0ZW5lcmAgdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJuc1xuICogYSBrZXkgZm9yIHVzZSB3aXRoIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9LlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X29uY2UgSWYgdHJ1ZSwgYWRkIHRoZSBsaXN0ZW5lciBhcyBvbmUtb2ZmIGxpc3RlbmVyLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRfdGhpcywgb3B0X29uY2UpIHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQpO1xuICBsZXQgbGlzdGVuZXJzID0gbGlzdGVuZXJNYXBbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJNYXBbdHlwZV0gPSBbXTtcbiAgfVxuICBsZXQgbGlzdGVuZXJPYmogPSBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIGZhbHNlKTtcbiAgaWYgKGxpc3RlbmVyT2JqKSB7XG4gICAgaWYgKCFvcHRfb25jZSkge1xuICAgICAgLy8gVHVybiBvbmUtb2ZmIGxpc3RlbmVyIGludG8gYSBwZXJtYW5lbnQgb25lLlxuICAgICAgbGlzdGVuZXJPYmouY2FsbE9uY2UgPSBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXJPYmogPSAvKiogQHR5cGUge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSAqLyAoe1xuICAgICAgYmluZFRvOiBvcHRfdGhpcyxcbiAgICAgIGNhbGxPbmNlOiAhIW9wdF9vbmNlLFxuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgYmluZExpc3RlbmVyKGxpc3RlbmVyT2JqKSk7XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXJPYmopO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVyT2JqO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgb25lLW9mZiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiB7QGxpbmsgaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sfVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIGFzIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lclxuICogdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJucyBhIGtleSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9IGluIGNhc2UgdGhlIGxpc3RlbmVyIG5lZWRzIHRvIGJlXG4gKiB1bnJlZ2lzdGVyZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBXaGVuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFmdGVyIHRoaXNcbiAqIGZ1bmN0aW9uLCB0aGUgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyIHdpbGwgYmUgdHVybmVkIGludG8gYSBwZXJtYW5lbnRcbiAqIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IEtleSBmb3IgdW5saXN0ZW5CeUtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbk9uY2UodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMpIHtcbiAgcmV0dXJuIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRfdGhpcywgdHJ1ZSk7XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiB7QGxpbmsgaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sfVxuICpcbiAqIFRvIHJldHVybiBhIGxpc3RlbmVyLCB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBleGFjdCBzYW1lXG4gKiBhcmd1bWVudHMgdGhhdCB3ZXJlIHVzZWQgZm9yIGEgcHJldmlvdXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+bGlzdGVufSBjYWxsLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICBjb25zdCBsaXN0ZW5lck9iaiA9IGZpbmRMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyLCBvcHRfdGhpcywgdHJ1ZSk7XG4gICAgaWYgKGxpc3RlbmVyT2JqKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGxpc3RlbmVyT2JqKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiB7QGxpbmsgaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sfVxuICpcbiAqIFRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBpcyB0aGUga2V5IHJldHVybmVkIGZyb21cbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gb3Ige0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+bGlzdGVuT25jZX0uXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleX0ga2V5IFRoZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkJ5S2V5KGtleSkge1xuICBpZiAoa2V5ICYmIGtleS50YXJnZXQpIHtcbiAgICBrZXkudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LnR5cGUsIGtleS5ib3VuZExpc3RlbmVyKTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnMoa2V5LnRhcmdldCwga2V5LnR5cGUpO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGNvbnN0IGkgPSAnZGVsZXRlSW5kZXgnIGluIGtleSA/IGtleS5kZWxldGVJbmRleCA6IGxpc3RlbmVycy5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycyhrZXkudGFyZ2V0LCBrZXkudHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsZWFyKGtleSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICoge0BsaW5rIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbH1cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR+RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGFyZ2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BbGwodGFyZ2V0KSB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0KTtcbiAgZm9yIChjb25zdCB0eXBlIGluIGxpc3RlbmVyTWFwKSB7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRcbiAqL1xuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTdHJpcHBlZCBkb3duIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnQgaW50ZXJmYWNlLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtaW50ZXJmYWNlfVxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb25seSBwcm92aWRlcyBgdHlwZWAgYW5kIGB0YXJnZXRgIHByb3BlcnRpZXMsIGFuZFxuICogYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgbWV0aG9kcy4gSXQgaXMgbWVhbnQgYXMgYmFzZSBjbGFzc1xuICogZm9yIGhpZ2hlciBsZXZlbCBldmVudHMgZGVmaW5lZCBpbiB0aGUgbGlicmFyeSwgYW5kIHdvcmtzIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fkV2ZW50VGFyZ2V0fS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKi9cbmNvbnN0IEV2ZW50ID0gZnVuY3Rpb24odHlwZSkge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGFwaVxuICAgKi9cbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGFwaVxuICAgKi9cbiAgdGhpcy50YXJnZXQgPSBudWxsO1xuXG59O1xuXG5cbi8qKlxuICogU3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAqIEBmdW5jdGlvblxuICogQGFwaVxuICovXG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPVxuXG4gIC8qKlxuICAgKiBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR8bW9kdWxlOm9sL2V2ZW50cy9FdmVudH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZ0KSB7XG4gIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR8bW9kdWxlOm9sL2V2ZW50cy9FdmVudH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldnQpIHtcbiAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9FdmVudFRhcmdldFxuICovXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7dW5saXN0ZW5BbGx9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge0V2ZW50VGFyZ2V0fG1vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR9IEV2ZW50VGFyZ2V0TGlrZVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFczQyBET00gTGV2ZWwgMiBFdmVudFRhcmdldCBpbnRlcmZhY2UuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItRXZlbnRzLTIwMDAxMTEzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldH1cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGltcG9ydGFudCBzaW1wbGlmaWNhdGlvbnMgY29tcGFyZWQgdG8gdGhlIHNwZWNpZmljYXRpb246XG4gKlxuICogMS4gVGhlIGhhbmRsaW5nIG9mIGB1c2VDYXB0dXJlYCBpbiBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kXG4gKiAgICBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAuIFRoZXJlIGlzIG5vIHJlYWwgY2FwdHVyZSBtb2RlbC5cbiAqIDIuIFRoZSBoYW5kbGluZyBvZiBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBvbiBgZGlzcGF0Y2hFdmVudGAuXG4gKiAgICBUaGVyZSBpcyBubyBldmVudCB0YXJnZXQgaGllcmFyY2h5LiBXaGVuIGEgbGlzdGVuZXIgY2FsbHNcbiAqICAgIGBzdG9wUHJvcGFnYXRpb25gIG9yIGBwcmV2ZW50RGVmYXVsdGAgb24gYW4gZXZlbnQgb2JqZWN0LCBpdCBtZWFucyB0aGF0IG5vXG4gKiAgICBtb3JlIGxpc3RlbmVycyBhZnRlciB0aGlzIG9uZSB3aWxsIGJlIGNhbGxlZC4gU2FtZSBhcyB3aGVuIHRoZSBsaXN0ZW5lclxuICogICAgcmV0dXJucyBmYWxzZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvRGlzcG9zYWJsZX1cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSBmdW5jdGlvbigpIHtcblxuICBEaXNwb3NhYmxlLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAqL1xuICB0aGlzLnBlbmRpbmdSZW1vdmFsc18gPSB7fTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICovXG4gIHRoaXMuZGlzcGF0Y2hpbmdfID0ge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb24+Pn1cbiAgICovXG4gIHRoaXMubGlzdGVuZXJzXyA9IHt9O1xuXG59O1xuXG5pbmhlcml0cyhFdmVudFRhcmdldCwgRGlzcG9zYWJsZSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdID0gW107XG4gIH1cbiAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3t0eXBlOiBzdHJpbmcsXG4gKiAgICAgdGFyZ2V0OiAoRXZlbnRUYXJnZXR8bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldHx1bmRlZmluZWQpfXxtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fFxuICogICAgIHN0cmluZ30gZXZlbnQgRXZlbnQgb3IgZXZlbnQgdHlwZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBgZmFsc2VgIGlmIGFueW9uZSBjYWxsZWQgcHJldmVudERlZmF1bHQgb24gdGhlXG4gKiAgICAgZXZlbnQgb2JqZWN0IG9yIGlmIGFueSBvZiB0aGUgbGlzdGVuZXJzIHJldHVybmVkIGZhbHNlLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGNvbnN0IGV2dCA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycgPyBuZXcgRXZlbnQoZXZlbnQpIDogZXZlbnQ7XG4gIGNvbnN0IHR5cGUgPSBldnQudHlwZTtcbiAgZXZ0LnRhcmdldCA9IHRoaXM7XG4gIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgbGV0IHByb3BhZ2F0ZTtcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIGlmICghKHR5cGUgaW4gdGhpcy5kaXNwYXRjaGluZ18pKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXSA9IDA7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV0gPSAwO1xuICAgIH1cbiAgICArK3RoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZXZ0KSA9PT0gZmFsc2UgfHwgZXZ0LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICBwcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC0tdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdID09PSAwKSB7XG4gICAgICBsZXQgcGVuZGluZ1JlbW92YWxzID0gdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdO1xuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgIHdoaWxlIChwZW5kaW5nUmVtb3ZhbHMtLSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgVU5ERUZJTkVEKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BhZ2F0ZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbigpIHtcbiAgdW5saXN0ZW5BbGwodGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuIExpc3RlbmVycyBhcmUgcmV0dXJuZWQgaW4gdGhlXG4gKiBvcmRlciB0aGF0IHRoZXkgd2lsbCBiZSBjYWxsZWQgaW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb24+fSBMaXN0ZW5lcnMuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdHlwZSBUeXBlLiBJZiBub3QgcHJvdmlkZWQsXG4gKiAgICAgYHRydWVgIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhpcyBFdmVudFRhcmdldCBoYXMgYW55IGxpc3RlbmVycy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEhhcyBsaXN0ZW5lcnMuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5oYXNMaXN0ZW5lciA9IGZ1bmN0aW9uKG9wdF90eXBlKSB7XG4gIHJldHVybiBvcHRfdHlwZSA/XG4gICAgb3B0X3R5cGUgaW4gdGhpcy5saXN0ZW5lcnNfIDpcbiAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVyc18pLmxlbmd0aCA+IDA7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAodHlwZSBpbiB0aGlzLnBlbmRpbmdSZW1vdmFsc18pIHtcbiAgICAgIC8vIG1ha2UgbGlzdGVuZXIgYSBuby1vcCwgYW5kIHJlbW92ZSBsYXRlciBpbiAjZGlzcGF0Y2hFdmVudCgpXG4gICAgICBsaXN0ZW5lcnNbaW5kZXhdID0gVU5ERUZJTkVEO1xuICAgICAgKyt0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBFdmVudFRhcmdldDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEdlbmVyaWMgY2hhbmdlIGV2ZW50LiBUcmlnZ2VyZWQgd2hlbiB0aGUgcmV2aXNpb24gY291bnRlciBpcyBpbmNyZWFzZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50I2NoYW5nZVxuICAgKiBAYXBpXG4gICAqL1xuICBDSEFOR0U6ICdjaGFuZ2UnLFxuXG4gIENMRUFSOiAnY2xlYXInLFxuICBDT05URVhUTUVOVTogJ2NvbnRleHRtZW51JyxcbiAgQ0xJQ0s6ICdjbGljaycsXG4gIERCTENMSUNLOiAnZGJsY2xpY2snLFxuICBEUkFHRU5URVI6ICdkcmFnZW50ZXInLFxuICBEUkFHT1ZFUjogJ2RyYWdvdmVyJyxcbiAgRFJPUDogJ2Ryb3AnLFxuICBFUlJPUjogJ2Vycm9yJyxcbiAgS0VZRE9XTjogJ2tleWRvd24nLFxuICBLRVlQUkVTUzogJ2tleXByZXNzJyxcbiAgTE9BRDogJ2xvYWQnLFxuICBNT1VTRURPV046ICdtb3VzZWRvd24nLFxuICBNT1VTRU1PVkU6ICdtb3VzZW1vdmUnLFxuICBNT1VTRU9VVDogJ21vdXNlb3V0JyxcbiAgTU9VU0VVUDogJ21vdXNldXAnLFxuICBNT1VTRVdIRUVMOiAnbW91c2V3aGVlbCcsXG4gIE1TUE9JTlRFUkRPV046ICdNU1BvaW50ZXJEb3duJyxcbiAgUkVTSVpFOiAncmVzaXplJyxcbiAgVE9VQ0hTVEFSVDogJ3RvdWNoc3RhcnQnLFxuICBUT1VDSE1PVkU6ICd0b3VjaG1vdmUnLFxuICBUT1VDSEVORDogJ3RvdWNoZW5kJyxcbiAgV0hFRUw6ICd3aGVlbCdcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50XG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IENvcm5lciBmcm9tICcuL2V4dGVudC9Db3JuZXIuanMnO1xuaW1wb3J0IFJlbGF0aW9uc2hpcCBmcm9tICcuL2V4dGVudC9SZWxhdGlvbnNoaXAuanMnO1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4gZXh0ZW50OiBgW21pbngsIG1pbnksIG1heHgsIG1heHldYC5cbiAqIEB0eXBlZGVmIHtBcnJheS48bnVtYmVyPn0gRXh0ZW50XG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBCdWlsZCBhbiBleHRlbnQgdGhhdCBpbmNsdWRlcyBhbGwgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEJvdW5kaW5nIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5kaW5nRXh0ZW50KGNvb3JkaW5hdGVzKSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB4cyBYcy5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHlzIFlzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmZ1bmN0aW9uIF9ib3VuZGluZ0V4dGVudFhZcyh4cywgeXMsIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgbWluWCA9IE1hdGgubWluLmFwcGx5KG51bGwsIHhzKTtcbiAgY29uc3QgbWluWSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHlzKTtcbiAgY29uc3QgbWF4WCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHhzKTtcbiAgY29uc3QgbWF4WSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHlzKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIGV4dGVudCBpbmNyZWFzZWQgYnkgdGhlIHByb3ZpZGVkIHZhbHVlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBleHRlbnQgc2hvdWxkIGJlIGJ1ZmZlcmVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihleHRlbnQsIHZhbHVlLCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXSAtIHZhbHVlO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV0gLSB2YWx1ZTtcbiAgICBvcHRfZXh0ZW50WzJdID0gZXh0ZW50WzJdICsgdmFsdWU7XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXSArIHZhbHVlO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICBleHRlbnRbMF0gLSB2YWx1ZSxcbiAgICAgIGV4dGVudFsxXSAtIHZhbHVlLFxuICAgICAgZXh0ZW50WzJdICsgdmFsdWUsXG4gICAgICBleHRlbnRbM10gKyB2YWx1ZVxuICAgIF07XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBleHRlbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBUaGUgY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShleHRlbnQsIG9wdF9leHRlbnQpIHtcbiAgaWYgKG9wdF9leHRlbnQpIHtcbiAgICBvcHRfZXh0ZW50WzBdID0gZXh0ZW50WzBdO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV07XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXTtcbiAgICBvcHRfZXh0ZW50WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHRlbnQuc2xpY2UoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7bnVtYmVyfSBDbG9zZXN0IHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGxldCBkeCwgZHk7XG4gIGlmICh4IDwgZXh0ZW50WzBdKSB7XG4gICAgZHggPSBleHRlbnRbMF0gLSB4O1xuICB9IGVsc2UgaWYgKGV4dGVudFsyXSA8IHgpIHtcbiAgICBkeCA9IHggLSBleHRlbnRbMl07XG4gIH0gZWxzZSB7XG4gICAgZHggPSAwO1xuICB9XG4gIGlmICh5IDwgZXh0ZW50WzFdKSB7XG4gICAgZHkgPSBleHRlbnRbMV0gLSB5O1xuICB9IGVsc2UgaWYgKGV4dGVudFszXSA8IHkpIHtcbiAgICBkeSA9IHkgLSBleHRlbnRbM107XG4gIH0gZWxzZSB7XG4gICAgZHkgPSAwO1xuICB9XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgaW4gdGhlIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIG9uZSBleHRlbnQgY29udGFpbnMgYW5vdGhlci5cbiAqXG4gKiBBbiBleHRlbnQgaXMgZGVlbWVkIGNvbnRhaW5lZCBpZiBpdCBsaWVzIGNvbXBsZXRlbHkgd2l0aGluIHRoZSBvdGhlciBleHRlbnQsXG4gKiBpbmNsdWRpbmcgaWYgdGhleSBzaGFyZSBvbmUgb3IgbW9yZSBlZGdlcy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWNvbmQgZXh0ZW50IGlzIGNvbnRhaW5lZCBieSBvciBvbiB0aGUgZWRnZSBvZiB0aGVcbiAqICAgICBmaXJzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRXh0ZW50KGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPD0gZXh0ZW50MlswXSAmJiBleHRlbnQyWzJdIDw9IGV4dGVudDFbMl0gJiZcbiAgICAgIGV4dGVudDFbMV0gPD0gZXh0ZW50MlsxXSAmJiBleHRlbnQyWzNdIDw9IGV4dGVudDFbM107XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB4LCB5IHZhbHVlcyBhcmUgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1hZKGV4dGVudCwgeCwgeSkge1xuICByZXR1cm4gZXh0ZW50WzBdIDw9IHggJiYgeCA8PSBleHRlbnRbMl0gJiYgZXh0ZW50WzFdIDw9IHkgJiYgeSA8PSBleHRlbnRbM107XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEgY29vcmRpbmF0ZSBhbmQgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50L1JlbGF0aW9uc2hpcH0gVGhlIHJlbGF0aW9uc2hpcCAoYml0d2lzZSBjb21wYXJlIHdpdGhcbiAqICAgICBtb2R1bGU6b2wvZXh0ZW50L1JlbGF0aW9uc2hpcH5SZWxhdGlvbnNoaXApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgY29uc3QgbWF4WCA9IGV4dGVudFsyXTtcbiAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgY29uc3QgeCA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdO1xuICBsZXQgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLlVOS05PV047XG4gIGlmICh4IDwgbWluWCkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5MRUZUO1xuICB9IGVsc2UgaWYgKHggPiBtYXhYKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLlJJR0hUO1xuICB9XG4gIGlmICh5IDwgbWluWSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5CRUxPVztcbiAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5BQk9WRTtcbiAgfVxuICBpZiAocmVsYXRpb25zaGlwID09PSBSZWxhdGlvbnNoaXAuVU5LTk9XTikge1xuICAgIHJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkc7XG4gIH1cbiAgcmV0dXJuIHJlbGF0aW9uc2hpcDtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbXB0eSBleHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRW1wdHkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHkoKSB7XG4gIHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXh0ZW50IG9yIHVwZGF0ZSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpIHtcbiAgaWYgKG9wdF9leHRlbnQpIHtcbiAgICBvcHRfZXh0ZW50WzBdID0gbWluWDtcbiAgICBvcHRfZXh0ZW50WzFdID0gbWluWTtcbiAgICBvcHRfZXh0ZW50WzJdID0gbWF4WDtcbiAgICBvcHRfZXh0ZW50WzNdID0gbWF4WTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21pblgsIG1pblksIG1heFgsIG1heFldO1xuICB9XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZW1wdHkgZXh0ZW50IG9yIG1ha2UgdGhlIHByb3ZpZGVkIG9uZSBlbXB0eS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUVtcHR5KG9wdF9leHRlbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKFxuICAgIEluZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKHgsIHksIHgsIHksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIGNvb3JkaW5hdGVzKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShvcHRfZXh0ZW50KTtcbiAgcmV0dXJuIGV4dGVuZEZsYXRDb29yZGluYXRlcyhleHRlbnQsIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tUmluZ3MocmluZ3MsIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShvcHRfZXh0ZW50KTtcbiAgcmV0dXJuIGV4dGVuZFJpbmdzKGV4dGVudCwgcmluZ3MpO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHR3byBleHRlbnRzIGFyZSBlcXVpdmFsZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gZXh0ZW50MVswXSA9PSBleHRlbnQyWzBdICYmIGV4dGVudDFbMl0gPT0gZXh0ZW50MlsyXSAmJlxuICAgICAgZXh0ZW50MVsxXSA9PSBleHRlbnQyWzFdICYmIGV4dGVudDFbM10gPT0gZXh0ZW50MlszXTtcbn1cblxuXG4vKipcbiAqIE1vZGlmeSBhbiBleHRlbnQgdG8gaW5jbHVkZSBhbm90aGVyIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDEgVGhlIGV4dGVudCB0byBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDIgVGhlIGV4dGVudCB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGZpcnN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCAoZXh0ZW5kZWQpIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChleHRlbnQxLCBleHRlbnQyKSB7XG4gIGlmIChleHRlbnQyWzBdIDwgZXh0ZW50MVswXSkge1xuICAgIGV4dGVudDFbMF0gPSBleHRlbnQyWzBdO1xuICB9XG4gIGlmIChleHRlbnQyWzJdID4gZXh0ZW50MVsyXSkge1xuICAgIGV4dGVudDFbMl0gPSBleHRlbnQyWzJdO1xuICB9XG4gIGlmIChleHRlbnQyWzFdIDwgZXh0ZW50MVsxXSkge1xuICAgIGV4dGVudDFbMV0gPSBleHRlbnQyWzFdO1xuICB9XG4gIGlmIChleHRlbnQyWzNdID4gZXh0ZW50MVszXSkge1xuICAgIGV4dGVudDFbM10gPSBleHRlbnQyWzNdO1xuICB9XG4gIHJldHVybiBleHRlbnQxO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgaWYgKGNvb3JkaW5hdGVbMF0gPCBleHRlbnRbMF0pIHtcbiAgICBleHRlbnRbMF0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzBdID4gZXh0ZW50WzJdKSB7XG4gICAgZXh0ZW50WzJdID0gY29vcmRpbmF0ZVswXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA8IGV4dGVudFsxXSkge1xuICAgIGV4dGVudFsxXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMV0gPiBleHRlbnRbM10pIHtcbiAgICBleHRlbnRbM10gPSBjb29yZGluYXRlWzFdO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGV4dGVuZFhZKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+fSByaW5ncyBSaW5ncy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIHJpbmdzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGV4dGVudFswXSA9IE1hdGgubWluKGV4dGVudFswXSwgeCk7XG4gIGV4dGVudFsxXSA9IE1hdGgubWluKGV4dGVudFsxXSwgeSk7XG4gIGV4dGVudFsyXSA9IE1hdGgubWF4KGV4dGVudFsyXSwgeCk7XG4gIGV4dGVudFszXSA9IE1hdGgubWF4KGV4dGVudFszXSwgeSk7XG59XG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBjYWxsYmFja2AgZm9yIGVhY2ggY29ybmVyIG9mIHRoZSBleHRlbnQuIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0IHZhbHVlXG4gKiBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBTfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7VD19IG9wdF90aGlzIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqIEByZXR1cm4ge1N8Ym9vbGVhbn0gVmFsdWUuXG4gKiBAdGVtcGxhdGUgUywgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaENvcm5lcihleHRlbnQsIGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICBsZXQgdmFsO1xuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRCb3R0b21MZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRCb3R0b21SaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0VG9wUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldFRvcExlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJlYShleHRlbnQpIHtcbiAgbGV0IGFyZWEgPSAwO1xuICBpZiAoIWlzRW1wdHkoZXh0ZW50KSkge1xuICAgIGFyZWEgPSBnZXRXaWR0aChleHRlbnQpICogZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IEJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21MZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzFdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IEJvdHRvbSByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbMV1dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ2VudGVyLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VudGVyKGV4dGVudCkge1xuICByZXR1cm4gWyhleHRlbnRbMF0gKyBleHRlbnRbMl0pIC8gMiwgKGV4dGVudFsxXSArIGV4dGVudFszXSkgLyAyXTtcbn1cblxuXG4vKipcbiAqIEdldCBhIGNvcm5lciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnQvQ29ybmVyfSBjb3JuZXIgQ29ybmVyLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29ybmVyIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpIHtcbiAgbGV0IGNvb3JkaW5hdGU7XG4gIGlmIChjb3JuZXIgPT09IENvcm5lci5CT1RUT01fTEVGVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSBDb3JuZXIuQk9UVE9NX1JJR0hUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldEJvdHRvbVJpZ2h0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSBDb3JuZXIuVE9QX0xFRlQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gQ29ybmVyLlRPUF9SSUdIVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRUb3BSaWdodChleHRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSwgMTMpOyAvLyBJbnZhbGlkIGNvcm5lclxuICB9XG4gIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHshbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gKi8gKGNvb3JkaW5hdGUpXG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5sYXJnZWQgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVubGFyZ2VkQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbihleHRlbnQxWzBdLCBleHRlbnQyWzBdKTtcbiAgY29uc3QgbWluWSA9IE1hdGgubWluKGV4dGVudDFbMV0sIGV4dGVudDJbMV0pO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXgoZXh0ZW50MVsyXSwgZXh0ZW50MlsyXSk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heChleHRlbnQxWzNdLCBleHRlbnQyWzNdKTtcbiAgcmV0dXJuIChtYXhYIC0gbWluWCkgKiAobWF4WSAtIG1pblkpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUsIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgZHggPSByZXNvbHV0aW9uICogc2l6ZVswXSAvIDI7XG4gIGNvbnN0IGR5ID0gcmVzb2x1dGlvbiAqIHNpemVbMV0gLyAyO1xuICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gIGNvbnN0IHhDb3MgPSBkeCAqIGNvc1JvdGF0aW9uO1xuICBjb25zdCB4U2luID0gZHggKiBzaW5Sb3RhdGlvbjtcbiAgY29uc3QgeUNvcyA9IGR5ICogY29zUm90YXRpb247XG4gIGNvbnN0IHlTaW4gPSBkeSAqIHNpblJvdGF0aW9uO1xuICBjb25zdCB4ID0gY2VudGVyWzBdO1xuICBjb25zdCB5ID0gY2VudGVyWzFdO1xuICBjb25zdCB4MCA9IHggLSB4Q29zICsgeVNpbjtcbiAgY29uc3QgeDEgPSB4IC0geENvcyAtIHlTaW47XG4gIGNvbnN0IHgyID0geCArIHhDb3MgLSB5U2luO1xuICBjb25zdCB4MyA9IHggKyB4Q29zICsgeVNpbjtcbiAgY29uc3QgeTAgPSB5IC0geFNpbiAtIHlDb3M7XG4gIGNvbnN0IHkxID0geSAtIHhTaW4gKyB5Q29zO1xuICBjb25zdCB5MiA9IHkgKyB4U2luICsgeUNvcztcbiAgY29uc3QgeTMgPSB5ICsgeFNpbiAtIHlDb3M7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBNYXRoLm1pbih4MCwgeDEsIHgyLCB4MyksIE1hdGgubWluKHkwLCB5MSwgeTIsIHkzKSxcbiAgICBNYXRoLm1heCh4MCwgeDEsIHgyLCB4MyksIE1hdGgubWF4KHkwLCB5MSwgeTIsIHkzKSxcbiAgICBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhlaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFszXSAtIGV4dGVudFsxXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnNlY3Rpb24gYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbkFyZWEoZXh0ZW50MSwgZXh0ZW50Mikge1xuICBjb25zdCBpbnRlcnNlY3Rpb24gPSBnZXRJbnRlcnNlY3Rpb24oZXh0ZW50MSwgZXh0ZW50Mik7XG4gIHJldHVybiBnZXRBcmVhKGludGVyc2VjdGlvbik7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZXh0ZW50cy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgT3B0aW9uYWwgZXh0ZW50IHRvIHBvcHVsYXRlIHdpdGggaW50ZXJzZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEludGVyc2VjdGluZyBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24oZXh0ZW50MSwgZXh0ZW50Miwgb3B0X2V4dGVudCkge1xuICBjb25zdCBpbnRlcnNlY3Rpb24gPSBvcHRfZXh0ZW50ID8gb3B0X2V4dGVudCA6IGNyZWF0ZUVtcHR5KCk7XG4gIGlmIChpbnRlcnNlY3RzKGV4dGVudDEsIGV4dGVudDIpKSB7XG4gICAgaWYgKGV4dGVudDFbMF0gPiBleHRlbnQyWzBdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMF0gPSBleHRlbnQxWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMF0gPSBleHRlbnQyWzBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVsxXSA+IGV4dGVudDJbMV0pIHtcbiAgICAgIGludGVyc2VjdGlvblsxXSA9IGV4dGVudDFbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblsxXSA9IGV4dGVudDJbMV07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzJdIDwgZXh0ZW50MlsyXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzJdID0gZXh0ZW50MVsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzJdID0gZXh0ZW50MlsyXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbM10gPCBleHRlbnQyWzNdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bM10gPSBleHRlbnQxWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bM10gPSBleHRlbnQyWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KGludGVyc2VjdGlvbik7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbjtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1hcmdpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmdpbihleHRlbnQpIHtcbiAgcmV0dXJuIGdldFdpZHRoKGV4dGVudCkgKyBnZXRIZWlnaHQoZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSAod2lkdGgsIGhlaWdodCkgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBUaGUgZXh0ZW50IHNpemUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSAtIGV4dGVudFswXSwgZXh0ZW50WzNdIC0gZXh0ZW50WzFdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgdG9wIGxlZnQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVG9wIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcExlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbM11dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB0b3AgcmlnaHQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVG9wIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BSaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFszXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHdpZHRoIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2lkdGgoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gLSBleHRlbnRbMF07XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgb25lIGV4dGVudCBpbnRlcnNlY3RzIGFub3RoZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgaW50ZXJzZWN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiBleHRlbnQxWzBdIDw9IGV4dGVudDJbMl0gJiZcbiAgICAgIGV4dGVudDFbMl0gPj0gZXh0ZW50MlswXSAmJlxuICAgICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzNdICYmXG4gICAgICBleHRlbnQxWzNdID49IGV4dGVudDJbMV07XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZXh0ZW50IGlzIGVtcHR5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFsyXSA8IGV4dGVudFswXSB8fCBleHRlbnRbM10gPCBleHRlbnRbMV07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk9yVXBkYXRlKGV4dGVudCwgb3B0X2V4dGVudCkge1xuICBpZiAob3B0X2V4dGVudCkge1xuICAgIG9wdF9leHRlbnRbMF0gPSBleHRlbnRbMF07XG4gICAgb3B0X2V4dGVudFsxXSA9IGV4dGVudFsxXTtcbiAgICBvcHRfZXh0ZW50WzJdID0gZXh0ZW50WzJdO1xuICAgIG9wdF9leHRlbnRbM10gPSBleHRlbnRbM107XG4gICAgcmV0dXJuIG9wdF9leHRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlRnJvbUNlbnRlcihleHRlbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRlbHRhWCA9ICgoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIGNvbnN0IGRlbHRhWSA9ICgoZXh0ZW50WzNdIC0gZXh0ZW50WzFdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIGV4dGVudFswXSAtPSBkZWx0YVg7XG4gIGV4dGVudFsyXSArPSBkZWx0YVg7XG4gIGV4dGVudFsxXSAtPSBkZWx0YVk7XG4gIGV4dGVudFszXSArPSBkZWx0YVk7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHNlZ21lbnQgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXMgaW50ZXJzZWN0cyAoY3Jvc3NlcyxcbiAqIHRvdWNoZXMsIG9yIGlzIGNvbnRhaW5lZCBieSkgdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBzdGFydCBTZWdtZW50IHN0YXJ0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGVuZCBTZWdtZW50IGVuZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c1NlZ21lbnQoZXh0ZW50LCBzdGFydCwgZW5kKSB7XG4gIGxldCBpbnRlcnNlY3RzID0gZmFsc2U7XG4gIGNvbnN0IHN0YXJ0UmVsID0gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIHN0YXJ0KTtcbiAgY29uc3QgZW5kUmVsID0gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIGVuZCk7XG4gIGlmIChzdGFydFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORyB8fFxuICAgICAgZW5kUmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HKSB7XG4gICAgaW50ZXJzZWN0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgICBjb25zdCBtaW5ZID0gZXh0ZW50WzFdO1xuICAgIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gICAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgICBjb25zdCBzdGFydFggPSBzdGFydFswXTtcbiAgICBjb25zdCBzdGFydFkgPSBzdGFydFsxXTtcbiAgICBjb25zdCBlbmRYID0gZW5kWzBdO1xuICAgIGNvbnN0IGVuZFkgPSBlbmRbMV07XG4gICAgY29uc3Qgc2xvcGUgPSAoZW5kWSAtIHN0YXJ0WSkgLyAoZW5kWCAtIHN0YXJ0WCk7XG4gICAgbGV0IHgsIHk7XG4gICAgaWYgKCEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkgJiZcbiAgICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgdG9wXG4gICAgICB4ID0gZW5kWCAtICgoZW5kWSAtIG1heFkpIC8gc2xvcGUpO1xuICAgICAgaW50ZXJzZWN0cyA9IHggPj0gbWluWCAmJiB4IDw9IG1heFg7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyAmJiAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHJpZ2h0XG4gICAgICB5ID0gZW5kWSAtICgoZW5kWCAtIG1heFgpICogc2xvcGUpO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyAmJiAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGJvdHRvbVxuICAgICAgeCA9IGVuZFggLSAoKGVuZFkgLSBtaW5ZKSAvIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkxFRlQpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuTEVGVCkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgbGVmdFxuICAgICAgeSA9IGVuZFkgLSAoKGVuZFggLSBtaW5YKSAqIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cblxuICB9XG4gIHJldHVybiBpbnRlcnNlY3RzO1xufVxuXG5cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBDYWxsZWQgd2l0aCBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBleHRlbnQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1Gbiwgb3B0X2V4dGVudCkge1xuICBjb25zdCBjb29yZGluYXRlcyA9IFtcbiAgICBleHRlbnRbMF0sIGV4dGVudFsxXSxcbiAgICBleHRlbnRbMF0sIGV4dGVudFszXSxcbiAgICBleHRlbnRbMl0sIGV4dGVudFsxXSxcbiAgICBleHRlbnRbMl0sIGV4dGVudFszXVxuICBdO1xuICB0cmFuc2Zvcm1Gbihjb29yZGluYXRlcywgY29vcmRpbmF0ZXMsIDIpO1xuICBjb25zdCB4cyA9IFtjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMl0sIGNvb3JkaW5hdGVzWzRdLCBjb29yZGluYXRlc1s2XV07XG4gIGNvbnN0IHlzID0gW2Nvb3JkaW5hdGVzWzFdLCBjb29yZGluYXRlc1szXSwgY29vcmRpbmF0ZXNbNV0sIGNvb3JkaW5hdGVzWzddXTtcbiAgcmV0dXJuIF9ib3VuZGluZ0V4dGVudFhZcyh4cywgeXMsIG9wdF9leHRlbnQpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudC9Db3JuZXJcbiAqL1xuXG4vKipcbiAqIEV4dGVudCBjb3JuZXIuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEJPVFRPTV9MRUZUOiAnYm90dG9tLWxlZnQnLFxuICBCT1RUT01fUklHSFQ6ICdib3R0b20tcmlnaHQnLFxuICBUT1BfTEVGVDogJ3RvcC1sZWZ0JyxcbiAgVE9QX1JJR0hUOiAndG9wLXJpZ2h0J1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnQvUmVsYXRpb25zaGlwXG4gKi9cblxuLyoqXG4gKiBSZWxhdGlvbnNoaXAgdG8gYW4gZXh0ZW50LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBVTktOT1dOOiAwLFxuICBJTlRFUlNFQ1RJTkc6IDEsXG4gIEFCT1ZFOiAyLFxuICBSSUdIVDogNCxcbiAgQkVMT1c6IDgsXG4gIExFRlQ6IDE2XG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Z1bmN0aW9uc1xuICovXG5cbi8qKlxuICogQWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gVFJVRSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQWx3YXlzIHJldHVybnMgZmFsc2UuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGQUxTRSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgcmV1c2FibGUgZnVuY3Rpb24sIHVzZWQgZS5nLiBhcyBhIGRlZmF1bHQgZm9yIGNhbGxiYWNrcy5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IE5vdGhpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBVTkRFRklORUQoKSB7fVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vR2VvbWV0cnlUeXBlXG4gKi9cblxuLyoqXG4gKiBUaGUgZ2VvbWV0cnkgdHlwZS4gT25lIG9mIGAnUG9pbnQnYCwgYCdMaW5lU3RyaW5nJ2AsIGAnTGluZWFyUmluZydgLFxuICogYCdQb2x5Z29uJ2AsIGAnTXVsdGlQb2ludCdgLCBgJ011bHRpTGluZVN0cmluZydgLCBgJ011bHRpUG9seWdvbidgLFxuICogYCdHZW9tZXRyeUNvbGxlY3Rpb24nYCwgYCdDaXJjbGUnYC5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUE9JTlQ6ICdQb2ludCcsXG4gIExJTkVfU1RSSU5HOiAnTGluZVN0cmluZycsXG4gIExJTkVBUl9SSU5HOiAnTGluZWFyUmluZycsXG4gIFBPTFlHT046ICdQb2x5Z29uJyxcbiAgTVVMVElfUE9JTlQ6ICdNdWx0aVBvaW50JyxcbiAgTVVMVElfTElORV9TVFJJTkc6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICBNVUxUSV9QT0xZR09OOiAnTXVsdGlQb2x5Z29uJyxcbiAgR0VPTUVUUllfQ09MTEVDVElPTjogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gIENJUkNMRTogJ0NpcmNsZSdcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2xcbiAqL1xuXG5pbXBvcnQge2dldENvbnRleHR9IGZyb20gJy4vd2ViZ2wuanMnO1xuXG5cbi8qKlxuICogQW4gYXJyYXkgd2l0aCB0d28gZWxlbWVudHMsIHJlcHJlc2VudGluZyBhIHBpeGVsLiBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAqIHgtY29vcmRpbmF0ZSwgdGhlIHNlY29uZCB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBwaXhlbC5cbiAqIEB0eXBlZGVmIHtBcnJheS48bnVtYmVyPn0gUGl4ZWxcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogSW5jbHVkZSBkZWJ1Z2dhYmxlIHNoYWRlciBzb3VyY2VzLiAgRGVmYXVsdCBpcyBgdHJ1ZWAuIFRoaXMgc2hvdWxkIGJlIHNldCB0b1xuICogYGZhbHNlYCBmb3IgcHJvZHVjdGlvbiBidWlsZHMuXG4gKiBUT0RPOiBtb3ZlIHRvIGEgc2VwYXJhdGUgb2wtd2ViZ2wgcGFja2FnZVxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBERUJVR19XRUJHTCA9IHRydWU7XG5cblxuLyoqXG4gKiBUT0RPOiBtb3ZlIHRvIGEgc2VwYXJhdGUgb2wtd2ViZ2wgcGFja2FnZVxuICogVGhlIG1heGltdW0gc3VwcG9ydGVkIFdlYkdMIHRleHR1cmUgc2l6ZSBpbiBwaXhlbHMuIElmIFdlYkdMIGlzIG5vdFxuICogc3VwcG9ydGVkLCB0aGUgdmFsdWUgaXMgc2V0IHRvIGB1bmRlZmluZWRgLlxuICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gKi9cbmxldCBXRUJHTF9NQVhfVEVYVFVSRV9TSVpFOyAvLyB2YWx1ZSBpcyBzZXQgYmVsb3dcblxuXG4vKipcbiAqIFRPRE86IG1vdmUgdG8gYSBzZXBhcmF0ZSBvbC13ZWJnbCBwYWNrYWdlXG4gKiBMaXN0IG9mIHN1cHBvcnRlZCBXZWJHTCBleHRlbnNpb25zLlxuICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICovXG5sZXQgV0VCR0xfRVhURU5TSU9OUzsgLy8gdmFsdWUgaXMgc2V0IGJlbG93XG5cblxuLyoqXG4gKiBUT0RPOiBtb3ZlIHRvIGEgc2VwYXJhdGUgb2wtd2ViZ2wgcGFja2FnZVxuICogV2ViR0wgaXMgYXZhaWxhYmxlLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmxldCBIQVNfV0VCR0wgPSBmYWxzZTtcblxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1dlYkdMUmVuZGVyaW5nQ29udGV4dCcgaW4gd2luZG93KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpKTtcbiAgICBjb25zdCBnbCA9IGdldENvbnRleHQoY2FudmFzLCB7ZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZX0pO1xuICAgIGlmIChnbCkge1xuICAgICAgSEFTX1dFQkdMID0gdHJ1ZTtcbiAgICAgIFdFQkdMX01BWF9URVhUVVJFX1NJWkUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKSk7XG4gICAgICBXRUJHTF9FWFRFTlNJT05TID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHBhc3NcbiAgfVxufVxuXG5leHBvcnQge0hBU19XRUJHTCwgV0VCR0xfTUFYX1RFWFRVUkVfU0laRSwgV0VCR0xfRVhURU5TSU9OU307XG5cblxuLyoqXG4gKiBPcGVuTGF5ZXJzIHZlcnNpb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICd2NC42LjQnO1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBmdW5jdGlvbiBQYXJlbnRDbGFzcyhhLCBiKSB7IH1cbiAqICAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGUuZm9vID0gZnVuY3Rpb24oYSkgeyB9XG4gKlxuICogICAgIGZ1bmN0aW9uIENoaWxkQ2xhc3MoYSwgYiwgYykge1xuICogICAgICAgLy8gQ2FsbCBwYXJlbnQgY29uc3RydWN0b3JcbiAqICAgICAgIFBhcmVudENsYXNzLmNhbGwodGhpcywgYSwgYik7XG4gKiAgICAgfVxuICogICAgIGluaGVyaXRzKENoaWxkQ2xhc3MsIFBhcmVudENsYXNzKTtcbiAqXG4gKiAgICAgdmFyIGNoaWxkID0gbmV3IENoaWxkQ2xhc3MoJ2EnLCAnYicsICdzZWUnKTtcbiAqICAgICBjaGlsZC5mb28oKTsgLy8gVGhpcyB3b3Jrcy5cbiAqXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gY2hpbGRDdG9yIENoaWxkIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHshRnVuY3Rpb259IHBhcmVudEN0b3IgUGFyZW50IGNvbnN0cnVjdG9yLlxuICogQGZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmhlcml0cyhjaGlsZEN0b3IsIHBhcmVudEN0b3IpIHtcbiAgY2hpbGRDdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q3Rvci5wcm90b3R5cGUpO1xuICBjaGlsZEN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGRDdG9yO1xufVxuXG5cbi8qKlxuICogQ291bnRlciBmb3IgZ2V0VWlkLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB1aWRDb3VudGVyXyA9IDA7XG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFVuaXF1ZSBJRHMgYXJlIGdlbmVyYXRlZFxuICogYXMgYSBzdHJpY3RseSBpbmNyZWFzaW5nIHNlcXVlbmNlLiBBZGFwdGVkIGZyb20gZ29vZy5nZXRVaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVpZChvYmopIHtcbiAgcmV0dXJuIG9iai5vbF91aWQgfHwgKG9iai5vbF91aWQgPSArK3VpZENvdW50ZXJfKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9tYXRoXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIGdpdmVuIG51bWJlci4gVGhlIG1ldGhvZCB3aWxsIHVzZSB0aGVcbiAqIG5hdGl2ZSBgTWF0aC5jb3NoYCBmdW5jdGlvbiBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSB0aGUgaHlwZXJib2xpY1xuICogY29zaW5lIHdpbGwgYmUgY2FsY3VsYXRlZCB2aWEgdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTW96aWxsYVxuICogZGV2ZWxvcGVyIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEByZXR1cm4ge251bWJlcn0gSHlwZXJib2xpYyBjb3NpbmUgb2YgeC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvc2ggID0gKGZ1bmN0aW9uKCkge1xuICAvLyBXcmFwcGVkIGluIGEgaWlmZSwgdG8gc2F2ZSB0aGUgb3ZlcmhlYWQgb2YgY2hlY2tpbmcgZm9yIHRoZSBuYXRpdmVcbiAgLy8gaW1wbGVtZW50YXRpb24gb24gZXZlcnkgaW52b2NhdGlvbi5cbiAgbGV0IGNvc2g7XG4gIGlmICgnY29zaCcgaW4gTWF0aCkge1xuICAgIC8vIFRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyB0aGUgbmF0aXZlIE1hdGguY29zaCBmdW5jdGlvbiwgdXNlIGl04oCmXG4gICAgY29zaCA9IE1hdGguY29zaDtcbiAgfSBlbHNlIHtcbiAgICAvLyDigKYgZWxzZSwgdXNlIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgTUROOlxuICAgIGNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICBjb25zdCB5ID0gTWF0aC5leHAoeCk7XG4gICAgICByZXR1cm4gKHkgKyAxIC8geSkgLyAyO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvc2g7XG59KCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVXBUb1Bvd2VyT2ZUd28oeCkge1xuICBhc3NlcnQoMCA8IHgsIDI5KTsgLy8gYHhgIG11c3QgYmUgZ3JlYXRlciB0aGFuIGAwYFxuICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKHgpIC8gTWF0aC5MTjIpKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCAoeCwgeSkgYW5kIHRoZVxuICogbGluZSBzZWdtZW50ICh4MSwgeTEpIHRvICh4MiwgeTIpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkU2VnbWVudERpc3RhbmNlKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICBjb25zdCB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoeCwgeSwgeDEsIHkxKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5cbi8qKlxuICogU29sdmVzIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIHVzaW5nIEdhdXNzaWFuIGVsaW1pbmF0aW9uIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IG1hdCBBdWdtZW50ZWQgbWF0cml4IChuIHggbiArIDEgY29sdW1uKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gcm93LW1ham9yIG9yZGVyLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRoZSByZXN1bHRpbmcgdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29sdmVMaW5lYXJTeXN0ZW0obWF0KSB7XG4gIGNvbnN0IG4gPSBtYXQubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgLy8gRmluZCBtYXggaW4gdGhlIGktdGggY29sdW1uIChpZ25vcmluZyBpIC0gMSBmaXJzdCByb3dzKVxuICAgIGxldCBtYXhSb3cgPSBpO1xuICAgIGxldCBtYXhFbCA9IE1hdGguYWJzKG1hdFtpXVtpXSk7XG4gICAgZm9yIChsZXQgciA9IGkgKyAxOyByIDwgbjsgcisrKSB7XG4gICAgICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKG1hdFtyXVtpXSk7XG4gICAgICBpZiAoYWJzVmFsdWUgPiBtYXhFbCkge1xuICAgICAgICBtYXhFbCA9IGFic1ZhbHVlO1xuICAgICAgICBtYXhSb3cgPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhFbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG1hdHJpeCBpcyBzaW5ndWxhclxuICAgIH1cblxuICAgIC8vIFN3YXAgbWF4IHJvdyB3aXRoIGktdGggKGN1cnJlbnQpIHJvd1xuICAgIGNvbnN0IHRtcCA9IG1hdFttYXhSb3ddO1xuICAgIG1hdFttYXhSb3ddID0gbWF0W2ldO1xuICAgIG1hdFtpXSA9IHRtcDtcblxuICAgIC8vIFN1YnRyYWN0IHRoZSBpLXRoIHJvdyB0byBtYWtlIGFsbCB0aGUgcmVtYWluaW5nIHJvd3MgMCBpbiB0aGUgaS10aCBjb2x1bW5cbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgIGNvbnN0IGNvZWYgPSAtbWF0W2pdW2ldIC8gbWF0W2ldW2ldO1xuICAgICAgZm9yIChsZXQgayA9IGk7IGsgPCBuICsgMTsgaysrKSB7XG4gICAgICAgIGlmIChpID09IGspIHtcbiAgICAgICAgICBtYXRbal1ba10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdFtqXVtrXSArPSBjb2VmICogbWF0W2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU29sdmUgQXg9YiBmb3IgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggQSAobWF0KVxuICBjb25zdCB4ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKGxldCBsID0gbiAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgeFtsXSA9IG1hdFtsXVtuXSAvIG1hdFtsXVtsXTtcbiAgICBmb3IgKGxldCBtID0gbCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICBtYXRbbV1bbl0gLT0gbWF0W21dW2xdICogeFtsXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0cyByYWRpYW5zIHRvIHRvIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIGRlZ3JlZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZXMoYW5nbGVJblJhZGlhbnMpIHtcbiAgcmV0dXJuIGFuZ2xlSW5SYWRpYW5zICogMTgwIC8gTWF0aC5QSTtcbn1cblxuXG4vKipcbiAqIENvbnZlcnRzIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJbkRlZ3JlZXMgQW5nbGUgaW4gZGVncmVlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhhbmdsZUluRGVncmVlcykge1xuICByZXR1cm4gYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZHVsbyBvZiBhIC8gYiwgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIGIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgRGl2aWRlbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gYiBEaXZpc29yLlxuICogQHJldHVybiB7bnVtYmVyfSBNb2R1bG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2R1bG8oYSwgYikge1xuICBjb25zdCByID0gYSAlIGI7XG4gIHJldHVybiByICogYiA8IDAgPyByICsgYiA6IHI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGluZWFybHkgaW50ZXJwb2xhdGVkIHZhbHVlIG9mIHggYmV0d2VlbiBhIGFuZCBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0geCBWYWx1ZSB0byBiZSBpbnRlcnBvbGF0ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVycG9sYXRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoYSwgYiwgeCkge1xuICByZXR1cm4gYSArIHggKiAoYiAtIGEpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL29ialxuICovXG5cblxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgT2JqZWN0LmFzc2lnbigpLiAgQXNzaWducyBlbnVtZXJhYmxlIGFuZCBvd24gcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyB0byBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG4gKiBAcGFyYW0geyFPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfc291cmNlcyBUaGUgc291cmNlIG9iamVjdChzKS5cbiAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBtb2RpZmllZCB0YXJnZXQgb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgYXNzaWduID0gKHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbih0YXJnZXQsIHZhcl9zb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICBmb3IgKGxldCBpID0gMSwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xlYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihvYmplY3QpIHtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgfVxufVxuXG5cbi8qKlxuICogR2V0IGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PEssVj59IG9iamVjdCBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHshQXJyYXk8Vj59IFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAdGVtcGxhdGUgSyxWXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZXMob2JqZWN0KSB7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIHZhbHVlcy5wdXNoKG9iamVjdFtwcm9wZXJ0eV0pO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhbnkgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBvYmplY3QgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuICBsZXQgcHJvcGVydHk7XG4gIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhcHJvcGVydHk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvalxuICovXG5cbi8qKlxuICogVGhlIG9sL3Byb2ogbW9kdWxlIHN0b3JlczpcbiAqICogYSBsaXN0IG9mIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufVxuICogb2JqZWN0cywgb25lIGZvciBlYWNoIHByb2plY3Rpb24gc3VwcG9ydGVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICogKiBhIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBuZWVkZWQgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBvbmUgcHJvamVjdGlvblxuICogaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBzdGF0aWMgZnVuY3Rpb25zIGFyZSB0aGUgbWV0aG9kcyB1c2VkIHRvIG1haW50YWluIHRoZXNlLlxuICogRWFjaCB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIGhhbmRsZSBub3Qgb25seSBzaW1wbGUgY29vcmRpbmF0ZSBwYWlycywgYnV0IGFsc29cbiAqIGxhcmdlIGFycmF5cyBvZiBjb29yZGluYXRlcyBzdWNoIGFzIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFdoZW4gbG9hZGVkLCB0aGUgbGlicmFyeSBhZGRzIHByb2plY3Rpb24gb2JqZWN0cyBmb3IgRVBTRzo0MzI2IChXR1M4NFxuICogZ2VvZ3JhcGhpYyBjb29yZGluYXRlcykgYW5kIEVQU0c6Mzg1NyAoV2ViIG9yIFNwaGVyaWNhbCBNZXJjYXRvciwgYXMgdXNlZFxuICogZm9yIGV4YW1wbGUgYnkgQmluZyBNYXBzIG9yIE9wZW5TdHJlZXRNYXApLCB0b2dldGhlciB3aXRoIHRoZSByZWxldmFudFxuICogdHJhbnNmb3JtIGZ1bmN0aW9ucy5cbiAqXG4gKiBBZGRpdGlvbmFsIHRyYW5zZm9ybXMgbWF5IGJlIGFkZGVkIGJ5IHVzaW5nIHRoZSB7QGxpbmsgaHR0cDovL3Byb2o0anMub3JnL31cbiAqIGxpYnJhcnkgKHZlcnNpb24gMi4yIG9yIGxhdGVyKS4gWW91IGNhbiB1c2UgdGhlIGZ1bGwgYnVpbGQgc3VwcGxpZWQgYnlcbiAqIFByb2o0anMsIG9yIGNyZWF0ZSBhIGN1c3RvbSBidWlsZCB0byBzdXBwb3J0IHRob3NlIHByb2plY3Rpb25zIHlvdSBuZWVkOyBzZWVcbiAqIHRoZSBQcm9qNGpzIHdlYnNpdGUgZm9yIGhvdyB0byBkbyB0aGlzLiBZb3UgYWxzbyBuZWVkIHRoZSBQcm9qNGpzIGRlZmluaXRpb25zXG4gKiBmb3IgdGhlIHJlcXVpcmVkIHByb2plY3Rpb25zLiBUaGVzZSBkZWZpbml0aW9ucyBjYW4gYmUgb2J0YWluZWQgZnJvbVxuICoge0BsaW5rIGh0dHBzOi8vZXBzZy5pby99LCBhbmQgYXJlIGEgSlMgZnVuY3Rpb24sIHNvIGNhbiBiZSBsb2FkZWQgaW4gYSBzY3JpcHRcbiAqIHRhZyAoYXMgaW4gdGhlIGV4YW1wbGVzKSBvciBwYXN0ZWQgaW50byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZSBhZGRlZCB0byBwcm9qNCdzIHJlZ2lzdHJ5IChieVxuICogdXNpbmcgYHByb2o0LmRlZnMoKWApLCBzaW1wbHkgY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBmcm9tIHRoZSBgb2wvcHJvai9wcm9qNGBcbiAqIHBhY2thZ2UuIEV4aXN0aW5nIHRyYW5zZm9ybXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IHRoaXMgZnVuY3Rpb24uIFNlZVxuICogZXhhbXBsZXMvd21zLWltYWdlLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogQWRkaXRpb25hbCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGNhbiBiZSByZWdpc3RlcmVkIHdpdGggYHByb2o0LmRlZnMoKWAgYW55XG4gKiB0aW1lLiBKdXN0IG1ha2Ugc3VyZSB0byBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGFnYWluOyBmb3IgZXhhbXBsZSwgd2l0aCB1c2VyLXN1cHBsaWVkIGRhdGEgd2hlcmUgeW91IGRvbid0XG4gKiBrbm93IGluIGFkdmFuY2Ugd2hhdCBwcm9qZWN0aW9ucyBhcmUgbmVlZGVkLCB5b3UgY2FuIGluaXRpYWxseSBsb2FkIG1pbmltYWxcbiAqIHN1cHBvcnQgYW5kIHRoZW4gbG9hZCB3aGljaGV2ZXIgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBOb3RlIHRoYXQgUHJvajRqcyBkb2VzIG5vdCBzdXBwb3J0IHByb2plY3Rpb24gZXh0ZW50cy4gSWYgeW91IHdhbnQgdG8gYWRkXG4gKiBvbmUgZm9yIGNyZWF0aW5nIGRlZmF1bHQgdGlsZSBncmlkcywgeW91IGNhbiBhZGQgaXQgYWZ0ZXIgdGhlIFByb2plY3Rpb25cbiAqIG9iamVjdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYHNldEV4dGVudGAsIGZvciBleGFtcGxlLFxuICogYGdldCgnRVBTRzoxMjM0Jykuc2V0RXh0ZW50KGV4dGVudClgLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIFByb2o0anMgc3VwcG9ydCwgYW55IHRyYW5zZm9ybSBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFRvIHVzZSB0aGlzLCB5b3UgbXVzdCBmaXJzdCBjcmVhdGVcbiAqIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IG9iamVjdCBmb3IgdGhlIG5ldyBwcm9qZWN0aW9uIGFuZCBhZGQgaXQgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZFByb2plY3Rpb259LiBZb3UgY2FuIHRoZW4gYWRkIHRoZSBmb3J3YXJkIGFuZCBpbnZlcnNlXG4gKiBmdW5jdGlvbnMgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+YWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXN9LiBTZWVcbiAqIGV4YW1wbGVzL3dtcy1jdXN0b20tcHJvaiBmb3IgYW4gZXhhbXBsZSBvZiB0aGlzLlxuICpcbiAqIE5vdGUgdGhhdCBpZiBubyB0cmFuc2Zvcm1zIGFyZSBuZWVkZWQgYW5kIHlvdSBvbmx5IG5lZWQgdG8gZGVmaW5lIHRoZVxuICogcHJvamVjdGlvbiwganVzdCBhZGQgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZFByb2plY3Rpb259LiBTZWUgZXhhbXBsZXMvd21zLW5vLXByb2ogZm9yIGFuIGV4YW1wbGUgb2ZcbiAqIHRoaXMuXG4gKi9cbmltcG9ydCB7Z2V0RGlzdGFuY2V9IGZyb20gJy4vc3BoZXJlLmpzJztcbmltcG9ydCB7YXBwbHlUcmFuc2Zvcm19IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHt0b0VQU0c0MzI2LCBmcm9tRVBTRzQzMjYsIFBST0pFQ1RJT05TIGFzIEVQU0czODU3X1BST0pFQ1RJT05TfSBmcm9tICcuL3Byb2ovZXBzZzM4NTcuanMnO1xuaW1wb3J0IHtQUk9KRUNUSU9OUyBhcyBFUFNHNDMyNl9QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2c0MzI2LmpzJztcbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cywge01FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qL1VuaXRzLmpzJztcbmltcG9ydCAqIGFzIHByb2plY3Rpb25zIGZyb20gJy4vcHJvai9wcm9qZWN0aW9ucy5qcyc7XG5pbXBvcnQge2FkZCBhcyBhZGRUcmFuc2Zvcm1GdW5jLCBjbGVhciBhcyBjbGVhclRyYW5zZm9ybUZ1bmNzLCBnZXQgYXMgZ2V0VHJhbnNmb3JtRnVuY30gZnJvbSAnLi9wcm9qL3RyYW5zZm9ybXMuanMnO1xuXG5cbi8qKlxuICogQSBwcm9qZWN0aW9uIGFzIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSwgU1JTIGlkZW50aWZpZXJcbiAqIHN0cmluZyBvciB1bmRlZmluZWQuXG4gKiBAdHlwZWRlZiB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbnxzdHJpbmd8dW5kZWZpbmVkfSBQcm9qZWN0aW9uTGlrZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBBIHRyYW5zZm9ybSBmdW5jdGlvbiBhY2NlcHRzIGFuIGFycmF5IG9mIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBhbiBvcHRpb25hbFxuICogb3V0cHV0IGFycmF5LCBhbmQgYW4gb3B0aW9uYWwgZGltZW5zaW9uIChkZWZhdWx0IHNob3VsZCBiZSAyKS4gIFRoZSBmdW5jdGlvblxuICogdHJhbnNmb3JtcyB0aGUgaW5wdXQgY29vcmRpbmF0ZSB2YWx1ZXMsIHBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5LCBhbmRcbiAqIHJldHVybnMgdGhlIG91dHB1dCBhcnJheS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXkuPG51bWJlcj4sIEFycmF5LjxudW1iZXI+PSwgbnVtYmVyPSk6IEFycmF5LjxudW1iZXI+fSBUcmFuc2Zvcm1GdW5jdGlvblxuICogQGFwaVxuICovXG5cblxuZXhwb3J0IHtNRVRFUlNfUEVSX1VOSVR9O1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gT3V0cHV0IGNvb3JkaW5hdGUgYXJyYXkgKG5ldyBhcnJheSwgc2FtZSBjb29yZGluYXRlXG4gKiAgICAgdmFsdWVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVHJhbnNmb3JtKGlucHV0LCBvcHRfb3V0cHV0LCBvcHRfZGltZW5zaW9uKSB7XG4gIGxldCBvdXRwdXQ7XG4gIGlmIChvcHRfb3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvcHRfb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIG91dHB1dCA9IG9wdF9vdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gSW5wdXQgY29vcmRpbmF0ZSBhcnJheSAoc2FtZSBhcnJheSBhcyBpbnB1dCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eVRyYW5zZm9ybShpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICBpZiAob3B0X291dHB1dCAhPT0gdW5kZWZpbmVkICYmIGlucHV0ICE9PSBvcHRfb3V0cHV0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3B0X291dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBpbnB1dCA9IG9wdF9vdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5cbi8qKlxuICogQWRkIGEgUHJvamVjdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHByb2plY3Rpb25zIHRoYXQgY2FuIGJlXG4gKiBsb29rZWQgdXAgYnkgdGhlaXIgY29kZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbiBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9ucy5hZGQocHJvamVjdGlvbi5nZXRDb2RlKCksIHByb2plY3Rpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24sIHByb2plY3Rpb24sIGNsb25lVHJhbnNmb3JtKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIHByb2plY3Rpb25zLmZvckVhY2goYWRkUHJvamVjdGlvbik7XG59XG5cblxuLyoqXG4gKiBGZXRjaGVzIGEgUHJvamVjdGlvbiBvYmplY3QgZm9yIHRoZSBjb2RlIHNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uTGlrZSBFaXRoZXIgYSBjb2RlIHN0cmluZyB3aGljaCBpc1xuICogICAgIGEgY29tYmluYXRpb24gb2YgYXV0aG9yaXR5IGFuZCBpZGVudGlmaWVyIHN1Y2ggYXMgXCJFUFNHOjQzMjZcIiwgb3IgYW5cbiAqICAgICBleGlzdGluZyBwcm9qZWN0aW9uIG9iamVjdCwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gUHJvamVjdGlvbiBvYmplY3QsIG9yIG51bGwgaWYgbm90IGluIGxpc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQocHJvamVjdGlvbkxpa2UpIHtcbiAgbGV0IHByb2plY3Rpb24gPSBudWxsO1xuICBpZiAocHJvamVjdGlvbkxpa2UgaW5zdGFuY2VvZiBQcm9qZWN0aW9uKSB7XG4gICAgcHJvamVjdGlvbiA9IHByb2plY3Rpb25MaWtlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9qZWN0aW9uTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb2RlID0gcHJvamVjdGlvbkxpa2U7XG4gICAgcHJvamVjdGlvbiA9IHByb2plY3Rpb25zLmdldChjb2RlKTtcbiAgfVxuICByZXR1cm4gcHJvamVjdGlvbjtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcG9pbnQgaW4gZGVncmVlcyBvciBkaXN0YW5jZSB1bml0cy5cbiAqIEZvciBwcm9qZWN0aW9ucyB3aXRoIGRlZ3JlZXMgYXMgdGhlIHVuaXQgdGhpcyB3aWxsIHNpbXBseSByZXR1cm4gdGhlXG4gKiBwcm92aWRlZCByZXNvbHV0aW9uLiBGb3Igb3RoZXIgcHJvamVjdGlvbnMgdGhlIHBvaW50IHJlc29sdXRpb24gaXNcbiAqIGJ5IGRlZmF1bHQgZXN0aW1hdGVkIGJ5IHRyYW5zZm9ybWluZyB0aGUgJ3BvaW50JyBwaXhlbCB0byBFUFNHOjQzMjYsXG4gKiBtZWFzdXJpbmcgaXRzIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG5vcm1hbCBzcGhlcmUsXG4gKiBhbmQgdGFraW5nIHRoZSBhdmVyYWdlIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICogQSBjdXN0b20gZnVuY3Rpb24gY2FuIGJlIHByb3ZpZGVkIGZvciBhIHNwZWNpZmljIHByb2plY3Rpb24sIGVpdGhlclxuICogYnkgc2V0dGluZyB0aGUgYGdldFBvaW50UmVzb2x1dGlvbmAgb3B0aW9uIGluIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gY29uc3RydWN0b3Igb3IgYnkgdXNpbmdcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb24jc2V0R2V0UG9pbnRSZXNvbHV0aW9ufSB0byBjaGFuZ2UgYW4gZXhpc3RpbmdcbiAqIHByb2plY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIE5vbWluYWwgcmVzb2x1dGlvbiBpbiBwcm9qZWN0aW9uIHVuaXRzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBwb2ludCBQb2ludCB0byBmaW5kIGFkanVzdGVkIHJlc29sdXRpb24gYXQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1VuaXRzPX0gb3B0X3VuaXRzIFVuaXRzIHRvIGdldCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpbi5cbiAqIERlZmF1bHQgaXMgdGhlIHByb2plY3Rpb24ncyB1bml0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gUG9pbnQgcmVzb2x1dGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50UmVzb2x1dGlvbihwcm9qZWN0aW9uLCByZXNvbHV0aW9uLCBwb2ludCwgb3B0X3VuaXRzKSB7XG4gIHByb2plY3Rpb24gPSBnZXQocHJvamVjdGlvbik7XG4gIGxldCBwb2ludFJlc29sdXRpb247XG4gIGNvbnN0IGdldHRlciA9IHByb2plY3Rpb24uZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYygpO1xuICBpZiAoZ2V0dGVyKSB7XG4gICAgcG9pbnRSZXNvbHV0aW9uID0gZ2V0dGVyKHJlc29sdXRpb24sIHBvaW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB1bml0cyA9IHByb2plY3Rpb24uZ2V0VW5pdHMoKTtcbiAgICBpZiAodW5pdHMgPT0gVW5pdHMuREVHUkVFUyAmJiAhb3B0X3VuaXRzIHx8IG9wdF91bml0cyA9PSBVbml0cy5ERUdSRUVTKSB7XG4gICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFc3RpbWF0ZSBwb2ludCByZXNvbHV0aW9uIGJ5IHRyYW5zZm9ybWluZyB0aGUgY2VudGVyIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAgICAgIC8vIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSwgYW5kIHRha2luZyB0aGVcbiAgICAgIC8vIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICBjb25zdCB0b0VQU0c0MzI2ID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHByb2plY3Rpb24sIGdldCgnRVBTRzo0MzI2JykpO1xuICAgICAgbGV0IHZlcnRpY2VzID0gW1xuICAgICAgICBwb2ludFswXSAtIHJlc29sdXRpb24gLyAyLCBwb2ludFsxXSxcbiAgICAgICAgcG9pbnRbMF0gKyByZXNvbHV0aW9uIC8gMiwgcG9pbnRbMV0sXG4gICAgICAgIHBvaW50WzBdLCBwb2ludFsxXSAtIHJlc29sdXRpb24gLyAyLFxuICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0gKyByZXNvbHV0aW9uIC8gMlxuICAgICAgXTtcbiAgICAgIHZlcnRpY2VzID0gdG9FUFNHNDMyNih2ZXJ0aWNlcywgdmVydGljZXMsIDIpO1xuICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXN0YW5jZSh2ZXJ0aWNlcy5zbGljZSgwLCAyKSwgdmVydGljZXMuc2xpY2UoMiwgNCkpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoNCwgNiksIHZlcnRpY2VzLnNsaWNlKDYsIDgpKTtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuICAgICAgY29uc3QgbWV0ZXJzUGVyVW5pdCA9IG9wdF91bml0cyA/XG4gICAgICAgIE1FVEVSU19QRVJfVU5JVFtvcHRfdW5pdHNdIDpcbiAgICAgICAgcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiAvPSBtZXRlcnNQZXJVbml0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRSZXNvbHV0aW9uO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzLiBUaG9zZSBhbGxvd1xuICogdG8gdHJhbnNmb3JtIGJldHdlZW4gcHJvamVjdGlvbnMgd2l0aCBlcXVhbCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucyk7XG4gIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgcHJvamVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKHNvdXJjZSAhPT0gZGVzdGluYXRpb24pIHtcbiAgICAgICAgYWRkVHJhbnNmb3JtRnVuYyhzb3VyY2UsIGRlc3RpbmF0aW9uLCBjbG9uZVRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGluIGFueSBwcm9qZWN0aW9uXG4gKiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMxIFByb2plY3Rpb25zIHdpdGggZXF1YWxcbiAqICAgICBtZWFuaW5nLlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj59IHByb2plY3Rpb25zMiBQcm9qZWN0aW9ucyB3aXRoIGVxdWFsXG4gKiAgICAgbWVhbmluZy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IGZvcndhcmRUcmFuc2Zvcm0gVHJhbnNmb3JtYXRpb24gZnJvbSBhbnlcbiAqICAgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IGludmVyc2VUcmFuc2Zvcm0gVHJhbnNmb3JtIGZyb20gYW55IHByb2plY3Rpb25cbiAqICAgaW4gcHJvamVjdGlvbjIgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMocHJvamVjdGlvbnMxLCBwcm9qZWN0aW9uczIsIGZvcndhcmRUcmFuc2Zvcm0sIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgcHJvamVjdGlvbnMxLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdGlvbjEpIHtcbiAgICBwcm9qZWN0aW9uczIuZm9yRWFjaChmdW5jdGlvbihwcm9qZWN0aW9uMikge1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIsIGZvcndhcmRUcmFuc2Zvcm0pO1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMiwgcHJvamVjdGlvbjEsIGludmVyc2VUcmFuc2Zvcm0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIENsZWFyIGFsbCBjYWNoZWQgcHJvamVjdGlvbnMgYW5kIHRyYW5zZm9ybXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckFsbFByb2plY3Rpb25zKCkge1xuICBwcm9qZWN0aW9ucy5jbGVhcigpO1xuICBjbGVhclRyYW5zZm9ybUZ1bmNzKCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRDb2RlIERlZmF1bHQgY29kZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IFByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uKHByb2plY3Rpb24sIGRlZmF1bHRDb2RlKSB7XG4gIGlmICghcHJvamVjdGlvbikge1xuICAgIHJldHVybiBnZXQoZGVmYXVsdENvZGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9qZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZXQocHJvamVjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gKi8gKHByb2plY3Rpb24pXG4gICAgKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBtb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gZnJvbSBhIHNpbXBsZSAyRCBjb29yZGluYXRlIHRyYW5zZm9ybVxuICogZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZFRyYW5zZm9ybSBDb29yZGluYXRlXG4gKiAgICAgdHJhbnNmb3JtLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGNvb3JkVHJhbnNmb3JtKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wdXQgSW5wdXQuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IE91dHB1dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gb3B0X2RpbWVuc2lvbiAhPT0gdW5kZWZpbmVkID8gb3B0X2RpbWVuc2lvbiA6IDI7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvcHRfb3V0cHV0ICE9PSB1bmRlZmluZWQgPyBvcHRfb3V0cHV0IDogbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBjb29yZFRyYW5zZm9ybShbaW5wdXRbaV0sIGlucHV0W2kgKyAxXV0pO1xuICAgICAgICBvdXRwdXRbaV0gPSBwb2ludFswXTtcbiAgICAgICAgb3V0cHV0W2kgKyAxXSA9IHBvaW50WzFdO1xuICAgICAgICBmb3IgKGxldCBqID0gZGltZW5zaW9uIC0gMTsgaiA+PSAyOyAtLWopIHtcbiAgICAgICAgICBvdXRwdXRbaSArIGpdID0gaW5wdXRbaSArIGpdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGNvb3JkaW5hdGUgdHJhbnNmb3JtIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGJldHdlZW4gdGhlXG4gKiBzb3VyY2UgcHJvamVjdGlvbiBhbmQgdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBUaGUgZm9yd2FyZCBhbmQgaW52ZXJzZSBmdW5jdGlvbnMgY29udmVydCBjb29yZGluYXRlIHBhaXJzOyB0aGlzIGZ1bmN0aW9uXG4gKiBjb252ZXJ0cyB0aGVzZSBpbnRvIHRoZSBmdW5jdGlvbnMgdXNlZCBpbnRlcm5hbGx5IHdoaWNoIGFsc28gaGFuZGxlXG4gKiBleHRlbnRzIGFuZCBjb29yZGluYXRlIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTogbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gZm9yd2FyZCBUaGUgZm9yd2FyZCB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBpbnZlcnNlIFRoZSBpbnZlcnNlIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHRvIHRoZSBzb3VyY2VcbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zKHNvdXJjZSwgZGVzdGluYXRpb24sIGZvcndhcmQsIGludmVyc2UpIHtcbiAgY29uc3Qgc291cmNlUHJvaiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0UHJvaiA9IGdldChkZXN0aW5hdGlvbik7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoc291cmNlUHJvaiwgZGVzdFByb2osIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGZvcndhcmQpKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhkZXN0UHJvaiwgc291cmNlUHJvaiwgY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oaW52ZXJzZSkpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgZnJvbSBsb25naXR1ZGUvbGF0aXR1ZGUgdG8gYSBkaWZmZXJlbnQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS5cbiAqICAgICBhbiBhcnJheSB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZT19IG9wdF9wcm9qZWN0aW9uIFRhcmdldCBwcm9qZWN0aW9uLiBUaGVcbiAqICAgICBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgcHJvamVjdGVkIHRvIHRoZSB0YXJnZXQgcHJvamVjdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Mb25MYXQoY29vcmRpbmF0ZSwgb3B0X3Byb2plY3Rpb24pIHtcbiAgcmV0dXJuIHRyYW5zZm9ybShjb29yZGluYXRlLCAnRVBTRzo0MzI2JyxcbiAgICBvcHRfcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0X3Byb2plY3Rpb24gOiAnRVBTRzozODU3Jyk7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSB0byBsb25naXR1ZGUvbGF0aXR1ZGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgUHJvamVjdGVkIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlPX0gb3B0X3Byb2plY3Rpb24gUHJvamVjdGlvbiBvZiB0aGUgY29vcmRpbmF0ZS5cbiAqICAgICBUaGUgZGVmYXVsdCBpcyBXZWIgTWVyY2F0b3IsIGkuZS4gJ0VQU0c6Mzg1NycuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS4gYW4gYXJyYXlcbiAqICAgICB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Mb25MYXQoY29vcmRpbmF0ZSwgb3B0X3Byb2plY3Rpb24pIHtcbiAgY29uc3QgbG9uTGF0ID0gdHJhbnNmb3JtKGNvb3JkaW5hdGUsXG4gICAgb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycsICdFUFNHOjQzMjYnKTtcbiAgY29uc3QgbG9uID0gbG9uTGF0WzBdO1xuICBpZiAobG9uIDwgLTE4MCB8fCBsb24gPiAxODApIHtcbiAgICBsb25MYXRbMF0gPSBtb2R1bG8obG9uICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIHJldHVybiBsb25MYXQ7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHByb2plY3Rpb25zIGFyZSB0aGUgc2FtZSwgdGhhdCBpcyBldmVyeSBjb29yZGluYXRlIGluIG9uZVxuICogcHJvamVjdGlvbiBkb2VzIHJlcHJlc2VudCB0aGUgc2FtZSBnZW9ncmFwaGljIHBvaW50IGFzIHRoZSBzYW1lIGNvb3JkaW5hdGUgaW5cbiAqIHRoZSBvdGhlciBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbjEgUHJvamVjdGlvbiAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uMiBQcm9qZWN0aW9uIDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1aXZhbGVudChwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpIHtcbiAgaWYgKHByb2plY3Rpb24xID09PSBwcm9qZWN0aW9uMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGVxdWFsVW5pdHMgPSBwcm9qZWN0aW9uMS5nZXRVbml0cygpID09PSBwcm9qZWN0aW9uMi5nZXRVbml0cygpO1xuICBpZiAocHJvamVjdGlvbjEuZ2V0Q29kZSgpID09PSBwcm9qZWN0aW9uMi5nZXRDb2RlKCkpIHtcbiAgICByZXR1cm4gZXF1YWxVbml0cztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMik7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMgPT09IGNsb25lVHJhbnNmb3JtICYmIGVxdWFsVW5pdHM7XG4gIH1cbn1cblxuXG4vKipcbiAqIFNlYXJjaGVzIGluIHRoZSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgZm9yIHRoZSBmdW5jdGlvbiBmb3IgY29udmVydGluZ1xuICogY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBQcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIFByb2plY3Rpb25cbiAqICAgICBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGxldCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnVuYyhzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpO1xuICBpZiAoIXRyYW5zZm9ybUZ1bmMpIHtcbiAgICB0cmFuc2Zvcm1GdW5jID0gaWRlbnRpdHlUcmFuc2Zvcm07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmM7XG59XG5cblxuLyoqXG4gKiBHaXZlbiB0aGUgcHJvamVjdGlvbi1saWtlIG9iamVjdHMsIHNlYXJjaGVzIGZvciBhIHRyYW5zZm9ybWF0aW9uXG4gKiBmdW5jdGlvbiB0byBjb252ZXJ0IGEgY29vcmRpbmF0ZXMgYXJyYXkgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCBzb3VyY2VQcm9qZWN0aW9uID0gZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uUHJvamVjdGlvbiA9IGdldChkZXN0aW5hdGlvbik7XG4gIHJldHVybiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoaXMgcmV0dXJucyBhIG5ldyBjb29yZGluYXRlIChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan50cmFuc2Zvcm1FeHRlbnR9IGZvciBleHRlbnQgdHJhbnNmb3JtYXRpb24uXG4gKiBTZWUgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBhbmQgaXRzXG4gKiBzdWJjbGFzc2VzIGZvciBnZW9tZXRyeSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMoY29vcmRpbmF0ZSwgdW5kZWZpbmVkLCBjb29yZGluYXRlLmxlbmd0aCk7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGV4dGVudCBmcm9tIHNvdXJjZSBwcm9qZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzXG4gKiByZXR1cm5zIGEgbmV3IGV4dGVudCAoYW5kIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwpLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IFRoZSB0cmFuc2Zvcm1lZCBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZ1bmMpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gcG9pbnQgdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBwb2ludCBQb2ludC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gc291cmNlUHJvamVjdGlvbiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBQb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVdpdGhQcm9qZWN0aW9ucyhwb2ludCwgc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMocG9pbnQpO1xufVxuXG4vKipcbiAqIEFkZCB0cmFuc2Zvcm1zIHRvIGFuZCBmcm9tIEVQU0c6NDMyNiBhbmQgRVBTRzozODU3LiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAqIGJ5IHdoZW4gdGhpcyBtb2R1bGUgaXMgZXhlY3V0ZWQgYW5kIHNob3VsZCBvbmx5IG5lZWQgdG8gYmUgY2FsbGVkIGFnYWluIGFmdGVyXG4gKiBgY2xlYXJBbGxQcm9qZWN0aW9ucygpYCBpcyBjYWxsZWQgKGUuZy4gaW4gdGVzdHMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29tbW9uKCkge1xuICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zIHRoYXQgZG9uJ3QgYWx0ZXIgY29vcmRpbmF0ZXMgdG8gY29udmVydCB3aXRoaW4gc2V0IG9mXG4gIC8vIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0czODU3X1BST0pFQ1RJT05TKTtcbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0c0MzI2X1BST0pFQ1RJT05TKTtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0byBjb252ZXJ0IEVQU0c6NDMyNiBsaWtlIGNvb3JkaW5hdGVzIHRvIEVQU0c6Mzg1NyBsaWtlXG4gIC8vIGNvb3JkaW5hdGVzIGFuZCBiYWNrLlxuICBhZGRFcXVpdmFsZW50VHJhbnNmb3JtcyhFUFNHNDMyNl9QUk9KRUNUSU9OUywgRVBTRzM4NTdfUFJPSkVDVElPTlMsIGZyb21FUFNHNDMyNiwgdG9FUFNHNDMyNik7XG59XG5cbmFkZENvbW1vbigpO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovUHJvamVjdGlvblxuICovXG5pbXBvcnQge01FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi4vcHJvai9Vbml0cy5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29kZSBUaGUgU1JTIGlkZW50aWZpZXIgY29kZSwgZS5nLiBgRVBTRzo0MzI2YC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3Byb2ovVW5pdHN8c3RyaW5nfSBbdW5pdHNdIFVuaXRzLiBSZXF1aXJlZCB1bmxlc3MgYVxuICogcHJvajQgcHJvamVjdGlvbiBpcyBkZWZpbmVkIGZvciBgY29kZWAuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XSBUaGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtheGlzT3JpZW50YXRpb249J2VudSddIFRoZSBheGlzIG9yaWVudGF0aW9uIGFzIHNwZWNpZmllZCBpbiBQcm9qNC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dsb2JhbD1mYWxzZV0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZCBmb3IgdGhlIHdob2xlIGdsb2JlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttZXRlcnNQZXJVbml0XSBUaGUgbWV0ZXJzIHBlciB1bml0IGZvciB0aGUgU1JTLlxuICogSWYgbm90IHByb3ZpZGVkLCB0aGUgYHVuaXRzYCBhcmUgdXNlZCB0byBnZXQgdGhlIG1ldGVycyBwZXIgdW5pdCBmcm9tIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovVW5pdHN+TUVURVJTX1BFUl9VTklUfVxuICogbG9va3VwIHRhYmxlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW3dvcmxkRXh0ZW50XSBUaGUgd29ybGQgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihudW1iZXIsIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOm51bWJlcn0gW2dldFBvaW50UmVzb2x1dGlvbl1cbiAqIEZ1bmN0aW9uIHRvIGRldGVybWluZSByZXNvbHV0aW9uIGF0IGEgcG9pbnQuIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gKiBge251bWJlcn1gIHZpZXcgcmVzb2x1dGlvbiBhbmQgYW4gYHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfWAgYXMgYXJndW1lbnRzLCBhbmQgcmV0dXJuc1xuICogdGhlIGB7bnVtYmVyfWAgcmVzb2x1dGlvbiBhdCB0aGUgcGFzc2VkIGNvb3JkaW5hdGUuIElmIHRoaXMgaXMgYHVuZGVmaW5lZGAsXG4gKiB0aGUgZGVmYXVsdCB7QGxpbmsgbW9kdWxlOm9sL3Byb2ojZ2V0UG9pbnRSZXNvbHV0aW9ufSBmdW5jdGlvbiB3aWxsIGJlIHVzZWQuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gZGVmaW5pdGlvbiBjbGFzcy4gT25lIG9mIHRoZXNlIGlzIGNyZWF0ZWQgZm9yIGVhY2ggcHJvamVjdGlvblxuICogc3VwcG9ydGVkIGluIHRoZSBhcHBsaWNhdGlvbiBhbmQgc3RvcmVkIGluIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p9IG5hbWVzcGFjZS5cbiAqIFlvdSBjYW4gdXNlIHRoZXNlIGluIGFwcGxpY2F0aW9ucywgYnV0IHRoaXMgaXMgbm90IHJlcXVpcmVkLCBhcyBBUEkgcGFyYW1zXG4gKiBhbmQgb3B0aW9ucyB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSB3aGljaCBtZWFucyB0aGUgc2ltcGxlIHN0cmluZ1xuICogY29kZSB3aWxsIHN1ZmZpY2UuXG4gKlxuICogWW91IGNhbiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmdldH0gdG8gcmV0cmlldmUgdGhlIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyXG4gKiBwcm9qZWN0aW9uLlxuICpcbiAqIFRoZSBsaWJyYXJ5IGluY2x1ZGVzIGRlZmluaXRpb25zIGZvciBgRVBTRzo0MzI2YCBhbmQgYEVQU0c6Mzg1N2AsIHRvZ2V0aGVyXG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgYWxpYXNlczpcbiAqICogYEVQU0c6NDMyNmA6IENSUzo4NCwgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni42OjQzMjYsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQsIHVybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCxcbiAqICAgICBodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNixcbiAqICAgICB1cm46eC1vZ2M6ZGVmOmNyczpFUFNHOjQzMjZcbiAqICogYEVQU0c6Mzg1N2A6IEVQU0c6MTAyMTAwLCBFUFNHOjEwMjExMywgRVBTRzo5MDA5MTMsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni4xODozOjM4NTcsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTdcbiAqXG4gKiBJZiB5b3UgdXNlIHByb2o0anMsIGFsaWFzZXMgY2FuIGJlIGFkZGVkIHVzaW5nIGBwcm9qNC5kZWZzKClgOyBzZWVcbiAqIFtkb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzKS4gVG8gc2V0IGFuIGFsdGVybmF0aXZlXG4gKiBuYW1lc3BhY2UgZm9yIHByb2o0LCB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qfnNldFByb2o0fS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5PcHRpb25zfSBvcHRpb25zIFByb2plY3Rpb24gb3B0aW9ucy5cbiAqIEBzdHJ1Y3RcbiAqIEBhcGlcbiAqL1xuY29uc3QgUHJvamVjdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLmNvZGVfID0gb3B0aW9ucy5jb2RlO1xuXG4gIC8qKlxuICAgKiBVbml0cyBvZiBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMuIFdoZW4gc2V0IHRvIGBUSUxFX1BJWEVMU2AsIGFcbiAgICogYHRoaXMuZXh0ZW50X2AgYW5kIGB0aGlzLndvcmxkRXh0ZW50X2AgbXVzdCBiZSBjb25maWd1cmVkIHByb3Blcmx5IGZvciBlYWNoXG4gICAqIHRpbGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvcHJvai9Vbml0c31cbiAgICovXG4gIHRoaXMudW5pdHNfID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvcHJvai9Vbml0c30gKi8gKG9wdGlvbnMudW5pdHMpO1xuXG4gIC8qKlxuICAgKiBWYWxpZGl0eSBleHRlbnQgb2YgdGhlIHByb2plY3Rpb24gaW4gcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBGb3IgcHJvamVjdGlvbnNcbiAgICogd2l0aCBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICogdGlsZSBwaXhlbCBzcGFjZS5cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgKi9cbiAgdGhpcy5leHRlbnRfID0gb3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0ZW50IDogbnVsbDtcblxuICAvKipcbiAgICogRXh0ZW50IG9mIHRoZSB3b3JsZCBpbiBFUFNHOjQzMjYuIEZvciBwcm9qZWN0aW9ucyB3aXRoXG4gICAqIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgKiBwcm9qZWN0ZWQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgKi9cbiAgdGhpcy53b3JsZEV4dGVudF8gPSBvcHRpb25zLndvcmxkRXh0ZW50ICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMud29ybGRFeHRlbnQgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5heGlzT3JpZW50YXRpb25fID0gb3B0aW9ucy5heGlzT3JpZW50YXRpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5heGlzT3JpZW50YXRpb24gOiAnZW51JztcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmdsb2JhbF8gPSBvcHRpb25zLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nbG9iYWwgOiBmYWxzZTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiB0aGlzLmV4dGVudF8pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IG9wdGlvbnMuZ2V0UG9pbnRSZXNvbHV0aW9uO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfVxuICAgKi9cbiAgdGhpcy5kZWZhdWx0VGlsZUdyaWRfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLm1ldGVyc1BlclVuaXRfID0gb3B0aW9ucy5tZXRlcnNQZXJVbml0O1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBwcm9qZWN0aW9uIGlzIHN1aXRhYmxlIGZvciB3cmFwcGluZyB0aGUgeC1heGlzXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmNhbldyYXBYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNhbldyYXBYXztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgZm9yIHRoaXMgcHJvamVjdGlvbiwgZS5nLiAnRVBTRzo0MzI2Jy5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29kZS5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0Q29kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb2RlXztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmV4dGVudF87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB1bml0cyBvZiB0aGlzIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Vbml0c30gVW5pdHMuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldFVuaXRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnVuaXRzXztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGFtb3VudCBvZiBtZXRlcnMgcGVyIHVuaXQgb2YgdGhpcyBwcm9qZWN0aW9uLiAgSWYgdGhlIHByb2plY3Rpb24gaXNcbiAqIG5vdCBjb25maWd1cmVkIHdpdGggYG1ldGVyc1BlclVuaXRgIG9yIGEgdW5pdHMgaWRlbnRpZmllciwgdGhlIHJldHVybiBpc1xuICogYHVuZGVmaW5lZGAuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNZXRlcnMuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldE1ldGVyc1BlclVuaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWV0ZXJzUGVyVW5pdF8gfHwgTUVURVJTX1BFUl9VTklUW3RoaXMudW5pdHNfXTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0V29ybGRFeHRlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud29ybGRFeHRlbnRfO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgYXhpcyBvcmllbnRhdGlvbiBvZiB0aGlzIHByb2plY3Rpb24uXG4gKiBFeGFtcGxlIHZhbHVlcyBhcmU6XG4gKiBlbnUgLSB0aGUgZGVmYXVsdCBlYXN0aW5nLCBub3J0aGluZywgZWxldmF0aW9uLlxuICogbmV1IC0gbm9ydGhpbmcsIGVhc3RpbmcsIHVwIC0gdXNlZnVsIGZvciBcImxhdC9sb25nXCIgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyxcbiAqICAgICBvciBzb3V0aCBvcmllbnRhdGVkIHRyYW5zdmVyc2UgbWVyY2F0b3IuXG4gKiB3bnUgLSB3ZXN0aW5nLCBub3J0aGluZywgdXAgLSBzb21lIHBsYW5ldGFyeSBjb29yZGluYXRlIHN5c3RlbXMgaGF2ZVxuICogICAgIFwid2VzdCBwb3NpdGl2ZVwiIGNvb3JkaW5hdGUgc3lzdGVtc1xuICogQHJldHVybiB7c3RyaW5nfSBBeGlzIG9yaWVudGF0aW9uLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRBeGlzT3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYXhpc09yaWVudGF0aW9uXztcbn07XG5cblxuLyoqXG4gKiBJcyB0aGlzIHByb2plY3Rpb24gYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGQ/XG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIGdsb2JhbC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuaXNHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ2xvYmFsXztcbn07XG5cblxuLyoqXG4qIFNldCBpZiB0aGUgcHJvamVjdGlvbiBpcyBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZFxuKiBAcGFyYW0ge2Jvb2xlYW59IGdsb2JhbCBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIGdsb2JhbC5cbiogQGFwaVxuKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldEdsb2JhbCA9IGZ1bmN0aW9uKGdsb2JhbCkge1xuICB0aGlzLmdsb2JhbF8gPSBnbG9iYWw7XG4gIHRoaXMuY2FuV3JhcFhfID0gISEoZ2xvYmFsICYmIHRoaXMuZXh0ZW50Xyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldERlZmF1bHRUaWxlR3JpZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kZWZhdWx0VGlsZUdyaWRfO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSB0aWxlR3JpZCBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldERlZmF1bHRUaWxlR3JpZCA9IGZ1bmN0aW9uKHRpbGVHcmlkKSB7XG4gIHRoaXMuZGVmYXVsdFRpbGVHcmlkXyA9IHRpbGVHcmlkO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQpIHtcbiAgdGhpcy5leHRlbnRfID0gZXh0ZW50O1xuICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiBleHRlbnQpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgd29ybGQgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSB3b3JsZEV4dGVudCBXb3JsZCBleHRlbnRcbiAqICAgICBbbWlubG9uLCBtaW5sYXQsIG1heGxvbiwgbWF4bGF0XS5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuc2V0V29ybGRFeHRlbnQgPSBmdW5jdGlvbih3b3JsZEV4dGVudCkge1xuICB0aGlzLndvcmxkRXh0ZW50XyA9IHdvcmxkRXh0ZW50O1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgZ2V0UG9pbnRSZXNvbHV0aW9uIGZ1bmN0aW9uIChzZWUge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmdldFBvaW50UmVzb2x1dGlvbn1cbiAqIGZvciB0aGlzIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6bnVtYmVyfSBmdW5jIEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldEdldFBvaW50UmVzb2x1dGlvbiA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IGZ1bmM7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBjdXN0b20gcG9pbnQgcmVzb2x1dGlvbiBmdW5jdGlvbiBmb3IgdGhpcyBwcm9qZWN0aW9uIChpZiBzZXQpLlxuICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfSBUaGUgY3VzdG9tIHBvaW50XG4gKiByZXNvbHV0aW9uIGZ1bmN0aW9uIChpZiBzZXQpLlxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRQb2ludFJlc29sdXRpb25GdW5jID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdldFBvaW50UmVzb2x1dGlvbkZ1bmNfO1xufTtcbmV4cG9ydCBkZWZhdWx0IFByb2plY3Rpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9Vbml0c1xuICovXG5cbi8qKlxuICogUHJvamVjdGlvbiB1bml0czogYCdkZWdyZWVzJ2AsIGAnZnQnYCwgYCdtJ2AsIGAncGl4ZWxzJ2AsIGAndGlsZS1waXhlbHMnYCBvclxuICogYCd1cy1mdCdgLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVW5pdHMgPSB7XG4gIERFR1JFRVM6ICdkZWdyZWVzJyxcbiAgRkVFVDogJ2Z0JyxcbiAgTUVURVJTOiAnbScsXG4gIFBJWEVMUzogJ3BpeGVscycsXG4gIFRJTEVfUElYRUxTOiAndGlsZS1waXhlbHMnLFxuICBVU0ZFRVQ6ICd1cy1mdCdcbn07XG5cblxuLyoqXG4gKiBNZXRlcnMgcGVyIHVuaXQgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0Ljxtb2R1bGU6b2wvcHJvai9Vbml0cywgbnVtYmVyPn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IHt9O1xuLy8gdXNlIHRoZSByYWRpdXMgb2YgdGhlIE5vcm1hbCBzcGhlcmVcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5ERUdSRUVTXSA9IDIgKiBNYXRoLlBJICogNjM3MDk5NyAvIDM2MDtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5GRUVUXSA9IDAuMzA0ODtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5NRVRFUlNdID0gMTtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5VU0ZFRVRdID0gMTIwMCAvIDM5Mzc7XG5cbmV4cG9ydCBkZWZhdWx0IFVuaXRzO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovZXBzZzM4NTdcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IHtjb3NofSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4uL3Byb2ovUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi4vcHJvai9Vbml0cy5qcyc7XG5cblxuLyoqXG4gKiBSYWRpdXMgb2YgV0dTODQgc3BoZXJlXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgUkFESVVTID0gNjM3ODEzNztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEhBTEZfU0laRSA9IE1hdGguUEkgKiBSQURJVVM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVYVEVOVCA9IFtcbiAgLUhBTEZfU0laRSwgLUhBTEZfU0laRSxcbiAgSEFMRl9TSVpFLCBIQUxGX1NJWkVcbl07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IFdPUkxEX0VYVEVOVCA9IFstMTgwLCAtODUsIDE4MCwgODVdO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIHdlYi9zcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIENvZGUuXG4gKi9cbmZ1bmN0aW9uIEVQU0czODU3UHJvamVjdGlvbihjb2RlKSB7XG4gIFByb2plY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgY29kZTogY29kZSxcbiAgICB1bml0czogVW5pdHMuTUVURVJTLFxuICAgIGV4dGVudDogRVhURU5ULFxuICAgIGdsb2JhbDogdHJ1ZSxcbiAgICB3b3JsZEV4dGVudDogV09STERfRVhURU5ULFxuICAgIGdldFBvaW50UmVzb2x1dGlvbjogZnVuY3Rpb24ocmVzb2x1dGlvbiwgcG9pbnQpIHtcbiAgICAgIHJldHVybiByZXNvbHV0aW9uIC8gY29zaChwb2ludFsxXSAvIFJBRElVUyk7XG4gICAgfVxuICB9KTtcbn1cbmluaGVyaXRzKEVQU0czODU3UHJvamVjdGlvbiwgUHJvamVjdGlvbik7XG5cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjM4NTcuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fVxuICovXG5leHBvcnQgY29uc3QgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjEwMCcpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjExMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjkwMDkxMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6RVBTRzo2LjE4OjM6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6RVBTRzo6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjMzg1NycpXG5dO1xuXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjQzMjYgdG8gRVBTRzozODU3LlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGltZW5zaW9uIERpbWVuc2lvbiAoZGVmYXVsdCBpcyBgMmApLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FUFNHNDMyNihpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IG9wdF9kaW1lbnNpb24gPiAxID8gb3B0X2RpbWVuc2lvbiA6IDI7XG4gIGxldCBvdXRwdXQgPSBvcHRfb3V0cHV0O1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFsZlNpemUgPSBIQUxGX1NJWkU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgIG91dHB1dFtpXSA9IGhhbGZTaXplICogaW5wdXRbaV0gLyAxODA7XG4gICAgbGV0IHkgPSBSQURJVVMgKlxuICAgICAgICBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJICogKGlucHV0W2kgKyAxXSArIDkwKSAvIDM2MCkpO1xuICAgIGlmICh5ID4gaGFsZlNpemUpIHtcbiAgICAgIHkgPSBoYWxmU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHkgPCAtaGFsZlNpemUpIHtcbiAgICAgIHkgPSAtaGFsZlNpemU7XG4gICAgfVxuICAgIG91dHB1dFtpICsgMV0gPSB5O1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBmcm9tIEVQU0c6Mzg1NyB0byBFUFNHOjQzMjYuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9FUFNHNDMyNihpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IG9wdF9kaW1lbnNpb24gPiAxID8gb3B0X2RpbWVuc2lvbiA6IDI7XG4gIGxldCBvdXRwdXQgPSBvcHRfb3V0cHV0O1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgb3V0cHV0W2ldID0gMTgwICogaW5wdXRbaV0gLyBIQUxGX1NJWkU7XG4gICAgb3V0cHV0W2kgKyAxXSA9IDM2MCAqIE1hdGguYXRhbihcbiAgICAgIE1hdGguZXhwKGlucHV0W2kgKyAxXSAvIFJBRElVUykpIC8gTWF0aC5QSSAtIDkwO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnNDMyNlxuICovXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuLi9wcm9qL1Byb2plY3Rpb24uanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4uL3Byb2ovVW5pdHMuanMnO1xuXG5cbi8qKlxuICogU2VtaS1tYWpvciByYWRpdXMgb2YgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG5cbi8qKlxuICogRXh0ZW50IG9mIHRoZSBFUFNHOjQzMjYgcHJvamVjdGlvbiB3aGljaCBpcyB0aGUgd2hvbGUgd29ybGQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbLTE4MCwgLTkwLCAxODAsIDkwXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IE1hdGguUEkgKiBSQURJVVMgLyAxODA7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIG9iamVjdCBmb3IgV0dTODQgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyAoRVBTRzo0MzI2KS5cbiAqXG4gKiBOb3RlIHRoYXQgT3BlbkxheWVycyBkb2VzIG5vdCBzdHJpY3RseSBjb21wbHkgd2l0aCB0aGUgRVBTRyBkZWZpbml0aW9uLlxuICogVGhlIEVQU0cgcmVnaXN0cnkgZGVmaW5lcyA0MzI2IGFzIGEgQ1JTIGZvciBMYXRpdHVkZSxMb25naXR1ZGUgKHkseCkuXG4gKiBPcGVuTGF5ZXJzIHRyZWF0cyBFUFNHOjQzMjYgYXMgYSBwc2V1ZG8tcHJvamVjdGlvbiwgd2l0aCB4LHkgY29vcmRpbmF0ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIENvZGUuXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9heGlzT3JpZW50YXRpb24gQXhpcyBvcmllbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gRVBTRzQzMjZQcm9qZWN0aW9uKGNvZGUsIG9wdF9heGlzT3JpZW50YXRpb24pIHtcbiAgUHJvamVjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICBjb2RlOiBjb2RlLFxuICAgIHVuaXRzOiBVbml0cy5ERUdSRUVTLFxuICAgIGV4dGVudDogRVhURU5ULFxuICAgIGF4aXNPcmllbnRhdGlvbjogb3B0X2F4aXNPcmllbnRhdGlvbixcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgbWV0ZXJzUGVyVW5pdDogTUVURVJTX1BFUl9VTklULFxuICAgIHdvcmxkRXh0ZW50OiBFWFRFTlRcbiAgfSk7XG59XG5pbmhlcml0cyhFUFNHNDMyNlByb2plY3Rpb24sIFByb2plY3Rpb24pO1xuXG5cbi8qKlxuICogUHJvamVjdGlvbnMgZXF1YWwgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBST0pFQ1RJT05TID0gW1xuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdDUlM6ODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignRVBTRzo0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6RVBTRzo6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni42OjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOngtb2djOmRlZjpjcnM6RVBTRzo0MzI2JywgJ25ldScpXG5dO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovcHJvamVjdGlvbnNcbiAqL1xuXG5cbi8qKlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPn1cbiAqL1xubGV0IGNhY2hlID0ge307XG5cblxuLyoqXG4gKiBDbGVhciB0aGUgcHJvamVjdGlvbnMgY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgY2FjaGUgPSB7fTtcbn1cblxuXG4vKipcbiAqIEdldCBhIGNhY2hlZCBwcm9qZWN0aW9uIGJ5IGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBUaGUgY29kZSBmb3IgdGhlIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBUaGUgcHJvamVjdGlvbiAoaWYgY2FjaGVkKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChjb2RlKSB7XG4gIHJldHVybiBjYWNoZVtjb2RlXSB8fCBudWxsO1xufVxuXG5cbi8qKlxuICogQWRkIGEgcHJvamVjdGlvbiB0byB0aGUgY2FjaGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBUaGUgcHJvamVjdGlvbiBjb2RlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uIHRvIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvZGUsIHByb2plY3Rpb24pIHtcbiAgY2FjaGVbY29kZV0gPSBwcm9qZWN0aW9uO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovdHJhbnNmb3Jtc1xuICovXG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uL29iai5qcyc7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9uPj59XG4gKi9cbmxldCB0cmFuc2Zvcm1zID0ge307XG5cblxuLyoqXG4gKiBDbGVhciB0aGUgdHJhbnNmb3JtIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIHRyYW5zZm9ybXMgPSB7fTtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gdG8gY29udmVydCBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChzb3VyY2UsIGRlc3RpbmF0aW9uLCB0cmFuc2Zvcm1Gbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgY29uc3QgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICBpZiAoIShzb3VyY2VDb2RlIGluIHRyYW5zZm9ybXMpKSB7XG4gICAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSA9IHt9O1xuICB9XG4gIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXSA9IHRyYW5zZm9ybUZuO1xufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgdGhlIGNvbnZlcnNpb24gZnVuY3Rpb24gdG8gY29udmVydCBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNsZWFuIHVwXG4gKiBjYWNoZWQgdHJhbnNmb3JtcyBkdXJpbmcgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUaGUgdW5yZWdpc3RlcmVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgaWYgKGlzRW1wdHkodHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkpIHtcbiAgICBkZWxldGUgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbi8qKlxuICogR2V0IGEgdHJhbnNmb3JtIGdpdmVuIGEgc291cmNlIGNvZGUgYW5kIGEgZGVzdGluYXRpb24gY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VDb2RlIFRoZSBjb2RlIGZvciB0aGUgc291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25Db2RlIFRoZSBjb2RlIGZvciB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufHVuZGVmaW5lZH0gVGhlIHRyYW5zZm9ybSBmdW5jdGlvbiAoaWYgZm91bmQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHNvdXJjZUNvZGUsIGRlc3RpbmF0aW9uQ29kZSkge1xuICBsZXQgdHJhbnNmb3JtO1xuICBpZiAoc291cmNlQ29kZSBpbiB0cmFuc2Zvcm1zICYmIGRlc3RpbmF0aW9uQ29kZSBpbiB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdKSB7XG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qXG4gKi9cbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zQ29vcmRpbmF0ZSwgY3JlYXRlRW1wdHksIGV4dGVuZCwgZ2V0SGVpZ2h0LCBnZXRUb3BMZWZ0LCBnZXRXaWR0aH0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtzb2x2ZUxpbmVhclN5c3RlbX0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7Z2V0UG9pbnRSZXNvbHV0aW9uLCB0cmFuc2Zvcm19IGZyb20gJy4vcHJvai5qcyc7XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGlkZWFsIHJlc29sdXRpb24gdG8gdXNlIGZyb20gdGhlIHNvdXJjZSBpbiBvcmRlciB0byBhY2hpZXZlXG4gKiBwaXhlbCBtYXBwaW5nIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIDE6MSBkdXJpbmcgcmVwcm9qZWN0aW9uLlxuICogVGhlIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZCByZWdhcmRsZXNzIG9mIHdoYXQgcmVzb2x1dGlvbnNcbiAqIGFyZSBhY3R1YWxseSBhdmFpbGFibGUgaW4gdGhlIGRhdGFzZXQgKFRpbGVHcmlkLCBJbWFnZSwgLi4uKS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHRhcmdldENlbnRlciBUYXJnZXQgY2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiZXN0IHJlc29sdXRpb24gdG8gdXNlLiBDYW4gYmUgKy1JbmZpbml0eSwgTmFOIG9yIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKHNvdXJjZVByb2osIHRhcmdldFByb2osXG4gIHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbikge1xuXG4gIGNvbnN0IHNvdXJjZUNlbnRlciA9IHRyYW5zZm9ybSh0YXJnZXRDZW50ZXIsIHRhcmdldFByb2osIHNvdXJjZVByb2opO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgaWRlYWwgcmVzb2x1dGlvbiBvZiB0aGUgc291cmNlIGRhdGFcbiAgbGV0IHNvdXJjZVJlc29sdXRpb24gPSBnZXRQb2ludFJlc29sdXRpb24odGFyZ2V0UHJvaiwgdGFyZ2V0UmVzb2x1dGlvbiwgdGFyZ2V0Q2VudGVyKTtcblxuICBjb25zdCB0YXJnZXRNZXRlcnNQZXJVbml0ID0gdGFyZ2V0UHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmICh0YXJnZXRNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uICo9IHRhcmdldE1ldGVyc1BlclVuaXQ7XG4gIH1cbiAgY29uc3Qgc291cmNlTWV0ZXJzUGVyVW5pdCA9IHNvdXJjZVByb2ouZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICBpZiAoc291cmNlTWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlUmVzb2x1dGlvbiAvPSBzb3VyY2VNZXRlcnNQZXJVbml0O1xuICB9XG5cbiAgLy8gQmFzZWQgb24gdGhlIHByb2plY3Rpb24gcHJvcGVydGllcywgdGhlIHBvaW50IHJlc29sdXRpb24gYXQgdGhlIHNwZWNpZmllZFxuICAvLyBjb29yZGluYXRlcyBtYXkgYmUgc2xpZ2h0bHkgZGlmZmVyZW50LiBXZSBuZWVkIHRvIHJldmVyc2UtY29tcGVuc2F0ZSB0aGlzXG4gIC8vIGluIG9yZGVyIHRvIGFjaGlldmUgb3B0aW1hbCByZXN1bHRzLlxuXG4gIGNvbnN0IHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gIGlmICghc291cmNlRXh0ZW50IHx8IGNvbnRhaW5zQ29vcmRpbmF0ZShzb3VyY2VFeHRlbnQsIHNvdXJjZUNlbnRlcikpIHtcbiAgICBjb25zdCBjb21wZW5zYXRpb25GYWN0b3IgPSBnZXRQb2ludFJlc29sdXRpb24oc291cmNlUHJvaiwgc291cmNlUmVzb2x1dGlvbiwgc291cmNlQ2VudGVyKSAvXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb247XG4gICAgaWYgKGlzRmluaXRlKGNvbXBlbnNhdGlvbkZhY3RvcikgJiYgY29tcGVuc2F0aW9uRmFjdG9yID4gMCkge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiAvPSBjb21wZW5zYXRpb25GYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVJlc29sdXRpb247XG59XG5cblxuLyoqXG4gKiBFbmxhcmdlIHRoZSBjbGlwcGluZyB0cmlhbmdsZSBwb2ludCBieSAxIHBpeGVsIHRvIGVuc3VyZSB0aGUgZWRnZXMgb3ZlcmxhcFxuICogaW4gb3JkZXIgdG8gbWFzayBnYXBzIGNhdXNlZCBieSBhbnRpYWxpYXNpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWCBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHggY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWSBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHkgY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCAoaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgKGluIHBpeGVscykuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBOZXcgcG9pbnQgMSBweCBmYXJ0aGVyIGZyb20gdGhlIGNlbnRyb2lkLlxuICovXG5mdW5jdGlvbiBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB4LCB5KSB7XG4gIGNvbnN0IGRYID0geCAtIGNlbnRyb2lkWDtcbiAgY29uc3QgZFkgPSB5IC0gY2VudHJvaWRZO1xuICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG4gIHJldHVybiBbTWF0aC5yb3VuZCh4ICsgZFggLyBkaXN0YW5jZSksIE1hdGgucm91bmQoeSArIGRZIC8gZGlzdGFuY2UpXTtcbn1cblxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHNvdXJjZSBkYXRhIGludG8gbmV3IGNhbnZhcyBiYXNlZCBvbiB0aGUgdHJpYW5ndWxhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzb3VyY2VSZXNvbHV0aW9uIFNvdXJjZSByZXNvbHV0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gc291cmNlRXh0ZW50IEV4dGVudCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcmVwcm9qL1RyaWFuZ3VsYXRpb259IHRyaWFuZ3VsYXRpb25cbiAqIENhbGN1bGF0ZWQgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPHtleHRlbnQ6IG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50LFxuICogICAgICAgICAgICAgICAgIGltYWdlOiAoSFRNTENhbnZhc0VsZW1lbnR8SW1hZ2V8SFRNTFZpZGVvRWxlbWVudCl9Pn0gc291cmNlc1xuICogQXJyYXkgb2Ygc291cmNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2VzLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JlbmRlckVkZ2VzIFJlbmRlciByZXByb2plY3Rpb24gZWRnZXMuXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzIHdpdGggcmVwcm9qZWN0ZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvLFxuICBzb3VyY2VSZXNvbHV0aW9uLCBzb3VyY2VFeHRlbnQsIHRhcmdldFJlc29sdXRpb24sIHRhcmdldEV4dGVudCxcbiAgdHJpYW5ndWxhdGlvbiwgc291cmNlcywgZ3V0dGVyLCBvcHRfcmVuZGVyRWRnZXMpIHtcblxuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHdpZHRoKSxcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBoZWlnaHQpKTtcblxuICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29udGV4dC5jYW52YXM7XG4gIH1cblxuICBjb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG4gIGNvbnN0IHNvdXJjZURhdGFFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc3JjLCBpLCBhcnIpIHtcbiAgICBleHRlbmQoc291cmNlRGF0YUV4dGVudCwgc3JjLmV4dGVudCk7XG4gIH0pO1xuXG4gIGNvbnN0IGNhbnZhc1dpZHRoSW5Vbml0cyA9IGdldFdpZHRoKHNvdXJjZURhdGFFeHRlbnQpO1xuICBjb25zdCBjYW52YXNIZWlnaHRJblVuaXRzID0gZ2V0SGVpZ2h0KHNvdXJjZURhdGFFeHRlbnQpO1xuICBjb25zdCBzdGl0Y2hDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgIE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIGNhbnZhc1dpZHRoSW5Vbml0cyAvIHNvdXJjZVJlc29sdXRpb24pLFxuICAgIE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIGNhbnZhc0hlaWdodEluVW5pdHMgLyBzb3VyY2VSZXNvbHV0aW9uKSk7XG5cbiAgY29uc3Qgc3RpdGNoU2NhbGUgPSBwaXhlbFJhdGlvIC8gc291cmNlUmVzb2x1dGlvbjtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc3JjLCBpLCBhcnIpIHtcbiAgICBjb25zdCB4UG9zID0gc3JjLmV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF07XG4gICAgY29uc3QgeVBvcyA9IC0oc3JjLmV4dGVudFszXSAtIHNvdXJjZURhdGFFeHRlbnRbM10pO1xuICAgIGNvbnN0IHNyY1dpZHRoID0gZ2V0V2lkdGgoc3JjLmV4dGVudCk7XG4gICAgY29uc3Qgc3JjSGVpZ2h0ID0gZ2V0SGVpZ2h0KHNyYy5leHRlbnQpO1xuXG4gICAgc3RpdGNoQ29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBzcmMuaW1hZ2UsXG4gICAgICBndXR0ZXIsIGd1dHRlcixcbiAgICAgIHNyYy5pbWFnZS53aWR0aCAtIDIgKiBndXR0ZXIsIHNyYy5pbWFnZS5oZWlnaHQgLSAyICogZ3V0dGVyLFxuICAgICAgeFBvcyAqIHN0aXRjaFNjYWxlLCB5UG9zICogc3RpdGNoU2NhbGUsXG4gICAgICBzcmNXaWR0aCAqIHN0aXRjaFNjYWxlLCBzcmNIZWlnaHQgKiBzdGl0Y2hTY2FsZSk7XG4gIH0pO1xuXG4gIGNvbnN0IHRhcmdldFRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG5cbiAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAvKiBDYWxjdWxhdGUgYWZmaW5lIHRyYW5zZm9ybSAoc3JjIC0+IGRzdClcbiAgICAgKiBSZXN1bHRpbmcgbWF0cml4IGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZGluYXRlXG4gICAgICogZnJvbSBgc291cmNlUHJvamVjdGlvbmAgdG8gZGVzdGluYXRpb24gcGl4ZWxzLlxuICAgICAqXG4gICAgICogVG8gb3B0aW1pemUgbnVtYmVyIG9mIGNvbnRleHQgY2FsbHMgYW5kIGluY3JlYXNlIG51bWVyaWNhbCBzdGFiaWxpdHksXG4gICAgICogd2UgYWxzbyBkbyB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gICAgICogdHJhbnMoLXRvcExlZnRFeHRlbnRDb3JuZXIpLCBzY2FsZSgxIC8gdGFyZ2V0UmVzb2x1dGlvbiksIHNjYWxlKDEsIC0xKVxuICAgICAqIGhlcmUgYmVmb3JlIHNvbHZpbmcgdGhlIGxpbmVhciBzeXN0ZW0gc28gW3VpLCB2aV0gYXJlIHBpeGVsIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogU3JjIHBvaW50czogeGksIHlpXG4gICAgICogRHN0IHBvaW50czogdWksIHZpXG4gICAgICogQWZmaW5lIGNvZWZmaWNpZW50czogYWlqXG4gICAgICpcbiAgICAgKiB8IHgwIHkwIDEgIDAgIDAgMCB8ICAgfGEwMHwgICB8dTB8XG4gICAgICogfCB4MSB5MSAxICAwICAwIDAgfCAgIHxhMDF8ICAgfHUxfFxuICAgICAqIHwgeDIgeTIgMSAgMCAgMCAwIHwgeCB8YTAyfCA9IHx1MnxcbiAgICAgKiB8ICAwICAwIDAgeDAgeTAgMSB8ICAgfGExMHwgICB8djB8XG4gICAgICogfCAgMCAgMCAwIHgxIHkxIDEgfCAgIHxhMTF8ICAgfHYxfFxuICAgICAqIHwgIDAgIDAgMCB4MiB5MiAxIHwgICB8YTEyfCAgIHx2MnxcbiAgICAgKi9cbiAgICBjb25zdCBzb3VyY2UgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgY29uc3QgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgIGxldCB4MCA9IHNvdXJjZVswXVswXSwgeTAgPSBzb3VyY2VbMF1bMV07XG4gICAgbGV0IHgxID0gc291cmNlWzFdWzBdLCB5MSA9IHNvdXJjZVsxXVsxXTtcbiAgICBsZXQgeDIgPSBzb3VyY2VbMl1bMF0sIHkyID0gc291cmNlWzJdWzFdO1xuICAgIGNvbnN0IHUwID0gKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICBjb25zdCB2MCA9IC0odGFyZ2V0WzBdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIGNvbnN0IHUxID0gKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICBjb25zdCB2MSA9IC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIGNvbnN0IHUyID0gKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICBjb25zdCB2MiA9IC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuXG4gICAgLy8gU2hpZnQgYWxsIHRoZSBzb3VyY2UgcG9pbnRzIHRvIGltcHJvdmUgbnVtZXJpY2FsIHN0YWJpbGl0eVxuICAgIC8vIG9mIGFsbCB0aGUgc3Vic2VxdWVudCBjYWxjdWxhdGlvbnMuIFRoZSBbeDAsIHkwXSBpcyB1c2VkIGhlcmUuXG4gICAgLy8gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2ltcGxpZnkgdGhlIGxpbmVhciBzeXN0ZW0uXG4gICAgY29uc3Qgc291cmNlTnVtZXJpY2FsU2hpZnRYID0geDA7XG4gICAgY29uc3Qgc291cmNlTnVtZXJpY2FsU2hpZnRZID0geTA7XG4gICAgeDAgPSAwO1xuICAgIHkwID0gMDtcbiAgICB4MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFg7XG4gICAgeTEgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRZO1xuICAgIHgyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MiAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG5cbiAgICBjb25zdCBhdWdtZW50ZWRNYXRyaXggPSBbXG4gICAgICBbeDEsIHkxLCAwLCAwLCB1MSAtIHUwXSxcbiAgICAgIFt4MiwgeTIsIDAsIDAsIHUyIC0gdTBdLFxuICAgICAgWzAsIDAsIHgxLCB5MSwgdjEgLSB2MF0sXG4gICAgICBbMCwgMCwgeDIsIHkyLCB2MiAtIHYwXVxuICAgIF07XG4gICAgY29uc3QgYWZmaW5lQ29lZnMgPSBzb2x2ZUxpbmVhclN5c3RlbShhdWdtZW50ZWRNYXRyaXgpO1xuICAgIGlmICghYWZmaW5lQ29lZnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGNlbnRyb2lkWCA9ICh1MCArIHUxICsgdTIpIC8gMztcbiAgICBjb25zdCBjZW50cm9pZFkgPSAodjAgKyB2MSArIHYyKSAvIDM7XG4gICAgY29uc3QgcDAgPSBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB1MCwgdjApO1xuICAgIGNvbnN0IHAxID0gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgdTEsIHYxKTtcbiAgICBjb25zdCBwMiA9IGVubGFyZ2VDbGlwUG9pbnQoY2VudHJvaWRYLCBjZW50cm9pZFksIHUyLCB2Mik7XG5cbiAgICBjb250ZXh0Lm1vdmVUbyhwMVswXSwgcDFbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHAwWzBdLCBwMFsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocDJbMF0sIHAyWzFdKTtcbiAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgIGNvbnRleHQudHJhbnNmb3JtKFxuICAgICAgYWZmaW5lQ29lZnNbMF0sIGFmZmluZUNvZWZzWzJdLCBhZmZpbmVDb2Vmc1sxXSwgYWZmaW5lQ29lZnNbM10sIHUwLCB2MCk7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZShzb3VyY2VEYXRhRXh0ZW50WzBdIC0gc291cmNlTnVtZXJpY2FsU2hpZnRYLFxuICAgICAgc291cmNlRGF0YUV4dGVudFszXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WSk7XG5cbiAgICBjb250ZXh0LnNjYWxlKHNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvLFxuICAgICAgLXNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvKTtcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHN0aXRjaENvbnRleHQuY2FudmFzLCAwLCAwKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgaWYgKG9wdF9yZW5kZXJFZGdlcykge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuXG4gICAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICAgIGNvbnN0IHUwID0gKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB1MSA9ICh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MSA9IC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjIgPSAtKHRhcmdldFsyXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MCwgdjApO1xuICAgICAgY29udGV4dC5saW5lVG8odTIsIHYyKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9UaWxlXG4gKi9cbmltcG9ydCB7RVJST1JfVEhSRVNIT0xEfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgVGlsZSBmcm9tICcuLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0QXJlYSwgZ2V0Q2VudGVyLCBnZXRJbnRlcnNlY3Rpb259IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7Y2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbiwgcmVuZGVyIGFzIHJlbmRlclJlcHJvamVjdGVkfSBmcm9tICcuLi9yZXByb2ouanMnO1xuaW1wb3J0IFRyaWFuZ3VsYXRpb24gZnJvbSAnLi4vcmVwcm9qL1RyaWFuZ3VsYXRpb24uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcikgOiBtb2R1bGU6b2wvVGlsZX0gRnVuY3Rpb25UeXBlXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIGVuY2Fwc3VsYXRpbmcgc2luZ2xlIHJlcHJvamVjdGVkIHRpbGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlflRpbGVJbWFnZX0uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL1RpbGV9XG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gc291cmNlVGlsZUdyaWQgU291cmNlIHRpbGUgZ3JpZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSB0YXJnZXRUaWxlR3JpZCBUYXJnZXQgdGlsZSBncmlkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIENvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB3cmFwcGVkVGlsZUNvb3JkIENvb3JkaW5hdGUgb2YgdGhlIHRpbGUgd3JhcHBlZCBpbiBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIEd1dHRlciBvZiB0aGUgc291cmNlIHRpbGVzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcmVwcm9qL1RpbGV+RnVuY3Rpb25UeXBlfSBnZXRUaWxlRnVuY3Rpb25cbiAqICAgICBGdW5jdGlvbiByZXR1cm5pbmcgc291cmNlIHRpbGVzICh6LCB4LCB5LCBwaXhlbFJhdGlvKS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2Vycm9yVGhyZXNob2xkIEFjY2VwdGFibGUgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBweCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmVuZGVyRWRnZXMgUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAqL1xuY29uc3QgUmVwcm9qVGlsZSA9IGZ1bmN0aW9uKHNvdXJjZVByb2osIHNvdXJjZVRpbGVHcmlkLFxuICB0YXJnZXRQcm9qLCB0YXJnZXRUaWxlR3JpZCwgdGlsZUNvb3JkLCB3cmFwcGVkVGlsZUNvb3JkLFxuICBwaXhlbFJhdGlvLCBndXR0ZXIsIGdldFRpbGVGdW5jdGlvbixcbiAgb3B0X2Vycm9yVGhyZXNob2xkLCBvcHRfcmVuZGVyRWRnZXMpIHtcbiAgVGlsZS5jYWxsKHRoaXMsIHRpbGVDb29yZCwgVGlsZVN0YXRlLklETEUpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMucmVuZGVyRWRnZXNfID0gb3B0X3JlbmRlckVkZ2VzICE9PSB1bmRlZmluZWQgPyBvcHRfcmVuZGVyRWRnZXMgOiBmYWxzZTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5ndXR0ZXJfID0gZ3V0dGVyO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqL1xuICB0aGlzLmNhbnZhc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfVxuICAgKi9cbiAgdGhpcy5zb3VyY2VUaWxlR3JpZF8gPSBzb3VyY2VUaWxlR3JpZDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH1cbiAgICovXG4gIHRoaXMudGFyZ2V0VGlsZUdyaWRfID0gdGFyZ2V0VGlsZUdyaWQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH1cbiAgICovXG4gIHRoaXMud3JhcHBlZFRpbGVDb29yZF8gPSB3cmFwcGVkVGlsZUNvb3JkID8gd3JhcHBlZFRpbGVDb29yZCA6IHRpbGVDb29yZDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFBcnJheS48bW9kdWxlOm9sL1RpbGU+fVxuICAgKi9cbiAgdGhpcy5zb3VyY2VUaWxlc18gPSBbXTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59XG4gICAqL1xuICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuc291cmNlWl8gPSAwO1xuXG4gIGNvbnN0IHRhcmdldEV4dGVudCA9IHRhcmdldFRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudCh0aGlzLndyYXBwZWRUaWxlQ29vcmRfKTtcbiAgY29uc3QgbWF4VGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG4gIGxldCBtYXhTb3VyY2VFeHRlbnQgPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcblxuICBjb25zdCBsaW1pdGVkVGFyZ2V0RXh0ZW50ID0gbWF4VGFyZ2V0RXh0ZW50ID9cbiAgICBnZXRJbnRlcnNlY3Rpb24odGFyZ2V0RXh0ZW50LCBtYXhUYXJnZXRFeHRlbnQpIDogdGFyZ2V0RXh0ZW50O1xuXG4gIGlmIChnZXRBcmVhKGxpbWl0ZWRUYXJnZXRFeHRlbnQpID09PSAwKSB7XG4gICAgLy8gVGlsZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgcmFuZ2UgLT4gRU1QVFlcbiAgICAvLyBUT0RPOiBpcyBpdCBhY3R1YWxseSBjb3JyZWN0IHRoYXQgdGhlIHNvdXJjZSBldmVuIGNyZWF0ZXMgdGhlIHRpbGUgP1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc291cmNlUHJvakV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gIGlmIChzb3VyY2VQcm9qRXh0ZW50KSB7XG4gICAgaWYgKCFtYXhTb3VyY2VFeHRlbnQpIHtcbiAgICAgIG1heFNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2pFeHRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFNvdXJjZUV4dGVudCA9IGdldEludGVyc2VjdGlvbihtYXhTb3VyY2VFeHRlbnQsIHNvdXJjZVByb2pFeHRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSB0YXJnZXRUaWxlR3JpZC5nZXRSZXNvbHV0aW9uKFxuICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF9bMF0pO1xuXG4gIGNvbnN0IHRhcmdldENlbnRlciA9IGdldENlbnRlcihsaW1pdGVkVGFyZ2V0RXh0ZW50KTtcbiAgY29uc3Qgc291cmNlUmVzb2x1dGlvbiA9IGNhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24oXG4gICAgc291cmNlUHJvaiwgdGFyZ2V0UHJvaiwgdGFyZ2V0Q2VudGVyLCB0YXJnZXRSZXNvbHV0aW9uKTtcblxuICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgIC8vIGludmFsaWQgc291cmNlUmVzb2x1dGlvbiAtPiBFTVBUWVxuICAgIC8vIHByb2JhYmx5IGVkZ2VzIG9mIHRoZSBwcm9qZWN0aW9ucyB3aGVuIG5vIGV4dGVudCBpcyBkZWZpbmVkXG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBlcnJvclRocmVzaG9sZEluUGl4ZWxzID0gb3B0X2Vycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdF9lcnJvclRocmVzaG9sZCA6IEVSUk9SX1RIUkVTSE9MRDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFtb2R1bGU6b2wvcmVwcm9qL1RyaWFuZ3VsYXRpb259XG4gICAqL1xuICB0aGlzLnRyaWFuZ3VsYXRpb25fID0gbmV3IFRyaWFuZ3VsYXRpb24oXG4gICAgc291cmNlUHJvaiwgdGFyZ2V0UHJvaiwgbGltaXRlZFRhcmdldEV4dGVudCwgbWF4U291cmNlRXh0ZW50LFxuICAgIHNvdXJjZVJlc29sdXRpb24gKiBlcnJvclRocmVzaG9sZEluUGl4ZWxzKTtcblxuICBpZiAodGhpcy50cmlhbmd1bGF0aW9uXy5nZXRUcmlhbmdsZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBubyB2YWxpZCB0cmlhbmdsZXMgLT4gRU1QVFlcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc291cmNlWl8gPSBzb3VyY2VUaWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbihzb3VyY2VSZXNvbHV0aW9uKTtcbiAgbGV0IHNvdXJjZUV4dGVudCA9IHRoaXMudHJpYW5ndWxhdGlvbl8uY2FsY3VsYXRlU291cmNlRXh0ZW50KCk7XG5cbiAgaWYgKG1heFNvdXJjZUV4dGVudCkge1xuICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIHNvdXJjZUV4dGVudFsxXSA9IGNsYW1wKFxuICAgICAgICBzb3VyY2VFeHRlbnRbMV0sIG1heFNvdXJjZUV4dGVudFsxXSwgbWF4U291cmNlRXh0ZW50WzNdKTtcbiAgICAgIHNvdXJjZUV4dGVudFszXSA9IGNsYW1wKFxuICAgICAgICBzb3VyY2VFeHRlbnRbM10sIG1heFNvdXJjZUV4dGVudFsxXSwgbWF4U291cmNlRXh0ZW50WzNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHNvdXJjZUV4dGVudCwgbWF4U291cmNlRXh0ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWdldEFyZWEoc291cmNlRXh0ZW50KSkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc291cmNlUmFuZ2UgPSBzb3VyY2VUaWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgc291cmNlRXh0ZW50LCB0aGlzLnNvdXJjZVpfKTtcblxuICAgIGZvciAobGV0IHNyY1ggPSBzb3VyY2VSYW5nZS5taW5YOyBzcmNYIDw9IHNvdXJjZVJhbmdlLm1heFg7IHNyY1grKykge1xuICAgICAgZm9yIChsZXQgc3JjWSA9IHNvdXJjZVJhbmdlLm1pblk7IHNyY1kgPD0gc291cmNlUmFuZ2UubWF4WTsgc3JjWSsrKSB7XG4gICAgICAgIGNvbnN0IHRpbGUgPSBnZXRUaWxlRnVuY3Rpb24odGhpcy5zb3VyY2VaXywgc3JjWCwgc3JjWSwgcGl4ZWxSYXRpbyk7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgdGhpcy5zb3VyY2VUaWxlc18ucHVzaCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgfVxuICB9XG59O1xuXG5pbmhlcml0cyhSZXByb2pUaWxlLCBUaWxlKTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblJlcHJvalRpbGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgIHRoaXMudW5saXN0ZW5Tb3VyY2VzXygpO1xuICB9XG4gIFRpbGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgSFRNTCBDYW52YXMgZWxlbWVudCBmb3IgdGhpcyB0aWxlLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcy5cbiAqL1xuUmVwcm9qVGlsZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzXztcbn07XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5SZXByb2pUaWxlLnByb3RvdHlwZS5yZXByb2plY3RfID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbih0aWxlLCBpLCBhcnIpIHtcbiAgICBpZiAodGlsZSAmJiB0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgc291cmNlcy5wdXNoKHtcbiAgICAgICAgZXh0ZW50OiB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS50aWxlQ29vcmQpLFxuICAgICAgICBpbWFnZTogdGlsZS5nZXRJbWFnZSgpXG4gICAgICB9KTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG4gIHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9IDA7XG5cbiAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB6ID0gdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXTtcbiAgICBjb25zdCBzaXplID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZVNpemUoeik7XG4gICAgY29uc3Qgd2lkdGggPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVswXTtcbiAgICBjb25zdCBoZWlnaHQgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVsxXTtcbiAgICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCBzb3VyY2VSZXNvbHV0aW9uID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbih0aGlzLnNvdXJjZVpfKTtcblxuICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8pO1xuICAgIHRoaXMuY2FudmFzXyA9IHJlbmRlclJlcHJvamVjdGVkKHdpZHRoLCBoZWlnaHQsIHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uLCB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKSxcbiAgICAgIHRhcmdldFJlc29sdXRpb24sIHRhcmdldEV4dGVudCwgdGhpcy50cmlhbmd1bGF0aW9uXywgc291cmNlcyxcbiAgICAgIHRoaXMuZ3V0dGVyXywgdGhpcy5yZW5kZXJFZGdlc18pO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FERUQ7XG4gIH1cbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuUmVwcm9qVGlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICB0aGlzLmNoYW5nZWQoKTtcblxuICAgIGxldCBsZWZ0VG9Mb2FkID0gMDtcblxuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBbXTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUsIGksIGFycikge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUgfHwgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgbGVmdFRvTG9hZCsrO1xuXG4gICAgICAgIGNvbnN0IHNvdXJjZUxpc3RlbktleSA9IGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5MT0FERUQgfHxcbiAgICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkVNUFRZKSB7XG4gICAgICAgICAgICAgIHVubGlzdGVuQnlLZXkoc291cmNlTGlzdGVuS2V5KTtcbiAgICAgICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgICAgICBpZiAobGVmdFRvTG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5saXN0ZW5Tb3VyY2VzXygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18ucHVzaChzb3VyY2VMaXN0ZW5LZXkpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUsIGksIGFycikge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgdGlsZS5sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobGVmdFRvTG9hZCA9PT0gMCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLnJlcHJvamVjdF8uYmluZCh0aGlzKSwgMCk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuUmVwcm9qVGlsZS5wcm90b3R5cGUudW5saXN0ZW5Tb3VyY2VzXyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBudWxsO1xufTtcbmV4cG9ydCBkZWZhdWx0IFJlcHJvalRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL1RyaWFuZ3VsYXRpb25cbiAqL1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgY3JlYXRlRW1wdHksIGV4dGVuZENvb3JkaW5hdGUsIGdldEJvdHRvbUxlZnQsIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LCBnZXRUb3BSaWdodCwgZ2V0V2lkdGgsIGludGVyc2VjdHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2dldFRyYW5zZm9ybX0gZnJvbSAnLi4vcHJvai5qcyc7XG5cblxuLyoqXG4gKiBTaW5nbGUgdHJpYW5nbGU7IGNvbnNpc3RzIG9mIDMgc291cmNlIHBvaW50cyBhbmQgMyB0YXJnZXQgcG9pbnRzLlxuICogQHR5cGVkZWYge09iamVjdH0gVHJpYW5nbGVcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBzb3VyY2VcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSB0YXJnZXRcbiAqL1xuXG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygc3ViZGl2aXNpb24gc3RlcHMgZHVyaW5nIHJhc3RlciByZXByb2plY3Rpb24gdHJpYW5ndWxhdGlvbi5cbiAqIFByZXZlbnRzIGhpZ2ggbWVtb3J5IHVzYWdlIGFuZCBsYXJnZSBudW1iZXIgb2YgcHJvajQgY2FsbHMgKGZvciBjZXJ0YWluXG4gKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGFyZWFzKS4gQXQgbW9zdCBgMiooMl50aGlzKWAgdHJpYW5nbGVzIGFyZSBjcmVhdGVkIGZvclxuICogZWFjaCB0cmlhbmd1bGF0ZWQgZXh0ZW50ICh0aWxlL2ltYWdlKS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9TVUJESVZJU0lPTiA9IDEwO1xuXG5cbi8qKlxuICogTWF4aW11bSBhbGxvd2VkIHNpemUgb2YgdHJpYW5nbGUgcmVsYXRpdmUgdG8gd29ybGQgd2lkdGguIFdoZW4gdHJhbnNmb3JtaW5nXG4gKiBjb3JuZXJzIG9mIHdvcmxkIGV4dGVudCBiZXR3ZWVuIGNlcnRhaW4gcHJvamVjdGlvbnMsIHRoZSByZXN1bHRpbmdcbiAqIHRyaWFuZ3VsYXRpb24gc2VlbXMgdG8gaGF2ZSB6ZXJvIGVycm9yIGFuZCBubyBzdWJkaXZpc2lvbiBpcyBwZXJmb3JtZWQuIElmXG4gKiB0aGUgdHJpYW5nbGUgd2lkdGggaXMgbW9yZSB0aGFuIHRoaXMgKHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoOyAwLTEpLFxuICogc3ViZGl2aXNvbiBpcyBmb3JjZWQgKHVwIHRvIGBNQVhfU1VCRElWSVNJT05gKS4gRGVmYXVsdCBpcyBgMC4yNWAuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfVFJJQU5HTEVfV0lEVEggPSAwLjI1O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgY29udGFpbmluZyB0cmlhbmd1bGF0aW9uIG9mIHRoZSBnaXZlbiB0YXJnZXQgZXh0ZW50LlxuICogVXNlZCBmb3IgZGV0ZXJtaW5pbmcgc291cmNlIGRhdGEgYW5kIHRoZSByZXByb2plY3Rpb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50IHRvIHRyaWFuZ3VsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gbWF4U291cmNlRXh0ZW50IE1heGltYWwgc291cmNlIGV4dGVudCB0aGF0IGNhbiBiZSB1c2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGVycm9yVGhyZXNob2xkIEFjY2VwdGFibGUgZXJyb3IgKGluIHNvdXJjZSB1bml0cykuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY29uc3QgVHJpYW5ndWxhdGlvbiA9IGZ1bmN0aW9uKHNvdXJjZVByb2osIHRhcmdldFByb2osIHRhcmdldEV4dGVudCxcbiAgbWF4U291cmNlRXh0ZW50LCBlcnJvclRocmVzaG9sZCkge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc291cmNlUHJval8gPSBzb3VyY2VQcm9qO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudGFyZ2V0UHJval8gPSB0YXJnZXRQcm9qO1xuXG4gIC8qKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gKi9cbiAgbGV0IHRyYW5zZm9ybUludkNhY2hlID0ge307XG4gIGNvbnN0IHRyYW5zZm9ybUludiA9IGdldFRyYW5zZm9ybSh0aGlzLnRhcmdldFByb2pfLCB0aGlzLnNvdXJjZVByb2pfKTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjIEEgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudHJhbnNmb3JtSW52XyA9IGZ1bmN0aW9uKGMpIHtcbiAgICBjb25zdCBrZXkgPSBjWzBdICsgJy8nICsgY1sxXTtcbiAgICBpZiAoIXRyYW5zZm9ybUludkNhY2hlW2tleV0pIHtcbiAgICAgIHRyYW5zZm9ybUludkNhY2hlW2tleV0gPSB0cmFuc2Zvcm1JbnYoYyk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1heFNvdXJjZUV4dGVudF8gPSBtYXhTb3VyY2VFeHRlbnQ7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF8gPSBlcnJvclRocmVzaG9sZCAqIGVycm9yVGhyZXNob2xkO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9yZXByb2ovVHJpYW5ndWxhdGlvbn5UcmlhbmdsZT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRyaWFuZ2xlc18gPSBbXTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHRyaWFuZ3VsYXRpb24gY3Jvc3NlcyBlZGdlIG9mIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLndyYXBzWEluU291cmNlXyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2FuV3JhcFhJblNvdXJjZV8gPSB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICEhbWF4U291cmNlRXh0ZW50ICYmXG4gICAgICAhIXRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgJiZcbiAgICAgIChnZXRXaWR0aChtYXhTb3VyY2VFeHRlbnQpID09IGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpKTtcblxuICAvKipcbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfID0gdGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSA/XG4gICAgZ2V0V2lkdGgodGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSkgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8gPSB0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpID9cbiAgICBnZXRXaWR0aCh0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpKSA6IG51bGw7XG5cbiAgY29uc3QgZGVzdGluYXRpb25Ub3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuICBjb25zdCBkZXN0aW5hdGlvblRvcFJpZ2h0ID0gZ2V0VG9wUmlnaHQodGFyZ2V0RXh0ZW50KTtcbiAgY29uc3QgZGVzdGluYXRpb25Cb3R0b21SaWdodCA9IGdldEJvdHRvbVJpZ2h0KHRhcmdldEV4dGVudCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQm90dG9tTGVmdCA9IGdldEJvdHRvbUxlZnQodGFyZ2V0RXh0ZW50KTtcbiAgY29uc3Qgc291cmNlVG9wTGVmdCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcExlZnQpO1xuICBjb25zdCBzb3VyY2VUb3BSaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcFJpZ2h0KTtcbiAgY29uc3Qgc291cmNlQm90dG9tUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Cb3R0b21SaWdodCk7XG4gIGNvbnN0IHNvdXJjZUJvdHRvbUxlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Cb3R0b21MZWZ0KTtcblxuICB0aGlzLmFkZFF1YWRfKFxuICAgIGRlc3RpbmF0aW9uVG9wTGVmdCwgZGVzdGluYXRpb25Ub3BSaWdodCxcbiAgICBkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0LCBkZXN0aW5hdGlvbkJvdHRvbUxlZnQsXG4gICAgc291cmNlVG9wTGVmdCwgc291cmNlVG9wUmlnaHQsIHNvdXJjZUJvdHRvbVJpZ2h0LCBzb3VyY2VCb3R0b21MZWZ0LFxuICAgIE1BWF9TVUJESVZJU0lPTik7XG5cbiAgaWYgKHRoaXMud3JhcHNYSW5Tb3VyY2VfKSB7XG4gICAgbGV0IGxlZnRCb3VuZCA9IEluZmluaXR5O1xuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIGxlZnRCb3VuZCA9IE1hdGgubWluKGxlZnRCb3VuZCxcbiAgICAgICAgdHJpYW5nbGUuc291cmNlWzBdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsyXVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaGlmdCB0cmlhbmdsZXMgdG8gYmUgYXMgY2xvc2UgdG8gYGxlZnRCb3VuZGAgYXMgcG9zc2libGVcbiAgICAvLyAoaWYgdGhlIGRpc3RhbmNlIGlzIG1vcmUgdGhhbiBgd29ybGRXaWR0aCAvIDJgIGl0IGNhbiBiZSBjbG9zZXIuXG4gICAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUpIHtcbiAgICAgIGlmIChNYXRoLm1heCh0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVswXSxcbiAgICAgICAgdHJpYW5nbGUuc291cmNlWzJdWzBdKSAtIGxlZnRCb3VuZCA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgIGNvbnN0IG5ld1RyaWFuZ2xlID0gW1t0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVswXVsxXV0sXG4gICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVsxXVswXSwgdHJpYW5nbGUuc291cmNlWzFdWzFdXSxcbiAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzJdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMV1dXTtcbiAgICAgICAgaWYgKChuZXdUcmlhbmdsZVswXVswXSAtIGxlZnRCb3VuZCkgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuZXdUcmlhbmdsZVsxXVswXSAtIGxlZnRCb3VuZCkgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIG5ld1RyaWFuZ2xlWzFdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuZXdUcmlhbmdsZVsyXVswXSAtIGxlZnRCb3VuZCkgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIG5ld1RyaWFuZ2xlWzJdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSYXJlbHkgKGlmIHRoZSBleHRlbnQgY29udGFpbnMgYm90aCB0aGUgZGF0ZWxpbmUgYW5kIHByaW1lIG1lcmlkaWFuKVxuICAgICAgICAvLyB0aGUgc2hpZnQgY2FuIGluIHR1cm4gYnJlYWsgc29tZSB0cmlhbmdsZXMuXG4gICAgICAgIC8vIERldGVjdCB0aGlzIGhlcmUgYW5kIGRvbid0IHNoaWZ0IGluIHN1Y2ggY2FzZXMuXG4gICAgICAgIGNvbnN0IG1pblggPSBNYXRoLm1pbihcbiAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSwgbmV3VHJpYW5nbGVbMV1bMF0sIG5ld1RyaWFuZ2xlWzJdWzBdKTtcbiAgICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KFxuICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLCBuZXdUcmlhbmdsZVsxXVswXSwgbmV3VHJpYW5nbGVbMl1bMF0pO1xuICAgICAgICBpZiAoKG1heFggLSBtaW5YKSA8IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgdHJpYW5nbGUuc291cmNlID0gbmV3VHJpYW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgdHJhbnNmb3JtSW52Q2FjaGUgPSB7fTtcbn07XG5cblxuLyoqXG4gKiBBZGRzIHRyaWFuZ2xlIHRvIHRoZSB0cmlhbmd1bGF0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhIFRoZSB0YXJnZXQgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjIFRoZSB0YXJnZXQgYyBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjU3JjIFRoZSBzb3VyY2UgYyBjb29yZGluYXRlLlxuICogQHByaXZhdGVcbiAqL1xuVHJpYW5ndWxhdGlvbi5wcm90b3R5cGUuYWRkVHJpYW5nbGVfID0gZnVuY3Rpb24oYSwgYiwgYyxcbiAgYVNyYywgYlNyYywgY1NyYykge1xuICB0aGlzLnRyaWFuZ2xlc18ucHVzaCh7XG4gICAgc291cmNlOiBbYVNyYywgYlNyYywgY1NyY10sXG4gICAgdGFyZ2V0OiBbYSwgYiwgY11cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBxdWFkIChwb2ludHMgaW4gY2xvY2std2lzZSBvcmRlcikgdG8gdGhlIHRyaWFuZ3VsYXRpb25cbiAqIChhbmQgcmVwcm9qZWN0cyB0aGUgdmVydGljZXMpIGlmIHZhbGlkLlxuICogUGVyZm9ybXMgcXVhZCBzdWJkaXZpc2lvbiBpZiBuZWVkZWQgdG8gaW5jcmVhc2UgcHJlY2lzaW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYiBUaGUgdGFyZ2V0IGIgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gZCBUaGUgdGFyZ2V0IGQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gZFNyYyBUaGUgc291cmNlIGQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTdWJkaXZpc2lvbiBNYXhpbWFsIGFsbG93ZWQgc3ViZGl2aXNpb24gb2YgdGhlIHF1YWQuXG4gKiBAcHJpdmF0ZVxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5hZGRRdWFkXyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsXG4gIGFTcmMsIGJTcmMsIGNTcmMsIGRTcmMsIG1heFN1YmRpdmlzaW9uKSB7XG5cbiAgY29uc3Qgc291cmNlUXVhZEV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KFthU3JjLCBiU3JjLCBjU3JjLCBkU3JjXSk7XG4gIGNvbnN0IHNvdXJjZUNvdmVyYWdlWCA9IHRoaXMuc291cmNlV29ybGRXaWR0aF8gP1xuICAgIGdldFdpZHRoKHNvdXJjZVF1YWRFeHRlbnQpIC8gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyA6IG51bGw7XG4gIGNvbnN0IHNvdXJjZVdvcmxkV2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuc291cmNlV29ybGRXaWR0aF8pO1xuXG4gIC8vIHdoZW4gdGhlIHF1YWQgaXMgd3JhcHBlZCBpbiB0aGUgc291cmNlIHByb2plY3Rpb25cbiAgLy8gaXQgY292ZXJzIG1vc3Qgb2YgdGhlIHByb2plY3Rpb24gZXh0ZW50LCBidXQgbm90IGZ1bGx5XG4gIGNvbnN0IHdyYXBzWCA9IHRoaXMuc291cmNlUHJval8uY2FuV3JhcFgoKSAmJlxuICAgICAgICAgICAgICAgc291cmNlQ292ZXJhZ2VYID4gMC41ICYmIHNvdXJjZUNvdmVyYWdlWCA8IDE7XG5cbiAgbGV0IG5lZWRzU3ViZGl2aXNpb24gPSBmYWxzZTtcblxuICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UHJval8uaXNHbG9iYWwoKSAmJiB0aGlzLnRhcmdldFdvcmxkV2lkdGhfKSB7XG4gICAgICBjb25zdCB0YXJnZXRRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2EsIGIsIGMsIGRdKTtcbiAgICAgIGNvbnN0IHRhcmdldENvdmVyYWdlWCA9IGdldFdpZHRoKHRhcmdldFF1YWRFeHRlbnQpIC8gdGhpcy50YXJnZXRXb3JsZFdpZHRoXztcbiAgICAgIG5lZWRzU3ViZGl2aXNpb24gfD1cbiAgICAgICAgICB0YXJnZXRDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEg7XG4gICAgfVxuICAgIGlmICghd3JhcHNYICYmIHRoaXMuc291cmNlUHJval8uaXNHbG9iYWwoKSAmJiBzb3VyY2VDb3ZlcmFnZVgpIHtcbiAgICAgIG5lZWRzU3ViZGl2aXNpb24gfD1cbiAgICAgICAgICBzb3VyY2VDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEg7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uICYmIHRoaXMubWF4U291cmNlRXh0ZW50Xykge1xuICAgIGlmICghaW50ZXJzZWN0cyhzb3VyY2VRdWFkRXh0ZW50LCB0aGlzLm1heFNvdXJjZUV4dGVudF8pKSB7XG4gICAgICAvLyB3aG9sZSBxdWFkIG91dHNpZGUgc291cmNlIHByb2plY3Rpb24gZXh0ZW50IC0+IGlnbm9yZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmVlZHNTdWJkaXZpc2lvbikge1xuICAgIGlmICghaXNGaW5pdGUoYVNyY1swXSkgfHwgIWlzRmluaXRlKGFTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShiU3JjWzBdKSB8fCAhaXNGaW5pdGUoYlNyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGNTcmNbMF0pIHx8ICFpc0Zpbml0ZShjU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoZFNyY1swXSkgfHwgIWlzRmluaXRlKGRTcmNbMV0pKSB7XG4gICAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgIGNvbnN0IGNlbnRlciA9IFsoYVswXSArIGNbMF0pIC8gMiwgKGFbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgY29uc3QgY2VudGVyU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNlbnRlcik7XG5cbiAgICAgIGxldCBkeDtcbiAgICAgIGlmICh3cmFwc1gpIHtcbiAgICAgICAgY29uc3QgY2VudGVyU3JjRXN0aW1YID1cbiAgICAgICAgICAgIChtb2R1bG8oYVNyY1swXSwgc291cmNlV29ybGRXaWR0aCkgK1xuICAgICAgICAgICAgIG1vZHVsbyhjU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKSkgLyAyO1xuICAgICAgICBkeCA9IGNlbnRlclNyY0VzdGltWCAtXG4gICAgICAgICAgICBtb2R1bG8oY2VudGVyU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gKGFTcmNbMF0gKyBjU3JjWzBdKSAvIDIgLSBjZW50ZXJTcmNbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBkeSA9IChhU3JjWzFdICsgY1NyY1sxXSkgLyAyIC0gY2VudGVyU3JjWzFdO1xuICAgICAgY29uc3QgY2VudGVyU3JjRXJyb3JTcXVhcmVkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uID0gY2VudGVyU3JjRXJyb3JTcXVhcmVkID4gdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfO1xuICAgIH1cbiAgICBpZiAobmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgaWYgKE1hdGguYWJzKGFbMF0gLSBjWzBdKSA8PSBNYXRoLmFicyhhWzFdIC0gY1sxXSkpIHtcbiAgICAgICAgLy8gc3BsaXQgaG9yaXpvbnRhbGx5ICh0b3AgJiBib3R0b20pXG4gICAgICAgIGNvbnN0IGJjID0gWyhiWzBdICsgY1swXSkgLyAyLCAoYlsxXSArIGNbMV0pIC8gMl07XG4gICAgICAgIGNvbnN0IGJjU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGJjKTtcbiAgICAgICAgY29uc3QgZGEgPSBbKGRbMF0gKyBhWzBdKSAvIDIsIChkWzFdICsgYVsxXSkgLyAyXTtcbiAgICAgICAgY29uc3QgZGFTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oZGEpO1xuXG4gICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgYSwgYiwgYmMsIGRhLCBhU3JjLCBiU3JjLCBiY1NyYywgZGFTcmMsIG1heFN1YmRpdmlzaW9uIC0gMSk7XG4gICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgZGEsIGJjLCBjLCBkLCBkYVNyYywgYmNTcmMsIGNTcmMsIGRTcmMsIG1heFN1YmRpdmlzaW9uIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5IChsZWZ0ICYgcmlnaHQpXG4gICAgICAgIGNvbnN0IGFiID0gWyhhWzBdICsgYlswXSkgLyAyLCAoYVsxXSArIGJbMV0pIC8gMl07XG4gICAgICAgIGNvbnN0IGFiU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGFiKTtcbiAgICAgICAgY29uc3QgY2QgPSBbKGNbMF0gKyBkWzBdKSAvIDIsIChjWzFdICsgZFsxXSkgLyAyXTtcbiAgICAgICAgY29uc3QgY2RTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oY2QpO1xuXG4gICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgYSwgYWIsIGNkLCBkLCBhU3JjLCBhYlNyYywgY2RTcmMsIGRTcmMsIG1heFN1YmRpdmlzaW9uIC0gMSk7XG4gICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgYWIsIGIsIGMsIGNkLCBhYlNyYywgYlNyYywgY1NyYywgY2RTcmMsIG1heFN1YmRpdmlzaW9uIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHdyYXBzWCkge1xuICAgIGlmICghdGhpcy5jYW5XcmFwWEluU291cmNlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndyYXBzWEluU291cmNlXyA9IHRydWU7XG4gIH1cblxuICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBjLCBkLCBhU3JjLCBjU3JjLCBkU3JjKTtcbiAgdGhpcy5hZGRUcmlhbmdsZV8oYSwgYiwgYywgYVNyYywgYlNyYywgY1NyYyk7XG59O1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBleHRlbnQgb2YgdGhlICdzb3VyY2UnIGNvb3JkaW5hdGVzIGZyb20gYWxsIHRoZSB0cmlhbmdsZXMuXG4gKlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IENhbGN1bGF0ZWQgZXh0ZW50LlxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVTb3VyY2VFeHRlbnQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgY29uc3Qgc3JjID0gdHJpYW5nbGUuc291cmNlO1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMF0pO1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMV0pO1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMl0pO1xuICB9KTtcblxuICByZXR1cm4gZXh0ZW50O1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvcmVwcm9qL1RyaWFuZ3VsYXRpb25+VHJpYW5nbGU+fSBBcnJheSBvZiB0aGUgY2FsY3VsYXRlZCB0cmlhbmdsZXMuXG4gKi9cblRyaWFuZ3VsYXRpb24ucHJvdG90eXBlLmdldFRyaWFuZ2xlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50cmlhbmdsZXNfO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRyaWFuZ3VsYXRpb247XG4iLCIvKipcbiAqIERlZmF1bHQgbWF4aW11bSBhbGxvd2VkIHRocmVzaG9sZCAgKGluIHBpeGVscykgZm9yIHJlcHJvamVjdGlvblxuICogdHJpYW5ndWxhdGlvbi5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBFUlJPUl9USFJFU0hPTEQgPSAwLjU7XG5cbi8qKlxuICogRW5hYmxlIGF1dG9tYXRpYyByZXByb2plY3Rpb24gb2YgcmFzdGVyIHNvdXJjZXMuIERlZmF1bHQgaXMgYHRydWVgLlxuICogVE9ETzogZGVjaWRlIGlmIHdlIHdhbnQgdG8gZXhwb3NlIHRoaXMgYXMgYSBidWlsZCBmbGFnIG9yIHJlbW92ZSBpdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiA9IHRydWU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc2l6ZVxuICovXG5cblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhIHNpemU6IGBbd2lkdGgsIGhlaWdodF1gLlxuICogQHR5cGVkZWYge0FycmF5LjxudW1iZXI+fSBTaXplXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXJlZCBzaXplLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBzaXplIFNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBhbW91bnQgYnkgd2hpY2ggdG8gYnVmZmVyLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplPX0gb3B0X3NpemUgT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFRoZSBidWZmZXJlZCBzaXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyKHNpemUsIG51bSwgb3B0X3NpemUpIHtcbiAgaWYgKG9wdF9zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRfc2l6ZSA9IFswLCAwXTtcbiAgfVxuICBvcHRfc2l6ZVswXSA9IHNpemVbMF0gKyAyICogbnVtO1xuICBvcHRfc2l6ZVsxXSA9IHNpemVbMV0gKyAyICogbnVtO1xuICByZXR1cm4gb3B0X3NpemU7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgc2l6ZSBoYXMgYSBwb3NpdGl2ZSBhcmVhLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBzaXplIFRoZSBzaXplIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2l6ZSBoYXMgYSBwb3NpdGl2ZSBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQXJlYShzaXplKSB7XG4gIHJldHVybiBzaXplWzBdID4gMCAmJiBzaXplWzFdID4gMDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYSBzaXplIHNjYWxlZCBieSBhIHJhdGlvLiBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyBSYXRpby5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF9zaXplIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBUaGUgc2NhbGVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShzaXplLCByYXRpbywgb3B0X3NpemUpIHtcbiAgaWYgKG9wdF9zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRfc2l6ZSA9IFswLCAwXTtcbiAgfVxuICBvcHRfc2l6ZVswXSA9IChzaXplWzBdICogcmF0aW8gKyAwLjUpIHwgMDtcbiAgb3B0X3NpemVbMV0gPSAoc2l6ZVsxXSAqIHJhdGlvICsgMC41KSB8IDA7XG4gIHJldHVybiBvcHRfc2l6ZTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYW4gYG1vZHVsZTpvbC9zaXplflNpemVgIGFycmF5IGZvciB0aGUgcGFzc2VkIGluIG51bWJlciAobWVhbmluZzogc3F1YXJlKSBvclxuICogYG1vZHVsZTpvbC9zaXplflNpemVgIGFycmF5LlxuICogKG1lYW5pbmc6IG5vbi1zcXVhcmUpLFxuICogQHBhcmFtIHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZX0gc2l6ZSBXaWR0aCBhbmQgaGVpZ2h0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplPX0gb3B0X3NpemUgT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFNpemUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1NpemUoc2l6ZSwgb3B0X3NpemUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0X3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0X3NpemUgPSBbc2l6ZSwgc2l6ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdF9zaXplWzBdID0gb3B0X3NpemVbMV0gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0X3NpemU7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvU291cmNlXG4gKi9cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB7VU5ERUZJTkVEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBzb3VyY2VcbiAqIGF0dHJpYnV0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlKTogKHN0cmluZ3xBcnJheS48c3RyaW5nPil9IEF0dHJpYnV0aW9uXG4gKi9cblxuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYXR0cmlidXRpb24gaW5mb3JtYXRpb24gZm9yIGRhdGEgc291cmNlcy5cbiAqXG4gKiBJdCByZXByZXNlbnRzIGVpdGhlclxuICogKiBhIHNpbXBsZSBzdHJpbmcgKGUuZy4gYCfCqSBBY21lIEluYy4nYClcbiAqICogYW4gYXJyYXkgb2Ygc2ltcGxlIHN0cmluZ3MgKGUuZy4gYFsnwqkgQWNtZSBJbmMuJywgJ8KpIEJhY21lIEluYy4nXWApXG4gKiAqIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgKGB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259YClcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbkxpa2VcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFtzdGF0ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYXVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyfSBzb3VyY2VzLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSBjaGFuZ2VzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFic3RyYWN0XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL09iamVjdH1cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+T3B0aW9uc30gb3B0aW9ucyBTb3VyY2Ugb3B0aW9ucy5cbiAqIEBhcGlcbiAqL1xuY29uc3QgU291cmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIEJhc2VPYmplY3QuY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gICAqL1xuICB0aGlzLnByb2plY3Rpb25fID0gZ2V0UHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7P21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufVxuICAgKi9cbiAgdGhpcy5hdHRyaWJ1dGlvbnNfID0gdGhpcy5hZGFwdEF0dHJpYnV0aW9uc18ob3B0aW9ucy5hdHRyaWJ1dGlvbnMpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3NvdXJjZS9TdGF0ZX1cbiAgICovXG4gIHRoaXMuc3RhdGVfID0gb3B0aW9ucy5zdGF0ZSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnN0YXRlIDogU291cmNlU3RhdGUuUkVBRFk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy53cmFwWF8gPSBvcHRpb25zLndyYXBYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBYIDogZmFsc2U7XG5cbn07XG5cbmluaGVyaXRzKFNvdXJjZSwgQmFzZU9iamVjdCk7XG5cbi8qKlxuICogVHVybnMgdGhlIGF0dHJpYnV0aW9ucyBvcHRpb24gaW50byBhbiBhdHRyaWJ1dGlvbnMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9uTGlrZSBUaGUgYXR0cmlidXRpb24gb3B0aW9uLlxuICogQHJldHVybiB7P21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufSBBbiBhdHRyaWJ1dGlvbiBmdW5jdGlvbiAob3IgbnVsbCkuXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuYWRhcHRBdHRyaWJ1dGlvbnNfID0gZnVuY3Rpb24oYXR0cmlidXRpb25MaWtlKSB7XG4gIGlmICghYXR0cmlidXRpb25MaWtlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRpb25MaWtlKSkge1xuICAgIHJldHVybiBmdW5jdGlvbihmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRpb25MaWtlO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGF0dHJpYnV0aW9uTGlrZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhdHRyaWJ1dGlvbkxpa2U7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybiBbYXR0cmlidXRpb25MaWtlXTtcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZVVpZHMgU2tpcHBlZCBmZWF0dXJlIHVpZHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKChtb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmUpKTogVH0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5Tb3VyY2UucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gVU5ERUZJTkVEO1xuXG5cbi8qKlxuICogR2V0IHRoZSBhdHRyaWJ1dGlvbiBmdW5jdGlvbiBmb3IgdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4gez9tb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn0gQXR0cmlidXRpb24gZnVuY3Rpb24uXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuZ2V0QXR0cmlidXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmF0dHJpYnV0aW9uc187XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBwcm9qZWN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICogQGFwaVxuICovXG5Tb3VyY2UucHJvdG90eXBlLmdldFByb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucHJvamVjdGlvbl87XG59O1xuXG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnx1bmRlZmluZWR9IFJlc29sdXRpb25zLlxuICovXG5Tb3VyY2UucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIEdldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSwgc2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1N0YXRlflN0YXRlfSBmb3IgcG9zc2libGUgc3RhdGVzLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3NvdXJjZS9TdGF0ZX0gU3RhdGUuXG4gKiBAYXBpXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGVfO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBXcmFwIFguXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuZ2V0V3JhcFggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud3JhcFhfO1xufTtcblxuXG4vKipcbiAqIFJlZnJlc2hlcyB0aGUgc291cmNlIGFuZCBmaW5hbGx5IGRpc3BhdGNoZXMgYSAnY2hhbmdlJyBldmVudC5cbiAqIEBhcGlcbiAqL1xuU291cmNlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRpb25zIG9mIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9ucyBBdHRyaWJ1dGlvbnMuXG4gKiAgICAgQ2FuIGJlIHBhc3NlZCBhcyBgc3RyaW5nYCwgYEFycmF5PHN0cmluZz5gLCBge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufWAsXG4gKiAgICAgb3IgYHVuZGVmaW5lZGAuXG4gKiBAYXBpXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0QXR0cmlidXRpb25zID0gZnVuY3Rpb24oYXR0cmlidXRpb25zKSB7XG4gIHRoaXMuYXR0cmlidXRpb25zXyA9IHRoaXMuYWRhcHRBdHRyaWJ1dGlvbnNfKGF0dHJpYnV0aW9ucyk7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9TdGF0ZX0gc3RhdGUgU3RhdGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5leHBvcnQgZGVmYXVsdCBTb3VyY2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1N0YXRlXG4gKi9cblxuLyoqXG4gKiBTdGF0ZSBvZiB0aGUgc291cmNlLCBvbmUgb2YgJ3VuZGVmaW5lZCcsICdsb2FkaW5nJywgJ3JlYWR5JyBvciAnZXJyb3InLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBVTkRFRklORUQ6ICd1bmRlZmluZWQnLFxuICBMT0FESU5HOiAnbG9hZGluZycsXG4gIFJFQURZOiAncmVhZHknLFxuICBFUlJPUjogJ2Vycm9yJ1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZVxuICovXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBUaWxlQ2FjaGUgZnJvbSAnLi4vVGlsZUNhY2hlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHtlcXVpdmFsZW50fSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7dG9TaXplLCBzY2FsZSBhcyBzY2FsZVNpemV9IGZyb20gJy4uL3NpemUuanMnO1xuaW1wb3J0IFNvdXJjZSBmcm9tICcuLi9zb3VyY2UvU291cmNlLmpzJztcbmltcG9ydCB7Z2V0S2V5WlhZLCB3aXRoaW5FeHRlbnRBbmRafSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuaW1wb3J0IHt3cmFwWCwgZ2V0Rm9yUHJvamVjdGlvbiBhcyBnZXRUaWxlR3JpZEZvclByb2plY3Rpb259IGZyb20gJy4uL3RpbGVncmlkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW9dXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9TdGF0ZX0gW3N0YXRlXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IFt0aWxlR3JpZF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGltYWdlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX1cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9UaWxlfk9wdGlvbnM9fSBvcHRpb25zIFNvdXJjZVRpbGUgc291cmNlIG9wdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmNvbnN0IFRpbGVTb3VyY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgU291cmNlLmNhbGwodGhpcywge1xuICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgZXh0ZW50OiBvcHRpb25zLmV4dGVudCxcbiAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgd3JhcFg6IG9wdGlvbnMud3JhcFhcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5vcGFxdWVfID0gb3B0aW9ucy5vcGFxdWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhcXVlIDogZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnRpbGVQaXhlbFJhdGlvXyA9IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyA6IDE7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH1cbiAgICovXG4gIHRoaXMudGlsZUdyaWQgPSBvcHRpb25zLnRpbGVHcmlkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbGVHcmlkIDogbnVsbDtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGVDYWNoZX1cbiAgICovXG4gIHRoaXMudGlsZUNhY2hlID0gbmV3IFRpbGVDYWNoZShvcHRpb25zLmNhY2hlU2l6ZSk7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge21vZHVsZTpvbC9zaXplflNpemV9XG4gICAqL1xuICB0aGlzLnRtcFNpemUgPSBbMCwgMF07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLmtleV8gPSAnJztcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV+T3B0aW9uc31cbiAgICovXG4gIHRoaXMudGlsZU9wdGlvbnMgPSB7dHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9ufTtcblxufTtcblxuaW5oZXJpdHMoVGlsZVNvdXJjZSwgU291cmNlKTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmNhbkV4cGlyZUNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9UaWxlUmFuZ2U+fSB1c2VkVGlsZXMgVXNlZCB0aWxlcy5cbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUgPSBmdW5jdGlvbihwcm9qZWN0aW9uLCB1c2VkVGlsZXMpIHtcbiAgY29uc3QgdGlsZUNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBpZiAodGlsZUNhY2hlKSB7XG4gICAgdGlsZUNhY2hlLmV4cGlyZUNhY2hlKHVzZWRUaWxlcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICogQHBhcmFtIHtmdW5jdGlvbihtb2R1bGU6b2wvVGlsZSk6KGJvb2xlYW58dW5kZWZpbmVkKX0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaFxuICogICAgIGxvYWRlZCB0aWxlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgdGhlIHRpbGUgd2lsbCBub3QgYmVcbiAqICAgICBjb25zaWRlcmVkIGxvYWRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHJhbmdlIGlzIGZ1bGx5IGNvdmVyZWQgd2l0aCBsb2FkZWQgdGlsZXMuXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmZvckVhY2hMb2FkZWRUaWxlID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgeiwgdGlsZVJhbmdlLCBjYWxsYmFjaykge1xuICBjb25zdCB0aWxlQ2FjaGUgPSB0aGlzLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGlmICghdGlsZUNhY2hlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IGNvdmVyZWQgPSB0cnVlO1xuICBsZXQgdGlsZSwgdGlsZUNvb3JkS2V5LCBsb2FkZWQ7XG4gIGZvciAobGV0IHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgZm9yIChsZXQgeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgIHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRpbGVDYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgICAgIHRpbGUgPSAvKiogQHR5cGUgeyFtb2R1bGU6b2wvVGlsZX0gKi8gKHRpbGVDYWNoZS5nZXQodGlsZUNvb3JkS2V5KSk7XG4gICAgICAgIGxvYWRlZCA9IHRpbGUuZ2V0U3RhdGUoKSA9PT0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgIGxvYWRlZCA9IChjYWxsYmFjayh0aWxlKSAhPT0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3ZlcmVkO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmdldEd1dHRlciA9IGZ1bmN0aW9uKHByb2plY3Rpb24pIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBrZXkgdG8gYmUgdXNlZCBmb3IgYWxsIHRpbGVzIGluIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBrZXkgZm9yIGFsbCB0aWxlcy5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmtleV87XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSB0byBiZSB1c2VkIGFzIHRoZSBrZXkgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aWxlcy5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIGlmICh0aGlzLmtleV8gIT09IGtleSkge1xuICAgIHRoaXMua2V5XyA9IGtleTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BhcXVlLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRPcGFxdWUgPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIHJldHVybiB0aGlzLm9wYXF1ZV87XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGlsZUdyaWQuZ2V0UmVzb2x1dGlvbnMoKTtcbn07XG5cblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL1RpbGV9IFRpbGUuXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbih6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7fTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgdGlsZSBncmlkIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gVGlsZSBncmlkLlxuICogQGFwaVxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlR3JpZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IFRpbGUgZ3JpZC5cbiAqL1xuVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICBpZiAoIXRoaXMudGlsZUdyaWQpIHtcbiAgICByZXR1cm4gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZUNhY2hlfSBUaWxlIGNhY2hlLlxuICogQHByb3RlY3RlZFxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICBjb25zdCB0aGlzUHJvaiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICBpZiAodGhpc1Byb2ogJiYgIWVxdWl2YWxlbnQodGhpc1Byb2osIHByb2plY3Rpb24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlO1xuICB9XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB0aWxlIHBpeGVsIHJhdGlvIGZvciB0aGlzIHNvdXJjZS4gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuICogbWV0aG9kLCB3aGljaCBpcyBtZWFudCB0byByZXR1cm4gYSBzdXBwb3J0ZWQgcGl4ZWwgcmF0aW8gdGhhdCBtYXRjaGVzIHRoZVxuICogcHJvdmlkZWQgYHBpeGVsUmF0aW9gIGFzIGNsb3NlIGFzIHBvc3NpYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcGl4ZWwgcmF0aW8uXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVQaXhlbFJhdGlvID0gZnVuY3Rpb24ocGl4ZWxSYXRpbykge1xuICByZXR1cm4gdGhpcy50aWxlUGl4ZWxSYXRpb187XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBUaWxlIHNpemUuXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVQaXhlbFNpemUgPSBmdW5jdGlvbih6LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGlsZUdyaWQuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZSk7XG4gIGlmICh0aWxlUGl4ZWxSYXRpbyA9PSAxKSB7XG4gICAgcmV0dXJuIHRpbGVTaXplO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2FsZVNpemUodGlsZVNpemUsIHRpbGVQaXhlbFJhdGlvLCB0aGlzLnRtcFNpemUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIHRpbGUgY29vcmRpbmF0ZSB3cmFwcGVkIGFyb3VuZCB0aGUgeC1heGlzLiBXaGVuIHRoZSB0aWxlIGNvb3JkaW5hdGVcbiAqIGlzIG91dHNpZGUgdGhlIHJlc29sdXRpb24gYW5kIGV4dGVudCByYW5nZSBvZiB0aGUgdGlsZSBncmlkLCBgbnVsbGAgd2lsbCBiZVxuICogcmV0dXJuZWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPX0gb3B0X3Byb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUgdG8gYmUgcGFzc2VkIHRvIHRoZSB0aWxlVXJsRnVuY3Rpb24gb3JcbiAqICAgICBudWxsIGlmIG5vIHRpbGUgVVJMIHNob3VsZCBiZSBjcmVhdGVkIGZvciB0aGUgcGFzc2VkIGB0aWxlQ29vcmRgLlxuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24gPSBmdW5jdGlvbih0aWxlQ29vcmQsIG9wdF9wcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHByb2plY3Rpb24gPSBvcHRfcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfcHJvamVjdGlvbiA6IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICBjb25zdCB0aWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBpZiAodGhpcy5nZXRXcmFwWCgpICYmIHByb2plY3Rpb24uaXNHbG9iYWwoKSkge1xuICAgIHRpbGVDb29yZCA9IHdyYXBYKHRpbGVHcmlkLCB0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICB9XG4gIHJldHVybiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpID8gdGlsZUNvb3JkIDogbnVsbDtcbn07XG5cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5UaWxlU291cmNlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudGlsZUNhY2hlLmNsZWFyKCk7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIE1hcmtzIGEgdGlsZSBjb29yZCBhcyBiZWluZyB1c2VkLCB3aXRob3V0IHRyaWdnZXJpbmcgYSBsb2FkLlxuICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLnVzZVRpbGUgPSBVTkRFRklORUQ7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudH1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlfSB0aWxlIFRoZSB0aWxlLlxuICovXG5leHBvcnQgY29uc3QgVGlsZVNvdXJjZUV2ZW50ID0gZnVuY3Rpb24odHlwZSwgdGlsZSkge1xuXG4gIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgLyoqXG4gICAqIFRoZSB0aWxlIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LlxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMudGlsZSA9IHRpbGU7XG5cbn07XG5pbmhlcml0cyhUaWxlU291cmNlRXZlbnQsIEV2ZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgVGlsZVNvdXJjZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgc3RhcnRzIGxvYWRpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZUV2ZW50I3RpbGVsb2Fkc3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURTVEFSVDogJ3RpbGVsb2Fkc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgZmluaXNoZXMgbG9hZGluZywgZWl0aGVyIHdoZW4gaXRzIGRhdGEgaXMgbG9hZGVkLFxuICAgKiBvciB3aGVuIGxvYWRpbmcgd2FzIGFib3J0ZWQgYmVjYXVzZSB0aGUgdGlsZSBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BREVORDogJ3RpbGVsb2FkZW5kJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGlmIHRpbGUgbG9hZGluZyByZXN1bHRzIGluIGFuIGVycm9yLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FERVJST1I6ICd0aWxlbG9hZGVycm9yJ1xuXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlSW1hZ2VcbiAqL1xuaW1wb3J0IHtFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTn0gZnJvbSAnLi4vcmVwcm9qL2NvbW1vbi5qcyc7XG5pbXBvcnQge2dldFVpZCwgaW5oZXJpdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCBJbWFnZVRpbGUgZnJvbSAnLi4vSW1hZ2VUaWxlLmpzJztcbmltcG9ydCBUaWxlQ2FjaGUgZnJvbSAnLi4vVGlsZUNhY2hlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudCwgZ2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IFJlcHJvalRpbGUgZnJvbSAnLi4vcmVwcm9qL1RpbGUuanMnO1xuaW1wb3J0IFVybFRpbGUgZnJvbSAnLi4vc291cmNlL1VybFRpbGUuanMnO1xuaW1wb3J0IHtnZXRLZXksIGdldEtleVpYWX0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7Z2V0Rm9yUHJvamVjdGlvbiBhcyBnZXRUaWxlR3JpZEZvclByb2plY3Rpb259IGZyb20gJy4uL3RpbGVncmlkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemU9MjA0OF0gQ2FjaGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3UgYXJlIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBvciBpZiB5b3Ugd2FudCB0b1xuICogYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLiAgU2VlXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2V9IGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZT10cnVlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFtzdGF0ZV0gU291cmNlIHN0YXRlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvSW1hZ2VUaWxlflRpbGVDbGFzc30gW3RpbGVDbGFzc10gQ2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBpbWFnZSB0aWxlcy5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9JbWFnZVRpbGV+SW1hZ2VUaWxlfS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpbz0xXSBUaGUgcGl4ZWwgcmF0aW8gdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpbGVcbiAqIHNlcnZpY2UgYWR2ZXJ0aXplcyAyNTZweCBieSAyNTZweCB0aWxlcyBidXQgYWN0dWFsbHkgc2VuZHMgNTEycHhcbiAqIGJ5IDUxMnB4IGltYWdlcyAoZm9yIHJldGluYS9oaWRwaSBkZXZpY2VzKSB0aGVuIGB0aWxlUGl4ZWxSYXRpb2BcbiAqIHNob3VsZCBiZSBzZXQgdG8gYDJgLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZ2V0IHRpbGUgVVJMIGdpdmVuIGEgdGlsZSBjb29yZGluYXRlIGFuZCB0aGUgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLCBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLlxuICogQSBgez8tP31gIHRlbXBsYXRlIHBhdHRlcm4sIGZvciBleGFtcGxlIGBzdWJkb21haW57YS1mfS5kb21haW4uY29tYCwgbWF5IGJlXG4gKiB1c2VkIGluc3RlYWQgb2YgZGVmaW5pbmcgZWFjaCBvbmUgc2VwYXJhdGVseSBpbiB0aGUgYHVybHNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFt1cmxzXSBBbiBhcnJheSBvZiBVUkwgdGVtcGxhdGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFhdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LiBUaGUgZGVmYXVsdCwgaXMgdG9cbiAqIHJlcXVlc3Qgb3V0LW9mLWJvdW5kcyB0aWxlcyBmcm9tIHRoZSBzZXJ2ZXIuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9ubHkgb25lXG4gKiB3b3JsZCB3aWxsIGJlIHJlbmRlcmVkLiBXaGVuIHNldCB0byBgdHJ1ZWAsIHRpbGVzIHdpbGwgYmUgcmVxdWVzdGVkIGZvciBvbmVcbiAqIHdvcmxkIG9ubHksIGJ1dCB0aGV5IHdpbGwgYmUgd3JhcHBlZCBob3Jpem9udGFsbHkgdG8gcmVuZGVyIG11bHRpcGxlIHdvcmxkcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgaW1hZ2VzIGRpdmlkZWQgaW50byBhIHRpbGUgZ3JpZC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaXJlcyBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZUV2ZW50XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL3NvdXJjZS9VcmxUaWxlfVxuICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1RpbGVJbWFnZX5PcHRpb25zPX0gb3B0aW9ucyBJbWFnZSB0aWxlIG9wdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmNvbnN0IFRpbGVJbWFnZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICBVcmxUaWxlLmNhbGwodGhpcywge1xuICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICBleHRlbnQ6IG9wdGlvbnMuZXh0ZW50LFxuICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbiA/XG4gICAgICBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24gOiBkZWZhdWx0VGlsZUxvYWRGdW5jdGlvbixcbiAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICB0aWxlVXJsRnVuY3Rpb246IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLFxuICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgdXJsczogb3B0aW9ucy51cmxzLFxuICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvblxuICB9KTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICovXG4gIHRoaXMuY3Jvc3NPcmlnaW4gPVxuICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc09yaWdpbiA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge2Z1bmN0aW9uKG5ldzogbW9kdWxlOm9sL0ltYWdlVGlsZSwgbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQsIG1vZHVsZTpvbC9UaWxlU3RhdGUsIHN0cmluZyxcbiAgICogICAgICAgID9zdHJpbmcsIG1vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbiwgbW9kdWxlOm9sL1RpbGV+T3B0aW9ucz0pfVxuICAgKi9cbiAgdGhpcy50aWxlQ2xhc3MgPSBvcHRpb25zLnRpbGVDbGFzcyAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnRpbGVDbGFzcyA6IEltYWdlVGlsZTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvVGlsZUNhY2hlPn1cbiAgICovXG4gIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbiA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZD59XG4gICAqL1xuICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfID0gb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IGZhbHNlO1xufTtcblxuaW5oZXJpdHMoVGlsZUltYWdlLCBVcmxUaWxlKTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgIHJldHVybiBVcmxUaWxlLnByb3RvdHlwZS5jYW5FeHBpcmVDYWNoZS5jYWxsKHRoaXMpO1xuICB9XG4gIGlmICh0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2tleV0uY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUgPSBmdW5jdGlvbihwcm9qZWN0aW9uLCB1c2VkVGlsZXMpIHtcbiAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgIFVybFRpbGUucHJvdG90eXBlLmV4cGlyZUNhY2hlLmNhbGwodGhpcywgcHJvamVjdGlvbiwgdXNlZFRpbGVzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXNlZFRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcblxuICB0aGlzLnRpbGVDYWNoZS5leHBpcmVDYWNoZSh0aGlzLnRpbGVDYWNoZSA9PSB1c2VkVGlsZUNhY2hlID8gdXNlZFRpbGVzIDoge30pO1xuICBmb3IgKGNvbnN0IGlkIGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltpZF07XG4gICAgdGlsZUNhY2hlLmV4cGlyZUNhY2hlKHRpbGVDYWNoZSA9PSB1c2VkVGlsZUNhY2hlID8gdXNlZFRpbGVzIDoge30pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuVGlsZUltYWdlLnByb3RvdHlwZS5nZXRHdXR0ZXIgPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIGlmIChFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiAmJlxuICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiYgcHJvamVjdGlvbiAmJiAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbikpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHdXR0ZXJJbnRlcm5hbCgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHByb3RlY3RlZFxuICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0R3V0dGVySW50ZXJuYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuVGlsZUltYWdlLnByb3RvdHlwZS5nZXRPcGFxdWUgPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIGlmIChFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiAmJlxuICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiYgcHJvamVjdGlvbiAmJiAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFVybFRpbGUucHJvdG90eXBlLmdldE9wYXF1ZS5jYWxsKHRoaXMsIHByb2plY3Rpb24pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24gPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICByZXR1cm4gVXJsVGlsZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uLmNhbGwodGhpcywgcHJvamVjdGlvbik7XG4gIH1cbiAgY29uc3QgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgaWYgKHRoaXMudGlsZUdyaWQgJiYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pLnRvU3RyaW5nKCk7XG4gICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbikpIHtcbiAgICAgIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uW3Byb2pLZXldID0gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHshbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSAqLyAodGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0pXG4gICAgKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uKHByb2plY3Rpb24pIHtcbiAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgIHJldHVybiBVcmxUaWxlLnByb3RvdHlwZS5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uLmNhbGwodGhpcywgcHJvamVjdGlvbik7XG4gIH1cbiAgY29uc3QgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTsgaWYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkge1xuICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pLnRvU3RyaW5nKCk7XG4gICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25bcHJvaktleV0gPSBuZXcgVGlsZUNhY2hlKHRoaXMudGlsZUNhY2hlLmhpZ2hXYXRlck1hcmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW3Byb2pLZXldO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBzZXQgb24gdGhlIHRpbGUuXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL1RpbGV9IFRpbGUuXG4gKiBAcHJpdmF0ZVxuICovXG5UaWxlSW1hZ2UucHJvdG90eXBlLmNyZWF0ZVRpbGVfID0gZnVuY3Rpb24oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KSB7XG4gIGNvbnN0IHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgY29uc3QgdXJsVGlsZUNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24oXG4gICAgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKTtcbiAgY29uc3QgdGlsZVVybCA9IHVybFRpbGVDb29yZCA/XG4gICAgdGhpcy50aWxlVXJsRnVuY3Rpb24odXJsVGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdGlsZSA9IG5ldyB0aGlzLnRpbGVDbGFzcyhcbiAgICB0aWxlQ29vcmQsXG4gICAgdGlsZVVybCAhPT0gdW5kZWZpbmVkID8gVGlsZVN0YXRlLklETEUgOiBUaWxlU3RhdGUuRU1QVFksXG4gICAgdGlsZVVybCAhPT0gdW5kZWZpbmVkID8gdGlsZVVybCA6ICcnLFxuICAgIHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgIHRoaXMudGlsZU9wdGlvbnMpO1xuICB0aWxlLmtleSA9IGtleTtcbiAgbGlzdGVuKHRpbGUsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgdGhpcy5oYW5kbGVUaWxlQ2hhbmdlLCB0aGlzKTtcbiAgcmV0dXJuIHRpbGU7XG59O1xuXG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICBjb25zdCBzb3VyY2VQcm9qZWN0aW9uID0gLyoqIEB0eXBlIHshbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gKi8gKHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiB8fFxuICAgICAgIXNvdXJjZVByb2plY3Rpb24gfHwgIXByb2plY3Rpb24gfHwgZXF1aXZhbGVudChzb3VyY2VQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKSkge1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uIHx8IHByb2plY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICBsZXQgdGlsZTtcbiAgICBjb25zdCB0aWxlQ29vcmRLZXkgPSBnZXRLZXkodGlsZUNvb3JkKTtcbiAgICBpZiAoY2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgdGlsZSA9IC8qKiBAdHlwZSB7IW1vZHVsZTpvbC9UaWxlfSAqLyAoY2FjaGUuZ2V0KHRpbGVDb29yZEtleSkpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgIGlmICh0aWxlICYmIHRpbGUua2V5ID09IGtleSkge1xuICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvdXJjZVRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24oc291cmNlUHJvamVjdGlvbik7XG4gICAgICBjb25zdCB0YXJnZXRUaWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgY29uc3Qgd3JhcHBlZFRpbGVDb29yZCA9XG4gICAgICAgICAgdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwcm9qZWN0aW9uKTtcbiAgICAgIGNvbnN0IG5ld1RpbGUgPSBuZXcgUmVwcm9qVGlsZShcbiAgICAgICAgc291cmNlUHJvamVjdGlvbiwgc291cmNlVGlsZUdyaWQsXG4gICAgICAgIHByb2plY3Rpb24sIHRhcmdldFRpbGVHcmlkLFxuICAgICAgICB0aWxlQ29vcmQsIHdyYXBwZWRUaWxlQ29vcmQsIHRoaXMuZ2V0VGlsZVBpeGVsUmF0aW8ocGl4ZWxSYXRpbyksXG4gICAgICAgIHRoaXMuZ2V0R3V0dGVySW50ZXJuYWwoKSxcbiAgICAgICAgZnVuY3Rpb24oeiwgeCwgeSwgcGl4ZWxSYXRpbykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkXyxcbiAgICAgICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18pO1xuICAgICAgbmV3VGlsZS5rZXkgPSBrZXk7XG5cbiAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgIG5ld1RpbGUuaW50ZXJpbVRpbGUgPSB0aWxlO1xuICAgICAgICBuZXdUaWxlLnJlZnJlc2hJbnRlcmltQ2hhaW4oKTtcbiAgICAgICAgY2FjaGUucmVwbGFjZSh0aWxlQ29vcmRLZXksIG5ld1RpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGUuc2V0KHRpbGVDb29yZEtleSwgbmV3VGlsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3VGlsZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvVGlsZX0gVGlsZS5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlSW50ZXJuYWwgPSBmdW5jdGlvbih6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gIGxldCB0aWxlID0gbnVsbDtcbiAgY29uc3QgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5WlhZKHosIHgsIHkpO1xuICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICBpZiAoIXRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICB0aWxlID0gdGhpcy5jcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpO1xuICAgIHRoaXMudGlsZUNhY2hlLnNldCh0aWxlQ29vcmRLZXksIHRpbGUpO1xuICB9IGVsc2Uge1xuICAgIHRpbGUgPSB0aGlzLnRpbGVDYWNoZS5nZXQodGlsZUNvb3JkS2V5KTtcbiAgICBpZiAodGlsZS5rZXkgIT0ga2V5KSB7XG4gICAgICAvLyBUaGUgc291cmNlJ3MgcGFyYW1zIGNoYW5nZWQuIElmIHRoZSB0aWxlIGhhcyBhbiBpbnRlcmltIHRpbGUgYW5kIGlmIHdlXG4gICAgICAvLyBjYW4gdXNlIGl0IHRoZW4gd2UgdXNlIGl0LiBPdGhlcndpc2Ugd2UgY3JlYXRlIGEgbmV3IHRpbGUuICBJbiBib3RoXG4gICAgICAvLyBjYXNlcyB3ZSBhdHRlbXB0IHRvIGFzc2lnbiBhbiBpbnRlcmltIHRpbGUgdG8gdGhlIG5ldyB0aWxlLlxuICAgICAgY29uc3QgaW50ZXJpbVRpbGUgPSB0aWxlO1xuICAgICAgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZV8oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KTtcblxuICAgICAgLy9tYWtlIHRoZSBuZXcgdGlsZSB0aGUgaGVhZCBvZiB0aGUgbGlzdCxcbiAgICAgIGlmIChpbnRlcmltVGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgIC8vdGhlIG9sZCB0aWxlIGhhc24ndCBiZWd1biBsb2FkaW5nIHlldCwgYW5kIGlzIG5vdyBvdXRkYXRlZCwgc28gd2UgY2FuIHNpbXBseSBkaXNjYXJkIGl0XG4gICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBpbnRlcmltVGlsZS5pbnRlcmltVGlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBpbnRlcmltVGlsZTtcbiAgICAgIH1cbiAgICAgIHRpbGUucmVmcmVzaEludGVyaW1DaGFpbigpO1xuICAgICAgdGhpcy50aWxlQ2FjaGUucmVwbGFjZSh0aWxlQ29vcmRLZXksIHRpbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlsZTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHdoZXRoZXIgdG8gcmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcyBvciBub3QgKHVzdWFsbHkgZm9yIGRlYnVnZ2luZykuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlciBSZW5kZXIgdGhlIGVkZ2VzLlxuICogQGFwaVxuICovXG5UaWxlSW1hZ2UucHJvdG90eXBlLnNldFJlbmRlclJlcHJvamVjdGlvbkVkZ2VzID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gfHxcbiAgICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID09IHJlbmRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IHJlbmRlcjtcbiAgZm9yIChjb25zdCBpZCBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25baWRdLmNsZWFyKCk7XG4gIH1cbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgdGlsZSBncmlkIHRvIHVzZSB3aGVuIHJlcHJvamVjdGluZyB0aGUgdGlsZXMgdG8gdGhlIGdpdmVuXG4gKiBwcm9qZWN0aW9uIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgdGlsZSBncmlkIGZvciB0aGUgcHJvamVjdGlvbi5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGUgZGVmYXVsdCB0aWxlIGdyaWQgY2Fubm90IGJlIGNyZWF0ZWRcbiAqIChlLmcuIHByb2plY3Rpb24gaGFzIG5vIGV4dGVudCBkZWZpbmVkKSBvclxuICogZm9yIG9wdGltaXphdGlvbiByZWFzb25zIChjdXN0b20gdGlsZSBzaXplLCByZXNvbHV0aW9ucywgLi4uKS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZWdyaWQgVGlsZSBncmlkIHRvIHVzZSBmb3IgdGhlIHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cblRpbGVJbWFnZS5wcm90b3R5cGUuc2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgdGlsZWdyaWQpIHtcbiAgaWYgKEVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OKSB7XG4gICAgY29uc3QgcHJvaiA9IGdldFByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKHByb2opIHtcbiAgICAgIGNvbnN0IHByb2pLZXkgPSBnZXRVaWQocHJvaikudG9TdHJpbmcoKTtcbiAgICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24pKSB7XG4gICAgICAgIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uW3Byb2pLZXldID0gdGlsZWdyaWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvSW1hZ2VUaWxlfSBpbWFnZVRpbGUgSW1hZ2UgdGlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU291cmNlLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0VGlsZUxvYWRGdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVJbWFnZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVXJsVGlsZVxuICovXG5pbXBvcnQge2dldFVpZCwgaW5oZXJpdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7ZXhwYW5kVXJsLCBjcmVhdGVGcm9tVGVtcGxhdGVzLCBudWxsVGlsZVVybEZ1bmN0aW9ufSBmcm9tICcuLi90aWxldXJsZnVuY3Rpb24uanMnO1xuaW1wb3J0IFRpbGVTb3VyY2UsIHtUaWxlU291cmNlRXZlbnR9IGZyb20gJy4uL3NvdXJjZS9UaWxlLmpzJztcbmltcG9ydCBUaWxlRXZlbnRUeXBlIGZyb20gJy4uL3NvdXJjZS9UaWxlRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0S2V5WlhZfSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XVxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFtzdGF0ZV1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBbdGlsZUdyaWRdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb11cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFt1cmxzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl1cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgdGlsZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkIG92ZXIgaHR0cC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhYnN0cmFjdFxuICogQGZpcmVzIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUV2ZW50XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL3NvdXJjZS9UaWxlfVxuICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1VybFRpbGV+T3B0aW9ucz19IG9wdGlvbnMgSW1hZ2UgdGlsZSBvcHRpb25zLlxuICovXG5jb25zdCBVcmxUaWxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIFRpbGVTb3VyY2UuY2FsbCh0aGlzLCB7XG4gICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgIGV4dGVudDogb3B0aW9ucy5leHRlbnQsXG4gICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSxcbiAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgdGlsZUdyaWQ6IG9wdGlvbnMudGlsZUdyaWQsXG4gICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb259XG4gICAqL1xuICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24gPSBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufVxuICAgKi9cbiAgdGhpcy50aWxlVXJsRnVuY3Rpb24gPSB0aGlzLmZpeGVkVGlsZVVybEZ1bmN0aW9uID9cbiAgICB0aGlzLmZpeGVkVGlsZVVybEZ1bmN0aW9uLmJpbmQodGhpcykgOiBudWxsVGlsZVVybEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHshQXJyYXkuPHN0cmluZz58bnVsbH1cbiAgICovXG4gIHRoaXMudXJscyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMudXJscykge1xuICAgIHRoaXMuc2V0VXJscyhvcHRpb25zLnVybHMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgdGhpcy5zZXRVcmwob3B0aW9ucy51cmwpO1xuICB9XG4gIGlmIChvcHRpb25zLnRpbGVVcmxGdW5jdGlvbikge1xuICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7IU9iamVjdC48bnVtYmVyLCBib29sZWFuPn1cbiAgICovXG4gIHRoaXMudGlsZUxvYWRpbmdLZXlzXyA9IHt9O1xuXG59O1xuXG5pbmhlcml0cyhVcmxUaWxlLCBUaWxlU291cmNlKTtcblxuXG4vKipcbiAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiBAcHJvdGVjdGVkXG4gKi9cblVybFRpbGUucHJvdG90eXBlLmZpeGVkVGlsZVVybEZ1bmN0aW9uO1xuXG4vKipcbiAqIFJldHVybiB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb259IFRpbGVMb2FkRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuVXJsVGlsZS5wcm90b3R5cGUuZ2V0VGlsZUxvYWRGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50aWxlTG9hZEZ1bmN0aW9uO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgdGlsZSBVUkwgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufSBUaWxlVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuVXJsVGlsZS5wcm90b3R5cGUuZ2V0VGlsZVVybEZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRpbGVVcmxGdW5jdGlvbjtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIFVSTHMgdXNlZCBmb3IgdGhpcyBzb3VyY2UuXG4gKiBXaGVuIGEgdGlsZVVybEZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiB1cmwgb3IgdXJscyxcbiAqIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFBcnJheS48c3RyaW5nPnxudWxsfSBVUkxzLlxuICogQGFwaVxuICovXG5VcmxUaWxlLnByb3RvdHlwZS5nZXRVcmxzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnVybHM7XG59O1xuXG5cbi8qKlxuICogSGFuZGxlIHRpbGUgY2hhbmdlIGV2ZW50cy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudH0gZXZlbnQgRXZlbnQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblVybFRpbGUucHJvdG90eXBlLmhhbmRsZVRpbGVDaGFuZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICBjb25zdCB0aWxlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX0gKi8gKGV2ZW50LnRhcmdldCk7XG4gIGNvbnN0IHVpZCA9IGdldFVpZCh0aWxlKTtcbiAgY29uc3QgdGlsZVN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICBsZXQgdHlwZTtcbiAgaWYgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgIHRoaXMudGlsZUxvYWRpbmdLZXlzX1t1aWRdID0gdHJ1ZTtcbiAgICB0eXBlID0gVGlsZUV2ZW50VHlwZS5USUxFTE9BRFNUQVJUO1xuICB9IGVsc2UgaWYgKHVpZCBpbiB0aGlzLnRpbGVMb2FkaW5nS2V5c18pIHtcbiAgICBkZWxldGUgdGhpcy50aWxlTG9hZGluZ0tleXNfW3VpZF07XG4gICAgdHlwZSA9IHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgPyBUaWxlRXZlbnRUeXBlLlRJTEVMT0FERVJST1IgOlxuICAgICAgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8IHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuQUJPUlQpID9cbiAgICAgICAgVGlsZUV2ZW50VHlwZS5USUxFTE9BREVORCA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZSAhPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRpbGVTb3VyY2VFdmVudCh0eXBlLCB0aWxlKSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHRpbGUgbG9hZCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb259IHRpbGVMb2FkRnVuY3Rpb24gVGlsZSBsb2FkIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5VcmxUaWxlLnByb3RvdHlwZS5zZXRUaWxlTG9hZEZ1bmN0aW9uID0gZnVuY3Rpb24odGlsZUxvYWRGdW5jdGlvbikge1xuICB0aGlzLnRpbGVDYWNoZS5jbGVhcigpO1xuICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24gPSB0aWxlTG9hZEZ1bmN0aW9uO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHRpbGUgVVJMIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufSB0aWxlVXJsRnVuY3Rpb24gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9rZXkgT3B0aW9uYWwgbmV3IHRpbGUga2V5IGZvciB0aGUgc291cmNlLlxuICogQGFwaVxuICovXG5VcmxUaWxlLnByb3RvdHlwZS5zZXRUaWxlVXJsRnVuY3Rpb24gPSBmdW5jdGlvbih0aWxlVXJsRnVuY3Rpb24sIG9wdF9rZXkpIHtcbiAgdGhpcy50aWxlVXJsRnVuY3Rpb24gPSB0aWxlVXJsRnVuY3Rpb247XG4gIHRoaXMudGlsZUNhY2hlLnBydW5lRXhjZXB0TmV3ZXN0WigpO1xuICBpZiAodHlwZW9mIG9wdF9rZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zZXRLZXkob3B0X2tleSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIFVSTCB0byB1c2UgZm9yIHJlcXVlc3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwuXG4gKiBAYXBpXG4gKi9cblVybFRpbGUucHJvdG90eXBlLnNldFVybCA9IGZ1bmN0aW9uKHVybCkge1xuICBjb25zdCB1cmxzID0gdGhpcy51cmxzID0gZXhwYW5kVXJsKHVybCk7XG4gIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKHRoaXMuZml4ZWRUaWxlVXJsRnVuY3Rpb24gP1xuICAgIHRoaXMuZml4ZWRUaWxlVXJsRnVuY3Rpb24uYmluZCh0aGlzKSA6XG4gICAgY3JlYXRlRnJvbVRlbXBsYXRlcyh1cmxzLCB0aGlzLnRpbGVHcmlkKSwgdXJsKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIFVSTHMgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHVybHMgVVJMcy5cbiAqIEBhcGlcbiAqL1xuVXJsVGlsZS5wcm90b3R5cGUuc2V0VXJscyA9IGZ1bmN0aW9uKHVybHMpIHtcbiAgdGhpcy51cmxzID0gdXJscztcbiAgY29uc3Qga2V5ID0gdXJscy5qb2luKCdcXG4nKTtcbiAgdGhpcy5zZXRUaWxlVXJsRnVuY3Rpb24odGhpcy5maXhlZFRpbGVVcmxGdW5jdGlvbiA/XG4gICAgdGhpcy5maXhlZFRpbGVVcmxGdW5jdGlvbi5iaW5kKHRoaXMpIDpcbiAgICBjcmVhdGVGcm9tVGVtcGxhdGVzKHVybHMsIHRoaXMudGlsZUdyaWQpLCBrZXkpO1xufTtcblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblVybFRpbGUucHJvdG90eXBlLnVzZVRpbGUgPSBmdW5jdGlvbih6LCB4LCB5KSB7XG4gIGNvbnN0IHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgaWYgKHRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICB0aGlzLnRpbGVDYWNoZS5nZXQodGlsZUNvb3JkS2V5KTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IFVybFRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1hZWlxuICovXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgVGlsZUltYWdlIGZyb20gJy4uL3NvdXJjZS9UaWxlSW1hZ2UuanMnO1xuaW1wb3J0IHtjcmVhdGVYWVosIGV4dGVudEZyb21Qcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IGFyZSB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgb3IgaWYgeW91IHdhbnQgdG9cbiAqIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci4gIFNlZVxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlfSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9dHJ1ZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MThdIE9wdGlvbmFsIG1heCB6b29tIGxldmVsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE9wdGlvbmFsIG1pbiB6b29tIGxldmVsLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IFt0aWxlR3JpZF0gVGlsZSBncmlkLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpbGUgc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGhlIHRpbGUgc2l6ZSB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBnZXRcbiAqIHRpbGUgVVJMIGdpdmVuIGEgdGlsZSBjb29yZGluYXRlIGFuZCB0aGUgcHJvamVjdGlvbi5cbiAqIFJlcXVpcmVkIGlmIHVybCBvciB1cmxzIGFyZSBub3QgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gVVJMIHRlbXBsYXRlLiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCxcbiAqIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuIEEgYHs/LT99YCB0ZW1wbGF0ZSBwYXR0ZXJuLCBmb3IgZXhhbXBsZSBgc3ViZG9tYWlue2EtZn0uZG9tYWluLmNvbWAsXG4gKiBtYXkgYmUgdXNlZCBpbnN0ZWFkIG9mIGRlZmluaW5nIGVhY2ggb25lIHNlcGFyYXRlbHkgaW4gdGhlIGB1cmxzYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbdXJsc10gQW4gYXJyYXkgb2YgVVJMIHRlbXBsYXRlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBEdXJhdGlvbiBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uIGZvciByZW5kZXJpbmcuXG4gKiBUbyBkaXNhYmxlIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24sIHBhc3MgYHRyYW5zaXRpb246IDBgLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRpbGUgZGF0YSB3aXRoIFVSTHMgaW4gYSBzZXQgWFlaIGZvcm1hdCB0aGF0IGFyZVxuICogZGVmaW5lZCBpbiBhIFVSTCB0ZW1wbGF0ZS4gQnkgZGVmYXVsdCwgdGhpcyBmb2xsb3dzIHRoZSB3aWRlbHktdXNlZFxuICogR29vZ2xlIGdyaWQgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgdG9wIGxlZnQuIEdyaWRzIGxpa2VcbiAqIFRNUyB3aGVyZSBgeGAgMCBhbmQgYHlgIDAgYXJlIGluIHRoZSBib3R0b20gbGVmdCBjYW4gYmUgdXNlZCBieVxuICogdXNpbmcgdGhlIGB7LXl9YCBwbGFjZWhvbGRlciBpbiB0aGUgVVJMIHRlbXBsYXRlLCBzbyBsb25nIGFzIHRoZVxuICogc291cmNlIGRvZXMgbm90IGhhdmUgYSBjdXN0b20gdGlsZSBncmlkLiBJbiB0aGlzIGNhc2UsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlSW1hZ2V9IGNhbiBiZSB1c2VkIHdpdGggYSBgdGlsZVVybEZ1bmN0aW9uYFxuICogc3VjaCBhczpcbiAqXG4gKiAgdGlsZVVybEZ1bmN0aW9uOiBmdW5jdGlvbihjb29yZGluYXRlKSB7XG4gKiAgICByZXR1cm4gJ2h0dHA6Ly9tYXBzZXJ2ZXIuY29tLycgKyBjb29yZGluYXRlWzBdICsgJy8nICtcbiAqICAgICAgICBjb29yZGluYXRlWzFdICsgJy8nICsgY29vcmRpbmF0ZVsyXSArICcucG5nJztcbiAqICAgIH1cbiAqXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm9sL3NvdXJjZS9UaWxlSW1hZ2V9XG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvWFlafk9wdGlvbnM9fSBvcHRfb3B0aW9ucyBYWVogb3B0aW9ucy5cbiAqIEBhcGlcbiAqL1xuY29uc3QgWFlaID0gZnVuY3Rpb24ob3B0X29wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnO1xuXG4gIGNvbnN0IHRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6XG4gICAgY3JlYXRlWFlaKHtcbiAgICAgIGV4dGVudDogZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbiksXG4gICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20sXG4gICAgICBtaW5ab29tOiBvcHRpb25zLm1pblpvb20sXG4gICAgICB0aWxlU2l6ZTogb3B0aW9ucy50aWxlU2l6ZVxuICAgIH0pO1xuXG4gIFRpbGVJbWFnZS5jYWxsKHRoaXMsIHtcbiAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgY3Jvc3NPcmlnaW46IG9wdGlvbnMuY3Jvc3NPcmlnaW4sXG4gICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSxcbiAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxuICAgIHJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkOiBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkLFxuICAgIHRpbGVHcmlkOiB0aWxlR3JpZCxcbiAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgdGlsZVVybEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbixcbiAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICB3cmFwWDogb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IHRydWUsXG4gICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uXG4gIH0pO1xuXG59O1xuXG5pbmhlcml0cyhYWVosIFRpbGVJbWFnZSk7XG5leHBvcnQgZGVmYXVsdCBYWVo7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMYXRpdHVkZS9sb25naXR1ZGUgc3BoZXJpY2FsIGdlb2Rlc3kgZm9ybXVsYWUgdGFrZW4gZnJvbVxuICogaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbiAqIExpY2Vuc2VkIHVuZGVyIENDLUJZLTMuMC5cbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgb2wvc3BoZXJlXG4gKi9cbmltcG9ydCB7dG9SYWRpYW5zLCB0b0RlZ3JlZXN9IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBvcHRpb25zIGZvciB0aGUge0BsaW5rIGdldExlbmd0aH0gb3Ige0BsaW5rIGdldEFyZWF9XG4gKiBmdW5jdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcGhlcmVNZXRyaWNPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J11cbiAqIFByb2plY3Rpb24gb2YgdGhlICBnZW9tZXRyeS4gIEJ5IGRlZmF1bHQsIHRoZSBnZW9tZXRyeSBpcyBhc3N1bWVkIHRvIGJlIGluXG4gKiBXZWIgTWVyY2F0b3IuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1cz02MzcxMDA4LjhdIFNwaGVyZSByYWRpdXMuICBCeSBkZWZhdWx0LCB0aGUgcmFkaXVzIG9mIHRoZVxuICogZWFydGggaXMgdXNlZCAoQ2xhcmtlIDE4NjYgQXV0aGFsaWMgU3BoZXJlKS5cbiAqL1xuXG5cbi8qKlxuICogVGhlIG1lYW4gRWFydGggcmFkaXVzICgxLzMgKiAoMmEgKyBiKSkgZm9yIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FYXJ0aF9yYWRpdXMjTWVhbl9yYWRpdXNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JBRElVUyA9IDYzNzEwMDguODtcblxuXG4vKipcbiAqIEdldCB0aGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIChpbiBtZXRlcnMpIGJldHdlZW4gdHdvIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBjMSBTdGFydGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheX0gYzIgRW5kaW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9yYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGMxLCBjMiwgb3B0X3JhZGl1cykge1xuICBjb25zdCByYWRpdXMgPSBvcHRfcmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgY29uc3QgbGF0MiA9IHRvUmFkaWFucyhjMlsxXSk7XG4gIGNvbnN0IGRlbHRhTGF0QnkyID0gKGxhdDIgLSBsYXQxKSAvIDI7XG4gIGNvbnN0IGRlbHRhTG9uQnkyID0gdG9SYWRpYW5zKGMyWzBdIC0gYzFbMF0pIC8gMjtcbiAgY29uc3QgYSA9IE1hdGguc2luKGRlbHRhTGF0QnkyKSAqIE1hdGguc2luKGRlbHRhTGF0QnkyKSArXG4gICAgICBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKiBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKlxuICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgcmV0dXJuIDIgKiByYWRpdXMgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1bXVsYXRpdmUgZ3JlYXQgY2lyY2xlIGxlbmd0aCBvZiBsaW5lc3RyaW5nIGNvb3JkaW5hdGVzIChnZW9ncmFwaGljKS5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIExpbmVzdHJpbmcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCAoaW4gbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cykge1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWkgLSAxOyArK2kpIHtcbiAgICBsZW5ndGggKz0gZ2V0RGlzdGFuY2UoY29vcmRpbmF0ZXNbaV0sIGNvb3JkaW5hdGVzW2kgKyAxXSwgcmFkaXVzKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgbGVuZ3RoIG9mIGEgZ2VvbWV0cnkuICBUaGlzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZVxuICogZ3JlYXQgY2lyY2xlIGRpc3RhbmNlcyBiZXR3ZWVuIGNvb3JkaW5hdGVzLiAgRm9yIHBvbHlnb25zLCB0aGUgbGVuZ3RoIGlzXG4gKiB0aGUgc3VtIG9mIGFsbCByaW5ncy4gIEZvciBwb2ludHMsIHRoZSBsZW5ndGggaXMgemVyby4gIEZvciBtdWx0aS1wYXJ0XG4gKiBnZW9tZXRyaWVzLCB0aGUgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIGxlbmd0aCBvZiBlYWNoIHBhcnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSBnZW9tZXRyeSBBIGdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3BoZXJlflNwaGVyZU1ldHJpY09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zIGZvciB0aGVcbiAqIGxlbmd0aCBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoKGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT04pIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICBsZXQgbGVuZ3RoID0gMDtcbiAgbGV0IGNvb3JkaW5hdGVzLCBjb29yZHMsIGksIGlpLCBqLCBqajtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6IHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FQVJfUklORzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBsZW5ndGggPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXNbaV0sIHJhZGl1cyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRzW2pdLCByYWRpdXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTjoge1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAoZ2VvbWV0cnkpLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGgoZ2VvbWV0cmllc1tpXSwgb3B0X29wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3BoZXJpY2FsIGFyZWEgZm9yIGEgbGlzdCBvZiBjb29yZGluYXRlcy5cbiAqXG4gKiBbUmVmZXJlbmNlXShodHRwczovL3Rycy1uZXcuanBsLm5hc2EuZ292L2hhbmRsZS8yMDE0LzQwNDA5KVxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yXG4gKiBQb2x5Z29ucyBvbiBhIFNwaGVyZVwiLCBKUEwgUHVibGljYXRpb24gMDctMDMsIEpldCBQcm9wdWxzaW9uXG4gKiBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwN1xuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBMaXN0IG9mIGNvb3JkaW5hdGVzIG9mIGEgbGluZWFyXG4gKiByaW5nLiBJZiB0aGUgcmluZyBpcyBvcmllbnRlZCBjbG9ja3dpc2UsIHRoZSBhcmVhIHdpbGwgYmUgcG9zaXRpdmUsXG4gKiBvdGhlcndpc2UgaXQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKGluIHNxdWFyZSBtZXRlcnMpLlxuICovXG5mdW5jdGlvbiBnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cykge1xuICBsZXQgYXJlYSA9IDA7XG4gIGNvbnN0IGxlbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgbGV0IHgxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMF07XG4gIGxldCB5MSA9IGNvb3JkaW5hdGVzW2xlbiAtIDFdWzFdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgeDIgPSBjb29yZGluYXRlc1tpXVswXTtcbiAgICBjb25zdCB5MiA9IGNvb3JkaW5hdGVzW2ldWzFdO1xuICAgIGFyZWEgKz0gdG9SYWRpYW5zKHgyIC0geDEpICpcbiAgICAgICAgKDIgKyBNYXRoLnNpbih0b1JhZGlhbnMoeTEpKSArXG4gICAgICAgIE1hdGguc2luKHRvUmFkaWFucyh5MikpKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIGFyZWEgKiByYWRpdXMgKiByYWRpdXMgLyAyLjA7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHNwaGVyaWNhbCBhcmVhIG9mIGEgZ2VvbWV0cnkuICBUaGlzIGlzIHRoZSBhcmVhIChpbiBtZXRlcnMpIGFzc3VtaW5nXG4gKiB0aGF0IHBvbHlnb24gZWRnZXMgYXJlIHNlZ21lbnRzIG9mIGdyZWF0IGNpcmNsZXMgb24gYSBzcGhlcmUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSBnZW9tZXRyeSBBIGdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3BoZXJlflNwaGVyZU1ldHJpY09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYXJlYVxuICogICAgIGNhbGN1bGF0aW9uLiAgQnkgZGVmYXVsdCwgZ2VvbWV0cmllcyBhcmUgYXNzdW1lZCB0byBiZSBpbiAnRVBTRzozODU3Jy5cbiAqICAgICBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgYXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT04pIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVBUl9SSU5HOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1BvbHlnb259ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGFyZWEgPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXNbMF0sIHJhZGl1cykpO1xuICAgICAgZm9yIChpID0gMSwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRzWzBdLCByYWRpdXMpKTtcbiAgICAgICAgZm9yIChqID0gMSwgamogPSBjb29yZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OOiB7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb259ICovIChnZW9tZXRyeSkuZ2V0R2VvbWV0cmllcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgYXJlYSArPSBnZXRBcmVhKGdlb21ldHJpZXNbaV0sIG9wdF9vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGF0IHRoZSBnaXZlbiBkaXN0YW5jZSBhbmQgYmVhcmluZyBmcm9tIGBjMWAuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjMSBUaGUgb3JpZ2luIHBvaW50IChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvcmlnaW5cbiAqICAgICBwb2ludCBhbmQgdGhlIHRhcmdldCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBiZWFyaW5nIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3JhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBUaGUgdGFyZ2V0IHBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0KGMxLCBkaXN0YW5jZSwgYmVhcmluZywgb3B0X3JhZGl1cykge1xuICBjb25zdCByYWRpdXMgPSBvcHRfcmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgY29uc3QgbG9uMSA9IHRvUmFkaWFucyhjMVswXSk7XG4gIGNvbnN0IGRCeVIgPSBkaXN0YW5jZSAvIHJhZGl1cztcbiAgY29uc3QgbGF0ID0gTWF0aC5hc2luKFxuICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MoZEJ5UikgK1xuICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGJlYXJpbmcpKTtcbiAgY29uc3QgbG9uID0gbG9uMSArIE1hdGguYXRhbjIoXG4gICAgTWF0aC5zaW4oYmVhcmluZykgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGxhdDEpLFxuICAgIE1hdGguY29zKGRCeVIpIC0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQpKTtcbiAgcmV0dXJuIFt0b0RlZ3JlZXMobG9uKSwgdG9EZWdyZWVzKGxhdCldO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvTFJVQ2FjaGVcbiAqL1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9FdmVudFRhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRW50cnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlfXG4gKiBAcHJvcGVydHkge09iamVjdH0gbmV3ZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvbGRlclxuICogQHByb3BlcnR5IHsqfSB2YWx1ZV9cbiAqL1xuXG5cbi8qKlxuICogSW1wbGVtZW50cyBhIExlYXN0LVJlY2VudGx5LVVzZWQgY2FjaGUgd2hlcmUgdGhlIGtleXMgZG8gbm90IGNvbmZsaWN0IHdpdGhcbiAqIE9iamVjdCdzIHByb3BlcnRpZXMgKGUuZy4gJ2hhc093blByb3BlcnR5JyBpcyBub3QgYWxsb3dlZCBhcyBhIGtleSkuIEV4cGlyaW5nXG4gKiBpdGVtcyBmcm9tIHRoZSBjYWNoZSBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHVzZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fVxuICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+RXZlbnRcbiAqIEBzdHJ1Y3RcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9oaWdoV2F0ZXJNYXJrIEhpZ2ggd2F0ZXIgbWFyay5cbiAqL1xuY29uc3QgTFJVQ2FjaGUgPSBmdW5jdGlvbihvcHRfaGlnaFdhdGVyTWFyaykge1xuXG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBvcHRfaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gb3B0X2hpZ2hXYXRlck1hcmsgOiAyMDQ4O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5jb3VudF8gPSAwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZX5FbnRyeT59XG4gICAqL1xuICB0aGlzLmVudHJpZXNfID0ge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHs/bW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGV+RW50cnl9XG4gICAqL1xuICB0aGlzLm9sZGVzdF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7P21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fVxuICAgKi9cbiAgdGhpcy5uZXdlc3RfID0gbnVsbDtcblxufTtcblxuaW5oZXJpdHMoTFJVQ2FjaGUsIEV2ZW50VGFyZ2V0KTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5jYW5FeHBpcmVDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXRDb3VudCgpID4gdGhpcy5oaWdoV2F0ZXJNYXJrO1xufTtcblxuXG4vKipcbiAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb3VudF8gPSAwO1xuICB0aGlzLmVudHJpZXNfID0ge307XG4gIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gIHRoaXMubmV3ZXN0XyA9IG51bGw7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0xFQVIpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMga2V5LlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuY29udGFpbnNLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIHRoaXMuZW50cmllc18uaGFzT3duUHJvcGVydHkoa2V5KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQsIHN0cmluZywgbW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGUpOiA/fSBmIFRoZSBmdW5jdGlvblxuICogICAgIHRvIGNhbGwgZm9yIGV2ZXJ5IGVudHJ5IGZyb20gdGhlIG9sZGVzdCB0byB0aGUgbmV3ZXIuIFRoaXMgZnVuY3Rpb24gdGFrZXNcbiAqICAgICAzIGFyZ3VtZW50cyAodGhlIGVudHJ5IHZhbHVlLCB0aGUgZW50cnkga2V5IGFuZCB0aGUgTFJVQ2FjaGUgb2JqZWN0KS5cbiAqICAgICBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gKiBAcGFyYW0ge1M9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYGZgLlxuICogQHRlbXBsYXRlIFNcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmLCBvcHRfdGhpcykge1xuICBsZXQgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIGYuY2FsbChvcHRfdGhpcywgZW50cnkudmFsdWVfLCBlbnRyeS5rZXlfLCB0aGlzKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5ld2VyO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gKiBAcmV0dXJuIHtUfSBWYWx1ZS5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgYXNzZXJ0KGVudHJ5ICE9PSB1bmRlZmluZWQsXG4gICAgMTUpOyAvLyBUcmllZCB0byBnZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgaWYgKGVudHJ5ID09PSB0aGlzLm5ld2VzdF8pIHtcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fSAqLyAodGhpcy5vbGRlc3RfLm5ld2VyKTtcbiAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7XG4gICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgfVxuICBlbnRyeS5uZXdlciA9IG51bGw7XG4gIGVudHJ5Lm9sZGVyID0gdGhpcy5uZXdlc3RfO1xuICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBlbnRyeTtcbiAgdGhpcy5uZXdlc3RfID0gZW50cnk7XG4gIHJldHVybiBlbnRyeS52YWx1ZV87XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgZW50cnkga2V5LlxuICogQHJldHVybiB7VH0gVGhlIHJlbW92ZWQgZW50cnkuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHtcbiAgY29uc3QgZW50cnkgPSB0aGlzLmVudHJpZXNfW2tleV07XG4gIGFzc2VydChlbnRyeSAhPT0gdW5kZWZpbmVkLCAxNSk7IC8vIFRyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZVxuICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgIHRoaXMubmV3ZXN0XyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGV+RW50cnl9ICovIChlbnRyeS5vbGRlcik7XG4gICAgaWYgKHRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGV+RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gICAgaWYgKHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyO1xuICB9XG4gIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2tleV07XG4gIC0tdGhpcy5jb3VudF87XG4gIHJldHVybiBlbnRyeS52YWx1ZV87XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBDb3VudC5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvdW50Xztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gS2V5cy5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qga2V5cyA9IG5ldyBBcnJheSh0aGlzLmNvdW50Xyk7XG4gIGxldCBpID0gMDtcbiAgbGV0IGVudHJ5O1xuICBmb3IgKGVudHJ5ID0gdGhpcy5uZXdlc3RfOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5vbGRlcikge1xuICAgIGtleXNbaSsrXSA9IGVudHJ5LmtleV87XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7QXJyYXkuPFQ+fSBWYWx1ZXMuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuY291bnRfKTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgZW50cnk7XG4gIGZvciAoZW50cnkgPSB0aGlzLm5ld2VzdF87IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm9sZGVyKSB7XG4gICAgdmFsdWVzW2krK10gPSBlbnRyeS52YWx1ZV87XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtUfSBMYXN0IHZhbHVlLlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUucGVla0xhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub2xkZXN0Xy52YWx1ZV87XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBMYXN0IGtleS5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWtMYXN0S2V5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9sZGVzdF8ua2V5Xztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGtleSBvZiB0aGUgbmV3ZXN0IGl0ZW0gaW4gdGhlIGNhY2hlLiAgVGhyb3dzIGlmIHRoZSBjYWNoZSBpcyBlbXB0eS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5ld2VzdCBrZXkuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5wZWVrRmlyc3RLZXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubmV3ZXN0Xy5rZXlfO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge1R9IHZhbHVlIFZhbHVlLlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICBkZWxldGUgdGhpcy5lbnRyaWVzX1tlbnRyeS5rZXlfXTtcbiAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBudWxsO1xuICB9XG4gIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGV+RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gIGlmICghdGhpcy5vbGRlc3RfKSB7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgfVxuICAtLXRoaXMuY291bnRfO1xuICByZXR1cm4gZW50cnkudmFsdWVfO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gIHRoaXMuZ2V0KGtleSk7ICAvLyB1cGRhdGUgYG5ld2VzdF9gXG4gIHRoaXMuZW50cmllc19ba2V5XS52YWx1ZV8gPSB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gIGFzc2VydCghKGtleSBpbiB0aGlzLmVudHJpZXNfKSxcbiAgICAxNik7IC8vIFRyaWVkIHRvIHNldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGlzIHVzZWQgYWxyZWFkeVxuICBjb25zdCBlbnRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGV+RW50cnl9ICovICh7XG4gICAga2V5Xzoga2V5LFxuICAgIG5ld2VyOiBudWxsLFxuICAgIG9sZGVyOiB0aGlzLm5ld2VzdF8sXG4gICAgdmFsdWVfOiB2YWx1ZVxuICB9KTtcbiAgaWYgKCF0aGlzLm5ld2VzdF8pIHtcbiAgICB0aGlzLm9sZGVzdF8gPSBlbnRyeTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBlbnRyeTtcbiAgfVxuICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgdGhpcy5lbnRyaWVzX1trZXldID0gZW50cnk7XG4gICsrdGhpcy5jb3VudF87XG59O1xuXG5cbi8qKlxuICogU2V0IGEgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBmb3IgdGhlIGNhY2hlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQ2FjaGUgc2l6ZS5cbiAqIEBhcGlcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IHNpemU7XG59O1xuXG5cbi8qKlxuICogUHJ1bmUgdGhlIGNhY2hlLlxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUucHJ1bmUgPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgIHRoaXMucG9wKCk7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBMUlVDYWNoZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlY29vcmRcbiAqL1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgdGhyZWUgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgdGlsZSBpbiBhIHRpbGVcbiAqIGdyaWQuIFRoZSBvcmRlciBpcyBgemAsIGB4YCwgYW5kIGB5YC4gYHpgIGlzIHRoZSB6b29tIGxldmVsLlxuICogQHR5cGVkZWYge0FycmF5LjxudW1iZXI+fSBUaWxlQ29vcmRcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKHosIHgsIHksIG9wdF90aWxlQ29vcmQpIHtcbiAgaWYgKG9wdF90aWxlQ29vcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIG9wdF90aWxlQ29vcmRbMF0gPSB6O1xuICAgIG9wdF90aWxlQ29vcmRbMV0gPSB4O1xuICAgIG9wdF90aWxlQ29vcmRbMl0gPSB5O1xuICAgIHJldHVybiBvcHRfdGlsZUNvb3JkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbeiwgeCwgeV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5WlhZKHosIHgsIHkpIHtcbiAgcmV0dXJuIHogKyAnLycgKyB4ICsgJy8nICsgeTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUga2V5IGZvciBhIHRpbGUgY29vcmQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGhlIHRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleSh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIGdldEtleVpYWSh0aWxlQ29vcmRbMF0sIHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdKTtcbn1cblxuXG4vKipcbiAqIEdldCBhIHRpbGUgY29vcmQgZ2l2ZW4gYSBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSB0aWxlIGNvb3JkIGtleS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkLlxuICogQHJldHVybiB7bnVtYmVyfSBIYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaCh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuICh0aWxlQ29vcmRbMV0gPDwgdGlsZUNvb3JkWzBdKSArIHRpbGVDb29yZFsyXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkLlxuICogQHJldHVybiB7c3RyaW5nfSBRdWFkIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRLZXkodGlsZUNvb3JkKSB7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIGNvbnN0IGRpZ2l0cyA9IG5ldyBBcnJheSh6KTtcbiAgbGV0IG1hc2sgPSAxIDw8ICh6IC0gMSk7XG4gIGxldCBpLCBjaGFyQ29kZTtcbiAgZm9yIChpID0gMDsgaSA8IHo7ICsraSkge1xuICAgIC8vIDQ4IGlzIGNoYXJDb2RlIGZvciAwIC0gJzAnLmNoYXJDb2RlQXQoMClcbiAgICBjaGFyQ29kZSA9IDQ4O1xuICAgIGlmICh0aWxlQ29vcmRbMV0gJiBtYXNrKSB7XG4gICAgICBjaGFyQ29kZSArPSAxO1xuICAgIH1cbiAgICBpZiAodGlsZUNvb3JkWzJdICYgbWFzaykge1xuICAgICAgY2hhckNvZGUgKz0gMjtcbiAgICB9XG4gICAgZGlnaXRzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgbWFzayA+Pj0gMTtcbiAgfVxuICByZXR1cm4gZGlnaXRzLmpvaW4oJycpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBjb29yZGluYXRlIGlzIHdpdGhpbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpIHtcbiAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgY29uc3QgeCA9IHRpbGVDb29yZFsxXTtcbiAgY29uc3QgeSA9IHRpbGVDb29yZFsyXTtcblxuICBpZiAodGlsZUdyaWQuZ2V0TWluWm9vbSgpID4geiB8fCB6ID4gdGlsZUdyaWQuZ2V0TWF4Wm9vbSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGV4dGVudCA9IHRpbGVHcmlkLmdldEV4dGVudCgpO1xuICBsZXQgdGlsZVJhbmdlO1xuICBpZiAoIWV4dGVudCkge1xuICAgIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gIH0gZWxzZSB7XG4gICAgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICB9XG4gIGlmICghdGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbGVSYW5nZS5jb250YWluc1hZKHgsIHkpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWdyaWRcbiAqL1xuaW1wb3J0IHtERUZBVUxUX01BWF9aT09NLCBERUZBVUxUX1RJTEVfU0laRX0gZnJvbSAnLi90aWxlZ3JpZC9jb21tb24uanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4vc2l6ZS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zQ29vcmRpbmF0ZSwgY3JlYXRlT3JVcGRhdGUsIGdldENvcm5lciwgZ2V0SGVpZ2h0LCBnZXRXaWR0aH0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IENvcm5lciBmcm9tICcuL2V4dGVudC9Db3JuZXIuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4vb2JqLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb24sIE1FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IFRpbGVHcmlkIGZyb20gJy4vdGlsZWdyaWQvVGlsZUdyaWQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBEZWZhdWx0IHRpbGUgZ3JpZCBmb3IgdGhlXG4gKiBwYXNzZWQgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBsZXQgdGlsZUdyaWQgPSBwcm9qZWN0aW9uLmdldERlZmF1bHRUaWxlR3JpZCgpO1xuICBpZiAoIXRpbGVHcmlkKSB7XG4gICAgdGlsZUdyaWQgPSBjcmVhdGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIHByb2plY3Rpb24uc2V0RGVmYXVsdFRpbGVHcmlkKHRpbGVHcmlkKTtcbiAgfVxuICByZXR1cm4gdGlsZUdyaWQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKHRpbGVHcmlkLCB0aWxlQ29vcmQsIHByb2plY3Rpb24pIHtcbiAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgY29uc3QgY2VudGVyID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGVDb29yZCk7XG4gIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgaWYgKCFjb250YWluc0Nvb3JkaW5hdGUocHJvamVjdGlvbkV4dGVudCwgY2VudGVyKSkge1xuICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICBjb25zdCB3b3JsZHNBd2F5ID0gTWF0aC5jZWlsKChwcm9qZWN0aW9uRXh0ZW50WzBdIC0gY2VudGVyWzBdKSAvIHdvcmxkV2lkdGgpO1xuICAgIGNlbnRlclswXSArPSB3b3JsZFdpZHRoICogd29ybGRzQXdheTtcbiAgICByZXR1cm4gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNlbnRlciwgeik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbGVDb29yZDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heFpvb20gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplPX0gb3B0X3RpbGVTaXplIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50L0Nvcm5lcj19IG9wdF9jb3JuZXIgRXh0ZW50IGNvcm5lciAoZGVmYXVsdCBpcyBgJ3RvcC1sZWZ0J2ApLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gVGlsZUdyaWQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JFeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplLCBvcHRfY29ybmVyKSB7XG4gIGNvbnN0IGNvcm5lciA9IG9wdF9jb3JuZXIgIT09IHVuZGVmaW5lZCA/IG9wdF9jb3JuZXIgOiBDb3JuZXIuVE9QX0xFRlQ7XG5cbiAgY29uc3QgcmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplKTtcblxuICByZXR1cm4gbmV3IFRpbGVHcmlkKHtcbiAgICBleHRlbnQ6IGV4dGVudCxcbiAgICBvcmlnaW46IGdldENvcm5lcihleHRlbnQsIGNvcm5lciksXG4gICAgcmVzb2x1dGlvbnM6IHJlc29sdXRpb25zLFxuICAgIHRpbGVTaXplOiBvcHRfdGlsZVNpemVcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYWVpPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIFRoZSBvcmlnaW4gZm9yIGFuIFhZWiB0aWxlIGdyaWQgaXMgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gVGhlIHplcm8gbGV2ZWwgb2YgdGhlIGdyaWQgaXMgZGVmaW5lZCBieSB0aGUgcmVzb2x1dGlvbiBhdCB3aGljaCBvbmUgdGlsZSBmaXRzIGluIHRoZVxuICogcHJvdmlkZWQgZXh0ZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBleHRlbnQgb2YgdGhlIEVQU0c6Mzg1NyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbS4gVGhlIGRlZmF1bHQgaXMgYDQyYC4gVGhpcyBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzXG4gKiBpbiB0aGUgZ3JpZCBzZXQuIEZvciBleGFtcGxlLCBhIGBtYXhab29tYCBvZiAyMSBtZWFucyB0aGVyZSBhcmUgMjIgbGV2ZWxzIGluIHRoZSBncmlkIHNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGlsZSBzaXplIGluIHBpeGVscy5cbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHRpbGUgZ3JpZCB3aXRoIGEgc3RhbmRhcmQgWFlaIHRpbGluZyBzY2hlbWUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZH5YWVpPcHRpb25zPX0gb3B0X29wdGlvbnMgVGlsZSBncmlkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBUaWxlIGdyaWQgaW5zdGFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVYWVoob3B0X29wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfk9wdGlvbnN9ICovICh7fSk7XG4gIGFzc2lnbihvcHRpb25zLCBvcHRfb3B0aW9ucyAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfb3B0aW9ucyA6IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVncmlkflhZWk9wdGlvbnN9ICovICh7fSkpO1xuICBpZiAob3B0aW9ucy5leHRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZXh0ZW50ID0gZ2V0UHJvamVjdGlvbignRVBTRzozODU3JykuZ2V0RXh0ZW50KCk7XG4gIH1cbiAgb3B0aW9ucy5yZXNvbHV0aW9ucyA9IHJlc29sdXRpb25zRnJvbUV4dGVudChcbiAgICBvcHRpb25zLmV4dGVudCwgb3B0aW9ucy5tYXhab29tLCBvcHRpb25zLnRpbGVTaXplKTtcbiAgZGVsZXRlIG9wdGlvbnMubWF4Wm9vbTtcblxuICByZXR1cm4gbmV3IFRpbGVHcmlkKG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgcmVzb2x1dGlvbnMgYXJyYXkgZnJvbSBhbiBleHRlbnQuICBBIHpvb20gZmFjdG9yIG9mIDIgaXMgYXNzdW1lZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9tYXhab29tIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEByZXR1cm4geyFBcnJheS48bnVtYmVyPn0gUmVzb2x1dGlvbnMgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdXRpb25zRnJvbUV4dGVudChleHRlbnQsIG9wdF9tYXhab29tLCBvcHRfdGlsZVNpemUpIHtcbiAgY29uc3QgbWF4Wm9vbSA9IG9wdF9tYXhab29tICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdF9tYXhab29tIDogREVGQVVMVF9NQVhfWk9PTTtcblxuICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgY29uc3Qgd2lkdGggPSBnZXRXaWR0aChleHRlbnQpO1xuXG4gIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKG9wdF90aWxlU2l6ZSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfdGlsZVNpemUgOiBERUZBVUxUX1RJTEVfU0laRSk7XG4gIGNvbnN0IG1heFJlc29sdXRpb24gPSBNYXRoLm1heChcbiAgICB3aWR0aCAvIHRpbGVTaXplWzBdLCBoZWlnaHQgLyB0aWxlU2l6ZVsxXSk7XG5cbiAgY29uc3QgbGVuZ3RoID0gbWF4Wm9vbSArIDE7XG4gIGNvbnN0IHJlc29sdXRpb25zID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IHogPSAwOyB6IDwgbGVuZ3RoOyArK3opIHtcbiAgICByZXNvbHV0aW9uc1t6XSA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdygyLCB6KTtcbiAgfVxuICByZXR1cm4gcmVzb2x1dGlvbnM7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9tYXhab29tIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudC9Db3JuZXI9fSBvcHRfY29ybmVyIEV4dGVudCBjb3JuZXIgKGRlZmF1bHQgaXMgYCd0b3AtbGVmdCdgKS5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uLCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplLCBvcHRfY29ybmVyKSB7XG4gIGNvbnN0IGV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICByZXR1cm4gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcik7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRpbGUgZ3JpZCBleHRlbnQgZnJvbSBhIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBoYXMgYW5cbiAqIGV4dGVudCwgaXQgaXMgdXNlZC4gIElmIG5vdCwgYSBnbG9iYWwgZXh0ZW50IGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgbGV0IGV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGlmICghZXh0ZW50KSB7XG4gICAgY29uc3QgaGFsZiA9IDE4MCAqIE1FVEVSU19QRVJfVU5JVFtVbml0cy5ERUdSRUVTXSAvIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlKC1oYWxmLCAtaGFsZiwgaGFsZiwgaGFsZik7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9UaWxlR3JpZFxuICovXG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlLCB7Y3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2V9IGZyb20gJy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQge2lzU29ydGVkLCBsaW5lYXJGaW5kTmVhcmVzdH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZ2V0VG9wTGVmdH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZH0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IFtleHRlbnRdIEV4dGVudCBmb3IgdGhlIHRpbGUgZ3JpZC4gTm8gdGlsZXMgb3V0c2lkZSB0aGlzXG4gKiBleHRlbnQgd2lsbCBiZSByZXF1ZXN0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX0gc291cmNlcy4gV2hlbiBubyBgb3JpZ2luYCBvclxuICogYG9yaWdpbnNgIGFyZSBjb25maWd1cmVkLCB0aGUgYG9yaWdpbmAgd2lsbCBiZSBzZXQgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gW29yaWdpbl0gVGhlIHRpbGUgZ3JpZCBvcmlnaW4sIGkuZS4gd2hlcmUgdGhlIGB4YFxuICogYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKS4gVGlsZSBjb29yZGluYXRlcyBpbmNyZWFzZSBsZWZ0IHRvIHJpZ2h0IGFuZCB1cHdhcmRzLiBJZiBub3RcbiAqIHNwZWNpZmllZCwgYGV4dGVudGAgb3IgYG9yaWdpbnNgIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gW29yaWdpbnNdIFRpbGUgZ3JpZCBvcmlnaW5zLCBpLmUuIHdoZXJlXG4gKiB0aGUgYHhgIGFuZCBgeWAgYXhlcyBtZWV0IChgW3osIDAsIDBdYCksIGZvciBlYWNoIHpvb20gbGV2ZWwuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIG9yaWdpbi4gVGlsZSBjb29yZGluYXRlcyBpbmNyZWFzZSBsZWZ0IHRvIHJpZ2h0IGFuZCB1cHdhcmRzLiBJZiBub3Qgc3BlY2lmaWVkLCBgZXh0ZW50YCBvclxuICogYG9yaWdpbmAgbXVzdCBiZSBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5LjxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy4gVGhlIGFycmF5IGluZGV4IG9mIGVhY2ggcmVzb2x1dGlvbiBuZWVkc1xuICogdG8gbWF0Y2ggdGhlIHpvb20gbGV2ZWwuIFRoaXMgbWVhbnMgdGhhdCBldmVuIGlmIGEgYG1pblpvb21gIGlzIGNvbmZpZ3VyZWQsIHRoZSByZXNvbHV0aW9uc1xuICogYXJyYXkgd2lsbCBoYXZlIGEgbGVuZ3RoIG9mIGBtYXhab29tICsgMWAuXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvc2l6ZX5TaXplPn0gW3NpemVzXSBTaXplcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplLlxuICogRGVmYXVsdCBpcyBgWzI1NiwgMjU2XWAuXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvc2l6ZX5TaXplPn0gW3RpbGVTaXplc10gVGlsZSBzaXplcy4gSWYgZ2l2ZW4sIHRoZSBhcnJheSBsZW5ndGhcbiAqIHNob3VsZCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBgcmVzb2x1dGlvbnNgIGFycmF5LCBpLmUuIGVhY2ggcmVzb2x1dGlvbiBjYW4gaGF2ZSBhIGRpZmZlcmVudFxuICogdGlsZSBzaXplLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciBzZXR0aW5nIHRoZSBncmlkIHBhdHRlcm4gZm9yIHNvdXJjZXMgYWNjZXNzaW5nIHRpbGVkLWltYWdlXG4gKiBzZXJ2ZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR+T3B0aW9uc30gb3B0aW9ucyBUaWxlIGdyaWQgb3B0aW9ucy5cbiAqIEBzdHJ1Y3RcbiAqIEBhcGlcbiAqL1xuY29uc3QgVGlsZUdyaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5ab29tIDogMDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRoaXMucmVzb2x1dGlvbnNfID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgYXNzZXJ0KGlzU29ydGVkKHRoaXMucmVzb2x1dGlvbnNfLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhO1xuICB9LCB0cnVlKSwgMTcpOyAvLyBgcmVzb2x1dGlvbnNgIG11c3QgYmUgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXJcblxuXG4gIC8vIGNoZWNrIGlmIHdlJ3ZlIGdvdCBhIGNvbnNpc3RlbnQgem9vbSBmYWN0b3IgYW5kIG9yaWdpblxuICBsZXQgem9vbUZhY3RvcjtcbiAgaWYgKCFvcHRpb25zLm9yaWdpbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKCF6b29tRmFjdG9yKSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSB0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXSAhPT0gem9vbUZhY3Rvcikge1xuICAgICAgICAgIHpvb21GYWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuem9vbUZhY3Rvcl8gPSB6b29tRmFjdG9yO1xuXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4Wm9vbSA9IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDE7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfVxuICAgKi9cbiAgdGhpcy5vcmlnaW5fID0gb3B0aW9ucy5vcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3JpZ2luIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn1cbiAgICovXG4gIHRoaXMub3JpZ2luc18gPSBudWxsO1xuICBpZiAob3B0aW9ucy5vcmlnaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLm9yaWdpbnNfID0gb3B0aW9ucy5vcmlnaW5zO1xuICAgIGFzc2VydCh0aGlzLm9yaWdpbnNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAyMCk7IC8vIE51bWJlciBvZiBgb3JpZ2luc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbFxuICB9XG5cbiAgY29uc3QgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQ7XG5cbiAgaWYgKGV4dGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhdGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSB7XG4gICAgdGhpcy5vcmlnaW5fID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICB9XG5cbiAgYXNzZXJ0KFxuICAgICghdGhpcy5vcmlnaW5fICYmIHRoaXMub3JpZ2luc18pIHx8ICh0aGlzLm9yaWdpbl8gJiYgIXRoaXMub3JpZ2luc18pLFxuICAgIDE4KTsgLy8gRWl0aGVyIGBvcmlnaW5gIG9yIGBvcmlnaW5zYCBtdXN0IGJlIGNvbmZpZ3VyZWQsIG5ldmVyIGJvdGhcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZT59XG4gICAqL1xuICB0aGlzLnRpbGVTaXplc18gPSBudWxsO1xuICBpZiAob3B0aW9ucy50aWxlU2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudGlsZVNpemVzXyA9IG9wdGlvbnMudGlsZVNpemVzO1xuICAgIGFzc2VydCh0aGlzLnRpbGVTaXplc18ubGVuZ3RoID09IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCxcbiAgICAgIDE5KTsgLy8gTnVtYmVyIG9mIGB0aWxlU2l6ZXNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemV9XG4gICAqL1xuICB0aGlzLnRpbGVTaXplXyA9IG9wdGlvbnMudGlsZVNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy50aWxlU2l6ZSA6XG4gICAgIXRoaXMudGlsZVNpemVzXyA/IERFRkFVTFRfVElMRV9TSVpFIDogbnVsbDtcbiAgYXNzZXJ0KFxuICAgICghdGhpcy50aWxlU2l6ZV8gJiYgdGhpcy50aWxlU2l6ZXNfKSB8fFxuICAgICAgKHRoaXMudGlsZVNpemVfICYmICF0aGlzLnRpbGVTaXplc18pLFxuICAgIDIyKTsgLy8gRWl0aGVyIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAgICovXG4gIHRoaXMuZXh0ZW50XyA9IGV4dGVudCAhPT0gdW5kZWZpbmVkID8gZXh0ZW50IDogbnVsbDtcblxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9UaWxlUmFuZ2U+fVxuICAgKi9cbiAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3NpemV+U2l6ZX1cbiAgICovXG4gIHRoaXMudG1wU2l6ZV8gPSBbMCwgMF07XG5cbiAgaWYgKG9wdGlvbnMuc2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gb3B0aW9ucy5zaXplcy5tYXAoZnVuY3Rpb24oc2l6ZSwgeikge1xuICAgICAgY29uc3QgdGlsZVJhbmdlID0gbmV3IFRpbGVSYW5nZShcbiAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVswXSksIE1hdGgubWF4KHNpemVbMF0gLSAxLCAtMSksXG4gICAgICAgIE1hdGgubWluKDAsIHNpemVbMV0pLCBNYXRoLm1heChzaXplWzFdIC0gMSwgLTEpKTtcbiAgICAgIHJldHVybiB0aWxlUmFuZ2U7XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAoZXh0ZW50KSB7XG4gICAgdGhpcy5jYWxjdWxhdGVUaWxlUmFuZ2VzXyhleHRlbnQpO1xuICB9XG5cbn07XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfVxuICovXG5jb25zdCB0bXBUaWxlQ29vcmQgPSBbMCwgMCwgMF07XG5cblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQpfSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmZvckVhY2hUaWxlQ29vcmQgPSBmdW5jdGlvbihleHRlbnQsIHpvb20sIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHpvb20pO1xuICBmb3IgKGxldCBpID0gdGlsZVJhbmdlLm1pblgsIGlpID0gdGlsZVJhbmdlLm1heFg7IGkgPD0gaWk7ICsraSkge1xuICAgIGZvciAobGV0IGogPSB0aWxlUmFuZ2UubWluWSwgamogPSB0aWxlUmFuZ2UubWF4WTsgaiA8PSBqajsgKytqKSB7XG4gICAgICBjYWxsYmFjayhbem9vbSwgaSwgal0pO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIG51bWJlciwgbW9kdWxlOm9sL1RpbGVSYW5nZSk6IGJvb2xlYW59IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHtUPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBjYWxsYmFja2AuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2U9fSBvcHRfdGlsZVJhbmdlIFRlbXBvcmFyeSBtb2R1bGU6b2wvVGlsZVJhbmdlIG9iamVjdC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudCBvYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDYWxsYmFjayBzdWNjZWVkZWQuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZSA9IGZ1bmN0aW9uKHRpbGVDb29yZCwgY2FsbGJhY2ssIG9wdF90aGlzLCBvcHRfdGlsZVJhbmdlLCBvcHRfZXh0ZW50KSB7XG4gIGxldCB0aWxlUmFuZ2UsIHgsIHk7XG4gIGxldCB0aWxlQ29vcmRFeHRlbnQgPSBudWxsO1xuICBsZXQgeiA9IHRpbGVDb29yZFswXSAtIDE7XG4gIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgeCA9IHRpbGVDb29yZFsxXTtcbiAgICB5ID0gdGlsZUNvb3JkWzJdO1xuICB9IGVsc2Uge1xuICAgIHRpbGVDb29yZEV4dGVudCA9IHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgb3B0X2V4dGVudCk7XG4gIH1cbiAgd2hpbGUgKHogPj0gdGhpcy5taW5ab29tKSB7XG4gICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICAgIHggPSBNYXRoLmZsb29yKHggLyAyKTtcbiAgICAgIHkgPSBNYXRoLmZsb29yKHkgLyAyKTtcbiAgICAgIHRpbGVSYW5nZSA9IGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKHgsIHgsIHksIHksIG9wdF90aWxlUmFuZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFoodGlsZUNvb3JkRXh0ZW50LCB6LCBvcHRfdGlsZVJhbmdlKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIHosIHRpbGVSYW5nZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAtLXo7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZCwgaWYgaXQgd2FzIGNvbmZpZ3VyZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmV4dGVudF87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggem9vbS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldE1heFpvb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWF4Wm9vbTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGdyaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbiB6b29tLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0TWluWm9vbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5taW5ab29tO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgb3JpZ2luIGZvciB0aGUgZ3JpZCBhdCB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IE9yaWdpbi5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldE9yaWdpbiA9IGZ1bmN0aW9uKHopIHtcbiAgaWYgKHRoaXMub3JpZ2luXykge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luc19bel07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uKHopIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3pdO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiByZXNvbHV0aW9ucyBmb3IgdGhlIHRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBSZXNvbHV0aW9ucy5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlPX0gb3B0X3RpbGVSYW5nZSBUZW1wb3JhcnkgbW9kdWxlOm9sL1RpbGVSYW5nZSBvYmplY3QuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBUZW1wb3JhcnkgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGVSYW5nZX0gVGlsZSByYW5nZS5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZENoaWxkVGlsZVJhbmdlID0gZnVuY3Rpb24odGlsZUNvb3JkLCBvcHRfdGlsZVJhbmdlLCBvcHRfZXh0ZW50KSB7XG4gIGlmICh0aWxlQ29vcmRbMF0gPCB0aGlzLm1heFpvb20pIHtcbiAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgY29uc3QgbWluWCA9IHRpbGVDb29yZFsxXSAqIDI7XG4gICAgICBjb25zdCBtaW5ZID0gdGlsZUNvb3JkWzJdICogMjtcbiAgICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCBtaW5YICsgMSwgbWluWSwgbWluWSArIDEsIG9wdF90aWxlUmFuZ2UpO1xuICAgIH1cbiAgICBjb25zdCB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpO1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICB0aWxlQ29vcmRFeHRlbnQsIHRpbGVDb29yZFswXSArIDEsIG9wdF90aWxlUmFuZ2UpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW50IGZvciBhIHRpbGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgVGVtcG9yYXJ5IG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlUmFuZ2VFeHRlbnQgPSBmdW5jdGlvbih6LCB0aWxlUmFuZ2UsIG9wdF9leHRlbnQpIHtcbiAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oeik7XG4gIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuICBjb25zdCBtaW5YID0gb3JpZ2luWzBdICsgdGlsZVJhbmdlLm1pblggKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gIGNvbnN0IG1heFggPSBvcmlnaW5bMF0gKyAodGlsZVJhbmdlLm1heFggKyAxKSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgY29uc3QgbWluWSA9IG9yaWdpblsxXSArIHRpbGVSYW5nZS5taW5ZICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICBjb25zdCBtYXhZID0gb3JpZ2luWzFdICsgKHRpbGVSYW5nZS5tYXhZICsgMSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBvcHRfZXh0ZW50KTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYSB0aWxlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gZXh0ZW50IGFuZCBpbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlPX0gb3B0X3RpbGVSYW5nZSBUZW1wb3JhcnkgdGlsZSByYW5nZSBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZVJhbmdlfSBUaWxlIHJhbmdlLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWiA9IGZ1bmN0aW9uKGV4dGVudCwgeiwgb3B0X3RpbGVSYW5nZSkge1xuICBjb25zdCB0aWxlQ29vcmQgPSB0bXBUaWxlQ29vcmQ7XG4gIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMF0sIGV4dGVudFsxXSwgeiwgZmFsc2UsIHRpbGVDb29yZCk7XG4gIGNvbnN0IG1pblggPSB0aWxlQ29vcmRbMV07XG4gIGNvbnN0IG1pblkgPSB0aWxlQ29vcmRbMl07XG4gIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMl0sIGV4dGVudFszXSwgeiwgdHJ1ZSwgdGlsZUNvb3JkKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIHRpbGVDb29yZFsxXSwgbWluWSwgdGlsZUNvb3JkWzJdLCBvcHRfdGlsZVJhbmdlKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVGlsZSBjZW50ZXIuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRDZW50ZXIgPSBmdW5jdGlvbih0aWxlQ29vcmQpIHtcbiAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICByZXR1cm4gW1xuICAgIG9yaWdpblswXSArICh0aWxlQ29vcmRbMV0gKyAwLjUpICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uLFxuICAgIG9yaWdpblsxXSArICh0aWxlQ29vcmRbMl0gKyAwLjUpICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uXG4gIF07XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBleHRlbnQgb2YgYSB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBleHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEV4dGVudCA9IGZ1bmN0aW9uKHRpbGVDb29yZCwgb3B0X2V4dGVudCkge1xuICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHRpbGVDb29yZFswXSk7XG4gIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUodGlsZUNvb3JkWzBdKSwgdGhpcy50bXBTaXplXyk7XG4gIGNvbnN0IG1pblggPSBvcmlnaW5bMF0gKyB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gIGNvbnN0IG1pblkgPSBvcmlnaW5bMV0gKyB0aWxlQ29vcmRbMl0gKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gIGNvbnN0IG1heFggPSBtaW5YICsgdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICBjb25zdCBtYXhZID0gbWluWSArIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdGlsZSBjb29yZGluYXRlIGZvciB0aGUgZ2l2ZW4gbWFwIGNvb3JkaW5hdGUgYW5kIHJlc29sdXRpb24uICBUaGlzXG4gKiBtZXRob2QgY29uc2lkZXJzIHRoYXQgY29vcmRpbmF0ZXMgdGhhdCBpbnRlcnNlY3QgdGlsZSBib3VuZGFyaWVzIHNob3VsZCBiZVxuICogYXNzaWduZWQgdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgRGVzdGluYXRpb24gbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEZvckNvb3JkQW5kUmVzb2x1dGlvbiA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUsIHJlc29sdXRpb24sIG9wdF90aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uXyhcbiAgICBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCByZXNvbHV0aW9uLCBmYWxzZSwgb3B0X3RpbGVDb29yZCk7XG59O1xuXG5cbi8qKlxuICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyB0aGF0IGNvcnJlc3BvbmRcbiAqIHRvIGFuIGludGVnZXIgem9vbSBsZXZlbC4gIEluc3RlYWQgY2FsbCB0aGUgYGdldFRpbGVDb29yZEZvclhZQW5kWl9gIG1ldGhvZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbiAoZm9yIGEgbm9uLWludGVnZXIgem9vbSBsZXZlbCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgSW5zdGVhZCBvZiBsZXR0aW5nIGVkZ2VcbiAqICAgICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gKiAgICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIFRlbXBvcmFyeSBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICogQHByaXZhdGVcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8gPSBmdW5jdGlvbihcbiAgeCwgeSwgcmVzb2x1dGlvbiwgcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSwgb3B0X3RpbGVDb29yZCkge1xuICBjb25zdCB6ID0gdGhpcy5nZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgY29uc3Qgc2NhbGUgPSByZXNvbHV0aW9uIC8gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplXyk7XG5cbiAgY29uc3QgYWRqdXN0WCA9IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgPyAwLjUgOiAwO1xuICBjb25zdCBhZGp1c3RZID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAgOiAwLjU7XG4gIGNvbnN0IHhGcm9tT3JpZ2luID0gTWF0aC5mbG9vcigoeCAtIG9yaWdpblswXSkgLyByZXNvbHV0aW9uICsgYWRqdXN0WCk7XG4gIGNvbnN0IHlGcm9tT3JpZ2luID0gTWF0aC5mbG9vcigoeSAtIG9yaWdpblsxXSkgLyByZXNvbHV0aW9uICsgYWRqdXN0WSk7XG4gIGxldCB0aWxlQ29vcmRYID0gc2NhbGUgKiB4RnJvbU9yaWdpbiAvIHRpbGVTaXplWzBdO1xuICBsZXQgdGlsZUNvb3JkWSA9IHNjYWxlICogeUZyb21PcmlnaW4gLyB0aWxlU2l6ZVsxXTtcblxuICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmNlaWwodGlsZUNvb3JkWCkgLSAxO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmNlaWwodGlsZUNvb3JkWSkgLSAxO1xuICB9IGVsc2Uge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmZsb29yKHRpbGVDb29yZFgpO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmZsb29yKHRpbGVDb29yZFkpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZUNvb3JkKHosIHRpbGVDb29yZFgsIHRpbGVDb29yZFksIG9wdF90aWxlQ29vcmQpO1xufTtcblxuXG4vKipcbiAqIEFsdGhvdWdoIHRoZXJlIGlzIHJlcGV0aXRpb24gYmV0d2VlbiB0aGlzIG1ldGhvZCBhbmQgYGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl9gLFxuICogdGhleSBzaG91bGQgaGF2ZSBzZXBhcmF0ZSBpbXBsZW1lbnRhdGlvbnMuICBUaGlzIG1ldGhvZCBpcyBmb3IgaW50ZWdlciB6b29tXG4gKiBsZXZlbHMuICBUaGUgb3RoZXIgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgY29ycmVzcG9uZGluZ1xuICogdG8gbm9uLWludGVnZXIgem9vbSBsZXZlbHMuXG4gKiBAcGFyYW0ge251bWJlcn0geCBNYXAgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgTWFwIHkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICogICAgIGludGVyc2VjdGlvbnMgZ28gdG8gdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUsIGxldCBlZGdlIGludGVyc2VjdGlvbnNcbiAqICAgICBnbyB0byB0aGUgbG93ZXIgdGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgVGVtcG9yYXJ5IG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcHJpdmF0ZVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyA9IGZ1bmN0aW9uKHgsIHksIHosIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksIG9wdF90aWxlQ29vcmQpIHtcbiAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oeik7XG4gIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuXG4gIGNvbnN0IGFkanVzdFggPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMC41IDogMDtcbiAgY29uc3QgYWRqdXN0WSA9IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgPyAwIDogMC41O1xuICBjb25zdCB4RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHggLSBvcmlnaW5bMF0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFgpO1xuICBjb25zdCB5RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHkgLSBvcmlnaW5bMV0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFkpO1xuICBsZXQgdGlsZUNvb3JkWCA9IHhGcm9tT3JpZ2luIC8gdGlsZVNpemVbMF07XG4gIGxldCB0aWxlQ29vcmRZID0geUZyb21PcmlnaW4gLyB0aWxlU2l6ZVsxXTtcblxuICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmNlaWwodGlsZUNvb3JkWCkgLSAxO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmNlaWwodGlsZUNvb3JkWSkgLSAxO1xuICB9IGVsc2Uge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmZsb29yKHRpbGVDb29yZFgpO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmZsb29yKHRpbGVDb29yZFkpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZUNvb3JkKHosIHRpbGVDb29yZFgsIHRpbGVDb29yZFksIG9wdF90aWxlQ29vcmQpO1xufTtcblxuXG4vKipcbiAqIEdldCBhIHRpbGUgY29vcmRpbmF0ZSBnaXZlbiBhIG1hcCBjb29yZGluYXRlIGFuZCB6b29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgRGVzdGluYXRpb24gbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWiA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUsIHosIG9wdF90aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhcbiAgICBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCB6LCBmYWxzZSwgb3B0X3RpbGVDb29yZCk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGlsZSByZXNvbHV0aW9uLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkUmVzb2x1dGlvbiA9IGZ1bmN0aW9uKHRpbGVDb29yZCkge1xuICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bdGlsZUNvb3JkWzBdXTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHRpbGUgc2l6ZSBmb3IgYSB6b29tIGxldmVsLiBUaGUgdHlwZSBvZiB0aGUgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhlXG4gKiBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIHRoYXQgdGhlIHRpbGUgZ3JpZCB3YXMgY29uZmlndXJlZCB3aXRoLiBUbyBhbHdheXNcbiAqIGdldCBhbiBgbW9kdWxlOm9sL3NpemV+U2l6ZWAsIHJ1biB0aGUgcmVzdWx0IHRocm91Z2ggYG1vZHVsZTpvbC9zaXplflNpemUudG9TaXplKClgLlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEByZXR1cm4ge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfSBUaWxlIHNpemUuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlU2l6ZSA9IGZ1bmN0aW9uKHopIHtcbiAgaWYgKHRoaXMudGlsZVNpemVfKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVNpemVfO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnRpbGVTaXplc19bel07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGVSYW5nZX0gRXh0ZW50IHRpbGUgcmFuZ2UgZm9yIHRoZSBzcGVjaWZpZWQgem9vbSBsZXZlbC5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldEZ1bGxUaWxlUmFuZ2UgPSBmdW5jdGlvbih6KSB7XG4gIGlmICghdGhpcy5mdWxsVGlsZVJhbmdlc18pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGlsZVJhbmdlc19bel07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGlyZWN0aW9uIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICogICAgIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3RcbiAqICAgICBoaWdoZXIgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuIERlZmF1bHQgaXMgMC5cbiAqIEByZXR1cm4ge251bWJlcn0gWi5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFpGb3JSZXNvbHV0aW9uID0gZnVuY3Rpb24ocmVzb2x1dGlvbiwgb3B0X2RpcmVjdGlvbikge1xuICBjb25zdCB6ID0gbGluZWFyRmluZE5lYXJlc3QodGhpcy5yZXNvbHV0aW9uc18sIHJlc29sdXRpb24sIG9wdF9kaXJlY3Rpb24gfHwgMCk7XG4gIHJldHVybiBjbGFtcCh6LCB0aGlzLm1pblpvb20sIHRoaXMubWF4Wm9vbSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLlxuICogQHByaXZhdGVcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmNhbGN1bGF0ZVRpbGVSYW5nZXNfID0gZnVuY3Rpb24oZXh0ZW50KSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aDtcbiAgY29uc3QgZnVsbFRpbGVSYW5nZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgZnVsbFRpbGVSYW5nZXNbel0gPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgfVxuICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IGZ1bGxUaWxlUmFuZ2VzO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRpbGVHcmlkO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIHpvb20gZm9yIGRlZmF1bHQgdGlsZSBncmlkcy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX01BWF9aT09NID0gNDI7XG5cbi8qKlxuICogRGVmYXVsdCB0aWxlIHNpemUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9USUxFX1NJWkUgPSAyNTY7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZXVybGZ1bmN0aW9uXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2hhc2ggYXMgdGlsZUNvb3JkSGFzaH0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIFRlbXBsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdGlsZUdyaWQpIHtcbiAgY29uc3QgelJlZ0V4ID0gL1xce3pcXH0vZztcbiAgY29uc3QgeFJlZ0V4ID0gL1xce3hcXH0vZztcbiAgY29uc3QgeVJlZ0V4ID0gL1xce3lcXH0vZztcbiAgY29uc3QgZGFzaFlSZWdFeCA9IC9cXHsteVxcfS9nO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoelJlZ0V4LCB0aWxlQ29vcmRbMF0udG9TdHJpbmcoKSlcbiAgICAgICAgICAucmVwbGFjZSh4UmVnRXgsIHRpbGVDb29yZFsxXS50b1N0cmluZygpKVxuICAgICAgICAgIC5yZXBsYWNlKHlSZWdFeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gLXRpbGVDb29yZFsyXSAtIDE7XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlcGxhY2UoZGFzaFlSZWdFeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWxlR3JpZC5nZXRGdWxsVGlsZVJhbmdlKHopO1xuICAgICAgICAgICAgYXNzZXJ0KHJhbmdlLCA1NSk7IC8vIFRoZSB7LXl9IHBsYWNlaG9sZGVyIHJlcXVpcmVzIGEgdGlsZSBncmlkIHdpdGggZXh0ZW50XG4gICAgICAgICAgICBjb25zdCB5ID0gcmFuZ2UuZ2V0SGVpZ2h0KCkgKyB0aWxlQ29vcmRbMl07XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHRlbXBsYXRlcyBUZW1wbGF0ZXMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlcyh0ZW1wbGF0ZXMsIHRpbGVHcmlkKSB7XG4gIGNvbnN0IGxlbiA9IHRlbXBsYXRlcy5sZW5ndGg7XG4gIGNvbnN0IHRpbGVVcmxGdW5jdGlvbnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHRpbGVVcmxGdW5jdGlvbnNbaV0gPSBjcmVhdGVGcm9tVGVtcGxhdGUodGVtcGxhdGVzW2ldLCB0aWxlR3JpZCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zKHRpbGVVcmxGdW5jdGlvbnMpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb24+fSB0aWxlVXJsRnVuY3Rpb25zIFRpbGUgVVJMIEZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zKHRpbGVVcmxGdW5jdGlvbnMpIHtcbiAgaWYgKHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRpbGVVcmxGdW5jdGlvbnNbMF07XG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBDb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRpbGUgVVJMLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGggPSB0aWxlQ29vcmRIYXNoKHRpbGVDb29yZCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbW9kdWxvKGgsIHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRpbGVVcmxGdW5jdGlvbnNbaW5kZXhdKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxUaWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTC5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBBcnJheSBvZiB1cmxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kVXJsKHVybCkge1xuICBjb25zdCB1cmxzID0gW107XG4gIGxldCBtYXRjaCA9IC9cXHsoW2Etel0pLShbYS16XSlcXH0vLmV4ZWModXJsKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgLy8gY2hhciByYW5nZVxuICAgIGNvbnN0IHN0YXJ0Q2hhckNvZGUgPSBtYXRjaFsxXS5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IHN0b3BDaGFyQ29kZSA9IG1hdGNoWzJdLmNoYXJDb2RlQXQoMCk7XG4gICAgbGV0IGNoYXJDb2RlO1xuICAgIGZvciAoY2hhckNvZGUgPSBzdGFydENoYXJDb2RlOyBjaGFyQ29kZSA8PSBzdG9wQ2hhckNvZGU7ICsrY2hhckNvZGUpIHtcbiAgICAgIHVybHMucHVzaCh1cmwucmVwbGFjZShtYXRjaFswXSwgU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgbWF0Y2ggPSBtYXRjaCA9IC9cXHsoXFxkKyktKFxcZCspXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIG51bWJlciByYW5nZVxuICAgIGNvbnN0IHN0b3AgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuICAgIGZvciAobGV0IGkgPSBwYXJzZUludChtYXRjaFsxXSwgMTApOyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgdXJscy5wdXNoKHVybC5yZXBsYWNlKG1hdGNoWzBdLCBpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgdXJscy5wdXNoKHVybCk7XG4gIHJldHVybiB1cmxzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3dlYmdsXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHMgdGFrZW4gZnJvbSBnb29nLndlYmdsXG4gKi9cblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IE9ORSA9IDE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBTUkNfQUxQSEEgPSAweDAzMDI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBDT0xPUl9BVFRBQ0hNRU5UMCA9IDB4OENFMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IENPTE9SX0JVRkZFUl9CSVQgPSAweDAwMDA0MDAwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVFJJQU5HTEVTID0gMHgwMDA0O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVFJJQU5HTEVfU1RSSVAgPSAweDAwMDU7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBPTkVfTUlOVVNfU1JDX0FMUEhBID0gMHgwMzAzO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQVJSQVlfQlVGRkVSID0gMHg4ODkyO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAweDg4OTM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBTVFJFQU1fRFJBVyA9IDB4ODhFMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFNUQVRJQ19EUkFXID0gMHg4OEU0O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRFlOQU1JQ19EUkFXID0gMHg4OEU4O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQ1VMTF9GQUNFID0gMHgwQjQ0O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQkxFTkQgPSAweDBCRTI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBTVEVOQ0lMX1RFU1QgPSAweDBCOTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERVBUSF9URVNUID0gMHgwQjcxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgU0NJU1NPUl9URVNUID0gMHgwQzExO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVU5TSUdORURfQllURSA9IDB4MTQwMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFVOU0lHTkVEX1NIT1JUID0gMHgxNDAzO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVU5TSUdORURfSU5UID0gMHgxNDA1O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRkxPQVQgPSAweDE0MDY7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSR0JBID0gMHgxOTA4O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRlJBR01FTlRfU0hBREVSID0gMHg4QjMwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVkVSVEVYX1NIQURFUiA9IDB4OEIzMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IExJTktfU1RBVFVTID0gMHg4QjgyO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgTElORUFSID0gMHgyNjAxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVEVYVFVSRV9NQUdfRklMVEVSID0gMHgyODAwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVEVYVFVSRV9NSU5fRklMVEVSID0gMHgyODAxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVEVYVFVSRV9XUkFQX1MgPSAweDI4MDI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBURVhUVVJFX1dSQVBfVCA9IDB4MjgwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFRFWFRVUkVfMkQgPSAweDBERTE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBURVhUVVJFMCA9IDB4ODRDMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IENMQU1QX1RPX0VER0UgPSAweDgxMkY7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBDT01QSUxFX1NUQVRVUyA9IDB4OEI4MTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEZSQU1FQlVGRkVSID0gMHg4RDQwO1xuXG5cbi8qKiBlbmQgb2YgZ29vZy53ZWJnbCBjb25zdGFudHNcbiAqL1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gKi9cbmNvbnN0IENPTlRFWFRfSURTID0gW1xuICAnZXhwZXJpbWVudGFsLXdlYmdsJyxcbiAgJ3dlYmdsJyxcbiAgJ3dlYmtpdC0zZCcsXG4gICdtb3otd2ViZ2wnXG5dO1xuXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIENhbnZhcy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHJpYnV0ZXMgQXR0cmlidXRlcy5cbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnV0ZXMpIHtcbiAgY29uc3QgaWkgPSBDT05URVhUX0lEUy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWk7ICsraSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoQ09OVEVYVF9JRFNbaV0sIG9wdF9hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgeyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9ICovIChjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBwYXNzXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEwLjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIGZhbWlsaWVzO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGljb246ICdpY29ucy9nb29nbGUuc3ZnJyxcbiAgICBuYW1lOiAnZ29vZ2xlJyxcbiAgICB0aXRsZTogJ0dvb2dsZSBGb250cycsXG4gICAgbGluazogJ2dvb2dsZS5jb20vZm9udHMnLFxuICAgIGdldE5hbWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYW1pbGllcztcbiAgICB9LFxuICAgIGdldExpbms6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiBcImh0dHBzOi8vZm9udHMuZ29vZ2xlLmNvbS9zcGVjaW1lbi9cIiArIChuYW1lLnJlcGxhY2UoLyggKS9nLCAnKycpKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfTtcblxuICBmYW1pbGllcyA9IFtcIkFCZWVaZWVcIiwgXCJBYmVsXCIsIFwiQWJyaWwgRmF0ZmFjZVwiLCBcIkFjbG9uaWNhXCIsIFwiQWNtZVwiLCBcIkFjdG9yXCIsIFwiQWRhbWluYVwiLCBcIkFkdmVudCBQcm9cIiwgXCJBZ3VhZmluYSBTY3JpcHRcIiwgXCJBa3JvbmltXCIsIFwiQWxhZGluXCIsIFwiQWxkcmljaFwiLCBcIkFsZWZcIiwgXCJBbGVncmV5YVwiLCBcIkFsZWdyZXlhIFNDXCIsIFwiQWxlZ3JleWEgU2Fuc1wiLCBcIkFsZWdyZXlhIFNhbnMgU0NcIiwgXCJBbGV4IEJydXNoXCIsIFwiQWxmYSBTbGFiIE9uZVwiLCBcIkFsaWNlXCIsIFwiQWxpa2VcIiwgXCJBbGlrZSBBbmd1bGFyXCIsIFwiQWxsYW5cIiwgXCJBbGxlcnRhXCIsIFwiQWxsZXJ0YSBTdGVuY2lsXCIsIFwiQWxsdXJhXCIsIFwiQWxtZW5kcmFcIiwgXCJBbG1lbmRyYSBEaXNwbGF5XCIsIFwiQWxtZW5kcmEgU0NcIiwgXCJBbWFyYW50ZVwiLCBcIkFtYXJhbnRoXCIsIFwiQW1hdGljIFNDXCIsIFwiQW1ldGh5c3RhXCIsIFwiQW1pcmlcIiwgXCJBbWl0YVwiLCBcIkFuYWhlaW1cIiwgXCJBbmRhZGFcIiwgXCJBbmRpa2FcIiwgXCJBbmdrb3JcIiwgXCJBbm5pZSBVc2UgWW91ciBUZWxlc2NvcGVcIiwgXCJBbm9ueW1vdXMgUHJvXCIsIFwiQW50aWNcIiwgXCJBbnRpYyBEaWRvbmVcIiwgXCJBbnRpYyBTbGFiXCIsIFwiQW50b25cIiwgXCJBcmFwZXlcIiwgXCJBcmJ1dHVzXCIsIFwiQXJidXR1cyBTbGFiXCIsIFwiQXJjaGl0ZWN0cyBEYXVnaHRlclwiLCBcIkFyY2hpdm8gQmxhY2tcIiwgXCJBcmNoaXZvIE5hcnJvd1wiLCBcIkFyaW1vXCIsIFwiQXJpem9uaWFcIiwgXCJBcm1hdGFcIiwgXCJBcnRpZmlrYVwiLCBcIkFydm9cIiwgXCJBcnlhXCIsIFwiQXNhcFwiLCBcIkFzYXJcIiwgXCJBc3NldFwiLCBcIkFzdGxvY2hcIiwgXCJBc3VsXCIsIFwiQXRvbWljIEFnZVwiLCBcIkF1YnJleVwiLCBcIkF1ZGlvd2lkZVwiLCBcIkF1dG91ciBPbmVcIiwgXCJBdmVyYWdlXCIsIFwiQXZlcmFnZSBTYW5zXCIsIFwiQXZlcmlhIEdydWVzYSBMaWJyZVwiLCBcIkF2ZXJpYSBMaWJyZVwiLCBcIkF2ZXJpYSBTYW5zIExpYnJlXCIsIFwiQXZlcmlhIFNlcmlmIExpYnJlXCIsIFwiQmFkIFNjcmlwdFwiLCBcIkJhbHRoYXphclwiLCBcIkJhbmdlcnNcIiwgXCJCYXNpY1wiLCBcIkJhdHRhbWJhbmdcIiwgXCJCYXVtYW5zXCIsIFwiQmF5b25cIiwgXCJCZWxncmFub1wiLCBcIkJlbGxlemFcIiwgXCJCZW5jaE5pbmVcIiwgXCJCZW50aGFtXCIsIFwiQmVya3NoaXJlIFN3YXNoXCIsIFwiQmV2YW5cIiwgXCJCaWdlbG93IFJ1bGVzXCIsIFwiQmlnc2hvdCBPbmVcIiwgXCJCaWxib1wiLCBcIkJpbGJvIFN3YXNoIENhcHNcIiwgXCJCaXJ5YW5pXCIsIFwiQml0dGVyXCIsIFwiQmxhY2sgT3BzIE9uZVwiLCBcIkJva29yXCIsIFwiQm9uYm9uXCIsIFwiQm9vZ2Fsb29cIiwgXCJCb3dsYnkgT25lXCIsIFwiQm93bGJ5IE9uZSBTQ1wiLCBcIkJyYXdsZXJcIiwgXCJCcmVlIFNlcmlmXCIsIFwiQnViYmxlZ3VtIFNhbnNcIiwgXCJCdWJibGVyIE9uZVwiLCBcIkJ1ZGFcIiwgXCJCdWVuYXJkXCIsIFwiQnV0Y2hlcm1hblwiLCBcIkJ1dHRlcmZseSBLaWRzXCIsIFwiQ2FiaW5cIiwgXCJDYWJpbiBDb25kZW5zZWRcIiwgXCJDYWJpbiBTa2V0Y2hcIiwgXCJDYWVzYXIgRHJlc3NpbmdcIiwgXCJDYWdsaW9zdHJvXCIsIFwiQ2FsbGlncmFmZml0dGlcIiwgXCJDYW1iYXlcIiwgXCJDYW1ib1wiLCBcIkNhbmRhbFwiLCBcIkNhbnRhcmVsbFwiLCBcIkNhbnRhdGEgT25lXCIsIFwiQ2FudG9yYSBPbmVcIiwgXCJDYXByaW9sYVwiLCBcIkNhcmRvXCIsIFwiQ2FybWVcIiwgXCJDYXJyb2lzIEdvdGhpY1wiLCBcIkNhcnJvaXMgR290aGljIFNDXCIsIFwiQ2FydGVyIE9uZVwiLCBcIkNhdGFtYXJhblwiLCBcIkNhdWRleFwiLCBcIkNhdmVhdFwiLCBcIkNhdmVhdCBCcnVzaFwiLCBcIkNlZGFydmlsbGUgQ3Vyc2l2ZVwiLCBcIkNldmljaGUgT25lXCIsIFwiQ2hhbmdhIE9uZVwiLCBcIkNoYW5nb1wiLCBcIkNoYXUgUGhpbG9tZW5lIE9uZVwiLCBcIkNoZWxhIE9uZVwiLCBcIkNoZWxzZWEgTWFya2V0XCIsIFwiQ2hlbmxhXCIsIFwiQ2hlcnJ5IENyZWFtIFNvZGFcIiwgXCJDaGVycnkgU3dhc2hcIiwgXCJDaGV3eVwiLCBcIkNoaWNsZVwiLCBcIkNoaXZvXCIsIFwiQ2hvbmJ1cmlcIiwgXCJDaW56ZWxcIiwgXCJDaW56ZWwgRGVjb3JhdGl2ZVwiLCBcIkNsaWNrZXIgU2NyaXB0XCIsIFwiQ29kYVwiLCBcIkNvZGEgQ2FwdGlvblwiLCBcIkNvZHlzdGFyXCIsIFwiQ29tYm9cIiwgXCJDb21mb3J0YWFcIiwgXCJDb21pbmcgU29vblwiLCBcIkNvbmNlcnQgT25lXCIsIFwiQ29uZGltZW50XCIsIFwiQ29udGVudFwiLCBcIkNvbnRyYWlsIE9uZVwiLCBcIkNvbnZlcmdlbmNlXCIsIFwiQ29va2llXCIsIFwiQ29wc2VcIiwgXCJDb3JiZW5cIiwgXCJDb3VyZ2V0dGVcIiwgXCJDb3VzaW5lXCIsIFwiQ291c3RhcmRcIiwgXCJDb3ZlcmVkIEJ5IFlvdXIgR3JhY2VcIiwgXCJDcmFmdHkgR2lybHNcIiwgXCJDcmVlcHN0ZXJcIiwgXCJDcmV0ZSBSb3VuZFwiLCBcIkNyaW1zb24gVGV4dFwiLCBcIkNyb2lzc2FudCBPbmVcIiwgXCJDcnVzaGVkXCIsIFwiQ3VwcnVtXCIsIFwiQ3V0aXZlXCIsIFwiQ3V0aXZlIE1vbm9cIiwgXCJEYW1pb25cIiwgXCJEYW5jaW5nIFNjcmlwdFwiLCBcIkRhbmdyZWtcIiwgXCJEYXduaW5nIG9mIGEgTmV3IERheVwiLCBcIkRheXMgT25lXCIsIFwiRGVra29cIiwgXCJEZWxpdXNcIiwgXCJEZWxpdXMgU3dhc2ggQ2Fwc1wiLCBcIkRlbGl1cyBVbmljYXNlXCIsIFwiRGVsbGEgUmVzcGlyYVwiLCBcIkRlbmsgT25lXCIsIFwiRGV2b25zaGlyZVwiLCBcIkRodXJqYXRpXCIsIFwiRGlkYWN0IEdvdGhpY1wiLCBcIkRpcGxvbWF0YVwiLCBcIkRpcGxvbWF0YSBTQ1wiLCBcIkRvbWluZVwiLCBcIkRvbmVnYWwgT25lXCIsIFwiRG9wcGlvIE9uZVwiLCBcIkRvcnNhXCIsIFwiRG9zaXNcIiwgXCJEciBTdWdpeWFtYVwiLCBcIkRyb2lkIFNhbnNcIiwgXCJEcm9pZCBTYW5zIE1vbm9cIiwgXCJEcm9pZCBTZXJpZlwiLCBcIkR1cnUgU2Fuc1wiLCBcIkR5bmFsaWdodFwiLCBcIkVCIEdhcmFtb25kXCIsIFwiRWFnbGUgTGFrZVwiLCBcIkVhdGVyXCIsIFwiRWNvbm9taWNhXCIsIFwiRWN6YXJcIiwgXCJFayBNdWt0YVwiLCBcIkVsZWN0cm9saXplXCIsIFwiRWxzaWVcIiwgXCJFbHNpZSBTd2FzaCBDYXBzXCIsIFwiRW1ibGVtYSBPbmVcIiwgXCJFbWlseXMgQ2FuZHlcIiwgXCJFbmdhZ2VtZW50XCIsIFwiRW5nbGViZXJ0XCIsIFwiRW5yaXF1ZXRhXCIsIFwiRXJpY2EgT25lXCIsIFwiRXN0ZWJhblwiLCBcIkV1cGhvcmlhIFNjcmlwdFwiLCBcIkV3ZXJ0XCIsIFwiRXhvXCIsIFwiRXhvIDJcIiwgXCJFeHBsZXR1cyBTYW5zXCIsIFwiRmFud29vZCBUZXh0XCIsIFwiRmFzY2luYXRlXCIsIFwiRmFzY2luYXRlIElubGluZVwiLCBcIkZhc3RlciBPbmVcIiwgXCJGYXN0aGFuZFwiLCBcIkZhdW5hIE9uZVwiLCBcIkZlZGVyYW50XCIsIFwiRmVkZXJvXCIsIFwiRmVsaXBhXCIsIFwiRmVuaXhcIiwgXCJGaW5nZXIgUGFpbnRcIiwgXCJGaXJhIE1vbm9cIiwgXCJGaXJhIFNhbnNcIiwgXCJGamFsbGEgT25lXCIsIFwiRmpvcmQgT25lXCIsIFwiRmxhbWVuY29cIiwgXCJGbGF2b3JzXCIsIFwiRm9uZGFtZW50b1wiLCBcIkZvbnRkaW5lciBTd2Fua3lcIiwgXCJGb3J1bVwiLCBcIkZyYW5jb2lzIE9uZVwiLCBcIkZyZWNrbGUgRmFjZVwiLCBcIkZyZWRlcmlja2EgdGhlIEdyZWF0XCIsIFwiRnJlZG9rYSBPbmVcIiwgXCJGcmVlaGFuZFwiLCBcIkZyZXNjYVwiLCBcIkZyaWpvbGVcIiwgXCJGcnVrdHVyXCIsIFwiRnVnYXogT25lXCIsIFwiR0ZTIERpZG90XCIsIFwiR0ZTIE5lb2hlbGxlbmljXCIsIFwiR2FicmllbGFcIiwgXCJHYWZhdGFcIiwgXCJHYWxkZWFub1wiLCBcIkdhbGluZG9cIiwgXCJHZW50aXVtIEJhc2ljXCIsIFwiR2VudGl1bSBCb29rIEJhc2ljXCIsIFwiR2VvXCIsIFwiR2Vvc3RhclwiLCBcIkdlb3N0YXIgRmlsbFwiLCBcIkdlcm1hbmlhIE9uZVwiLCBcIkdpZHVndVwiLCBcIkdpbGRhIERpc3BsYXlcIiwgXCJHaXZlIFlvdSBHbG9yeVwiLCBcIkdsYXNzIEFudGlxdWFcIiwgXCJHbGVnb29cIiwgXCJHbG9yaWEgSGFsbGVsdWphaFwiLCBcIkdvYmxpbiBPbmVcIiwgXCJHb2NoaSBIYW5kXCIsIFwiR29yZGl0YXNcIiwgXCJHb3VkeSBCb29rbGV0dGVyIDE5MTFcIiwgXCJHcmFkdWF0ZVwiLCBcIkdyYW5kIEhvdGVsXCIsIFwiR3Jhdml0YXMgT25lXCIsIFwiR3JlYXQgVmliZXNcIiwgXCJHcmlmZnlcIiwgXCJHcnVwcG9cIiwgXCJHdWRlYVwiLCBcIkd1cmFqYWRhXCIsIFwiSGFiaWJpXCIsIFwiSGFsYW50XCIsIFwiSGFtbWVyc21pdGggT25lXCIsIFwiSGFuYWxlaVwiLCBcIkhhbmFsZWkgRmlsbFwiLCBcIkhhbmRsZWVcIiwgXCJIYW51bWFuXCIsIFwiSGFwcHkgTW9ua2V5XCIsIFwiSGVhZGxhbmQgT25lXCIsIFwiSGVubnkgUGVubnlcIiwgXCJIZXJyIFZvbiBNdWVsbGVyaG9mZlwiLCBcIkhpbmRcIiwgXCJIaW5kIFNpbGlndXJpXCIsIFwiSGluZCBWYWRvZGFyYVwiLCBcIkhvbHR3b29kIE9uZSBTQ1wiLCBcIkhvbWVtYWRlIEFwcGxlXCIsIFwiSG9tZW5hamVcIiwgXCJJTSBGZWxsIERXIFBpY2FcIiwgXCJJTSBGZWxsIERXIFBpY2EgU0NcIiwgXCJJTSBGZWxsIERvdWJsZSBQaWNhXCIsIFwiSU0gRmVsbCBEb3VibGUgUGljYSBTQ1wiLCBcIklNIEZlbGwgRW5nbGlzaFwiLCBcIklNIEZlbGwgRW5nbGlzaCBTQ1wiLCBcIklNIEZlbGwgRnJlbmNoIENhbm9uXCIsIFwiSU0gRmVsbCBGcmVuY2ggQ2Fub24gU0NcIiwgXCJJTSBGZWxsIEdyZWF0IFByaW1lclwiLCBcIklNIEZlbGwgR3JlYXQgUHJpbWVyIFNDXCIsIFwiSWNlYmVyZ1wiLCBcIkljZWxhbmRcIiwgXCJJbXByaW1hXCIsIFwiSW5jb25zb2xhdGFcIiwgXCJJbmRlclwiLCBcIkluZGllIEZsb3dlclwiLCBcIkluaWthXCIsIFwiSW5rbnV0IEFudGlxdWFcIiwgXCJJcmlzaCBHcm92ZXJcIiwgXCJJc3RvayBXZWJcIiwgXCJJdGFsaWFuYVwiLCBcIkl0YWxpYW5ub1wiLCBcIkl0aW1cIiwgXCJKYWNxdWVzIEZyYW5jb2lzXCIsIFwiSmFjcXVlcyBGcmFuY29pcyBTaGFkb3dcIiwgXCJKYWxkaVwiLCBcIkppbSBOaWdodHNoYWRlXCIsIFwiSm9ja2V5IE9uZVwiLCBcIkpvbGx5IExvZGdlclwiLCBcIkpvc2VmaW4gU2Fuc1wiLCBcIkpvc2VmaW4gU2xhYlwiLCBcIkpvdGkgT25lXCIsIFwiSnVkc29uXCIsIFwiSnVsZWVcIiwgXCJKdWxpdXMgU2FucyBPbmVcIiwgXCJKdW5nZVwiLCBcIkp1cmFcIiwgXCJKdXN0IEFub3RoZXIgSGFuZFwiLCBcIkp1c3QgTWUgQWdhaW4gRG93biBIZXJlXCIsIFwiS2Fkd2FcIiwgXCJLYWxhbVwiLCBcIkthbWVyb25cIiwgXCJLYW50dW1ydXlcIiwgXCJLYXJsYVwiLCBcIkthcm1hXCIsIFwiS2F1c2hhbiBTY3JpcHRcIiwgXCJLYXZvb25cIiwgXCJLZGFtIFRobW9yXCIsIFwiS2VhbmlhIE9uZVwiLCBcIktlbGx5IFNsYWJcIiwgXCJLZW5pYVwiLCBcIktoYW5kXCIsIFwiS2htZXJcIiwgXCJLaHVsYVwiLCBcIktpdGUgT25lXCIsIFwiS25ld2F2ZVwiLCBcIktvdHRhIE9uZVwiLCBcIktvdWxlblwiLCBcIktyYW5reVwiLCBcIktyZW9uXCIsIFwiS3Jpc3RpXCIsIFwiS3JvbmEgT25lXCIsIFwiS3VyYWxlXCIsIFwiTGEgQmVsbGUgQXVyb3JlXCIsIFwiTGFpbGFcIiwgXCJMYWtraSBSZWRkeVwiLCBcIkxhbmNlbG90XCIsIFwiTGF0ZWVmXCIsIFwiTGF0b1wiLCBcIkxlYWd1ZSBTY3JpcHRcIiwgXCJMZWNrZXJsaSBPbmVcIiwgXCJMZWRnZXJcIiwgXCJMZWt0b25cIiwgXCJMZW1vblwiLCBcIkxpYnJlIEJhc2tlcnZpbGxlXCIsIFwiTGlmZSBTYXZlcnNcIiwgXCJMaWxpdGEgT25lXCIsIFwiTGlseSBTY3JpcHQgT25lXCIsIFwiTGltZWxpZ2h0XCIsIFwiTGluZGVuIEhpbGxcIiwgXCJMb2JzdGVyXCIsIFwiTG9ic3RlciBUd29cIiwgXCJMb25kcmluYSBPdXRsaW5lXCIsIFwiTG9uZHJpbmEgU2hhZG93XCIsIFwiTG9uZHJpbmEgU2tldGNoXCIsIFwiTG9uZHJpbmEgU29saWRcIiwgXCJMb3JhXCIsIFwiTG92ZSBZYSBMaWtlIEEgU2lzdGVyXCIsIFwiTG92ZWQgYnkgdGhlIEtpbmdcIiwgXCJMb3ZlcnMgUXVhcnJlbFwiLCBcIkx1Y2tpZXN0IEd1eVwiLCBcIkx1c2l0YW5hXCIsIFwiTHVzdHJpYVwiLCBcIk1hY29uZG9cIiwgXCJNYWNvbmRvIFN3YXNoIENhcHNcIiwgXCJNYWdyYVwiLCBcIk1haWRlbiBPcmFuZ2VcIiwgXCJNYWtvXCIsIFwiTWFsbGFubmFcIiwgXCJNYW5kYWxpXCIsIFwiTWFyY2VsbHVzXCIsIFwiTWFyY2VsbHVzIFNDXCIsIFwiTWFyY2sgU2NyaXB0XCIsIFwiTWFyZ2FyaW5lXCIsIFwiTWFya28gT25lXCIsIFwiTWFybWVsYWRcIiwgXCJNYXJ0ZWxcIiwgXCJNYXJ0ZWwgU2Fuc1wiLCBcIk1hcnZlbFwiLCBcIk1hdGVcIiwgXCJNYXRlIFNDXCIsIFwiTWF2ZW4gUHJvXCIsIFwiTWNMYXJlblwiLCBcIk1lZGRvblwiLCBcIk1lZGlldmFsU2hhcnBcIiwgXCJNZWR1bGEgT25lXCIsIFwiTWVncmltXCIsIFwiTWVpZSBTY3JpcHRcIiwgXCJNZXJpZW5kYVwiLCBcIk1lcmllbmRhIE9uZVwiLCBcIk1lcnJpd2VhdGhlclwiLCBcIk1lcnJpd2VhdGhlciBTYW5zXCIsIFwiTWV0YWxcIiwgXCJNZXRhbCBNYW5pYVwiLCBcIk1ldGFtb3JwaG91c1wiLCBcIk1ldHJvcGhvYmljXCIsIFwiTWljaHJvbWFcIiwgXCJNaWxvbmdhXCIsIFwiTWlsdG9uaWFuXCIsIFwiTWlsdG9uaWFuIFRhdHRvb1wiLCBcIk1pbml2ZXJcIiwgXCJNaXNzIEZhamFyZG9zZVwiLCBcIk1vZGFrXCIsIFwiTW9kZXJuIEFudGlxdWFcIiwgXCJNb2xlbmdvXCIsIFwiTW9sbGVcIiwgXCJNb25kYVwiLCBcIk1vbm9mZXR0XCIsIFwiTW9ub3RvblwiLCBcIk1vbnNpZXVyIExhIERvdWxhaXNlXCIsIFwiTW9udGFnYVwiLCBcIk1vbnRlelwiLCBcIk1vbnRzZXJyYXRcIiwgXCJNb250c2VycmF0IEFsdGVybmF0ZXNcIiwgXCJNb250c2VycmF0IFN1YnJheWFkYVwiLCBcIk1vdWxcIiwgXCJNb3VscGFsaVwiLCBcIk1vdW50YWlucyBvZiBDaHJpc3RtYXNcIiwgXCJNb3VzZSBNZW1vaXJzXCIsIFwiTXIgQmVkZm9ydFwiLCBcIk1yIERhZm9lXCIsIFwiTXIgRGUgSGF2aWxhbmRcIiwgXCJNcnMgU2FpbnQgRGVsYWZpZWxkXCIsIFwiTXJzIFNoZXBwYXJkc1wiLCBcIk11bGlcIiwgXCJNeXN0ZXJ5IFF1ZXN0XCIsIFwiTlRSXCIsIFwiTmV1Y2hhXCIsIFwiTmV1dG9uXCIsIFwiTmV3IFJvY2tlclwiLCBcIk5ld3MgQ3ljbGVcIiwgXCJOaWNvbm5lXCIsIFwiTml4aWUgT25lXCIsIFwiTm9iaWxlXCIsIFwiTm9rb3JhXCIsIFwiTm9yaWNhblwiLCBcIk5vc2lmZXJcIiwgXCJOb3RoaW5nIFlvdSBDb3VsZCBEb1wiLCBcIk5vdGljaWEgVGV4dFwiLCBcIk5vdG8gU2Fuc1wiLCBcIk5vdG8gU2VyaWZcIiwgXCJOb3ZhIEN1dFwiLCBcIk5vdmEgRmxhdFwiLCBcIk5vdmEgTW9ub1wiLCBcIk5vdmEgT3ZhbFwiLCBcIk5vdmEgUm91bmRcIiwgXCJOb3ZhIFNjcmlwdFwiLCBcIk5vdmEgU2xpbVwiLCBcIk5vdmEgU3F1YXJlXCIsIFwiTnVtYW5zXCIsIFwiTnVuaXRvXCIsIFwiT2RvciBNZWFuIENoZXlcIiwgXCJPZmZzaWRlXCIsIFwiT2xkIFN0YW5kYXJkIFRUXCIsIFwiT2xkZW5idXJnXCIsIFwiT2xlbyBTY3JpcHRcIiwgXCJPbGVvIFNjcmlwdCBTd2FzaCBDYXBzXCIsIFwiT3BlbiBTYW5zXCIsIFwiT3BlbiBTYW5zIENvbmRlbnNlZFwiLCBcIk9yYW5pZW5iYXVtXCIsIFwiT3JiaXRyb25cIiwgXCJPcmVnYW5vXCIsIFwiT3JpZW50YVwiLCBcIk9yaWdpbmFsIFN1cmZlclwiLCBcIk9zd2FsZFwiLCBcIk92ZXIgdGhlIFJhaW5ib3dcIiwgXCJPdmVybG9ja1wiLCBcIk92ZXJsb2NrIFNDXCIsIFwiT3ZvXCIsIFwiT3h5Z2VuXCIsIFwiT3h5Z2VuIE1vbm9cIiwgXCJQVCBNb25vXCIsIFwiUFQgU2Fuc1wiLCBcIlBUIFNhbnMgQ2FwdGlvblwiLCBcIlBUIFNhbnMgTmFycm93XCIsIFwiUFQgU2VyaWZcIiwgXCJQVCBTZXJpZiBDYXB0aW9uXCIsIFwiUGFjaWZpY29cIiwgXCJQYWxhbnF1aW5cIiwgXCJQYWxhbnF1aW4gRGFya1wiLCBcIlBhcHJpa2FcIiwgXCJQYXJpc2llbm5lXCIsIFwiUGFzc2VybyBPbmVcIiwgXCJQYXNzaW9uIE9uZVwiLCBcIlBhdGh3YXkgR290aGljIE9uZVwiLCBcIlBhdHJpY2sgSGFuZFwiLCBcIlBhdHJpY2sgSGFuZCBTQ1wiLCBcIlBhdHVhIE9uZVwiLCBcIlBheXRvbmUgT25lXCIsIFwiUGVkZGFuYVwiLCBcIlBlcmFsdGFcIiwgXCJQZXJtYW5lbnQgTWFya2VyXCIsIFwiUGV0aXQgRm9ybWFsIFNjcmlwdFwiLCBcIlBldHJvbmFcIiwgXCJQaGlsb3NvcGhlclwiLCBcIlBpZWRyYVwiLCBcIlBpbnlvbiBTY3JpcHRcIiwgXCJQaXJhdGEgT25lXCIsIFwiUGxhc3RlclwiLCBcIlBsYXlcIiwgXCJQbGF5YmFsbFwiLCBcIlBsYXlmYWlyIERpc3BsYXlcIiwgXCJQbGF5ZmFpciBEaXNwbGF5IFNDXCIsIFwiUG9ka292YVwiLCBcIlBvaXJldCBPbmVcIiwgXCJQb2xsZXIgT25lXCIsIFwiUG9seVwiLCBcIlBvbXBpZXJlXCIsIFwiUG9udGFubyBTYW5zXCIsIFwiUG9wcGluc1wiLCBcIlBvcnQgTGxpZ2F0IFNhbnNcIiwgXCJQb3J0IExsaWdhdCBTbGFiXCIsIFwiUHJhZ2F0aSBOYXJyb3dcIiwgXCJQcmF0YVwiLCBcIlByZWFodmloZWFyXCIsIFwiUHJlc3MgU3RhcnQgMlBcIiwgXCJQcmluY2VzcyBTb2ZpYVwiLCBcIlByb2Npb25vXCIsIFwiUHJvc3RvIE9uZVwiLCBcIlB1cml0YW5cIiwgXCJQdXJwbGUgUHVyc2VcIiwgXCJRdWFuZG9cIiwgXCJRdWFudGljb1wiLCBcIlF1YXR0cm9jZW50b1wiLCBcIlF1YXR0cm9jZW50byBTYW5zXCIsIFwiUXVlc3RyaWFsXCIsIFwiUXVpY2tzYW5kXCIsIFwiUXVpbnRlc3NlbnRpYWxcIiwgXCJRd2lnbGV5XCIsIFwiUmFjaW5nIFNhbnMgT25lXCIsIFwiUmFkbGV5XCIsIFwiUmFqZGhhbmlcIiwgXCJSYWxld2F5XCIsIFwiUmFsZXdheSBEb3RzXCIsIFwiUmFtYWJoYWRyYVwiLCBcIlJhbWFyYWphXCIsIFwiUmFtYmxhXCIsIFwiUmFtbWV0dG8gT25lXCIsIFwiUmFuY2hlcnNcIiwgXCJSYW5jaG9cIiwgXCJSYW5nYVwiLCBcIlJhdGlvbmFsZVwiLCBcIlJhdmkgUHJha2FzaFwiLCBcIlJlZHJlc3NlZFwiLCBcIlJlZW5pZSBCZWFuaWVcIiwgXCJSZXZhbGlhXCIsIFwiUmhvZGl1bSBMaWJyZVwiLCBcIlJpYmV5ZVwiLCBcIlJpYmV5ZSBNYXJyb3dcIiwgXCJSaWdodGVvdXNcIiwgXCJSaXNxdWVcIiwgXCJSb2JvdG9cIiwgXCJSb2JvdG8gQ29uZGVuc2VkXCIsIFwiUm9ib3RvIE1vbm9cIiwgXCJSb2JvdG8gU2xhYlwiLCBcIlJvY2hlc3RlclwiLCBcIlJvY2sgU2FsdFwiLCBcIlJva2tpdHRcIiwgXCJSb21hbmVzY29cIiwgXCJSb3BhIFNhbnNcIiwgXCJSb3NhcmlvXCIsIFwiUm9zYXJpdm9cIiwgXCJSb3VnZSBTY3JpcHRcIiwgXCJSb3poYSBPbmVcIiwgXCJSdWJpa1wiLCBcIlJ1YmlrIE1vbm8gT25lXCIsIFwiUnViaWsgT25lXCIsIFwiUnVkYVwiLCBcIlJ1ZmluYVwiLCBcIlJ1Z2UgQm9vZ2llXCIsIFwiUnVsdWtvXCIsIFwiUnVtIFJhaXNpblwiLCBcIlJ1c2xhbiBEaXNwbGF5XCIsIFwiUnVzc28gT25lXCIsIFwiUnV0aGllXCIsIFwiUnllXCIsIFwiU2FjcmFtZW50b1wiLCBcIlNhaGl0eWFcIiwgXCJTYWlsXCIsIFwiU2Fsc2FcIiwgXCJTYW5jaGV6XCIsIFwiU2FuY3JlZWtcIiwgXCJTYW5zaXRhIE9uZVwiLCBcIlNhcmFsYVwiLCBcIlNhcmluYVwiLCBcIlNhcnBhbmNoXCIsIFwiU2F0aXNmeVwiLCBcIlNjYWRhXCIsIFwiU2NoZWhlcmF6YWRlXCIsIFwiU2Nob29sYmVsbFwiLCBcIlNlYXdlZWQgU2NyaXB0XCIsIFwiU2V2aWxsYW5hXCIsIFwiU2V5bW91ciBPbmVcIiwgXCJTaGFkb3dzIEludG8gTGlnaHRcIiwgXCJTaGFkb3dzIEludG8gTGlnaHQgVHdvXCIsIFwiU2hhbnRpXCIsIFwiU2hhcmVcIiwgXCJTaGFyZSBUZWNoXCIsIFwiU2hhcmUgVGVjaCBNb25vXCIsIFwiU2hvanVtYXJ1XCIsIFwiU2hvcnQgU3RhY2tcIiwgXCJTaWVtcmVhcFwiLCBcIlNpZ21hciBPbmVcIiwgXCJTaWduaWthXCIsIFwiU2lnbmlrYSBOZWdhdGl2ZVwiLCBcIlNpbW9uZXR0YVwiLCBcIlNpbnRvbnlcIiwgXCJTaXJpbiBTdGVuY2lsXCIsIFwiU2l4IENhcHNcIiwgXCJTa3JhbmppXCIsIFwiU2xhYm8gMTNweFwiLCBcIlNsYWJvIDI3cHhcIiwgXCJTbGFja2V5XCIsIFwiU21va3VtXCIsIFwiU215dGhlXCIsIFwiU25pZ2xldFwiLCBcIlNuaXBwZXRcIiwgXCJTbm93YnVyc3QgT25lXCIsIFwiU29mYWRpIE9uZVwiLCBcIlNvZmlhXCIsIFwiU29uc2llIE9uZVwiLCBcIlNvcnRzIE1pbGwgR291ZHlcIiwgXCJTb3VyY2UgQ29kZSBQcm9cIiwgXCJTb3VyY2UgU2FucyBQcm9cIiwgXCJTb3VyY2UgU2VyaWYgUHJvXCIsIFwiU3BlY2lhbCBFbGl0ZVwiLCBcIlNwaWN5IFJpY2VcIiwgXCJTcGlubmFrZXJcIiwgXCJTcGlyYXhcIiwgXCJTcXVhZGEgT25lXCIsIFwiU3JlZSBLcnVzaG5hZGV2YXJheWFcIiwgXCJTdGFsZW1hdGVcIiwgXCJTdGFsaW5pc3QgT25lXCIsIFwiU3RhcmRvcyBTdGVuY2lsXCIsIFwiU3RpbnQgVWx0cmEgQ29uZGVuc2VkXCIsIFwiU3RpbnQgVWx0cmEgRXhwYW5kZWRcIiwgXCJTdG9rZVwiLCBcIlN0cmFpdFwiLCBcIlN1ZSBFbGxlbiBGcmFuY2lzY29cIiwgXCJTdW1hbmFcIiwgXCJTdW5zaGluZXlcIiwgXCJTdXBlcm1lcmNhZG8gT25lXCIsIFwiU3VyYVwiLCBcIlN1cmFubmFcIiwgXCJTdXJhdmFyYW1cIiwgXCJTdXdhbm5hcGh1bVwiLCBcIlN3YW5reSBhbmQgTW9vIE1vb1wiLCBcIlN5bmNvcGF0ZVwiLCBcIlRhbmdlcmluZVwiLCBcIlRhcHJvbVwiLCBcIlRhdXJpXCIsIFwiVGVrb1wiLCBcIlRlbGV4XCIsIFwiVGVuYWxpIFJhbWFrcmlzaG5hXCIsIFwiVGVub3IgU2Fuc1wiLCBcIlRleHQgTWUgT25lXCIsIFwiVGhlIEdpcmwgTmV4dCBEb29yXCIsIFwiVGllbm5lXCIsIFwiVGlsbGFuYVwiLCBcIlRpbW1hbmFcIiwgXCJUaW5vc1wiLCBcIlRpdGFuIE9uZVwiLCBcIlRpdGlsbGl1bSBXZWJcIiwgXCJUcmFkZSBXaW5kc1wiLCBcIlRyb2NjaGlcIiwgXCJUcm9jaHV0XCIsIFwiVHJ5a2tlclwiLCBcIlR1bHBlbiBPbmVcIiwgXCJVYnVudHVcIiwgXCJVYnVudHUgQ29uZGVuc2VkXCIsIFwiVWJ1bnR1IE1vbm9cIiwgXCJVbHRyYVwiLCBcIlVuY2lhbCBBbnRpcXVhXCIsIFwiVW5kZXJkb2dcIiwgXCJVbmljYSBPbmVcIiwgXCJVbmlmcmFrdHVyQ29va1wiLCBcIlVuaWZyYWt0dXJNYWd1bnRpYVwiLCBcIlVua2VtcHRcIiwgXCJVbmxvY2tcIiwgXCJVbm5hXCIsIFwiVlQzMjNcIiwgXCJWYW1waXJvIE9uZVwiLCBcIlZhcmVsYVwiLCBcIlZhcmVsYSBSb3VuZFwiLCBcIlZhc3QgU2hhZG93XCIsIFwiVmVzcGVyIExpYnJlXCIsIFwiVmlidXJcIiwgXCJWaWRhbG9rYVwiLCBcIlZpZ2FcIiwgXCJWb2Nlc1wiLCBcIlZvbGtob3ZcIiwgXCJWb2xsa29yblwiLCBcIlZvbHRhaXJlXCIsIFwiV2FpdGluZyBmb3IgdGhlIFN1bnJpc2VcIiwgXCJXYWxscG9ldFwiLCBcIldhbHRlciBUdXJuY29hdFwiLCBcIldhcm5lc1wiLCBcIldlbGxmbGVldFwiLCBcIldlbmR5IE9uZVwiLCBcIldpcmUgT25lXCIsIFwiV29yayBTYW5zXCIsIFwiWWFub25lIEthZmZlZXNhdHpcIiwgXCJZYW50cmFtYW5hdlwiLCBcIlllbGxvd3RhaWxcIiwgXCJZZXNldmEgT25lXCIsIFwiWWVzdGVyeWVhclwiLCBcIlpleWFkYVwiXTtcblxufSkuY2FsbCh0aGlzKTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsImltcG9ydCB7YXBwbHksIGFwcGx5QmFja2dyb3VuZCwgYXBwbHlTdHlsZX0gZnJvbSAnLi9pbmRleCc7XHJcbmltcG9ydCBzdHlsZWZ1bmN0aW9uIGZyb20gJy4vc3R5bGVmdW5jdGlvbic7XHJcblxyXG5jb25zdCBvbG1zID0ge1xyXG4gIGFwcGx5OiBhcHBseSxcclxuICBhcHBseUJhY2tncm91bmQ6IGFwcGx5QmFja2dyb3VuZCxcclxuICBhcHBseVN0eWxlOiBhcHBseVN0eWxlLFxyXG4gIHN0eWxlZnVuY3Rpb246IHN0eWxlZnVuY3Rpb25cclxufTtcclxuaWYgKHdpbmRvdykge1xyXG4gIHdpbmRvdy5vbG1zID0gb2xtcztcclxufVxyXG5leHBvcnQgZGVmYXVsdCBvbG1zO1xyXG5cclxuIiwiLypcclxub2wtbWFwYm94LXN0eWxlIC0gVXNlIE1hcGJveCBTdHlsZSBvYmplY3RzIHdpdGggT3BlbkxheWVyc1xyXG5Db3B5cmlnaHQgMjAxNi1wcmVzZW50IEJvdW5kbGVzcyBTcGF0aWFsLCBJbmMuXHJcbkxpY2Vuc2U6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ib3VuZGxlc3NnZW8vb2wtbWFwYm94LWdsLXN0eWxlL21hc3Rlci9MSUNFTlNFXHJcbiovXHJcblxyXG5pbXBvcnQgU3R5bGUgZnJvbSAnb2wvc3R5bGUvU3R5bGUnO1xyXG5pbXBvcnQgRmlsbCBmcm9tICdvbC9zdHlsZS9GaWxsJztcclxuaW1wb3J0IFN0cm9rZSBmcm9tICdvbC9zdHlsZS9TdHJva2UnO1xyXG5pbXBvcnQgSWNvbiBmcm9tICdvbC9zdHlsZS9JY29uJztcclxuaW1wb3J0IFRleHQgZnJvbSAnb2wvc3R5bGUvVGV4dCc7XHJcbmltcG9ydCBDaXJjbGUgZnJvbSAnb2wvc3R5bGUvQ2lyY2xlJztcclxuaW1wb3J0IFBvaW50IGZyb20gJ29sL2dlb20vUG9pbnQnO1xyXG5pbXBvcnQge2RlcmVmTGF5ZXJzfSBmcm9tICdAbWFwYm94L21hcGJveC1nbC1zdHlsZS1zcGVjJztcclxuaW1wb3J0IHtcclxuICBleHByZXNzaW9uLCBDb2xvcixcclxuICBmdW5jdGlvbiBhcyBmbixcclxuICBsYXRlc3QgYXMgc3BlYyxcclxuICBmZWF0dXJlRmlsdGVyIGFzIGNyZWF0ZUZpbHRlclxyXG59IGZyb20gJ0BtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMnO1xyXG5pbXBvcnQgbWIyY3NzIGZyb20gJ21hcGJveC10by1jc3MtZm9udCc7XHJcbmltcG9ydCB7XHJcbiAgZGVnMnJhZCxcclxuICBnZXRab29tRm9yUmVzb2x1dGlvblxyXG59IGZyb20gJy4vdXRpbCc7XHJcblxyXG5cclxuY29uc3QgaXNGdW5jdGlvbiA9IGZuLmlzRnVuY3Rpb247XHJcbmNvbnN0IGNvbnZlcnRGdW5jdGlvbiA9IGZuLmNvbnZlcnRGdW5jdGlvbjtcclxuY29uc3QgaXNFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5pc0V4cHJlc3Npb247XHJcbmNvbnN0IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uO1xyXG5cclxuY29uc3QgdHlwZXMgPSB7XHJcbiAgJ1BvaW50JzogMSxcclxuICAnTXVsdGlQb2ludCc6IDEsXHJcbiAgJ0xpbmVTdHJpbmcnOiAyLFxyXG4gICdNdWx0aUxpbmVTdHJpbmcnOiAyLFxyXG4gICdQb2x5Z29uJzogMyxcclxuICAnTXVsdGlQb2x5Z29uJzogM1xyXG59O1xyXG5jb25zdCBleHByZXNzaW9uRGF0YSA9IGZ1bmN0aW9uKHJhd0V4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xyXG4gIGNvbnN0IGNvbXBpbGVkRXhwcmVzc2lvbiA9IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbihyYXdFeHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpO1xyXG4gIGlmIChjb21waWxlZEV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoY29tcGlsZWRFeHByZXNzaW9uLnZhbHVlLm1hcChlcnIgPT4gYCR7ZXJyLmtleX06ICR7ZXJyLm1lc3NhZ2V9YCkuam9pbignLCAnKSk7XHJcbiAgfVxyXG4gIHJldHVybiBjb21waWxlZEV4cHJlc3Npb24udmFsdWU7XHJcbn07XHJcblxyXG5jb25zdCBlbXB0eU9iaiA9IHt9O1xyXG5jb25zdCB6b29tT2JqID0ge3pvb206IDB9O1xyXG5jb25zdCBmdW5jdGlvbkNhY2hlID0ge307XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIEdsIG9iamVjdCBsYXllci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGxheW91dE9yUGFpbnQgJ2xheW91dCcgb3IgJ3BhaW50Jy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IEZlYXR1cmUgcHJvcGVydHkuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlIEdsIGZlYXR1cmUuXHJcbiAqIEByZXR1cm4gez99IFZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlKGxheWVyLCBsYXlvdXRPclBhaW50LCBwcm9wZXJ0eSwgem9vbSwgZmVhdHVyZSkge1xyXG4gIGNvbnN0IGxheWVySWQgPSBsYXllci5pZDtcclxuICBpZiAoIWZ1bmN0aW9uQ2FjaGVbbGF5ZXJJZF0pIHtcclxuICAgIGZ1bmN0aW9uQ2FjaGVbbGF5ZXJJZF0gPSB7fTtcclxuICB9XHJcbiAgY29uc3QgZnVuY3Rpb25zID0gZnVuY3Rpb25DYWNoZVtsYXllcklkXTtcclxuICBpZiAoIWZ1bmN0aW9uc1twcm9wZXJ0eV0pIHtcclxuICAgIGxldCB2YWx1ZSA9IChsYXllcltsYXlvdXRPclBhaW50XSB8fCBlbXB0eU9iailbcHJvcGVydHldO1xyXG4gICAgY29uc3QgcHJvcGVydHlTcGVjID0gc3BlY1tgJHtsYXlvdXRPclBhaW50fV8ke2xheWVyLnR5cGV9YF1bcHJvcGVydHldO1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFsdWUgPSBwcm9wZXJ0eVNwZWMuZGVmYXVsdDtcclxuICAgIH1cclxuICAgIGxldCBpc0V4cHIgPSBpc0V4cHJlc3Npb24oKHZhbHVlKSk7XHJcbiAgICBpZiAoIWlzRXhwciAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICB2YWx1ZSA9IGNvbnZlcnRGdW5jdGlvbih2YWx1ZSwgcHJvcGVydHlTcGVjKTtcclxuICAgICAgaXNFeHByID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpc0V4cHIpIHtcclxuICAgICAgY29uc3QgY29tcGlsZWRFeHByZXNzaW9uID0gZXhwcmVzc2lvbkRhdGEodmFsdWUsIHByb3BlcnR5U3BlYyk7XHJcbiAgICAgIGZ1bmN0aW9uc1twcm9wZXJ0eV0gPSBjb21waWxlZEV4cHJlc3Npb24uZXZhbHVhdGUuYmluZChjb21waWxlZEV4cHJlc3Npb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHByb3BlcnR5U3BlYy50eXBlID09ICdjb2xvcicpIHtcclxuICAgICAgICB2YWx1ZSA9IENvbG9yLnBhcnNlKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbnNbcHJvcGVydHldID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuICB6b29tT2JqLnpvb20gPSB6b29tO1xyXG4gIHJldHVybiBmdW5jdGlvbnNbcHJvcGVydHldKHpvb21PYmosIGZlYXR1cmUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb3ZlcnRJY29uQW5jaG9yKGljb25BbmNob3IpIHtcclxuICBsZXQgYW5jaG9yT2Zmc2V0ID0gWzAuNSwgMC41XTtcclxuICBpZiAoWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J10uaW5kZXhPZihpY29uQW5jaG9yKSA+IC0xKSB7XHJcbiAgICBhbmNob3JPZmZzZXQgPSBbMCwgMF07XHJcbiAgfVxyXG4gIGlmIChpY29uQW5jaG9yID09PSAnbGVmdCcpIHtcclxuICAgIGljb25BbmNob3IgPSAndG9wLWxlZnQnO1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAsIDAuNV07XHJcbiAgfVxyXG4gIGlmIChpY29uQW5jaG9yID09PSAncmlnaHQnKSB7XHJcbiAgICBpY29uQW5jaG9yID0gJ3RvcC1sZWZ0JztcclxuICAgIGFuY2hvck9mZnNldCA9IFsxLCAwLjVdO1xyXG4gIH1cclxuICBpZiAoaWNvbkFuY2hvciA9PT0gJ2JvdHRvbScpIHtcclxuICAgIGljb25BbmNob3IgPSAndG9wLWxlZnQnO1xyXG4gICAgYW5jaG9yT2Zmc2V0ID0gWzAuNSwgMV07XHJcbiAgfVxyXG4gIGlmIChpY29uQW5jaG9yID09PSAndG9wJykge1xyXG4gICAgaWNvbkFuY2hvciA9ICd0b3AtbGVmdCc7XHJcbiAgICBhbmNob3JPZmZzZXQgPSBbMC41LCAwXTtcclxuICB9XHJcbiAgLy9jZW50ZXJcclxuICByZXR1cm4ge1xyXG4gICAgYW5jaG9yT2Zmc2V0OiBhbmNob3JPZmZzZXQsXHJcbiAgICBpY29uQW5jaG9yOiBpY29uQW5jaG9yXHJcbiAgfTtcclxufVxyXG5cclxuY29uc3QgZm9udE1hcCA9IHt9O1xyXG5cclxuZnVuY3Rpb24gY2hvb3NlRm9udChmb250cywgYXZhaWxhYmxlRm9udHMpIHtcclxuICBpZiAoZm9udE1hcFtmb250c10pIHtcclxuICAgIHJldHVybiBmb250TWFwW2ZvbnRzXTtcclxuICB9XHJcbiAgaWYgKGF2YWlsYWJsZUZvbnRzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmb250cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgIGNvbnN0IGZvbnQgPSBmb250c1tpXTtcclxuICAgICAgaWYgKGF2YWlsYWJsZUZvbnRzLmluZGV4T2YoZm9udCkgIT0gLTEpIHtcclxuICAgICAgICBmb250TWFwW2ZvbnRzXSA9IGZvbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZm9udE1hcFtmb250c10pIHtcclxuICAgICAgLy8gZmFsbGJhY2sgZm9udFxyXG4gICAgICBmb250TWFwW2ZvbnRzXSA9IGZvbnRzW2ZvbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBmb250TWFwW2ZvbnRzXSA9IGZvbnRzWzBdO1xyXG4gIH1cclxuICByZXR1cm4gZm9udE1hcFtmb250c107XHJcbn1cclxuXHJcbmNvbnN0IGZpbHRlckNhY2hlID0ge307XHJcblxyXG5mdW5jdGlvbiBldmFsdWF0ZUZpbHRlcihsYXllcklkLCBmaWx0ZXIsIGZlYXR1cmUsIHpvb20pIHtcclxuICBpZiAoIShsYXllcklkIGluIGZpbHRlckNhY2hlKSkge1xyXG4gICAgZmlsdGVyQ2FjaGVbbGF5ZXJJZF0gPSBjcmVhdGVGaWx0ZXIoZmlsdGVyKS5maWx0ZXI7XHJcbiAgfVxyXG4gIHpvb21PYmouem9vbSA9IHpvb207XHJcbiAgcmV0dXJuIGZpbHRlckNhY2hlW2xheWVySWRdKHpvb21PYmosIGZlYXR1cmUpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY29sb3JXaXRoT3BhY2l0eShjb2xvciwgb3BhY2l0eSkge1xyXG4gIGlmIChjb2xvcikge1xyXG4gICAgaWYgKGNvbG9yLmEgPT09IDAgfHwgb3BhY2l0eSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYSA9IGNvbG9yLmE7XHJcbiAgICBvcGFjaXR5ID0gb3BhY2l0eSA9PT0gdW5kZWZpbmVkID8gMSA6IG9wYWNpdHk7XHJcbiAgICByZXR1cm4gJ3JnYmEoJyArIE1hdGgucm91bmQoY29sb3IuciAqIDI1NSAvIGEpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5nICogMjU1IC8gYSkgK1xyXG4gICAgICAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIgKiAyNTUgLyBhKSArICcsJyArIChhICogb3BhY2l0eSkgKyAnKSc7XHJcbiAgfVxyXG4gIHJldHVybiBjb2xvcjtcclxufVxyXG5cclxuY29uc3QgdGVtcGxhdGVSZWdFeCA9IC9eKFteXSopXFx7KC4qKVxcfShbXl0qKSQvO1xyXG5cclxuZnVuY3Rpb24gZnJvbVRlbXBsYXRlKHRleHQsIHByb3BlcnRpZXMpIHtcclxuICBsZXQgcGFydHM7XHJcbiAgZG8ge1xyXG4gICAgcGFydHMgPSB0ZXh0Lm1hdGNoKHRlbXBsYXRlUmVnRXgpO1xyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydGllc1twYXJ0c1syXV0gfHwgJyc7XHJcbiAgICAgIHRleHQgPSBwYXJ0c1sxXSArIHZhbHVlICsgcGFydHNbM107XHJcbiAgICB9XHJcbiAgfSB3aGlsZSAocGFydHMpO1xyXG4gIHJldHVybiB0ZXh0O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHN0eWxlIGZ1bmN0aW9uIGZyb20gdGhlIGBnbFN0eWxlYCBvYmplY3QgZm9yIGFsbCBsYXllcnMgdGhhdCB1c2VcclxuICogdGhlIHNwZWNpZmllZCBgc291cmNlYCwgd2hpY2ggbmVlZHMgdG8gYmUgYSBgXCJ0eXBlXCI6IFwidmVjdG9yXCJgIG9yXHJcbiAqIGBcInR5cGVcIjogXCJnZW9qc29uXCJgIHNvdXJjZSBhbmQgYXBwbGllcyBpdCB0byB0aGUgc3BlY2lmaWVkIE9wZW5MYXllcnMgbGF5ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2wubGF5ZXIuVmVjdG9yfG9sLmxheWVyLlZlY3RvclRpbGV9IG9sTGF5ZXIgT3BlbkxheWVycyBsYXllciB0b1xyXG4gKiBhcHBseSB0aGUgc3R5bGUgdG8uIEluIGFkZGl0aW9uIHRvIHRoZSBzdHlsZSwgdGhlIGxheWVyIHdpbGwgZ2V0IHR3b1xyXG4gKiBwcm9wZXJ0aWVzOiBgbWFwYm94LXNvdXJjZWAgd2lsbCBiZSB0aGUgYGlkYCBvZiB0aGUgYGdsU3R5bGVgJ3Mgc291cmNlIHVzZWRcclxuICogZm9yIHRoZSBsYXllciwgYW5kIGBtYXBib3gtbGF5ZXJzYCB3aWxsIGJlIGFuIGFycmF5IG9mIHRoZSBgaWRgcyBvZiB0aGVcclxuICogYGdsU3R5bGVgJ3MgbGF5ZXJzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGdsU3R5bGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gc291cmNlIGBzb3VyY2VgIGtleSBvciBhbiBhcnJheSBvZiBsYXllciBgaWRgc1xyXG4gKiBmcm9tIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0LiBXaGVuIGEgYHNvdXJjZWAga2V5IGlzIHByb3ZpZGVkLCBhbGwgbGF5ZXJzIGZvclxyXG4gKiB0aGUgc3BlY2lmaWVkIHNvdXJjZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdHlsZSBmdW5jdGlvbi4gV2hlbiBsYXllciBgaWRgc1xyXG4gKiBhcmUgcHJvdmlkZWQsIHRoZXkgbXVzdCBiZSBmcm9tIGxheWVycyB0aGF0IHVzZSB0aGUgc2FtZSBzb3VyY2UuXHJcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3Jlc29sdXRpb25zPVs3ODI3MS41MTY5NjQwMjA0OCwgMzkxMzUuNzU4NDgyMDEwMjQsXHJcbiAqIDE5NTY3Ljg3OTI0MTAwNTEyLCA5NzgzLjkzOTYyMDUwMjU2LCA0ODkxLjk2OTgxMDI1MTI4LCAyNDQ1Ljk4NDkwNTEyNTY0LFxyXG4gKiAxMjIyLjk5MjQ1MjU2MjgyLCA2MTEuNDk2MjI2MjgxNDEsIDMwNS43NDgxMTMxNDA3MDUsIDE1Mi44NzQwNTY1NzAzNTI1LFxyXG4gKiA3Ni40MzcwMjgyODUxNzYyNSwgMzguMjE4NTE0MTQyNTg4MTMsIDE5LjEwOTI1NzA3MTI5NDA2MywgOS41NTQ2Mjg1MzU2NDcwMzIsXHJcbiAqIDQuNzc3MzE0MjY3ODIzNTE2LCAyLjM4ODY1NzEzMzkxMTc1OCwgMS4xOTQzMjg1NjY5NTU4NzksIDAuNTk3MTY0MjgzNDc3OTM5NSxcclxuICogMC4yOTg1ODIxNDE3Mzg5Njk3NCwgMC4xNDkyOTEwNzA4Njk0ODQ4NywgMC4wNzQ2NDU1MzU0MzQ3NDI0NF1dXHJcbiAqIFJlc29sdXRpb25zIGZvciBtYXBwaW5nIHJlc29sdXRpb24gdG8gem9vbSBsZXZlbC5cclxuICogQHBhcmFtIHtPYmplY3R9IFtzcHJpdGVEYXRhPXVuZGVmaW5lZF0gU3ByaXRlIGRhdGEgZnJvbSB0aGUgdXJsIHNwZWNpZmllZCBpblxyXG4gKiB0aGUgTWFwYm94IFN0eWxlIG9iamVjdCdzIGBzcHJpdGVgIHByb3BlcnR5LiBPbmx5IHJlcXVpcmVkIGlmIGEgYHNwcml0ZWBcclxuICogcHJvcGVydHkgaXMgc3BlY2lmaWVkIGluIHRoZSBNYXBib3ggU3R5bGUgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Nwcml0ZUltYWdlVXJsPXVuZGVmaW5lZF0gU3ByaXRlIGltYWdlIHVybCBmb3IgdGhlIHNwcml0ZVxyXG4gKiBzcGVjaWZpZWQgaW4gdGhlIE1hcGJveCBTdHlsZSBvYmplY3QncyBgc3ByaXRlYCBwcm9wZXJ0eS4gT25seSByZXF1aXJlZCBpZiBhXHJcbiAqIGBzcHJpdGVgIHByb3BlcnR5IGlzIHNwZWNpZmllZCBpbiB0aGUgTWFwYm94IFN0eWxlIG9iamVjdC5cclxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbZm9udHM9dW5kZWZpbmVkXSBBcnJheSBvZiBhdmFpbGFibGUgZm9udHMsIHVzaW5nIHRoZVxyXG4gKiBzYW1lIGZvbnQgbmFtZXMgYXMgdGhlIE1hcGJveCBTdHlsZSBvYmplY3QuIElmIG5vdCBwcm92aWRlZCwgdGhlIHN0eWxlXHJcbiAqIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHVzZSB0aGUgZmlyc3QgZm9udCBmcm9tIHRoZSBmb250IGFycmF5LlxyXG4gKiBAcmV0dXJuIHtvbC5zdHlsZS5TdHlsZUZ1bmN0aW9ufSBTdHlsZSBmdW5jdGlvbiBmb3IgdXNlIGluXHJcbiAqIGBvbC5sYXllci5WZWN0b3JgIG9yIGBvbC5sYXllci5WZWN0b3JUaWxlYC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9sTGF5ZXIsIGdsU3R5bGUsIHNvdXJjZSwgcmVzb2x1dGlvbnMsIHNwcml0ZURhdGEsIHNwcml0ZUltYWdlVXJsLHNwcml0ZUltYWdlLCBmb250cykge1xyXG4gIGlmICghcmVzb2x1dGlvbnMpIHtcclxuICAgIHJlc29sdXRpb25zID0gW107XHJcbiAgICBmb3IgKGxldCByZXMgPSA3ODI3MS41MTY5NjQwMjA0ODsgcmVzb2x1dGlvbnMubGVuZ3RoIDwgMjE7IHJlcyAvPSAyKSB7XHJcbiAgICAgIHJlc29sdXRpb25zLnB1c2gocmVzKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHR5cGVvZiBnbFN0eWxlID09ICdzdHJpbmcnKSB7XHJcbiAgICBnbFN0eWxlID0gSlNPTi5wYXJzZShnbFN0eWxlKTtcclxuICB9XHJcbiAgaWYgKGdsU3R5bGUudmVyc2lvbiAhPSA4KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsU3R5bGUgdmVyc2lvbiA4IHJlcXVpcmVkLicpO1xyXG4gIH1cclxuXHJcbiAgbGV0IHNwcml0ZUltZ1NpemU7XHJcbiAgaWYgKHNwcml0ZUltYWdlVXJsICYmICFzcHJpdGVJbWFnZSkge1xyXG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgc3ByaXRlSW1hZ2UgPSBpbWc7XHJcbiAgICAgIHNwcml0ZUltZ1NpemUgPSBbaW1nLndpZHRoLCBpbWcuaGVpZ2h0XTtcclxuICAgICAgb2xMYXllci5jaGFuZ2VkKCk7XHJcbiAgICB9O1xyXG4gICAgaW1nLnNyYyA9IHNwcml0ZUltYWdlVXJsO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ0FOVkFTJykuZ2V0Q29udGV4dCgnMmQnKTtcclxuICBjb25zdCBtZWFzdXJlQ2FjaGUgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gd3JhcENoaW5lc2VUZXh0KHRleHQsIG1heFdpZHRoLCBjdHgpIHtcclxuICAgIHZhciB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XHJcbiAgICBpZiAodGV4dFdpZHRoID4gbWF4V2lkdGgpIHtcclxuICAgICAgbGV0IHJlcyA9IFtdO1xyXG4gICAgICBsZXQgdGVtcCA9IFtdO1xyXG4gICAgICBsZXQgc3BsaXRUZXh0ID0gdGV4dC5zcGxpdCgnJyk7XHJcbiAgICAgIHNwbGl0VGV4dC5mb3JFYWNoKChzaW5nbGVUZXh0KSA9PiB7XHJcbiAgICAgICAgbGV0IHRlbXBUZXh0ID0gdGVtcC5qb2luKCcnKSArIHNpbmdsZVRleHQ7XHJcbiAgICAgICAgaWYgKGN0eC5tZWFzdXJlVGV4dCh0ZW1wVGV4dCkud2lkdGggPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgcmVzLnB1c2godGVtcC5qb2luKCcnKSk7XHJcbiAgICAgICAgICB0ZW1wID0gW3NpbmdsZVRleHRdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0ZW1wLnB1c2goc2luZ2xlVGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmVzLnB1c2godGVtcC5qb2luKCcnKSk7XHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3RleHRdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gd3JhcFRleHQodGV4dCwgZm9udCwgZW0pIHtcclxuICAgIGNvbnN0IGtleSA9IGVtICsgJywnICsgZm9udCArICcsJyArIHRleHQ7XHJcbiAgICBsZXQgd3JhcHBlZFRleHQgPSBtZWFzdXJlQ2FjaGVba2V5XTtcclxuICAgIGlmICghd3JhcHBlZFRleHQpIHtcclxuICAgICAgY3R4LmZvbnQgPSBmb250O1xyXG4gICAgICBjb25zdCBvbmVFbSA9IGN0eC5tZWFzdXJlVGV4dCgnTScpLndpZHRoO1xyXG4gICAgICBjb25zdCB3aWR0aCA9IG9uZUVtICogZW07XHJcbiAgICAgIHZhciB3b3JkcyA9IFtdO1xyXG4gICAgICBpZiAoL1tcXHU0RTAwLVxcdTlGQTVdKy8udGVzdCh0ZXh0KSkge1xyXG4gICAgICAgIHdvcmRzID0gd3JhcENoaW5lc2VUZXh0KHRleHQsIHdpZHRoLCBjdHgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdvcmRzID0gdGV4dC5zcGxpdCgnICcpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBsaW5lID0gJyc7XHJcbiAgICAgIGNvbnN0IGxpbmVzID0gW107XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHdvcmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICBjb25zdCB3b3JkID0gd29yZHNbaV07XHJcbiAgICAgICAgaWYgKChjdHgubWVhc3VyZVRleHQobGluZSArIHdvcmQpLndpZHRoIDw9IHdpZHRoKSkge1xyXG4gICAgICAgICAgbGluZSArPSAobGluZSA/ICcgJyA6ICcnKSArIHdvcmQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChsaW5lKSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsaW5lID0gd29yZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xyXG4gICAgICB9XHJcbiAgICAgIG1lYXN1cmVDYWNoZVtrZXldID0gd3JhcHBlZFRleHQgPSBsaW5lcy5qb2luKCdcXG4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiB3cmFwcGVkVGV4dDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGFsbExheWVycyA9IGRlcmVmTGF5ZXJzKGdsU3R5bGUubGF5ZXJzKTtcclxuXHJcbiAgY29uc3QgbGF5ZXJzQnlTb3VyY2VMYXllciA9IHt9O1xyXG4gIGNvbnN0IG1hcGJveExheWVycyA9IFtdO1xyXG4gIGxldCBtYXBib3hTb3VyY2U7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYWxsTGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgIGNvbnN0IGxheWVyID0gYWxsTGF5ZXJzW2ldO1xyXG4gICAgY29uc3QgbGF5ZXJJZCA9IGxheWVyLmlkO1xyXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT0gJ3N0cmluZycgJiYgbGF5ZXIuc291cmNlID09IHNvdXJjZSB8fFxyXG4gICAgICBzb3VyY2UuaW5kZXhPZihsYXllcklkKSAhPT0gLTEpIHtcclxuICAgICAgY29uc3Qgc291cmNlTGF5ZXIgPSBsYXllclsnc291cmNlLWxheWVyJ107XHJcbiAgICAgIGlmICghbWFwYm94U291cmNlKSB7XHJcbiAgICAgICAgbWFwYm94U291cmNlID0gbGF5ZXIuc291cmNlO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBsYXllcnMgPSBsYXllcnNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVyXTtcclxuICAgICAgaWYgKCFsYXllcnMpIHtcclxuICAgICAgICBsYXllcnMgPSBsYXllcnNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVyXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGxheWVycy5wdXNoKHtcclxuICAgICAgICBsYXllcjogbGF5ZXIsXHJcbiAgICAgICAgaW5kZXg6IGlcclxuICAgICAgfSk7XHJcbiAgICAgIG1hcGJveExheWVycy5wdXNoKGxheWVySWQpO1xyXG4gICAgfVxyXG4gICAgLy8gLy8gVE9ETyByZXZpc2l0IHdoZW4gZGlmZmluZyBnZXRzIGFkZGVkXHJcbiAgICBkZWxldGUgZnVuY3Rpb25DYWNoZVtsYXllcklkXTtcclxuICAgIGRlbGV0ZSBmaWx0ZXJDYWNoZVtsYXllcklkXTtcclxuICB9XHJcbiAgY29uc3QgaWNvbkltYWdlQ2FjaGUgPSB7fTtcclxuXHJcbiAgY29uc3Qgc3R5bGVzID0gW107XHJcbiAgY29uc3QgcGF0dGVybkNhY2hlID0ge307XHJcblxyXG4gIGNvbnN0IHN0eWxlRnVuY3Rpb24gPSBmdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKSB7XHJcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gZmVhdHVyZS5nZXRQcm9wZXJ0aWVzKCk7XHJcbiAgICBmZWF0dXJlLnN0eWxlSWRzID0gZmVhdHVyZS5zdHlsZUlkcyB8fCB7fTtcclxuICAgIGNvbnN0IGxheWVycyA9IGxheWVyc0J5U291cmNlTGF5ZXJbcHJvcGVydGllcy5sYXllcl07XHJcbiAgICBpZiAoIWxheWVycykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgem9vbSA9IHJlc29sdXRpb25zLmluZGV4T2YocmVzb2x1dGlvbik7XHJcbiAgICBpZiAoem9vbSA9PSAtMSkge1xyXG4gICAgICB6b29tID0gTWF0aC5yb3VuZChnZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCByZXNvbHV0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdHlwZSA9IHR5cGVzW2ZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCldO1xyXG4gICAgY29uc3QgZiA9IHtcclxuICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcclxuICAgICAgdHlwZTogdHlwZVxyXG4gICAgfTtcclxuICAgIGxldCBzdHlsZXNMZW5ndGggPSAtMTtcclxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgIGNvbnN0IGxheWVyRGF0YSA9IGxheWVyc1tpXTtcclxuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllckRhdGEubGF5ZXI7XHJcbiAgICAgIGNvbnN0IGxheWVySWQgPSBsYXllci5pZDtcclxuXHJcbiAgICAgIGNvbnN0IGxheW91dCA9IGxheWVyLmxheW91dCB8fCBlbXB0eU9iajtcclxuICAgICAgY29uc3QgcGFpbnQgPSBsYXllci5wYWludCB8fCBlbXB0eU9iajtcclxuICAgICAgaWYgKGxheW91dC52aXNpYmlsaXR5ID09PSAnbm9uZScgfHwgKCdtaW56b29tJyBpbiBsYXllciAmJiB6b29tIDwgbGF5ZXIubWluem9vbSkgfHxcclxuICAgICAgICAoJ21heHpvb20nIGluIGxheWVyICYmIHpvb20gPj0gbGF5ZXIubWF4em9vbSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dID0gZmVhdHVyZS5zdHlsZUlkc1t6b29tXSB8fCBbXTtcclxuICAgICAgY29uc3QgZmlsdGVyID0gbGF5ZXIuZmlsdGVyO1xyXG4gICAgICBsZXQgaWNvbiwgaWNvbkltZztcclxuICAgICAgaWYgKCFmaWx0ZXIgfHwgZXZhbHVhdGVGaWx0ZXIobGF5ZXJJZCwgZmlsdGVyLCBmLCB6b29tKSkge1xyXG4gICAgICAgIGxldCBjb2xvciwgb3BhY2l0eSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VDb2xvciwgc3R5bGU7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBsYXllckRhdGEuaW5kZXg7XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gMyAmJiBsYXllci50eXBlID09ICdmaWxsJykge1xyXG4gICAgICAgICAgb3BhY2l0eSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnZmlsbC1vcGFjaXR5Jywgem9vbSwgZik7XHJcbiAgICAgICAgICBpZiAoJ2ZpbGwtcGF0dGVybicgaW4gcGFpbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgaWNvbkltYWdlID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdmaWxsLXBhdHRlcm4nLCB6b29tLCBmKTtcclxuICAgICAgICAgICAgaWYgKGljb25JbWFnZSkge1xyXG4gICAgICAgICAgICAgIGljb24gPSB0eXBlb2YgaWNvbkltYWdlID09PSAnc3RyaW5nJyA/IGZyb21UZW1wbGF0ZShpY29uSW1hZ2UsIHByb3BlcnRpZXMpIDogaWNvbkltYWdlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgaWYgKHNwcml0ZUltYWdlICYmIHNwcml0ZURhdGEgJiYgc3ByaXRlRGF0YVtpY29uXSkge1xyXG4gICAgICAgICAgICAgICAgKytzdHlsZXNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldFRleHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdID0gbmV3IFN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBuZXcgRmlsbCgpXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsbCA9IHN0eWxlLmdldEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uX2NhY2hlX2tleSA9IGljb24gKyAnLicgKyBvcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSBwYXR0ZXJuQ2FjaGVbaWNvbl9jYWNoZV9rZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNwcml0ZUltYWdlRGF0YSA9IHNwcml0ZURhdGFbaWNvbl07XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBzcHJpdGVJbWFnZURhdGEud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEueSxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKGNhbnZhcywgJ3JlcGVhdCcpO1xyXG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuQ2FjaGVbaWNvbl9jYWNoZV9rZXldID0gcGF0dGVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbGwuc2V0Q29sb3IocGF0dGVybik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCdmaWxsLWNvbG9yJyBpbiBwYWludCkge1xyXG4gICAgICAgICAgICBjb2xvciA9IGNvbG9yV2l0aE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdmaWxsLWNvbG9yJywgem9vbSwgZiksIG9wYWNpdHkpO1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgICArK3N0eWxlc0xlbmd0aDtcclxuICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldEZpbGwoKSB8fCBzdHlsZS5nZXRTdHJva2UoKSB8fCBzdHlsZS5nZXRUZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICBmaWxsOiBuZXcgRmlsbCgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZmlsbCA9IHN0eWxlLmdldEZpbGwoKTtcclxuICAgICAgICAgICAgICBmaWxsLnNldENvbG9yKGNvbG9yKTtcclxuICAgICAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgnZmlsbC1vdXRsaW5lLWNvbG9yJyBpbiBwYWludCkge1xyXG4gICAgICAgICAgICAgIHN0cm9rZUNvbG9yID0gY29sb3JXaXRoT3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ZpbGwtb3V0bGluZS1jb2xvcicsIHpvb20sIHByb3BlcnRpZXMpLCBvcGFjaXR5KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgnZmlsbC1hbnRpYWxpYXMnIGluIHBhaW50KSB7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBjb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgICAgICAgICArK3N0eWxlc0xlbmd0aDtcclxuICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldFN0cm9rZSgpIHx8IHN0eWxlLmdldEZpbGwoKSB8fCBzdHlsZS5nZXRUZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICBzdHJva2U6IG5ldyBTdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgIHN0cm9rZS5zZXRDb2xvcihzdHJva2VDb2xvcik7XHJcbiAgICAgICAgICAgICAgc3Ryb2tlLnNldFdpZHRoKDEpO1xyXG4gICAgICAgICAgICAgIHN0eWxlLnNldFpJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgIT0gMSAmJiBsYXllci50eXBlID09ICdsaW5lJykge1xyXG4gICAgICAgICAgY29sb3IgPSAhKCdsaW5lLXBhdHRlcm4nIGluIHBhaW50KSAmJiAnbGluZS1jb2xvcicgaW4gcGFpbnQgP1xyXG4gICAgICAgICAgICBjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnbGluZS1jb2xvcicsIHpvb20sIGYpLCBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2xpbmUtb3BhY2l0eScsIHpvb20sIGYpKSA6XHJcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdsaW5lLXdpZHRoJywgem9vbSwgZik7XHJcbiAgICAgICAgICBpZiAoY29sb3IgJiYgd2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5pbmRleE9mKGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdO1xyXG4gICAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRTdHJva2UoKSB8fCBzdHlsZS5nZXRGaWxsKCkgfHwgc3R5bGUuZ2V0VGV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IG5ldyBTdHJva2UoKVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xyXG4gICAgICAgICAgICBzdHJva2Uuc2V0TGluZUNhcChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdsaW5lLWNhcCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgc3Ryb2tlLnNldExpbmVKb2luKGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2xpbmUtam9pbicsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgc3Ryb2tlLnNldE1pdGVyTGltaXQoZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnbGluZS1taXRlci1saW1pdCcsIHpvb20sIGYpKTtcclxuICAgICAgICAgICAgc3Ryb2tlLnNldENvbG9yKGNvbG9yKTtcclxuICAgICAgICAgICAgc3Ryb2tlLnNldFdpZHRoKHdpZHRoKTtcclxuICAgICAgICAgICAgc3Ryb2tlLnNldExpbmVEYXNoKHBhaW50WydsaW5lLWRhc2hhcnJheSddID9cclxuICAgICAgICAgICAgICBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2xpbmUtZGFzaGFycmF5Jywgem9vbSwgZikubWFwKGZ1bmN0aW9uKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4ICogd2lkdGg7XHJcbiAgICAgICAgICAgICAgfSkgOiBudWxsKTtcclxuICAgICAgICAgICAgc3R5bGUuc2V0WkluZGV4KGluZGV4KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBoYXNJbWFnZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB0ZXh0ID0gbnVsbDtcclxuICAgICAgICBsZXQgc2tpcExhYmVsO1xyXG4gICAgICAgIGlmICgodHlwZSA9PSAxIHx8IHR5cGUgPT0gMikgJiYgJ2ljb24taW1hZ2UnIGluIGxheW91dCkge1xyXG4gICAgICAgICAgY29uc3QgaWNvbkltYWdlID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1pbWFnZScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgaWYgKGljb25JbWFnZSkge1xyXG4gICAgICAgICAgICBpY29uID0gdHlwZW9mIGljb25JbWFnZSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICA/IGZyb21UZW1wbGF0ZShpY29uSW1hZ2UsIHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgOiBpY29uSW1hZ2UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbGV0IHN0eWxlR2VvbSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHNwcml0ZUltYWdlICYmIHNwcml0ZURhdGEgJiYgc3ByaXRlRGF0YVtpY29uXSkge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlID09IDIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGdlb20gPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBvbCBwYWNrYWdlIGFuZCBvbC1kZWJ1Zy5qcyBvbmx5XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbS5nZXRGbGF0TWlkcG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gZ2VvbS5nZXRFeHRlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguc3FydChNYXRoLm1heChcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdygoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIHJlc29sdXRpb24sIDIpLFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KChleHRlbnRbM10gLSBleHRlbnRbMV0pIC8gcmVzb2x1dGlvbiwgMikpKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiAxNTApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0ZJWE1FIERvIG5vdCBoYXJkLWNvZGUgYSBzaXplIG9mIDE1MFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlR2VvbSA9IG5ldyBQb2ludChnZW9tLmdldEZsYXRNaWRwb2ludCgpKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gMiB8fCBzdHlsZUdlb20pIHtcclxuICAgICAgICAgICAgICAgICsrc3R5bGVzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3R5bGVJZHNbem9vbV0uaW5kZXhPZihsYXllcklkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zdHlsZUlkc1t6b29tXS5wdXNoKGxheWVySWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIGlmICghc3R5bGUgfHwgIXN0eWxlLmdldEltYWdlKCkgfHwgc3R5bGUuZ2V0RmlsbCgpIHx8IHN0eWxlLmdldFN0cm9rZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0eWxlLnNldEdlb21ldHJ5KHN0eWxlR2VvbSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uU2l6ZSA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2ljb24tc2l6ZScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbkNvbG9yID0gcGFpbnRbJ2ljb24tY29sb3InXSAhPT0gdW5kZWZpbmVkID8gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdpY29uLWNvbG9yJywgem9vbSwgZikgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvblRyYW5zbGF0ZSA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnaWNvbi10cmFuc2xhdGUnLCB6b29tLCBmKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25UcmFuc2xhdGVBbmNob3IgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2ljb24tdHJhbnNsYXRlLWFuY2hvcicsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbkFuY2hvclZhbHVlID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAnaWNvbi1hbmNob3InLCB6b29tLCBmKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25PZmZzZXQgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICdpY29uLW9mZnNldCcsIHpvb20sIGYpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHtcclxuICAgICAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICBpY29uQW5jaG9yID0gaWNvbkFuY2hvclZhbHVlXHJcbiAgICAgICAgICAgICAgICB9ID0gY292ZXJ0SWNvbkFuY2hvcihpY29uQW5jaG9yVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGljb25fY2FjaGVfa2V5ID0gaWNvbiArICcuJyArIGljb25TaXplICsgJy4nICsgaWNvblRyYW5zbGF0ZSArICcuJyArIGljb25UcmFuc2xhdGVBbmNob3IgKyAnLicgKyBpY29uQW5jaG9yICsgJy4nICsgaWNvbk9mZnNldCArICcuJyArIGFuY2hvck9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmIChpY29uQ29sb3IgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgaWNvbl9jYWNoZV9rZXkgKz0gJy4nICsgaWNvbkNvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWNvbkltZyA9IGljb25JbWFnZUNhY2hlW2ljb25fY2FjaGVfa2V5XTtcclxuICAgICAgICAgICAgICAgIGlmICghaWNvbkltZykge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGVJbWFnZURhdGEgPSBzcHJpdGVEYXRhW2ljb25dO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gc3ByaXRlSW1hZ2VEYXRhLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc3ByaXRlSW1hZ2VEYXRhLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLngsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLnksXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbWFnZURhdGEuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChpY29uQ29sb3IgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjdXQgb3V0IHRoZSBzcHJpdGUgYW5kIGNvbG9yIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcldpdGhPcGFjaXR5KGljb25Db2xvciwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IDAsIGNjID0gZGF0YS5kYXRhLmxlbmd0aDsgYyA8IGNjOyBjICs9IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtjXSA9IGNvbG9yWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhW2MgKyAxXSA9IGNvbG9yWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhW2MgKyAyXSA9IGNvbG9yWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVPZmZzZXQgPSBbaWNvblRyYW5zbGF0ZVswXSAvIHNwcml0ZUltYWdlRGF0YS53aWR0aCwgaWNvblRyYW5zbGF0ZVsxXSAvIHNwcml0ZUltYWdlRGF0YS5oZWlnaHRdO1xyXG4gICAgICAgICAgICAgICAgICBpY29uSW1nID0gaWNvbkltYWdlQ2FjaGVbaWNvbl9jYWNoZV9rZXldID0gbmV3IEljb24oe1xyXG4gICAgICAgICAgICAgICAgICAgIGltZzogY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvck9yaWdpbjogaWNvbkFuY2hvcixcclxuICAgICAgICAgICAgICAgICAgICBhbmNob3I6IFtpY29uT2Zmc2V0WzBdICsgYW5jaG9yT2Zmc2V0WzBdICsgdHJhbnNsYXRlT2Zmc2V0WzBdLCBpY29uT2Zmc2V0WzFdICsgYW5jaG9yT2Zmc2V0WzFdIC0gdHJhbnNsYXRlT2Zmc2V0WzFdXSxcclxuICAgICAgICAgICAgICAgICAgICBpbWdTaXplOiBbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogaWNvblNpemUgLyBzcHJpdGVJbWFnZURhdGEucGl4ZWxSYXRpb1xyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCByb3RhdGVWYWx1ZSA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ2ljb24tcm90YXRlJywgem9vbSwgZik7XHJcbiAgICAgICAgICAgICAgICBpZiAocm90YXRlVmFsdWUuaW5kZXhPZiAmJiByb3RhdGVWYWx1ZS5pbmRleE9mKCd7JykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgcm90YXRlVmFsdWUgPSAzNjAgLSBmcm9tVGVtcGxhdGUocm90YXRlVmFsdWUsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWNvbkltZy5zZXRSb3RhdGlvbihkZWcycmFkKHJvdGF0ZVZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBpY29uSW1nLnNldE9wYWNpdHkoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdpY29uLW9wYWNpdHknLCB6b29tLCBmKSk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRJbWFnZShpY29uSW1nKTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBzdHlsZS5nZXRUZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRUZXh0KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoOTk5OTkgLSBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBoYXNJbWFnZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBza2lwTGFiZWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2tpcExhYmVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlID09IDEgJiYgJ2NpcmNsZS1yYWRpdXMnIGluIHBhaW50KSB7XHJcbiAgICAgICAgICArK3N0eWxlc0xlbmd0aDtcclxuICAgICAgICAgIGlmIChmZWF0dXJlLnN0eWxlSWRzW3pvb21dLmluZGV4T2YobGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuc3R5bGVJZHNbem9vbV0ucHVzaChsYXllcklkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF07XHJcbiAgICAgICAgICBpZiAoIXN0eWxlIHx8ICFzdHlsZS5nZXRJbWFnZSgpIHx8IHN0eWxlLmdldEZpbGwoKSB8fCBzdHlsZS5nZXRTdHJva2UoKSkge1xyXG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlc1tzdHlsZXNMZW5ndGhdID0gbmV3IFN0eWxlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1yYWRpdXMnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZVN0cm9rZUNvbG9yID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdjaXJjbGUtc3Ryb2tlLWNvbG9yJywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjaXJjbGVDb2xvciA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAnY2lyY2xlLWNvbG9yJywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCBjaXJjbGVPcGFjaXR5ID0gZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICdjaXJjbGUtb3BhY2l0eScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2lyY2xlU3Ryb2tlV2lkdGggPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1zdHJva2Utd2lkdGgnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGNpcmNsZVN0cm9rZU9wYWNpdHkgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ2NpcmNsZS1zdHJva2Utb3BhY2l0eScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgY2FjaGVfa2V5ID0gY2lyY2xlUmFkaXVzICsgJy4nICsgY2lyY2xlU3Ryb2tlQ29sb3IgKyAnLicgK1xyXG4gICAgICAgICAgICBjaXJjbGVDb2xvciArICcuJyArIGNpcmNsZU9wYWNpdHkgKyAnLicgKyBjaXJjbGVTdHJva2VXaWR0aCArICcuJyArIGNpcmNsZVN0cm9rZU9wYWNpdHk7XHJcbiAgICAgICAgICBpY29uSW1nID0gaWNvbkltYWdlQ2FjaGVbY2FjaGVfa2V5XTtcclxuICAgICAgICAgIGlmICghaWNvbkltZykge1xyXG4gICAgICAgICAgICBpY29uSW1nID0gbmV3IENpcmNsZSh7XHJcbiAgICAgICAgICAgICAgcmFkaXVzOiBjaXJjbGVSYWRpdXMsXHJcbiAgICAgICAgICAgICAgc3Ryb2tlOiBjaXJjbGVTdHJva2VXaWR0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IG5ldyBTdHJva2Uoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNpcmNsZVN0cm9rZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yV2l0aE9wYWNpdHkoY2lyY2xlU3Ryb2tlQ29sb3IsIGNpcmNsZVN0cm9rZU9wYWNpdHkpXHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yV2l0aE9wYWNpdHkoY2lyY2xlQ29sb3IsIGNpcmNsZU9wYWNpdHkpXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdHlsZS5zZXRJbWFnZShpY29uSW1nKTtcclxuICAgICAgICAgIHRleHQgPSBzdHlsZS5nZXRUZXh0KCk7XHJcbiAgICAgICAgICBzdHlsZS5zZXRUZXh0KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICBzdHlsZS5zZXRHZW9tZXRyeSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgc3R5bGUuc2V0WkluZGV4KDk5OTk5IC0gaW5kZXgpO1xyXG4gICAgICAgICAgaGFzSW1hZ2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxhYmVsO1xyXG4gICAgICAgIGlmICgndGV4dC1maWVsZCcgaW4gbGF5b3V0KSB7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0RmllbGQgPSBnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LWZpZWxkJywgem9vbSwgZik7XHJcbiAgICAgICAgICBsYWJlbCA9IGZyb21UZW1wbGF0ZSh0ZXh0RmllbGQsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFiZWwgJiYgIXNraXBMYWJlbCkge1xyXG4gICAgICAgICAgaWYgKCFoYXNJbWFnZSkge1xyXG4gICAgICAgICAgICArK3N0eWxlc0xlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3R5bGVJZHNbem9vbV0uaW5kZXhPZihsYXllcklkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICBmZWF0dXJlLnN0eWxlSWRzW3pvb21dLnB1c2gobGF5ZXJJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbc3R5bGVzTGVuZ3RoXTtcclxuICAgICAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUuZ2V0VGV4dCgpIHx8IHN0eWxlLmdldEZpbGwoKSB8fCBzdHlsZS5nZXRTdHJva2UoKSkge1xyXG4gICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW3N0eWxlc0xlbmd0aF0gPSBuZXcgU3R5bGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZS5zZXRJbWFnZSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRHZW9tZXRyeSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFzdHlsZS5nZXRUZXh0KCkpIHtcclxuICAgICAgICAgICAgc3R5bGUuc2V0VGV4dCh0ZXh0IHx8IG5ldyBUZXh0KCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGV4dCA9IHN0eWxlLmdldFRleHQoKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRTaXplID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1zaXplJywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0TGluZUhlaWdodCA9IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3RleHQtbGluZS1oZWlnaHQnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IGZvbnQgPSBtYjJjc3MoY2hvb3NlRm9udChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LWZvbnQnLCB6b29tLCBmKSksIHRleHRTaXplKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRUcmFuc2Zvcm0gPSBsYXlvdXRbJ3RleHQtdHJhbnNmb3JtJ107XHJcbiAgICAgICAgICBpZiAodGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJykge1xyXG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcclxuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3Qgd3JhcHBlZExhYmVsID0gdHlwZSA9PSAyID8gbGFiZWwgOiB3cmFwVGV4dChsYWJlbCwgZm9udCwgZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1tYXgtd2lkdGgnLCB6b29tLCBmKSk7XHJcbiAgICAgICAgICB0ZXh0LnNldFRleHQod3JhcHBlZExhYmVsKTtcclxuICAgICAgICAgIHRleHQuc2V0Rm9udChmb250KTtcclxuICAgICAgICAgIHRleHQuc2V0Um90YXRpb24oZGVnMnJhZChnZXRWYWx1ZShsYXllciwgJ2xheW91dCcsICd0ZXh0LXJvdGF0ZScsIHpvb20sIGYpKSk7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0QW5jaG9yID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1hbmNob3InLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChoYXNJbWFnZSB8fCB0eXBlID09IDEpID8gJ3BvaW50JyA6IGdldFZhbHVlKGxheWVyLCAnbGF5b3V0JywgJ3N5bWJvbC1wbGFjZW1lbnQnLCB6b29tLCBmKTtcclxuICAgICAgICAgIHRleHQuc2V0UGxhY2VtZW50KHBsYWNlbWVudCk7XHJcbiAgICAgICAgICBsZXQgdGV4dEhhbG9XaWR0aCA9IGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1oYWxvLXdpZHRoJywgem9vbSwgZik7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0T2Zmc2V0ID0gZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1vZmZzZXQnLCB6b29tLCBmKTtcclxuICAgICAgICAgIGNvbnN0IHRleHRUcmFuc2xhdGUgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ3RleHQtdHJhbnNsYXRlJywgem9vbSwgZik7XHJcbiAgICAgICAgICBsZXQgdk9mZnNldCA9IDA7XHJcbiAgICAgICAgICBsZXQgaE9mZnNldCA9IDA7XHJcbiAgICAgICAgICBsZXQgdGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICBpZiAodGV4dEFuY2hvci5pbmRleE9mKCdsZWZ0JykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICAgICAgaE9mZnNldCA9IHRleHRIYWxvV2lkdGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbmNob3IuaW5kZXhPZigncmlnaHQnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICAgICAgaE9mZnNldCA9IC10ZXh0SGFsb1dpZHRoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBsYWNlbWVudCA9PSAncG9pbnQnKSB7XHJcbiAgICAgICAgICAgIHRleHQuc2V0VGV4dEFsaWduKHRleHRBbGlnbik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0LnNldE1heEFuZ2xlKGRlZzJyYWQoZ2V0VmFsdWUobGF5ZXIsICdsYXlvdXQnLCAndGV4dC1tYXgtYW5nbGUnLCB6b29tLCBmKSkgKiBsYWJlbC5sZW5ndGggLyB3cmFwcGVkTGFiZWwubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGV4dC5zZXRUZXh0QWxpZ24oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICAgICAgICAgIGlmICh0ZXh0QW5jaG9yLmluZGV4T2YoJ2JvdHRvbScpID09IDApIHtcclxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgIHZPZmZzZXQgPSAtdGV4dEhhbG9XaWR0aCAtICgwLjUgKiAodGV4dExpbmVIZWlnaHQgLSAxKSkgKiB0ZXh0U2l6ZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFuY2hvci5pbmRleE9mKCd0b3AnKSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xyXG4gICAgICAgICAgICB2T2Zmc2V0ID0gdGV4dEhhbG9XaWR0aCArICgwLjUgKiAodGV4dExpbmVIZWlnaHQgLSAxKSkgKiB0ZXh0U2l6ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRleHQuc2V0VGV4dEJhc2VsaW5lKHRleHRCYXNlbGluZSk7XHJcbiAgICAgICAgICB0ZXh0LnNldE9mZnNldFgodGV4dE9mZnNldFswXSAqIHRleHRTaXplICsgaE9mZnNldCArIHRleHRUcmFuc2xhdGVbMF0pO1xyXG4gICAgICAgICAgdGV4dC5zZXRPZmZzZXRZKHRleHRPZmZzZXRbMV0gKiB0ZXh0U2l6ZSArIHZPZmZzZXQgKyB0ZXh0VHJhbnNsYXRlWzFdKTtcclxuICAgICAgICAgIG9wYWNpdHkgPSBnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ3RleHQtb3BhY2l0eScsIHpvb20sIGYpO1xyXG4gICAgICAgICAgY29uc3QgdGV4dENvbG9yID0gbmV3IEZpbGwoKTtcclxuXHJcbiAgICAgICAgICB0ZXh0Q29sb3Iuc2V0Q29sb3IoY29sb3JXaXRoT3BhY2l0eShnZXRWYWx1ZShsYXllciwgJ3BhaW50JywgJ3RleHQtY29sb3InLCB6b29tLCBmKSwgb3BhY2l0eSkgfHwncmdiYSgwLDAsMCwwKScpO1xyXG4gICAgICAgICAgdGV4dC5zZXRGaWxsKHRleHRDb2xvcik7XHJcbiAgICAgICAgICBjb25zdCBoYWxvQ29sb3IgPSBjb2xvcldpdGhPcGFjaXR5KGdldFZhbHVlKGxheWVyLCAncGFpbnQnLCAndGV4dC1oYWxvLWNvbG9yJywgem9vbSwgZiksIG9wYWNpdHkpO1xyXG4gICAgICAgICAgaWYgKGhhbG9Db2xvcikge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0SGFsbyA9IG5ldyBTdHJva2UoKTtcclxuICAgICAgICAgICAgdGV4dEhhbG8uc2V0Q29sb3IoaGFsb0NvbG9yKTtcclxuICAgICAgICAgICAgdGV4dEhhbG8uc2V0V2lkdGgoZ2V0VmFsdWUobGF5ZXIsICdwYWludCcsICd0ZXh0LWhhbG8td2lkdGgnLCB6b29tLCBmKSk7XHJcbiAgICAgICAgICAgIHRleHQuc2V0U3Ryb2tlKHRleHRIYWxvKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQuc2V0U3Ryb2tlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdHlsZS5zZXRaSW5kZXgoOTk5OTkgLSBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0eWxlc0xlbmd0aCA+IC0xKSB7XHJcbiAgICAgIHN0eWxlcy5sZW5ndGggPSBzdHlsZXNMZW5ndGggKyAxO1xyXG4gICAgICByZXR1cm4gc3R5bGVzO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIG9sTGF5ZXIuc2V0U3R5bGUoc3R5bGVGdW5jdGlvbik7XHJcbiAgb2xMYXllci5zZXQoJ21hcGJveC1zb3VyY2UnLCBtYXBib3hTb3VyY2UpO1xyXG4gIG9sTGF5ZXIuc2V0KCdtYXBib3gtbGF5ZXJzJywgbWFwYm94TGF5ZXJzKTtcclxuICByZXR1cm4gc3R5bGVGdW5jdGlvbjtcclxufVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gZGVnMnJhZChkZWdyZWVzKSB7XHJcbiAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Wm9vbUZvclJlc29sdXRpb24ocmVzb2x1dGlvbiwgcmVzb2x1dGlvbnMpIHtcclxuICBsZXQgaSA9IDA7XHJcbiAgY29uc3QgaWkgPSByZXNvbHV0aW9ucy5sZW5ndGg7XHJcbiAgZm9yICg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICBjb25zdCBjYW5kaWRhdGUgPSByZXNvbHV0aW9uc1tpXTtcclxuICAgIGlmIChjYW5kaWRhdGUgPCByZXNvbHV0aW9uICYmIGkgKyAxIDwgaWkpIHtcclxuICAgICAgY29uc3Qgem9vbUZhY3RvciA9IHJlc29sdXRpb25zW2ldIC8gcmVzb2x1dGlvbnNbaSArIDFdO1xyXG4gICAgICByZXR1cm4gaSArIE1hdGgubG9nKHJlc29sdXRpb25zW2ldIC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGlpIC0gMTtcclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfTWFwX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX09ic2VydmFibGVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfZm9ybWF0X0dlb0pTT05fXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfZm9ybWF0X01WVF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9nZW9tX1BvaW50X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX2xheWVyX1RpbGVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfbGF5ZXJfVmVjdG9yX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX2xheWVyX1ZlY3RvclRpbGVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfcHJval9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zb3VyY2VfVGlsZUpTT05fXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc291cmNlX1ZlY3Rvcl9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zb3VyY2VfVmVjdG9yVGlsZV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9DaXJjbGVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfb2xfc3R5bGVfRmlsbF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9JY29uX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3N0eWxlX1N0cm9rZV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9TdHlsZV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbF9zdHlsZV9UZXh0X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29sX3RpbGVncmlkX187Il0sInNvdXJjZVJvb3QiOiIifQ==