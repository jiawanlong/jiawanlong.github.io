<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>狗敦A季</title>
  
  <subtitle>贾宛龙的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiawanlong.github.io/"/>
  <updated>2019-06-05T09:52:13.441Z</updated>
  <id>https://jiawanlong.github.io/</id>
  
  <author>
    <name>狗敦A季&quot;</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript：前端面试知识点目录整理</title>
    <link href="https://jiawanlong.github.io/2019/06/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9B%AE%E5%BD%95%E6%95%B4%E7%90%86/"/>
    <id>https://jiawanlong.github.io/2019/06/05/前端面试知识点目录整理/</id>
    <published>2019-06-05T09:51:28.122Z</published>
    <updated>2019-06-05T09:52:13.441Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面</p><blockquote><p>金三银四，又到了一年一度的跳槽季，相信大家都在准备自己的面试笔记，我也针对自己工作中所掌握或了解的一些东西做了一个目录总结，方便自己复习。详细内容会在之后一一对应地补充上去（有些在我的个人主页笔记中也有相关记录），这里暂且放一个我的面试知识点目录，大家有兴趣可以自己根据目录去扩展。欢迎在评论下方指点一二，看还有哪些没考虑到的，互相交流一哈…</p></blockquote><p>基本功考察</p><h3 id="1-关于Html"><a href="#1-关于Html" class="headerlink" title="1.关于Html"></a>1.关于Html</h3><p>1、html语义化标签的理解、结构化的理解；能否写出简洁的html结构；SEO优化。</p><p>2、h5中新增的属性，如自定义属性data、类名className等；新增表单元素；拖拽Drag。</p><p>3、h5中新增的API、修改的API、废弃的API稍作了解（离线存储、audio、video）。</p><h3 id="2-关于CSS"><a href="#2-关于CSS" class="headerlink" title="2.关于CSS"></a>2.关于CSS</h3><p>1、CSS选择器（三大特性）。</p><p>2、BFC机制。</p><p>3、盒模型。</p><p>4、CSS模块化开发（封装）；SCSS和LESS的使用。</p><p>5、屏幕适配以及页面自适应。</p><p>6、CSS3中新增的选择器。</p><p>7、CSS3中新增的属性，transform、trasition、animation等。</p><h3 id="3-关于布局"><a href="#3-关于布局" class="headerlink" title="3.关于布局"></a>3.关于布局</h3><p>1、标准文档流（padding + margin + 负margin）+ 浮动float + 定位 left + right + top + bottom。</p><p>2、百分比布局：px单位用%num代替，占父级元素的百分比。</p><p>3、flex弹性布局：主轴、辅助轴的几个属性。</p><p>4、grid栅格布局：使用框架中的类名来替代，本质上还是百分比布局。</p><h3 id="4-关于JS基础"><a href="#4-关于JS基础" class="headerlink" title="4.关于JS基础"></a>4.关于JS基础</h3><p>1、变量数据类型及检测：基本 + 引用。</p><p>2、运算符：算术 + 条件 + 逻辑 + 位 + 短路、隐式转换等。</p><p>3、条件、循环、异常处理if、switch(){case xxx:}、try、catch、finally、throw。</p><p>4、函数定义、调用方式（apply、call、直接调用）；传参：实参给形参赋值。</p><p>5、字符串、数组、对象常用API。</p><p>6、正则表达式。</p><h3 id="5-关于JS高级"><a href="#5-关于JS高级" class="headerlink" title="5.关于JS高级"></a>5.关于JS高级</h3><p>1、作用域、作用域链、闭包。</p><p>2、原型、原型链、继承。</p><p>3、函数上下文、this指向。</p><p>4、js的运行机制、事件队列和循环。</p><p>5、Ajax原理、axios库。</p><p>6、同步、异步编程。</p><p>7、jQuery源码学习。</p><h3 id="6-关于浏览器"><a href="#6-关于浏览器" class="headerlink" title="6.关于浏览器"></a>6.关于浏览器</h3><p>1、浏览器的构成和运行机制。</p><p>2、浏览器内核。</p><p>3、浏览器交互：BOM和DOM相关webApi、监听事件。</p><p>4、浏览器缓存机制。</p><p>5、浏览器的渲染原理。</p><p>6、浏览器的安全性：跨域和攻击。</p><h3 id="7-关于网络协议"><a href="#7-关于网络协议" class="headerlink" title="7.关于网络协议"></a>7.关于网络协议</h3><p>1、HTTP协议。</p><p>2、cookie、session、token。</p><h3 id="8-关于ES6语法"><a href="#8-关于ES6语法" class="headerlink" title="8.关于ES6语法"></a>8.关于ES6语法</h3><p>1、字符串、数组、对象扩展的api。</p><p>2、变量扩展：let、const解构赋值，块级作用域。</p><p>3、函数扩展：箭头函数默认参数、rest参数。</p><p>4、展开运算符、模板字符串。</p><p>5、set和map数据结构。</p><p>6、迭代器和生成器函数next和yield的理解。</p><p>7、proxy对象属性代理器：属性的读取（get）和设置（set）相关操作。</p><p>8、promise对象、异步编程的解决方案。</p><p>9、async + await：异步编程的终极方案promise + generator的语法糖。</p><p>10、class语法、构造函数的语法糖。</p><p>11、模块化编程export + import的导出和导入。</p><h3 id="9-VUE基础"><a href="#9-VUE基础" class="headerlink" title="9.VUE基础"></a>9.VUE基础</h3><p>1、基本指令。</p><p>2、实例的属性和方法。</p><p>3、实例的生命周期。</p><p>4、组件基础：创建、注册、添加属性方法、套用等。</p><p>5、组件通信传值，父子、兄弟、跨级。</p><p>6、插槽slot等。</p><h3 id="10-VUE高级"><a href="#10-VUE高级" class="headerlink" title="10.VUE高级"></a>10.VUE高级</h3><p>1、vue-router：搭建SPA</p><p>路由、组件的配置。</p><p>路由间的传值。</p><p>路由跳转。</p><p>路由的导航守卫。</p><p>记住在router.js和组件页面中的使用方式。</p><p>2、vuex：状态管理、数据仓库store</p><p>实例化仓库的5大属性的使用。</p><p>state、getters、mutations、actions、modules。</p><p>辅助函数mapState等，仓库中计算属性的映射、方便操作。</p><p>记住在store.js和组件中使用方式。</p><h3 id="11-VUE深入、源码阅读"><a href="#11-VUE深入、源码阅读" class="headerlink" title="11.VUE深入、源码阅读"></a>11.VUE深入、源码阅读</h3><p>1、数据响应式原理。</p><p>2、virtual dom。</p><p>3、diff 算法。</p><p>4、nextTick等等。</p><h3 id="工程能力考察"><a href="#工程能力考察" class="headerlink" title="工程能力考察"></a>工程能力考察</h3><p>1.项目能力<br>1、vue-cli脚手架搭建和功能配置vue.config.js。</p><p>2、webpack的常用配置。</p><p>3、项目构建打包。</p><p>4、熟悉各类框架的文档。</p><p>5、UI框架：Bootstrap、MUI、Element-ui等。</p><p>6、常用的插件整理；整理一个自己插件库，封装自己的方法库、组件库。</p><p>7、常用的工具熟练度。</p><p>8、PC端和移动端开发注意事项。</p><p>9、经验总结：快速确定项目的技术选型。</p><p>10、坑点总结：项目遇到坑坑坑！</p><p>11、项目中的性能优化记录（都是细节点，多记录）。</p><p>12、需求文档的理解，可以结合项目流程图、UML图。</p><p>13、问题解决能力：bug定位调试、查找文档、寻求他人。</p><p>14、记录习惯养成。</p><p>2.模块化、组件化开发能力<br>1、项目分类；各类文件整理、分类。</p><p>2、各类功能封装。</p><p>3、组件和功能模块的抽离、解耦、复用。</p><p>内功考察<br>1.面向对象的编程思想<br>1、类的抽象。</p><p>2、对象的封装、继承。</p><p>3、为了更好的去管理数据、分类数据，实现高内聚、低耦合。</p><p>2.设计模式<br>设计模式感觉也是将面向对象思想再度抽象成现实中某些特定模式。</p><p>3.数据结构和算法<br>1、学习常用的排序搜索算法、顺序表、链表、栈、队列、树、堆等。</p><p>2、考验你的抽象思维和数学功底。</p><p>3、将现实需求抽象成计算机代码的思维能力。</p><p>附加技能考察<br>1.学习能力<br>1、持续学习的态度——博客、笔记记录。</p><p>2、技术论坛活跃度高、问答多。</p><p>3、GitHub开源项目参与。</p><p>2.了解一门后端语言<br>1、python、node.js、php等。</p><p>2、数据库mysql、redis、mongodb；sql的操作语句、mongodb的操作语句、redis的操作语句。</p><p>3、node + express搭建本地服务等。</p><p>4、python + django + request + scrapy。</p><p>3.系统编程<br>1、Linux命令行操作、系统文件管理。</p><p>2、多任务、多线程、多进程、协程、并发、并行、串行、同步、异步等概念的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在前面&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;金三银四，又到了一年一度的跳槽季，相信大家都在准备自己的面试笔记，我也针对自己工作中所掌握或了解的一些东西做了一个目录总结，方便自己复习。详细内容会在之后一一对应地补充上去（有些在我的个人主页笔记中也有相关记录），这里暂且放
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="面试" scheme="https://jiawanlong.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="知识点" scheme="https://jiawanlong.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：十大排序的算法思路和代码实现</title>
    <link href="https://jiawanlong.github.io/2019/06/05/JavaScript%EF%BC%9A%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E5%92%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://jiawanlong.github.io/2019/06/05/JavaScript：十大排序的算法思路和代码实现/</id>
    <published>2019-06-05T09:49:15.299Z</published>
    <updated>2019-06-05T09:50:07.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。</p><p>最好：<code>O(n)</code>，只需要冒泡一次数组就有序了。<br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p><h2 id="单向冒泡"><a href="#单向冒泡" class="headerlink" title="单向冒泡"></a>单向冒泡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(nums) &#123;</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len-1; i++) &#123;</span><br><span class="line">    // 如果一轮比较中没有需要交换的数据，则说明数组已经有序。主要是对[5,1,2,3,4]之类的数组进行优化</span><br><span class="line">    let mark = true;</span><br><span class="line">    for(let j=0; j&lt;len-i-1; j++) &#123;</span><br><span class="line">      if(nums[j] &gt; nums[j+1]) &#123;</span><br><span class="line">        [nums[j], nums[j+1]] = [nums[j+1], nums[j]];</span><br><span class="line">        mark = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mark)  return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向冒泡"><a href="#双向冒泡" class="headerlink" title="双向冒泡"></a>双向冒泡</h2><p>普通的冒泡排序在一趟循环中只能找出一个最大值或最小值，双向冒泡则是多一轮循环既找出最大值也找出最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort_twoWays(nums) &#123;</span><br><span class="line">  let low = 0;</span><br><span class="line">  let high = nums.length - 1;</span><br><span class="line">  while(low &lt; high) &#123;</span><br><span class="line">    let mark = true;</span><br><span class="line">    // 找到最大值放到右边</span><br><span class="line">    for(let i=low; i&lt;high; i++) &#123;</span><br><span class="line">      if(nums[i] &gt; nums[i+1]) &#123;</span><br><span class="line">        [nums[i], nums[i+1]] = [nums[i+1], nums[i]];</span><br><span class="line">        mark = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high--;</span><br><span class="line">    // 找到最小值放到左边</span><br><span class="line">    for(let j=high; j&gt;low; j--) &#123;</span><br><span class="line">      if(nums[j] &lt; nums[j-1]) &#123;</span><br><span class="line">        [nums[j], nums[j-1]] = [nums[j-1], nums[j]];</span><br><span class="line">        mark = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    low++;</span><br><span class="line">    if(mark)  return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>和冒泡排序相似，区别在于选择排序是将每一个元素和它后面的元素进行比较和交换。</p><p>最好：<code>O(n²)</code><br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function selectSort(nums) &#123;</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    for(let j=i+1; j&lt;len; j++) &#123;</span><br><span class="line">      if(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>以第一个元素作为有序数组，其后的元素通过在这个已有序的数组中找到合适的位置并插入。</p><p>最好：<code>O(n)</code>，原数组已经是升序的。<br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function insertSort(nums) &#123;</span><br><span class="line">  for(let i=1, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    let temp = nums[i];</span><br><span class="line">    let j = i;</span><br><span class="line">    while(j &gt;= 0 &amp;&amp; temp &lt; nums[j-1]) &#123;</span><br><span class="line">      nums[j] = nums[j-1];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>选择一个元素作为基数（通常是第一个元素），把比基数小的元素放到它左边，比基数大的元素放到它右边（相当于二分），再不断递归基数左右两边的序列。</p><p>最好：<code>O(n * logn)</code>，所有数均匀分布在基数的两边，此时的递归就是不断地二分左右序列。<br>最坏：<code>O(n²)</code>，所有数都分布在基数的一边，此时划分左右序列就相当于是插入排序。<br>平均：<code>O(n * logn)</code></p><p>参考学习链接：<br><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" target="_blank" rel="noopener">算法 3：最常用的排序——快速排序</a><br><a href="https://blog.csdn.net/insistGoGo/article/details/7785038" target="_blank" rel="noopener">三种快速排序以及快速排序的优化</a></p><h2 id="快速排序之填坑"><a href="#快速排序之填坑" class="headerlink" title="快速排序之填坑"></a>快速排序之填坑</h2><p>从右边向中间推进的时候，遇到小于基数的数就赋给左边（一开始是基数的位置），右边保留原先的值等之后被左边的值填上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(nums) &#123;</span><br><span class="line">  // 递归排序基数左右两边的序列</span><br><span class="line">  function recursive(arr, left, right) &#123;</span><br><span class="line">    if(left &gt;= right)  return;</span><br><span class="line">    let index = partition(arr, left, right);</span><br><span class="line">    recursive(arr, left, index - 1);</span><br><span class="line">    recursive(arr, index + 1, right);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  // 将小于基数的数放到基数左边，大于基数的数放到基数右边，并返回基数的位置</span><br><span class="line">  function partition(arr, left, right) &#123;</span><br><span class="line">    // 取第一个数为基数</span><br><span class="line">    let temp = arr[left];</span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">      while(left &lt; right &amp;&amp; arr[right] &gt;= temp)  right--;</span><br><span class="line">      arr[left] = arr[right];</span><br><span class="line">      while(left &lt; right &amp;&amp; arr[left] &lt; temp)  left++;</span><br><span class="line">      arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改基数的位置</span><br><span class="line">    arr[left] = temp;</span><br><span class="line">    return left;</span><br><span class="line">  &#125;</span><br><span class="line">  recursive(nums, 0, nums.length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序之交换"><a href="#快速排序之交换" class="headerlink" title="快速排序之交换"></a>快速排序之交换</h2><p>从左右两边向中间推进的时候，遇到不符合的数就两边交换值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function quickSort1(nums) &#123;</span><br><span class="line">  function recursive(arr, left, right) &#123;</span><br><span class="line">    if(left &gt;= right)  return;</span><br><span class="line">    let index = partition(arr, left, right);</span><br><span class="line">    recursive(arr, left, index - 1);</span><br><span class="line">    recursive(arr, index + 1, right);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  function partition(arr, left, right) &#123;</span><br><span class="line">    let temp = arr[left];</span><br><span class="line">    let p = left + 1;</span><br><span class="line">    let q = right;</span><br><span class="line">    while(p &lt;= q) &#123;</span><br><span class="line">      while(p &lt;= q &amp;&amp; arr[p] &lt; temp)  p++;</span><br><span class="line">      while(p &lt;= q &amp;&amp; arr[q] &gt; temp)  q--;</span><br><span class="line">      if(p &lt;= q) &#123;</span><br><span class="line">        [arr[p], arr[q]] = [arr[q], arr[p]];</span><br><span class="line">        // 交换值后两边各向中间推进一位</span><br><span class="line">        p++;</span><br><span class="line">        q--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改基数的位置</span><br><span class="line">    [arr[left], arr[q]] = [arr[q], arr[left]];</span><br><span class="line">    return q;</span><br><span class="line">  &#125;</span><br><span class="line">  recursive(nums, 0, nums.length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>递归将数组分为两个序列，有序合并这两个序列。</p><p>最好：<code>O(n * logn)</code><br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p><p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(nums) &#123;</span><br><span class="line">  // 有序合并两个数组</span><br><span class="line">  function merge(l1, r1, l2, r2) &#123;</span><br><span class="line">    let arr = [];</span><br><span class="line">    let index = 0;</span><br><span class="line">    let i = l1, j = l2;</span><br><span class="line">    while(i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line">      arr[index++] = nums[i] &lt; nums[j] ? nums[i++] : nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt;= r1)  arr[index++] = nums[i++];</span><br><span class="line">    while(j &lt;= r2)  arr[index++] = nums[j++];</span><br><span class="line">    // 将有序合并后的数组修改回原数组</span><br><span class="line">    for(let t=0; t&lt;index; t++) &#123;</span><br><span class="line">      nums[l1 + t] = arr[t];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 递归将数组分为两个序列</span><br><span class="line">  function recursive(left, right) &#123;</span><br><span class="line">    if(left &gt;= right)  return;</span><br><span class="line">    // 比起(left+right)/2，更推荐下面这种写法，可以避免数溢出</span><br><span class="line">    let mid = parseInt((right - left) / 2) + left;</span><br><span class="line">    recursive(left, mid);</span><br><span class="line">    recursive(mid+1, right);</span><br><span class="line">    merge(left, mid, mid+1, right);</span><br><span class="line">    return nums;</span><br><span class="line">  &#125;</span><br><span class="line">  recursive(0, nums.length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>取 n 个桶，根据数组的最大值和最小值确认每个桶存放的数的区间，将数组元素插入到相应的桶里，最后再合并各个桶。</p><p>最好：<code>O(n)</code>，每个数都在分布在一个桶里，这样就不用将数插入排序到桶里了(类似于计数排序以空间换时间)。<br>最坏：<code>O(n²)</code>，所有的数都分布在一个桶里。<br>平均：<code>O(n + k)</code>，k表示桶的个数。</p><p>参考学习链接：<br><a href="http://zhuanlan.51cto.com/art/201811/586129.htm" target="_blank" rel="noopener">拜托，面试别再问我桶排序了！！！</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(nums) &#123;</span><br><span class="line">  // 桶的个数，只要是正数即可</span><br><span class="line">  let num = 5;</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let min = Math.min(...nums);</span><br><span class="line">  // 计算每个桶存放的数值范围，至少为1，</span><br><span class="line">  let range = Math.ceil((max - min) / num) || 1;</span><br><span class="line">  // 创建二维数组，第一维表示第几个桶，第二维表示该桶里存放的数</span><br><span class="line">  let arr = Array.from(Array(num)).map(() =&gt; Array().fill(0));</span><br><span class="line">  nums.forEach(val =&gt; &#123;</span><br><span class="line">    // 计算元素应该分布在哪个桶</span><br><span class="line">    let index = parseInt((val - min) / range);</span><br><span class="line">    // 防止index越界，例如当[5,1,1,2,0,0]时index会出现5</span><br><span class="line">    index = index &gt;= num ? num - 1 : index;</span><br><span class="line">    let temp = arr[index];</span><br><span class="line">    // 插入排序，将元素有序插入到桶中</span><br><span class="line">    let j = temp.length - 1;</span><br><span class="line">    while(j &gt;= 0 &amp;&amp; val &lt; temp[j]) &#123;</span><br><span class="line">      temp[j+1] = temp[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[j+1] = val;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 修改回原数组</span><br><span class="line">  let res = [].concat.apply([], arr);</span><br><span class="line">  nums.forEach((val, i) =&gt; &#123;</span><br><span class="line">    nums[i] = res[i];</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>使用十个桶 0-9，把每个数从低位到高位根据位数放到相应的桶里，以此循环最大值的位数次。<strong>但只能排列正整数，因为遇到负号和小数点无法进行比较</strong>。</p><p>最好：<code>O(n * k)</code>，k表示最大值的位数。<br>最坏：<code>O(n * k)</code><br>平均：<code>O(n * k)</code></p><p>参考学习链接：<br><a href="https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html" target="_blank" rel="noopener">算法总结系列之五: 基数排序(Radix Sort)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function radixSort(nums) &#123;</span><br><span class="line">  // 计算位数</span><br><span class="line">  function getDigits(n) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">      sum++;</span><br><span class="line">      n = parseInt(n / 10);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line">  // 第一维表示位数即0-9，第二维表示里面存放的值</span><br><span class="line">  let arr = Array.from(Array(10)).map(() =&gt; Array());</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let maxDigits = getDigits(max);</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    // 用0把每一个数都填充成相同的位数</span><br><span class="line">    nums[i] = (nums[i] + &apos;&apos;).padStart(maxDigits, 0);</span><br><span class="line">    // 先根据个位数把每一个数放到相应的桶里</span><br><span class="line">    let temp = nums[i][nums[i].length-1];</span><br><span class="line">    arr[temp].push(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  // 循环判断每个位数</span><br><span class="line">  for(let i=maxDigits-2; i&gt;=0; i--) &#123;</span><br><span class="line">    // 循环每一个桶</span><br><span class="line">    for(let j=0; j&lt;=9; j++) &#123;</span><br><span class="line">      let temp = arr[j]</span><br><span class="line">      let len = temp.length;</span><br><span class="line">      // 根据当前的位数i把桶里的数放到相应的桶里</span><br><span class="line">      while(len--) &#123;</span><br><span class="line">        let str = temp[0];</span><br><span class="line">        temp.shift();</span><br><span class="line">        arr[str[i]].push(str);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 修改回原数组</span><br><span class="line">  let res = [].concat.apply([], arr);</span><br><span class="line">  nums.forEach((val, index) =&gt; &#123;</span><br><span class="line">    nums[index] = +res[index];</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。因为 JavaScript 的数组下标是以字符串形式存储的，所以<strong>计数排序可以用来排列负数，但不可以排列小数</strong>。</p><p>最好：<code>O(n + k)</code>，k是最大值和最小值的差。<br>最坏：<code>O(n + k)</code><br>平均：<code>O(n + k)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(nums) &#123;</span><br><span class="line">  let arr = [];</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let min = Math.min(...nums);</span><br><span class="line">  // 装桶</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    let temp = nums[i];</span><br><span class="line">    arr[temp] = arr[temp] + 1 || 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let index = 0;</span><br><span class="line">  // 还原原数组</span><br><span class="line">  for(let i=min; i&lt;=max; i++) &#123;</span><br><span class="line">    while(arr[i] &gt; 0) &#123;</span><br><span class="line">      nums[index++] = i;</span><br><span class="line">      arr[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序优化"><a href="#计数排序优化" class="headerlink" title="计数排序优化"></a>计数排序优化</h2><p>把每一个数组元素都加上 <code>min</code> 的相反数，来避免特殊情况下的空间浪费，通过这种优化可以把所开的空间大小从 <code>max+1</code> 降低为 <code>max-min+1</code>，<code>max</code> 和 <code>min</code> 分别为数组中的最大值和最小值。</p><p>比如数组 <code>[103, 102, 101, 100]</code>，普通的计数排序需要开一个长度为 104 的数组，而且前面 100 个值都是 <code>undefined</code>，使用该优化方法后可以只开一个长度为 4 的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(nums) &#123;</span><br><span class="line">  let arr = [];</span><br><span class="line">  let max = Math.max(...nums);</span><br><span class="line">  let min = Math.min(...nums);</span><br><span class="line">  // 加上最小值的相反数来缩小数组范围</span><br><span class="line">  let add = -min;</span><br><span class="line">  for(let i=0, len=nums.length; i&lt;len; i++) &#123;</span><br><span class="line">    let temp = nums[i];</span><br><span class="line">    temp += add;</span><br><span class="line">    arr[temp] = arr[temp] + 1 || 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let index = 0;</span><br><span class="line">  for(let i=min; i&lt;=max; i++) &#123;</span><br><span class="line">    let temp = arr[i+add];</span><br><span class="line">    while(temp &gt; 0) &#123;</span><br><span class="line">      nums[index++] = i;</span><br><span class="line">      temp--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>根据数组建立一个堆（类似完全二叉树），每个结点的值都大于左右结点（最大堆，通常用于升序），或小于左右结点（最小堆，通常用于降序）。对于升序排序，先构建最大堆后，交换堆顶元素（表示最大值）和堆底元素，每一次交换都能得到未有序序列的最大值。重新调整最大堆，再交换堆顶元素和堆底元素，重复 n-1 次后就能得到一个升序的数组。</p><p>最好：<code>O(n * logn)</code>，logn是调整最大堆所花的时间。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p><p>参考学习链接：<br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function heapSort(nums) &#123;</span><br><span class="line">  // 调整最大堆，使index的值大于左右节点</span><br><span class="line">  function adjustHeap(nums, index, size) &#123;</span><br><span class="line">    // 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右结点</span><br><span class="line">    while(true) &#123;</span><br><span class="line">      let max = index;</span><br><span class="line">      let left = index * 2 + 1;   // 左节点</span><br><span class="line">      let right = index * 2 + 2;  // 右节点</span><br><span class="line">      if(left &lt; size &amp;&amp; nums[max] &lt; nums[left])  max = left;</span><br><span class="line">      if(right &lt; size &amp;&amp; nums[max] &lt; nums[right])  max = right;</span><br><span class="line">      // 如果左右结点大于当前的结点则交换，并再循环一遍判断交换后的左右结点位置是否破坏了堆结构（比左右结点小了）</span><br><span class="line">      if(index !== max) &#123;</span><br><span class="line">        [nums[index], nums[max]] = [nums[max], nums[index]];</span><br><span class="line">        index = max;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 建立最大堆</span><br><span class="line">  function buildHeap(nums) &#123;</span><br><span class="line">    // 注意这里的头节点是从0开始的，所以最后一个非叶子结点是 parseInt(nums.length/2)-1</span><br><span class="line">    let start = parseInt(nums.length / 2) - 1;</span><br><span class="line">    let size = nums.length;</span><br><span class="line">    // 从最后一个非叶子结点开始调整，直至堆顶。</span><br><span class="line">    for(let i=start; i&gt;=0; i--) &#123;</span><br><span class="line">      adjustHeap(nums, i, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildHeap(nums);</span><br><span class="line">  // 循环n-1次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构</span><br><span class="line">  for(let i=nums.length-1; i&gt;0; i--) &#123;</span><br><span class="line">    [nums[i], nums[0]] = [nums[0], nums[i]];</span><br><span class="line">    adjustHeap(nums, 0, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。</p><p>最好：<code>O(n * logn)</code>，步长不断二分。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p><p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(nums) &#123;</span><br><span class="line">  let len = nums.length;</span><br><span class="line">  // 初始步数</span><br><span class="line">  let gap = parseInt(len / 2);</span><br><span class="line">  // 逐渐缩小步数</span><br><span class="line">  while(gap) &#123;</span><br><span class="line">    // 从第gap个元素开始遍历</span><br><span class="line">    for(let i=gap; i&lt;len; i++) &#123;</span><br><span class="line">      // 逐步其和前面其他的组成员进行比较和交换</span><br><span class="line">      for(let j=i-gap; j&gt;=0; j-=gap) &#123;</span><br><span class="line">        if(nums[j] &gt; nums[j+gap]) &#123;</span><br><span class="line">          [nums[j], nums[j+gap]] = [nums[j+gap], nums[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gap = parseInt(gap / 2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。&lt;/p&gt;
&lt;p&gt;最好：&lt;code&gt;O(n)&lt;/c
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="排序" scheme="https://jiawanlong.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="https://jiawanlong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>页面性能优化办法有哪些</title>
    <link href="https://jiawanlong.github.io/2019/06/05/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>https://jiawanlong.github.io/2019/06/05/页面性能优化办法有哪些/</id>
    <published>2019-06-05T07:30:34.221Z</published>
    <updated>2019-06-05T09:45:01.541Z</updated>
    
    <content type="html"><![CDATA[<p>引子<br>互联网有一项著名的8秒原则。用户在访问Web网页时，如果时间超过8秒就会感到不耐烦，如果加载需要太长时间，他们就会放弃访问。大部分用户希望网页能在2秒之内就完成加载。事实上，加载时间每多1秒，你就会流失7%的用户。8秒并不是准确的8秒钟，只是向网站开发者表明了加载时间的重要性。那我们如何优化页面性能，提高页面加载速度呢？这是本文主要要探讨的问题，然而性能优化是个综合性问题，没有标准答案，想要面面俱到罗列出来，并非易事。本文只关注一些核心要点，以下是我总结性能优化常见的办法：</p><p>一、资源压缩与合并<br>主要包括这些方面：html压缩、css 压缩、js的压缩和混乱和文件合并。<br>资源压缩可以从文件中去掉多余的字符，比如回车、空格。你在编辑器中写代码的时候，会使用缩进和注释，这些方法无疑会让你的代码简洁而且易读，但它们也会在文档中添加多余的字节。</p><p>1.html压缩<br>html代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩。</p><p>如何进行html压缩：</p><p>使用在线网站进行压缩(开发过程中一般不用)<br>nodejs 提供了html-minifier工具<br>后端模板引擎渲染压缩<br>2.css代码压缩：<br>css代码压缩简单来说就是无效代码删除和css语义合并</p><p>如何进行css压缩：</p><p>使用在线网站进行压缩(开发过程中一般不用)<br>使用html-minifier工具<br>使用clean-css对css压缩<br>css 压缩</p><p>3.js的压缩和混乱<br>js的压缩和混乱主要包括以下这几部分：</p><p>无效字符的删除<br>剔除注释<br>代码语义的缩减和优化<br>代码保护(代码逻辑变得混乱，降低代码的可读性，这点很重要)<br>如何进行js的压缩和混乱</p><p>使用在线网站进行压缩(开发过程中一般不用)<br>使用html-minifier工具<br>使用uglifyjs2对js进行压缩<br>其实css压缩与js的压缩和混乱比html压缩收益要大得多，同时css代码和js代码比html代码多得多，通过css压缩和js压缩带来流量的减少，会非常明显。所以对大公司来说，html压缩可有可无，但css压缩与js的压缩和混乱必须要有！</p><p>4.文件合并</p><p>文件与文件之间有插入的上行请求，增加了N-1个网络延迟<br>受丢包问题影响更严重<br>keep-alive方式可能会出现状况，经过代理服务器时可能会被断开，也就是说不能一直保持keep-alive的状态<br>压缩合并css和js可以减少网站http请求的次数，但合并文件可能会带来问题:首屏渲染和缓存失效问题。那该如何处理这问题呢？—-公共库合并和不同页面的合并。</p><p>如何进行文件合并</p><p>使用在线网站进行文件合并<br>使用nodejs实现文件合并(gulp、fis3)<br>二、非核心代码异步加载异步加载的方式<br>1、异步加载的方式<br>异步加载的三种方式——async和defer、动态脚本创建</p><p>① async方式</p><p>async属性是HTML5新增属性，需要Chrome、FireFox、IE9+浏览器支持<br>async属性规定一旦脚本可用，则会异步执行<br>async属性仅适用于外部脚本<br>如果是多个脚本，该方法不能保证脚本按顺序执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>② defer方式</p><p>兼容所有浏览器<br>defer属性规定是否对脚本执行进行延迟，直到页面加载为止<br>如果是多个脚本，该方法可以确保所有设置了defer属性的脚本按顺序执行<br>如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度<br>③动态创建script标签<br>在还没定义defer和async前，异步加载的方式是动态创建script，通过window.onload方法确保页面加载完毕再将script标签插入到DOM中,具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src)&#123;  </span><br><span class="line">    var script = document.createElement(&apos;script&apos;);  </span><br><span class="line">    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);  </span><br><span class="line">    script.src = src;  </span><br><span class="line">    document.body.appendChild(script);  </span><br><span class="line">&#125;  </span><br><span class="line">window.onload = function()&#123;  </span><br><span class="line">    addScriptTag(&quot;js/index.js&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、异步加载的区别<br>1)defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行</p><p>2)async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关<br>async和defer</p><p>其中蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p><p>三、利用浏览器缓存<br>对于web应用来说，缓存是提升页面性能同时减少服务器压力的利器。</p><p>浏览器缓存类型<br>1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；</p><p>相关的header:<br>Expires ：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。它的值为一个绝对时间的GMT格式的时间字符串， 比如Expires:Thu,21 Jan 2018 23:39:02 GMT</p><p>Cache-Control ：这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。比如Cache-Control:max-age=300，</p><p>简单概括：其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容较客户端是否已经发生了更新呢？此时我们需要协商缓存策略。</p><p>2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用。</p><p>相关的header:<br>①Last-Modified和If-Modified-Since：当第一次请求资源时，服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p><p>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT<br>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。<br>Last-Modified和If-Modified-Since</p><p>但last-modified 存在一些缺点：</p><p>Ⅰ.某些服务端不能获取精确的修改时间</p><p>Ⅱ.文件修改时间改了，但文件内容却没有变</p><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？—-ETag和If-None-Match</p><p>②ETag和If-None-Match：Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><p>ETag和If-None-Match</p><p>两者之间对比：<br>首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。<br>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。<br>第三在优先级上，服务器校验优先考虑Etag</p><p>缓存的机制<br>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p><p>缓存的机制</p><p>用户行为对浏览器缓存的影响<br>1.地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；</p><p>2.F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；</p><p>3.ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</p><p>如果想了解更多缓存机制，请猛戳 深入理解浏览器的缓存机制</p><p>四、使用CDN<br>大型Web应用对速度的追求并没有止步于仅仅利用浏览器缓存，因为浏览器缓存始终只是为了提升二次访问的速度，对于首次访问的加速，我们需要从网络层面进行优化，最常见的手段就是CDN（Content Delivery Network，内容分发网络）加速。通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载。</p><p>遍布全国的CDN节点和内容源示意图</p><p>CDN是怎么做到加速的呢？<br>其实这是CDN服务商在全国各个省份部署计算节点，CDN加速将网站的内容缓存在网络边缘,不同地区的用户就会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。</p><p>五、预解析DNS<br>资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。<br>通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。例如，我们将来可从 example.com 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>当我们从该 URL 请求一个资源时，就不再需要等待 DNS 的解析过程。该技术对使用第三方资源特别有用。通过简单的一行代码就可以告知那些兼容的浏览器进行 DNS 预解析，这意味着当浏览器真正请求该域中的某个资源时，DNS 的解析就已经完成了,从而节省了宝贵的时间。<br>另外需要注意的是，浏览器会对a标签的href自动启用DNS Prefetching，所以a标签里包含的域名不需要在head中手动设置link。但是在HTTPS下不起作用，需要meta来强制开启功能。这个限制的原因是防止窃听者根据DNS Prefetching推断显示在HTTPS页面中超链接的主机名。下面这句话作用是强制打开a标签域名解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引子&lt;br&gt;互联网有一项著名的8秒原则。用户在访问Web网页时，如果时间超过8秒就会感到不耐烦，如果加载需要太长时间，他们就会放弃访问。大部分用户希望网页能在2秒之内就完成加载。事实上，加载时间每多1秒，你就会流失7%的用户。8秒并不是准确的8秒钟，只是向网站开发者表明了加
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="页面性能" scheme="https://jiawanlong.github.io/tags/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/"/>
    
      <category term="优化" scheme="https://jiawanlong.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>async-await入门</title>
    <link href="https://jiawanlong.github.io/2019/03/21/async-await%E5%85%A5%E9%97%A8/"/>
    <id>https://jiawanlong.github.io/2019/03/21/async-await入门/</id>
    <published>2019-03-21T07:16:37.317Z</published>
    <updated>2019-03-21T07:17:40.249Z</updated>
    
    <content type="html"><![CDATA[<p>关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。今天就来学习一下 async-await。</p><h3 id="1、async-await和Promise的关系"><a href="#1、async-await和Promise的关系" class="headerlink" title="1、async-await和Promise的关系"></a>1、async-await和Promise的关系</h3><p>async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。<br>基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function basicDemo() &#123;</span><br><span class="line">    let result = await Math.random();</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">basicDemo();</span><br><span class="line">// 0.6484863241051226</span><br><span class="line">//Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: undefined&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码就是async-await的基本使用形式。有两个陌生的关键字async、await，同时函数执行结果似乎返回了一个promise对象。</p><h3 id="2、async"><a href="#2、async" class="headerlink" title="2、async"></a>2、async</h3><p>async用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function demo01() &#123;</span><br><span class="line">    return 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo01().then(val =&gt; &#123;</span><br><span class="line">    console.log(val);// 123</span><br><span class="line">&#125;);</span><br><span class="line">若 async 定义的函数有返回值，return 123;相当于Promise.resolve(123),没有声明式的 return则相当于执行了Promise.resolve();</span><br></pre></td></tr></table></figure></p><h3 id="3、await"><a href="#3、await" class="headerlink" title="3、await"></a>3、await</h3><p>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function notAsyncFunc() &#123;</span><br><span class="line">    await Math.random();</span><br><span class="line">&#125;</span><br><span class="line">notAsyncFunc();//Uncaught SyntaxError: Unexpected identifier</span><br></pre></td></tr></table></figure></p><p>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function sleep(second) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&apos; enough sleep~&apos;);</span><br><span class="line">        &#125;, second);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function normalFunc() &#123;</span><br><span class="line">    console.log(&apos;normalFunc&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function awaitDemo() &#123;</span><br><span class="line">    await normalFunc();</span><br><span class="line">    console.log(&apos;something, ~~&apos;);</span><br><span class="line">    let result = await sleep(2000);</span><br><span class="line">    console.log(result);// 两秒之后会被打印出来</span><br><span class="line">&#125;</span><br><span class="line">awaitDemo();</span><br><span class="line">// normalFunc</span><br><span class="line">// VM4036:13 something, ~~</span><br><span class="line">// VM4036:15  enough sleep~</span><br></pre></td></tr></table></figure></p><h3 id="4、实例"><a href="#4、实例" class="headerlink" title="4、实例"></a>4、实例</h3><p>举例说明啊，你有三个请求需要发生，第三个请求是依赖于第二个请求的解构第二个请求依赖于第一个请求的结果。若用 ES5实现会有3层的回调，若用Promise 实现至少需要3个then。一个是代码横向发展，另一个是纵向发展。今天指给出 async-await 的实现哈~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//我们仍然使用 setTimeout 来模拟异步请求</span><br><span class="line">function sleep(second, param) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(param);</span><br><span class="line">        &#125;, second);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function test() &#123;</span><br><span class="line">    let result1 = await sleep(2000, &apos;req01&apos;);</span><br><span class="line">    let result2 = await sleep(1000, &apos;req02&apos; + result1);</span><br><span class="line">    let result3 = await sleep(500, &apos;req03&apos; + result2);</span><br><span class="line">    console.log(`</span><br><span class="line">        $&#123;result3&#125;</span><br><span class="line">        $&#123;result2&#125;</span><br><span class="line">        $&#123;result1&#125;</span><br><span class="line">    `);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line">//req03req02req01</span><br><span class="line">//req02req01</span><br><span class="line">//req01</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。今天就来学习一下 async-await。&lt;/p&gt;
&lt;h3 id=&quot;1、async-await和Promise的关系&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="vue" scheme="https://jiawanlong.github.io/tags/vue/"/>
    
      <category term="async-await" scheme="https://jiawanlong.github.io/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>数组遍历方法详解</title>
    <link href="https://jiawanlong.github.io/2019/03/21/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jiawanlong.github.io/2019/03/21/数组遍历方法详解/</id>
    <published>2019-03-21T07:16:37.245Z</published>
    <updated>2019-03-21T07:17:17.030Z</updated>
    
    <content type="html"><![CDATA[<p>遍历的三大方法：<br>1、forEach，代替for循环的<br>2、filter，根据条件过滤数组<br>3、indexOf，数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标</p><h3 id="1、数组内置方法Array-prototype-forEach"><a href="#1、数组内置方法Array-prototype-forEach" class="headerlink" title="1、数组内置方法Array.prototype.forEach"></a>1、数组内置方法Array.prototype.forEach</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">a.forEach(function(value,key,arr)&#123;</span><br><span class="line">  console.log(value)    // 结果依次为1，2，3</span><br><span class="line">  console.log(key)      // 结尾依次为0，1，2</span><br><span class="line">  console.log(arr)      // 三次结果都为[1,2,3]，该参数貌似没什么用</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>代码解读：forEach方法最大的好处就是便于使用，而且不用定义额外的参数变量，但是从效率以及性能角度来说它是劣于原始for循环的，而且也不能强制return结束循环</p><h3 id="2、数组内置方法Array-prototype-filter"><a href="#2、数组内置方法Array-prototype-filter" class="headerlink" title="2、数组内置方法Array.prototype.filter"></a>2、数组内置方法Array.prototype.filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">var b = a.filter(function(value,key,arr)&#123;</span><br><span class="line">    console.log(value)    // 结果依次为1，2，3</span><br><span class="line">    console.log(key)      // 结尾依次为0，1，2</span><br><span class="line">    console.log(arr)      // 三次结果都为[1,2,3]</span><br><span class="line">    if(value === 3)&#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a); // 结果为[ 1, 2, 3 ]</span><br><span class="line">console.log(b); // 结果为[ 1,2 ]</span><br></pre></td></tr></table></figure><p>代码解读：filter目的是为了去掉不要的值，在循环的时候如果返回的是false那么就表示本次循环的不添加该值，返回true则相反是表示要添加到新建的数组中</p><h3 id="3、数组内置方法Array-prototype-indexOf"><a href="#3、数组内置方法Array-prototype-indexOf" class="headerlink" title="3、数组内置方法Array.prototype.indexOf"></a>3、数组内置方法Array.prototype.indexOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">var b = a.indexOf(2);</span><br><span class="line">console.log(a);         // 结果为[ 1, 2, 3 ]</span><br><span class="line">console.log(b);         // 结果为1</span><br></pre></td></tr></table></figure><p>代码解读：对于indexOf方法来说，在数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;遍历的三大方法：&lt;br&gt;1、forEach，代替for循环的&lt;br&gt;2、filter，根据条件过滤数组&lt;br&gt;3、indexOf，数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标&lt;/p&gt;
&lt;h3 id=&quot;1、数组内置方法Array-prot
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="vue" scheme="https://jiawanlong.github.io/tags/vue/"/>
    
      <category term="数组" scheme="https://jiawanlong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Axios入门</title>
    <link href="https://jiawanlong.github.io/2019/03/12/Axios%E5%85%A5%E9%97%A8/"/>
    <id>https://jiawanlong.github.io/2019/03/12/Axios入门/</id>
    <published>2019-03-12T11:37:59.163Z</published>
    <updated>2019-03-12T11:39:16.386Z</updated>
    
    <content type="html"><![CDATA[<p>axios是基于promise用于浏览器和node.js的http客户端。<br>axios的作用是什么呢：axios主要是用于向后台发起请求的，还有在请求中做更多是可控功能。有以下特点：支持浏览器和node.js、支持promise、能拦截请求和响应、能转换请求和响应数据、能取消请求、自动转换JSON数据、浏览器端支持防止CSRF(跨站请求伪造)<br>promise是什么：是一个对象用来传递异步操作的信息，它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的api，可供进一步的处理。promise的作用：Promise的出现主要是解决地狱回调的问题，比如你需要结果需要请求很多个接口，这些接口的参数需要另外那个的接口返回的数据作为依赖，这样就需要我们一层嵌套一层，但是有了Promise 我们就无需嵌套。promise的本质是什么：分离异步数据获取和业务</p><h2 id="1、axios基础用法"><a href="#1、axios基础用法" class="headerlink" title="1、axios基础用法"></a>1、axios基础用法</h2><h3 id="1-1、get请求demo"><a href="#1-1、get请求demo" class="headerlink" title="1.1、get请求demo"></a>1.1、get请求demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 为给定 ID 的 user 创建请求</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 可选地，上面的请求可以这样做</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="1-2、post请求demo"><a href="#1-2、post请求demo" class="headerlink" title="1.2、post请求demo"></a>1.2、post请求demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="1-3、执行多个并发请求"><a href="#1-3、执行多个并发请求" class="headerlink" title="1.3、执行多个并发请求"></a>1.3、执行多个并发请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    // 两个请求现在都执行完成</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><h3 id="1-4、API"><a href="#1-4、API" class="headerlink" title="1.4、API"></a>1.4、API</h3><h4 id="1-4-1-请求配置"><a href="#1-4-1-请求配置" class="headerlink" title="1.4.1 请求配置"></a>1.4.1 请求配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;,</span><br><span class="line">    // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span><br><span class="line">    // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class="line">    timeout: 1000,</span><br><span class="line">    // `withCredentials` 表示跨域请求时是否需要使用凭证</span><br><span class="line">    withCredentials: false, // 默认的</span><br><span class="line">    // &apos;proxy&apos; 定义代理服务器的主机名称和端口</span><br><span class="line">    // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class="line">    // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      host: &apos;127.0.0.1&apos;,</span><br><span class="line">      port: 9000,</span><br><span class="line">      auth: : &#123;</span><br><span class="line">        username: &apos;mikeymike&apos;,</span><br><span class="line">        password: &apos;rapunz3l&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="1-4-2-响应结构"><a href="#1-4-2-响应结构" class="headerlink" title="1.4.2 响应结构"></a>1.4.2 响应结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // `data` 由服务器提供的响应</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class="line">  status: 200,</span><br><span class="line">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class="line">  statusText: &apos;OK&apos;,</span><br><span class="line">  // `headers` 服务器响应的头</span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line">  // `config` 是为请求提供的配置信息</span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-全局的-axios-默认值"><a href="#1-5-全局的-axios-默认值" class="headerlink" title="1.5 全局的 axios 默认值"></a>1.5 全局的 axios 默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout  = 2000;</span><br><span class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure><h2 id="2、axios和vue结合"><a href="#2、axios和vue结合" class="headerlink" title="2、axios和vue结合"></a>2、axios和vue结合</h2><h3 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get"></a>2.1 get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const SERVERIP = &quot;&quot;;</span><br><span class="line">export const apiLogin = (userid, password) =&gt; &#123;</span><br><span class="line">  return axios.get(`$&#123;SERVERIP&#125;/api/login/login?userid=$&#123;userid&#125;&amp;password=$&#123;password&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">import &#123; apiLogin &#125; from &quot;./api/api.js&quot;;</span><br><span class="line">apiLogin(this.userid, this.pwd).then(res =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-post"><a href="#2-2-post" class="headerlink" title="2.2 post"></a>2.2 post</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const SERVERIP = &quot;&quot;;</span><br><span class="line">export const updateUserPwd = (params) =&gt; &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    url: `$&#123;SERVERIP&#125;/api/user/update`,</span><br><span class="line">    data: params</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">import &#123; apiLogin &#125; from &quot;./api/api.js&quot;;</span><br><span class="line">obj = JSON.stringify(obj);</span><br><span class="line">updateUserPwd(obj).then(res =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3、同步实现"><a href="#3、同步实现" class="headerlink" title="3、同步实现"></a>3、同步实现</h2><h3 id="3-1-、简单模式实现"><a href="#3-1-、简单模式实现" class="headerlink" title="3.1 、简单模式实现"></a>3.1 、简单模式实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getBu();</span><br><span class="line"></span><br><span class="line">function chinaCity()&#123;</span><br><span class="line">    // return axios.get(&apos;./lib/chinaCity.json&apos;)</span><br><span class="line">    return axios.get(&apos;./lib/chinaCity.json&apos;,&#123;</span><br><span class="line">        params:&#123;                    //传值模式</span><br><span class="line">            id:222</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getBu()&#123;</span><br><span class="line">    var data = await chinaCity();</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-、常用模式"><a href="#3-1-、常用模式" class="headerlink" title="3.1 、常用模式"></a>3.1 、常用模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const SERVERIP = &quot;&quot;;</span><br><span class="line">export const apiLogin = (userid, password) =&gt; &#123;</span><br><span class="line">  return axios.get(`$&#123;SERVERIP&#125;/api/login/login?userid=$&#123;userid&#125;&amp;password=$&#123;password&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">import &#123; apiLogin &#125; from &quot;./api/api.js&quot;;</span><br><span class="line">methods: &#123;</span><br><span class="line">  async myLogin()&#123;</span><br><span class="line">    var res = await apiLogin(this.userid, this.pwd);</span><br><span class="line">    console.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;axios是基于promise用于浏览器和node.js的http客户端。&lt;br&gt;axios的作用是什么呢：axios主要是用于向后台发起请求的，还有在请求中做更多是可控功能。有以下特点：支持浏览器和node.js、支持promise、能拦截请求和响应、能转换请求和响应数据
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="Axios" scheme="https://jiawanlong.github.io/tags/Axios/"/>
    
      <category term="vue" scheme="https://jiawanlong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6第三课、number扩展</title>
    <link href="https://jiawanlong.github.io/2019/01/15/ES6%E7%AC%AC%E4%B8%89%E8%AF%BE%E3%80%81number%E6%89%A9%E5%B1%95/"/>
    <id>https://jiawanlong.github.io/2019/01/15/ES6第三课、number扩展/</id>
    <published>2019-01-15T06:49:54.597Z</published>
    <updated>2019-01-15T06:50:28.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-Number-isFinite-Number-isNaN"><a href="#4-1-Number-isFinite-Number-isNaN" class="headerlink" title="4.1 Number.isFinite(), Number.isNaN()"></a>4.1 Number.isFinite(), Number.isNaN()</h2><p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity<br>注意，如果参数类型不是数值，Number.isFinite一律返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(15); // true</span><br><span class="line">Number.isFinite(0.8); // true</span><br><span class="line">Number.isFinite(NaN); // false</span><br><span class="line">Number.isFinite(Infinity); // false</span><br><span class="line">Number.isFinite(-Infinity); // false</span><br><span class="line">Number.isFinite(&apos;foo&apos;); // false</span><br><span class="line">Number.isFinite(&apos;15&apos;); // false</span><br><span class="line">Number.isFinite(true); // false</span><br><span class="line">isNaN(NaN) // true</span><br><span class="line">isNaN(&quot;NaN&quot;) // true</span><br><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(&quot;NaN&quot;) // false</span><br></pre></td></tr></table></figure></p><p>如果参数类型不是NaN，Number.isNaN一律返回false。<br>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p><h2 id="4-2-Number-parseInt-Number-parseFloat"><a href="#4-2-Number-parseInt-Number-parseFloat" class="headerlink" title="4.2 Number.parseInt(), Number.parseFloat()"></a>4.2 Number.parseInt(), Number.parseFloat()</h2><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p><h2 id="4-3-Number-isInteger"><a href="#4-3-Number-isInteger" class="headerlink" title="4.3 Number.isInteger()"></a>4.3 Number.isInteger()</h2><p>Number.isInteger()用来判断一个数值是否为整数。  </p><h2 id="4-4-Math-trunc"><a href="#4-4-Math-trunc" class="headerlink" title="4.4 Math.trunc()"></a>4.4 Math.trunc()</h2><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(4.1) // 4</span><br><span class="line">Math.trunc(4.9) // 4</span><br><span class="line">Math.trunc(-4.1) // -4</span><br><span class="line">Math.trunc(-4.9) // -4</span><br><span class="line">Math.trunc(-0.1234) // -0</span><br></pre></td></tr></table></figure></p><p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(&apos;123.456&apos;) // 123</span><br><span class="line">Math.trunc(true) //1</span><br><span class="line">Math.trunc(false) // 0</span><br><span class="line">Math.trunc(null) // 0</span><br></pre></td></tr></table></figure></p><p>对于空值和无法截取整数的值，返回NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(NaN);      // NaN</span><br><span class="line">Math.trunc(&apos;foo&apos;);    // NaN</span><br><span class="line">Math.trunc();         // NaN</span><br><span class="line">Math.trunc(undefined) // NaN</span><br></pre></td></tr></table></figure></p><h2 id="4-5-Math-sign"><a href="#4-5-Math-sign" class="headerlink" title="4.5 Math.sign()"></a>4.5 Math.sign()</h2><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。<br>它会返回五种值。</p><ul><li>参数为正数，返回+1；</li><li>参数为负数，返回-1；</li><li>参数为 0，返回0；</li><li>参数为-0，返回-0;</li><li>其他值，返回NaN。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;4-1-Number-isFinite-Number-isNaN&quot;&gt;&lt;a href=&quot;#4-1-Number-isFinite-Number-isNaN&quot; class=&quot;headerlink&quot; title=&quot;4.1 Number.isFinite(), Numbe
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="ES6" scheme="https://jiawanlong.github.io/tags/ES6/"/>
    
      <category term="number" scheme="https://jiawanlong.github.io/tags/number/"/>
    
  </entry>
  
  <entry>
    <title>ES6第四课、函数扩展</title>
    <link href="https://jiawanlong.github.io/2019/01/15/ES6%E7%AC%AC%E5%9B%9B%E8%AF%BE%E3%80%81%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/"/>
    <id>https://jiawanlong.github.io/2019/01/15/ES6第四课、函数扩展/</id>
    <published>2019-01-15T06:49:54.577Z</published>
    <updated>2019-01-15T06:50:52.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1、函数参数的默认值"><a href="#5-1、函数参数的默认值" class="headerlink" title="5.1、函数参数的默认值"></a>5.1、函数参数的默认值</h2><h3 id="5-1-1、基本用法"><a href="#5-1-1、基本用法" class="headerlink" title="5.1.1、基本用法"></a>5.1.1、基本用法</h3><p>ES6 之前，不能直接为函数的参数指定默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y) &#123;</span><br><span class="line">  y = y || &apos;World&apos;;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</span><br></pre></td></tr></table></figure></p><p>这种写法的<strong>缺点</strong>在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。<br>参数y等于空字符，结果被改为默认值<br>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof y === &apos;undefined&apos;) &#123;</span><br><span class="line">  y = &apos;World&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</span><br></pre></td></tr></table></figure></p><p>另外一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Point(x = 0, y = 0) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Point();</span><br><span class="line">p // &#123; x: 0, y: 0 &#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：参数变量是默认声明的，所以不能用let或const再次声明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(x = 5) &#123;</span><br><span class="line">  let x = 1; // error</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-1-2、与解构赋值默认值结合使用"><a href="#5-1-2、与解构赋值默认值结合使用" class="headerlink" title="5.1.2、与解构赋值默认值结合使用"></a>5.1.2、与解构赋值默认值结合使用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1 2</span><br><span class="line">foo() // TypeError: Cannot read property &apos;x&apos; of undefined</span><br></pre></td></tr></table></figure></p><p>如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // undefined 5</span><br></pre></td></tr></table></figure></p><p>上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。<br><strong>两种写法区别</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure></p><h3 id="5-1-3、参数默认值的位置"><a href="#5-1-3、参数默认值的位置" class="headerlink" title="5.1.3、参数默认值的位置"></a>5.1.3、参数默认值的位置</h3><p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(x = 5, y = 6) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(undefined, null)</span><br><span class="line">// 5 null</span><br></pre></td></tr></table></figure></p><h2 id="5-2、rest-参数"><a href="#5-2、rest-参数" class="headerlink" title="5.2、rest 参数"></a>5.2、rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。<br><strong>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure></p><p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arguments变量的写法</span><br><span class="line">function sortNumbers() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// rest参数的写法</span><br><span class="line">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure></p><h2 id="5-3、严格模式"><a href="#5-3、严格模式" class="headerlink" title="5.3、严格模式"></a>5.3、严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(a, b) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function doSomething(a, b = a) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = function (&#123;a, b&#125;) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = (...a) =&gt; &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>设定全局性的严格模式，这是合法的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function doSomething(a, b = a) &#123;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-4、name-属性"><a href="#5-4、name-属性" class="headerlink" title="5.4、name 属性"></a>5.4、name 属性</h2><p>函数的name属性，返回该函数的函数名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line">foo.name // &quot;foo&quot;</span><br></pre></td></tr></table></figure></p><p>如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;&#125;;</span><br><span class="line">// ES5</span><br><span class="line">f.name // &quot;&quot;</span><br><span class="line">// ES6</span><br><span class="line">f.name // &quot;f&quot;</span><br></pre></td></tr></table></figure></p><p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const bar = function baz() &#123;&#125;;</span><br><span class="line">// ES5</span><br><span class="line">bar.name // &quot;baz&quot;</span><br><span class="line">// ES6</span><br><span class="line">bar.name // &quot;baz&quot;</span><br></pre></td></tr></table></figure></p><h2 id="5-5、箭头函数"><a href="#5-5、箭头函数" class="headerlink" title="5.5、箭头函数"></a>5.5、箭头函数</h2><h3 id="5-5-1、基本用法"><a href="#5-5-1、基本用法" class="headerlink" title="5.5.1、基本用法"></a>5.5.1、基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// 不报错</span><br><span class="line">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br></pre></td></tr></table></figure></p><p>箭头函数的一个用处是简化回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数写法</span><br><span class="line">[1,2,3].map(function (x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;);</span><br><span class="line">// 箭头函数写法</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">// 正常函数写法</span><br><span class="line">var result = values.sort(function (a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;);</span><br><span class="line">// 箭头函数写法</span><br><span class="line">var result = values.sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure></p><h3 id="5-5-2、使用注意点"><a href="#5-5-2、使用注意点" class="headerlink" title="5.5.2、使用注意点"></a>5.5.2、使用注意点</h3><p>-（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>-（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>-（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>-（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line">var id = 21;</span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;5-1、函数参数的默认值&quot;&gt;&lt;a href=&quot;#5-1、函数参数的默认值&quot; class=&quot;headerlink&quot; title=&quot;5.1、函数参数的默认值&quot;&gt;&lt;/a&gt;5.1、函数参数的默认值&lt;/h2&gt;&lt;h3 id=&quot;5-1-1、基本用法&quot;&gt;&lt;a href=&quot;#5-1
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="ES6" scheme="https://jiawanlong.github.io/tags/ES6/"/>
    
      <category term="函数" scheme="https://jiawanlong.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://jiawanlong.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>原生js封装ajax</title>
    <link href="https://jiawanlong.github.io/2018/12/27/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/"/>
    <id>https://jiawanlong.github.io/2018/12/27/原生js封装ajax/</id>
    <published>2018-12-27T09:03:50.745Z</published>
    <updated>2018-12-27T09:06:02.530Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">var $ajax = function () &#123;</span><br><span class="line"></span><br><span class="line">    //默认请求参数</span><br><span class="line">    var _options = &#123;</span><br><span class="line">        url: null,</span><br><span class="line">        type: &apos;GET&apos;,</span><br><span class="line">        data: null,</span><br><span class="line">        dataType: &apos;text&apos;,</span><br><span class="line">        jsonp: &apos;callback&apos;,</span><br><span class="line">        jsonpCallback: &apos;jsonpCallback&apos;,</span><br><span class="line">        async: true,</span><br><span class="line">        cache: true,</span><br><span class="line">        timeout: null,</span><br><span class="line">        contentType: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">        success: null,</span><br><span class="line">        fail: null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // json转化为字符串</span><br><span class="line">    var _param = function (data) &#123;</span><br><span class="line">        var str = &apos;&apos;;</span><br><span class="line">        if (!data || _empty(data)) &#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        for (var key in data) &#123;</span><br><span class="line">            str += key + &apos;=&apos; + data[key] + &apos;&amp;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.slice(0, -1);</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断对象是否为空</span><br><span class="line">    var _empty = function (obj) &#123;</span><br><span class="line">        for (var key in obj) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var _extend = function (target, options) &#123;</span><br><span class="line">        if (typeof target !== &apos;object&apos; || typeof options !== &apos;object&apos;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var copy, clone, name;</span><br><span class="line">        for (name in options) &#123;</span><br><span class="line">            if (options.hasOwnProperty(name) &amp;&amp; !target.hasOwnProperty(name)) &#123;</span><br><span class="line">                target[name] = options[name];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 自定义text转化json格式</span><br><span class="line">    var parseJSON = function (text) &#123;</span><br><span class="line">        if (typeof text !== &apos;string&apos;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (JSON &amp;&amp; JSON.parse) &#123;</span><br><span class="line">            return JSON.parse(text);</span><br><span class="line">        &#125;</span><br><span class="line">        return (new Function(&apos;return &apos; + text))();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // jsonp处理函数</span><br><span class="line">    function _sendJsonpRequest(url, callbackName, succCallback) &#123;</span><br><span class="line"></span><br><span class="line">        var script = document.createElement(&apos;script&apos;);</span><br><span class="line"></span><br><span class="line">        script.type = &quot;text/javascript&quot;;</span><br><span class="line">        script.src = url;</span><br><span class="line"></span><br><span class="line">        document.body.appendChild(script);</span><br><span class="line">        // 如果用户自己定义了回调函数，就用自己定义的，否则，调用success函数</span><br><span class="line">        window[callbackName] = window[callbackName] || succCallback;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return function (options) &#123;</span><br><span class="line"></span><br><span class="line">        // 没有传参或者没有url，抛出错误</span><br><span class="line">        if (!options || !options.url) &#123;</span><br><span class="line">            throw (&apos;参数错误！&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 继承操作</span><br><span class="line">        options.type = options.type.toUpperCase();</span><br><span class="line">        _extend(options, _options);</span><br><span class="line"></span><br><span class="line">        /*jsonp部分，直接返回*/</span><br><span class="line">        if (options.dataType === &apos;jsonp&apos;) &#123;</span><br><span class="line">            var jsonpUrl = options.url.indexOf(&apos;?&apos;) &gt; -1 ? options.url : options.url +</span><br><span class="line">                &apos;?&apos; + options.jsonp + &apos;=&apos; + options.jsonpCallback;</span><br><span class="line"></span><br><span class="line">            _sendJsonpRequest(jsonpUrl, options.jsonpCallback, options.success);</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //XMLHttpRequest传参无影响</span><br><span class="line">        var xhr = new(window.XMLHttpRequest || ActiveXObject)(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line"></span><br><span class="line">        // get搜索字符串</span><br><span class="line">        var search = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">        // 将data序列化</span><br><span class="line">        var param = _param(options.data)</span><br><span class="line"></span><br><span class="line">        if (options.type === &apos;GET&apos;) &#123;</span><br><span class="line">            search = (options.url.indexOf(&apos;?&apos;) &gt; -1 ? &apos;&amp;&apos; : &apos;?&apos;) + param;</span><br><span class="line">            if (!options.cache) &#123;</span><br><span class="line">                search += &apos;&amp;radom=&apos; + Math.random();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            param = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.open(options.type, options.url + search, options.async);</span><br><span class="line"></span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            if (xhr.readyState == 4) &#123;</span><br><span class="line">                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123;</span><br><span class="line">                    var text = xhr.responseText;</span><br><span class="line">                    // json格式转换</span><br><span class="line">                    if (options.dataType == &apos;json&apos;) &#123;</span><br><span class="line">                        text = parseJSON(text)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (typeof options.success === &apos;function&apos;) &#123;</span><br><span class="line"></span><br><span class="line">                        options.success(text, xhr.status)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    if (typeof options.fail === &apos;function&apos;) &#123;</span><br><span class="line">                        options.fail(&apos;获取失败&apos;, 500)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.setRequestHeader(&apos;content-type&apos;, options.contentType);</span><br><span class="line">        // get请求时param时null</span><br><span class="line">        xhr.send(param);</span><br><span class="line"></span><br><span class="line">        // 如果设置了超时，就定义</span><br><span class="line">        if (typeof options.timeout === &apos;number&apos;) &#123;</span><br><span class="line">            // ie9+</span><br><span class="line">            if (xhr.timeout) &#123;</span><br><span class="line">                xhr.timeout = options.timeout;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    xhr.abort();</span><br><span class="line">                &#125;, options.timeout)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">var aaaa = null</span><br><span class="line">$ajax(&#123;</span><br><span class="line">    url: &apos;http://172.16.4.190:8088/dataflow/services/siteManage/getSiteList.json&apos;,</span><br><span class="line">    type: &apos;get&apos;,</span><br><span class="line">    dataType: &apos;json&apos;,</span><br><span class="line">    timeout: 1000,</span><br><span class="line">    data: &#123;</span><br><span class="line">        pageindex: &quot;1&quot;,</span><br><span class="line">        pagesize: &quot;10&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    async: false,</span><br><span class="line">    success: function (data, status) &#123;</span><br><span class="line">        aaaa = data.data;</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function (err, status) &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(aaaa)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="原生js" scheme="https://jiawanlong.github.io/tags/%E5%8E%9F%E7%94%9Fjs/"/>
    
      <category term="ajax" scheme="https://jiawanlong.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>ES6第二课、字符串扩展</title>
    <link href="https://jiawanlong.github.io/2018/12/27/ES6%E7%AC%AC%E4%BA%8C%E8%AF%BE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/"/>
    <id>https://jiawanlong.github.io/2018/12/27/ES6第二课、字符串扩展/</id>
    <published>2018-12-27T09:00:42.471Z</published>
    <updated>2018-12-27T09:03:21.234Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1-字符串的遍历器"><a href="#3-1-字符串的遍历器" class="headerlink" title="3.1 字符串的遍历器"></a>3.1 字符串的遍历器</h3><p>字符串可以被for…of循环遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let codePoint of &apos;foo&apos;) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line">// &quot;f&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line">// &quot;o&quot;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-includes-startsWith-endsWith"><a href="#3-2-includes-startsWith-endsWith" class="headerlink" title="3.2 includes(), startsWith(), endsWith()"></a>3.2 includes(), startsWith(), endsWith()</h3><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = &apos;Hello world!&apos;;</span><br><span class="line">s.startsWith(&apos;Hello&apos;) // true</span><br><span class="line">s.endsWith(&apos;!&apos;) // true</span><br><span class="line">s.includes(&apos;o&apos;) // true</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-repeat"><a href="#3-3-repeat" class="headerlink" title="3.3 repeat()"></a>3.3 repeat()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</span><br><span class="line">&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;</span><br><span class="line">&apos;na&apos;.repeat(0) // &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-4-模板字符串"><a href="#3-4-模板字符串" class="headerlink" title="3.4 模板字符串"></a>3.4 模板字符串</h3><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中.如果不想要这个换行，可以使用trim方法消除它。<br><strong>模板字符串中嵌入变量，需要将变量名写在${}之中。</strong><br>传统的 JavaScript 语言，输出模板通常是这样写的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#result&apos;).append(</span><br><span class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</span><br><span class="line">  &apos;items in your basket, &apos; +</span><br><span class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</span><br><span class="line">  &apos;&lt;/em&gt; are on sale!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>ES6 引入了模板字符串解决这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br><span class="line"></span><br><span class="line">//**消灭换行**</span><br><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure></p><p><strong>字符串中嵌入变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure></p><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line"></span><br><span class="line">`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`</span><br><span class="line">// &quot;1 + 2 = 3&quot;</span><br><span class="line"></span><br><span class="line">`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`</span><br><span class="line">// &quot;1 + 4 = 5&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123;x: 1, y: 2&#125;;</span><br><span class="line">`$&#123;obj.x + obj.y&#125;`</span><br><span class="line">// &quot;3&quot;</span><br></pre></td></tr></table></figure></p><p>模板字符串之中还能调用函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  return &quot;Hello World&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`foo $&#123;fn()&#125; bar`</span><br><span class="line">// foo Hello World bar</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;3-1-字符串的遍历器&quot;&gt;&lt;a href=&quot;#3-1-字符串的遍历器&quot; class=&quot;headerlink&quot; title=&quot;3.1 字符串的遍历器&quot;&gt;&lt;/a&gt;3.1 字符串的遍历器&lt;/h3&gt;&lt;p&gt;字符串可以被for…of循环遍历&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="ES6" scheme="https://jiawanlong.github.io/tags/ES6/"/>
    
      <category term="字符串" scheme="https://jiawanlong.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ES6第一课、let和const命令</title>
    <link href="https://jiawanlong.github.io/2018/12/24/ES6%E7%AC%AC%E4%B8%80%E8%AF%BE%E3%80%81let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>https://jiawanlong.github.io/2018/12/24/ES6第一课、let和const命令/</id>
    <published>2018-12-24T09:53:56.193Z</published>
    <updated>2018-12-25T01:06:26.515Z</updated>
    
    <content type="html"><![CDATA[<!-- [TOC] --><h2 id="2-1、let命令"><a href="#2-1、let命令" class="headerlink" title="2.1、let命令"></a>2.1、let命令</h2><h3 id="2-1-1-基本用法"><a href="#2-1-1-基本用法" class="headerlink" title="2.1.1 基本用法"></a>2.1.1 基本用法</h3><p>所声明的变量，只在let命令所在的代码块内有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;&#125;</span><br><span class="line">console.log(i);</span><br><span class="line">// ReferenceError: i is not defined</span><br></pre></td></tr></table></figure></p><h3 id="2-1-2-不存在变量提升"><a href="#2-1-2-不存在变量提升" class="headerlink" title="2.1.2 不存在变量提升"></a>2.1.2 不存在变量提升</h3><p>var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// let 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line">let bar = 2;</span><br></pre></td></tr></table></figure></p><h3 id="2-1-3-暂时性死区"><a href="#2-1-3-暂时性死区" class="headerlink" title="2.1.3 暂时性死区"></a>2.1.3 暂时性死区</h3><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // 暂时性死区开始</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // 暂时性死区结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-1-4-不允许重复声明"><a href="#2-1-4-不允许重复声明" class="headerlink" title="2.1.4 不允许重复声明"></a>2.1.4 不允许重复声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2、块级作用域"><a href="#2-2、块级作用域" class="headerlink" title="2.2、块级作用域"></a>2.2、块级作用域</h2><h3 id="2-2-1、为什么需要块级作用域？"><a href="#2-2-1、为什么需要块级作用域？" class="headerlink" title="2.2.1、为什么需要块级作用域？"></a>2.2.1、为什么需要块级作用域？</h3><p>1、变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure></p><p>2、内层变量可能会覆盖外层变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure></p><h3 id="2-2-2、ES6-的块级作用域"><a href="#2-2-2、ES6-的块级作用域" class="headerlink" title="2.2.2、ES6 的块级作用域"></a>2.2.2、ES6 的块级作用域</h3><p>函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  let n = 5;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>外层作用域无法读取内层作用域的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure></p><p>内层作用域<strong>可以</strong>定义外层作用域的同名变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  let insane = &apos;Hello World&apos;;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure></p><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(function () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  let tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-3、const-命令"><a href="#2-3、const-命令" class="headerlink" title="2.3、const 命令"></a>2.3、const 命令</h2><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer in const declaration</span><br><span class="line"></span><br><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line">PI = 3; // TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></p><p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure></p><h2 id="2-4、ES6-声明变量的六种方法"><a href="#2-4、ES6-声明变量的六种方法" class="headerlink" title="2.4、ES6 声明变量的六种方法"></a>2.4、ES6 声明变量的六种方法</h2><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。</p><h2 id="2-5、顶层对象和全局变量"><a href="#2-5、顶层对象和全局变量" class="headerlink" title="2.5、顶层对象和全局变量"></a>2.5、顶层对象和全局变量</h2><p>var命令和function命令声明的全局变量，依旧是顶层对象的属性。<br>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line">let b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- [TOC] --&gt;
&lt;h2 id=&quot;2-1、let命令&quot;&gt;&lt;a href=&quot;#2-1、let命令&quot; class=&quot;headerlink&quot; title=&quot;2.1、let命令&quot;&gt;&lt;/a&gt;2.1、let命令&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-基本用法&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="ES6" scheme="https://jiawanlong.github.io/tags/ES6/"/>
    
      <category term="let const" scheme="https://jiawanlong.github.io/tags/let-const/"/>
    
  </entry>
  
  <entry>
    <title>我爱这被风带走不会再有的每一天</title>
    <link href="https://jiawanlong.github.io/2018/11/19/%E6%88%91%E7%88%B1%E8%BF%99%E8%A2%AB%E9%A3%8E%E5%B8%A6%E8%B5%B0%E4%B8%8D%E4%BC%9A%E5%86%8D%E6%9C%89%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9/"/>
    <id>https://jiawanlong.github.io/2018/11/19/我爱这被风带走不会再有的每一天/</id>
    <published>2018-11-19T03:02:36.873Z</published>
    <updated>2018-11-19T03:04:23.593Z</updated>
    
    <content type="html"><![CDATA[<p>不重要的一天又开始了，就像昨晚结束时那样。</p><p>我想，没有什么比爱更好的事了。</p><p>爱朴树，爱这没什么旋律又偏重金属的《我去2000年》，压抑而又嘈乱，爱他吞吞吐吐时的样子</p><p>爱小波，爱那些无奈的黑色幽默，又例如《三十而立》，又如那龟头血肿李先生。满天都是星星，好像冻结了的大雨</p><p>爱妈妈做的韭菜盒子，辣椒鸡蛋，酸辣白菜，饺子，热烘烘的白馒头</p><p>爱下雨，淅沥沥的下午，没有时间，没有颜色</p><p>爱可乐，一定是罐装百事</p><p>爱家人，爸妈唠叨给我讲道理，和妹妹一起捉鱼，虽然一只都抓不到，一家四口夏天的中午坐在大门口吊扇下吃饭，母亲有说不完的家常，父亲有讲不完的道理，和妹妹一起吵吵闹闹停不下来</p><p>爱阳光，一定要闭着眼</p><p>爱文学，一定是长篇小说，西北文学，也有例外，如看多少遍都不烦的《鲁滨逊漂流记》，如天马行空的小波</p><p>爱年轻，因为怕老</p><p>爱感动，却不爱哭，记得小时候是一个特别爱哭的人，可现在却屈指可数。上次哭是和妹妹吵架，上上次是外爷去世</p><p>爱香蕉，我还给它取了个名字，幸福果</p><p>爱朋友，也许半年一年不曾联系一次，那一无所有却有趣的年少时光，我们曾一起骑车，一起下棋，一起放风筝</p><p>爱五月，麦子还没黄，天还没热，我们还没长大</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不重要的一天又开始了，就像昨晚结束时那样。&lt;/p&gt;
&lt;p&gt;我想，没有什么比爱更好的事了。&lt;/p&gt;
&lt;p&gt;爱朴树，爱这没什么旋律又偏重金属的《我去2000年》，压抑而又嘈乱，爱他吞吞吐吐时的样子&lt;/p&gt;
&lt;p&gt;爱小波，爱那些无奈的黑色幽默，又例如《三十而立》，又如那龟头血肿李
      
    
    </summary>
    
      <category term="GREAT LIFE" scheme="https://jiawanlong.github.io/categories/GREAT-LIFE/"/>
    
    
      <category term="生活" scheme="https://jiawanlong.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="我爱这被风带走不会再有的每一天" scheme="https://jiawanlong.github.io/tags/%E6%88%91%E7%88%B1%E8%BF%99%E8%A2%AB%E9%A3%8E%E5%B8%A6%E8%B5%B0%E4%B8%8D%E4%BC%9A%E5%86%8D%E6%9C%89%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>leaflet汇总</title>
    <link href="https://jiawanlong.github.io/2018/11/08/leaflet%E6%B1%87%E6%80%BB/"/>
    <id>https://jiawanlong.github.io/2018/11/08/leaflet汇总/</id>
    <published>2018-11-08T10:34:21.137Z</published>
    <updated>2018-11-08T10:44:20.285Z</updated>
    
    <content type="html"><![CDATA[<p>乱七八糟的功能，没时间总结。。。纯当笔记了</p><ul><li><a href="https://jiawanlong.github.io/demo/leaflet/leaflet%E6%96%87%E5%AD%97%E6%A0%87%E6%B3%A8.html">leaflet文字标注</a></li><li><a href="https://jiawanlong.github.io/demo/leaflet/leaflet%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%9C%86%E7%BA%BF.html">leaflet多边形圆线</a></li><li><a href="https://jiawanlong.github.io/demo/leaflet/leaflet%E5%90%84%E7%A7%8D%E4%BA%8B%E4%BB%B6.html">leaflet各种事件</a></li><li><a href="https://jiawanlong.github.io/demo">leaflet量距和量面完整包下载</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;乱七八糟的功能，没时间总结。。。纯当笔记了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jiawanlong.github.io/demo/leaflet/leaflet%E6%96%87%E5%AD%97%E6%A0%87%E6%B3%A8.html&quot;&gt;l
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="leaflet" scheme="https://jiawanlong.github.io/tags/leaflet/"/>
    
      <category term="gis" scheme="https://jiawanlong.github.io/tags/gis/"/>
    
  </entry>
  
  <entry>
    <title>vuex小白入门</title>
    <link href="https://jiawanlong.github.io/2018/10/11/vuex%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8/"/>
    <id>https://jiawanlong.github.io/2018/10/11/vuex小白入门/</id>
    <published>2018-10-11T07:12:15.369Z</published>
    <updated>2018-10-11T07:12:55.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先：Vuex是什么？"><a href="#首先：Vuex是什么？" class="headerlink" title="首先：Vuex是什么？"></a>首先：Vuex是什么？</h2><p>有关于Vuex，官网是这样定义的：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>我是这么认为的：Vuex是为了解决多个组件共享状态而存在的。他能够有效的解决兄弟组件，父子组件，爷孙组件的传值。他将组件的共享状态抽取出来，以一个全局单例模式管理。</p><h5 id="Vuex有以下5个重要属性："><a href="#Vuex有以下5个重要属性：" class="headerlink" title="Vuex有以下5个重要属性："></a>Vuex有以下5个重要属性：</h5><p><strong>1、State</strong><br>单一状态树，每个应用将仅仅包含一个 store 实例。<br><strong>2、Getter</strong><br>可以认为是 store 的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><strong>3、Mutation</strong><br>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。<br><strong>4、Action</strong><br>类似于 mutation，在于Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作<br><strong>5、Module</strong><br>Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter。模块内部的 action、mutation 和 getter 是注册在全局命名空间的。</p><h3 id="1、不使用Module开发"><a href="#1、不使用Module开发" class="headerlink" title="1、不使用Module开发"></a>1、不使用Module开发</h3><ul><li><p>文件存放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── state.js          # 跟级别的 state</span><br><span class="line">    ├── getters.js        # 跟级别的 getter</span><br><span class="line">    └── mutations.js      # 根级别的 mutation</span><br></pre></td></tr></table></figure></li><li><p>index.js存放的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import vue from &apos;vue&apos;;</span><br><span class="line">import vuex from &apos;vuex&apos;;</span><br><span class="line">import state from &apos;./state.js&apos;;</span><br><span class="line">import * as getters from &apos;./getters.js&apos;;</span><br><span class="line">import mutations from &apos;./mutations.js&apos;;</span><br><span class="line"></span><br><span class="line">vue.use(vuex);</span><br><span class="line"></span><br><span class="line">export default new vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>state.js存放的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">  name: &apos;jwl&apos;,</span><br><span class="line">  age: 24</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default state;</span><br></pre></td></tr></table></figure></li><li><p>getters.js存放的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export const name = (state) =&gt; &#123;</span><br><span class="line">    return state.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const age = (state) =&gt; &#123;</span><br><span class="line">    return state.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const other = (state) =&gt; &#123;</span><br><span class="line">    return `My name is $&#123;state.name&#125;, I am $&#123;state.age&#125;.`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutations.js存放的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    SET_NAME(state, name) &#123;</span><br><span class="line">        state.name = name;</span><br><span class="line">    &#125;,</span><br><span class="line">    SET_AGE(state, age) &#123;</span><br><span class="line">        state.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>main.js存放的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import App from &apos;./App.vue&apos;;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import router from &apos;./router/index.js&apos;</span><br><span class="line">import vuex from &apos;vuex&apos;</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(vuex);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>在组件中使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    姓名 &#123;&#123;name&#125;&#125; </span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    年龄 &#123;&#123;age&#125;&#125;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &#123;&#123;other&#125;&#125;</span><br><span class="line">    &lt;input @click=&quot;changeName&quot; type=&quot;button&quot; value=&apos;改变名字&apos;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapGetters, mapMutations ,mapState&#125; from &quot;vuex&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([&quot;name&quot;, &quot;age&quot;, &quot;other&quot;])</span><br><span class="line">    </span><br><span class="line">    //也可以用这个，但mapGetters要强大</span><br><span class="line">    //...mapState([&quot;name&quot;, &quot;age&quot;, &quot;other&quot;])</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      setName: &quot;SET_NAME&quot;,</span><br><span class="line">      setAge: &quot;SET_AGE&quot;</span><br><span class="line">    &#125;),</span><br><span class="line">    changeName() &#123;</span><br><span class="line">      this.setName(&quot;jiawan&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、使用Module开发"><a href="#2、使用Module开发" class="headerlink" title="2、使用Module开发"></a>2、使用Module开发</h3><ul><li><p>文件存放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    └── modules</span><br><span class="line">        ├── demo1.js         # 模块1</span><br><span class="line">        └── demo2.js         # 模块2</span><br></pre></td></tr></table></figure></li><li><p>index.js存放的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import vue from &apos;vue&apos;;</span><br><span class="line">import vuex from &apos;vuex&apos;;</span><br><span class="line">import demo1 from &apos;./modules/demo1.js&apos;;</span><br><span class="line"></span><br><span class="line">vue.use(vuex);</span><br><span class="line"></span><br><span class="line">export default new vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    demo1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>demo1.js存放的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const demo1 = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    names: `demo1`</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    change2(state, va) &#123;</span><br><span class="line">      state.names = va.new;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    names(state, getters, rootState) &#123;</span><br><span class="line">      return state.names + &apos;hhhhh&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default demo1;</span><br></pre></td></tr></table></figure></li><li><p>main.js存放的内容不变</p></li><li><strong>在组件中使用</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    //state内容，也可以在计算属性里面</span><br><span class="line">    &#123;&#123;$store.state.demo1.names&#125;&#125;</span><br><span class="line">    &lt;br&gt; </span><br><span class="line">    &#123;&#123;demo1name&#125;&#125; </span><br><span class="line">    &lt;input @click=&quot;changeDemo1Name&quot; type=&quot;button&quot; value=&apos;改变demo1名字&apos;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    //getters内容</span><br><span class="line">    demo1name() &#123;</span><br><span class="line">      return this.$store.getters.names;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeDemo1Name() &#123;</span><br><span class="line">      this.$store.commit(&quot;change2&quot;, &#123;</span><br><span class="line">        new: &quot;修改了修改了...&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先：Vuex是什么？&quot;&gt;&lt;a href=&quot;#首先：Vuex是什么？&quot; class=&quot;headerlink&quot; title=&quot;首先：Vuex是什么？&quot;&gt;&lt;/a&gt;首先：Vuex是什么？&lt;/h2&gt;&lt;p&gt;有关于Vuex，官网是这样定义的：Vuex 是一个专为 Vue.js
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="vue" scheme="https://jiawanlong.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="https://jiawanlong.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>图吧加密坐标转XY，图吧坐标转WGS84算法</title>
    <link href="https://jiawanlong.github.io/2018/09/26/%E5%9B%BE%E5%90%A7%E5%8A%A0%E5%AF%86%E5%9D%90%E6%A0%87%E8%BD%ACXY%EF%BC%8C%E5%9B%BE%E5%90%A7%E5%9D%90%E6%A0%87%E8%BD%ACWGS84%E7%AE%97%E6%B3%95/"/>
    <id>https://jiawanlong.github.io/2018/09/26/图吧加密坐标转XY，图吧坐标转WGS84算法/</id>
    <published>2018-09-26T08:09:26.896Z</published>
    <updated>2018-09-26T08:16:14.696Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做网络爬虫，爬全国的POI数据，大约爬了3000多万条，但图吧的坐标都是加密的，类似“HHVSJRWVTTGDD”这样的字符串，还好我跟踪的代码，发现其转换方法，无奈只有js版本，就顺手写了一个python版本的解密算法，但图吧的坐标有自己的坐标系，为了通用，又需要转成wgs84吗，所以我将他们综合了一下。</p><h4 id="1、JS版本"><a href="#1、JS版本" class="headerlink" title="1、JS版本"></a>1、JS版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var  vp = function(xT) &#123;</span><br><span class="line">      var v6;</span><br><span class="line">      var pk = -1;</span><br><span class="line">      var fE = 0;</span><br><span class="line">      var ub = &apos;&apos;;</span><br><span class="line">      var fH = &apos;&apos;;</span><br><span class="line">      for (var i = 0; i &lt; xT.length; i++) &#123;</span><br><span class="line">          var n8 = parseInt(xT.charAt(i), 36) - 10;</span><br><span class="line">          if (n8 &gt;= 17)</span><br><span class="line">              n8 = n8 - 7;</span><br><span class="line">          ub += (n8).toString(36);</span><br><span class="line">          if (n8 &gt; fE) &#123;</span><br><span class="line">              pk = i;</span><br><span class="line">              fE = n8</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      var n9 = parseInt(ub.substring(0, pk), 16);</span><br><span class="line">      var n0 = parseInt(ub.substring(pk + 1), 16);</span><br><span class="line"></span><br><span class="line">      v6 = new Array();</span><br><span class="line">      v6[0] = (n9 + n0 - parseInt(3409)) / 2;</span><br><span class="line">      </span><br><span class="line">      v6[1] = (n0 - v6[0]) / 100000.0;</span><br><span class="line">      </span><br><span class="line">      v6[0] /= 100000.0;</span><br><span class="line">      if (v6[0] &gt; 180)</span><br><span class="line">          v6[0] -= 360;</span><br><span class="line">      return v6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapBar2WGS84(x, y) &#123;</span><br><span class="line">    x = parseFloat(x) * 100000 % 36000000;</span><br><span class="line">    y = parseFloat(y) * 100000 % 36000000;</span><br><span class="line">    x1 = parseInt( - (((Math.cos(y / 100000)) * (x / 18000)) + ((Math.sin(x / 100000)) * (y / 9000))) + x);</span><br><span class="line">    y1 = parseInt( - (((Math.sin(y / 100000)) * (x / 18000)) + ((Math.cos(x / 100000)) * (y / 9000))) + y);</span><br><span class="line">    x2 = parseInt( - (((Math.cos(y1 / 100000)) * (x1 / 18000)) + ((Math.sin(x1 / 100000)) * (y1 / 9000))) + x + ((x &gt; 0) ? 1 : -1));</span><br><span class="line">    y2 = parseInt( - (((Math.sin(y1 / 100000)) * (x1 / 18000)) + ((Math.cos(x1 / 100000)) * (y1 / 9000))) + y + ((y &gt; 0) ? 1 : -1));</span><br><span class="line">    return [x2 / 100000.0, y2 / 100000.0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(vp(&quot;HHVSJRWVTTGDD&quot;))</span><br><span class="line">var x = vp(&quot;HHVSJRWVTTGDD&quot;)[0]</span><br><span class="line">var y = vp(&quot;HHVSJRWVTTGDD&quot;)[1]</span><br><span class="line">console.log(mapBar2WGS84(x,y))</span><br></pre></td></tr></table></figure><h4 id="2、Python版本"><a href="#2、Python版本" class="headerlink" title="2、Python版本"></a>2、Python版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def itoa(num, radix):</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line">    while num &gt; 0:</span><br><span class="line">        result = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;[num % radix] + result</span><br><span class="line">        num /= radix</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">def baseN(num, b):</span><br><span class="line">    return ((num == 0) and &quot;0&quot;) or (baseN(num // b, b).lstrip(&quot;0&quot;) + &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;[num % b])</span><br><span class="line"></span><br><span class="line">def mapBarKey2XY(xT):</span><br><span class="line">    v6 = []</span><br><span class="line">    pk = -1</span><br><span class="line">    fE = 0</span><br><span class="line">    ub = &apos;&apos;</span><br><span class="line">    for inx, iiii in enumerate(xT):</span><br><span class="line">        n8 = int(iiii,36) - 10</span><br><span class="line">        if n8 &gt;= 17:</span><br><span class="line">            n8 = n8 - 7</span><br><span class="line">        ub += baseN(n8,36)</span><br><span class="line">        if n8 &gt; fE:</span><br><span class="line">            pk = inx</span><br><span class="line">            fE = n8</span><br><span class="line"></span><br><span class="line">    n9 = int(ub[0:pk], 16)</span><br><span class="line">    pks = 0-pk</span><br><span class="line">    n0 = int(ub[pks:], 16)</span><br><span class="line"></span><br><span class="line">    v6.append((n9 + n0 - 3409)/2)</span><br><span class="line">    v6.append((n0 - v6[0])/100000.0)</span><br><span class="line">    v6[0] = v6[0] / 100000.0</span><br><span class="line"></span><br><span class="line">    if v6[0] &gt; 180:</span><br><span class="line">        v6[0] = v6[0] - 360</span><br><span class="line"></span><br><span class="line">    return v6</span><br><span class="line"></span><br><span class="line">def mapBar2WGS84(lng, lat):</span><br><span class="line">    lng = float(lng) * 100000 % 36000000;</span><br><span class="line">    lat = float(lat) * 100000 % 36000000;</span><br><span class="line">    lng1 = int(- (((math.cos(lat / 100000)) * (lng / 18000)) + ((math.sin(lng / 100000)) * (lat / 9000))) + lng)</span><br><span class="line">    lat1 = int(- (((math.sin(lat / 100000)) * (lng / 18000)) + ((math.cos(lng / 100000)) * (lat / 9000))) + lat)</span><br><span class="line">    lng2 = int(- (((math.cos(lat1 / 100000)) * (lng1 / 18000)) + ((math.sin(lng1 / 100000)) * (lat1 / 9000))) + lng + (</span><br><span class="line">        1 if lng &gt; 0 else -1))</span><br><span class="line">    lat2 = int(- (((math.sin(lat1 / 100000)) * (lng1 / 18000)) + ((math.cos(lng1 / 100000)) * (lat1 / 9000))) + lat + (</span><br><span class="line">        1 if lat &gt; 0 else -1))</span><br><span class="line">    return lng2 / 100000.0, lat2 / 100000.0</span><br><span class="line"></span><br><span class="line">print(mapBarKey2XY(&quot;HHVSJRWVTTGDD&quot;))</span><br><span class="line">print(mapBar2WGS84(mapBarKey2XY(&quot;HHVSJRWVTTGDD&quot;)[0],mapBarKey2XY(&quot;HHVSJRWVTTGDD&quot;)[1]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做网络爬虫，爬全国的POI数据，大约爬了3000多万条，但图吧的坐标都是加密的，类似“HHVSJRWVTTGDD”这样的字符串，还好我跟踪的代码，发现其转换方法，无奈只有js版本，就顺手写了一个python版本的解密算法，但图吧的坐标有自己的坐标系，为了通用，又需要转
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="图吧" scheme="https://jiawanlong.github.io/tags/%E5%9B%BE%E5%90%A7/"/>
    
      <category term="爬虫" scheme="https://jiawanlong.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="加密坐标" scheme="https://jiawanlong.github.io/tags/%E5%8A%A0%E5%AF%86%E5%9D%90%E6%A0%87/"/>
    
      <category term="坐标转换" scheme="https://jiawanlong.github.io/tags/%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>社会主义好</title>
    <link href="https://jiawanlong.github.io/2018/08/24/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E5%A5%BD/"/>
    <id>https://jiawanlong.github.io/2018/08/24/社会主义好/</id>
    <published>2018-08-24T08:01:01.436Z</published>
    <updated>2018-08-24T09:08:11.364Z</updated>
    
    <content type="html"><![CDATA[<p>看TG就像看老罗一样，明明知道他不行，还一次又一次的期望，结果却让人一次一次让人失望，因为我不相信他只是个锤子。<br>深圳、寿光完全被封锁死，我还能说什么？社会主义好！如果还有什么是TANK解决不了的，那一定需要高压水枪来帮忙。<br><strong>微博，知乎，朋友圈等所有的图片，相关信息大多刚出来被删除，今日博文仅以图片表达。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-54b6bbec29c8cc5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-25bce4298b341f38.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1工会斗争时间轴.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-c19a58f11f7f3b3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1时间轴2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-0eed361553ac3357.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-aecca5ba37d1582d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-a1cf35961ee2115c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-388df809500f4f51.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-e2719f21f6996654.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.5.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-3659273b3f54c54f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.6.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-d8f0624216f0921e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.7.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-cc312b23bf69b14c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.8.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-b9b57c1251885605.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.9.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-ea4c60cc4beb7e16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-5c3b24cbee94a70a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-37a7095999ba6b17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-5fa7a63a8c98a165.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-146011de83ab0932.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-af5137b2dddcd586.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-2b840a1da804fef7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-5ac4fc52b19c9caa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.7.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/8040955-d1ceddc3de313c0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.8.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看TG就像看老罗一样，明明知道他不行，还一次又一次的期望，结果却让人一次一次让人失望，因为我不相信他只是个锤子。&lt;br&gt;深圳、寿光完全被封锁死，我还能说什么？社会主义好！如果还有什么是TANK解决不了的，那一定需要高压水枪来帮忙。&lt;br&gt;&lt;strong&gt;微博，知乎，朋友圈等
      
    
    </summary>
    
      <category term="FUCK FUCK FUCK" scheme="https://jiawanlong.github.io/categories/FUCK-FUCK-FUCK/"/>
    
    
      <category term="FUCK" scheme="https://jiawanlong.github.io/tags/FUCK/"/>
    
      <category term="社会主义好" scheme="https://jiawanlong.github.io/tags/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E5%A5%BD/"/>
    
  </entry>
  
  <entry>
    <title>supermap专题图</title>
    <link href="https://jiawanlong.github.io/2018/08/15/supermap%E4%B8%93%E9%A2%98%E5%9B%BE/"/>
    <id>https://jiawanlong.github.io/2018/08/15/supermap专题图/</id>
    <published>2018-08-15T02:33:49.889Z</published>
    <updated>2018-08-24T08:03:07.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加载热力图"><a href="#加载热力图" class="headerlink" title="加载热力图"></a>加载热力图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var map, tiandituLayer, marker, markers, tianMarkerLayer;</span><br><span class="line">map = new SuperMap.Map(&quot;map&quot;);</span><br><span class="line">tiandituLayer = new SuperMap.Layer.Tianditu();</span><br><span class="line">map.addLayers([tiandituLayer]);</span><br><span class="line">map.setCenter(new SuperMap.LonLat(116,40), 3);</span><br><span class="line"></span><br><span class="line">var heatMapLayer = new SuperMap.Layer.HeatMapLayer(&quot;heatMap&quot;);</span><br><span class="line">map.addLayers([heatMapLayer]);</span><br><span class="line">var heatFeature = new SuperMap.Feature.Vector(</span><br><span class="line">    new SuperMap.Geometry.Point(116,40)</span><br><span class="line">);</span><br><span class="line">    var heatFeature1 = new SuperMap.Feature.Vector(</span><br><span class="line">    new SuperMap.Geometry.Point(116,30)</span><br><span class="line">);</span><br><span class="line">var heatFeatures = [heatFeature,heatFeature1];</span><br><span class="line">heatMapLayer.addFeatures(heatFeatures);</span><br></pre></td></tr></table></figure><h3 id="加载迁徙图"><a href="#加载迁徙图" class="headerlink" title="加载迁徙图"></a>加载迁徙图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var map, layer,</span><br><span class="line">host = window.isLocal ? window.server : &quot;http://support.supermap.com.cn:8090&quot;,</span><br><span class="line">url = host + &quot;/iserver/services/map-world/rest/maps/World&quot;;</span><br><span class="line">var features = [</span><br><span class="line">    new SuperMap.Feature.Vector(</span><br><span class="line">            new SuperMap.Geometry.Point(120,0),//设置第一个位置</span><br><span class="line">            &#123;</span><br><span class="line">                FEATUREID:&quot;point1&quot;,//设置为点的id</span><br><span class="line">                TIME:0//设置第一个时间</span><br><span class="line">            &#125;</span><br><span class="line">    ),</span><br><span class="line">    new SuperMap.Feature.Vector(</span><br><span class="line">            new SuperMap.Geometry.Point(110,0),//设置第二个位置</span><br><span class="line">            &#123;</span><br><span class="line">                FEATUREID:&quot;point1&quot;,</span><br><span class="line">                TIME:1</span><br><span class="line">            &#125;</span><br><span class="line">    ),</span><br><span class="line">    new SuperMap.Feature.Vector(</span><br><span class="line">            new SuperMap.Geometry.Point(120,0),//设置第二个位置</span><br><span class="line">            &#123;</span><br><span class="line">                FEATUREID:&quot;point2&quot;,</span><br><span class="line">                TIME:0</span><br><span class="line">            &#125;</span><br><span class="line">    ),</span><br><span class="line">    new SuperMap.Feature.Vector(</span><br><span class="line">            new SuperMap.Geometry.Point(130,2),//设置第二个位置</span><br><span class="line">            &#123;</span><br><span class="line">                FEATUREID:&quot;point2&quot;,</span><br><span class="line">                TIME:1</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">];  </span><br><span class="line">var animatorVector = new SuperMap.Layer.AnimatorVector(&quot;layer&quot;, &#123;&#125;,&#123;</span><br><span class="line">    speed:0.01,</span><br><span class="line">    startTime:0,//设置开始时间为0时刻</span><br><span class="line">    endTime:1//设置结束时间为1时刻</span><br><span class="line">&#125;);</span><br><span class="line">//初始化地图</span><br><span class="line">map = new SuperMap.Map(&quot;map&quot;, &#123;</span><br><span class="line">    controls: [</span><br><span class="line">        new SuperMap.Control.Navigation(),</span><br><span class="line">        new SuperMap.Control.Zoom()]</span><br><span class="line">&#125;);</span><br><span class="line">map.addControl(new SuperMap.Control.MousePosition());</span><br><span class="line">//初始化图层</span><br><span class="line">layer = new SuperMap.Layer.TiledDynamicRESTLayer(&quot;World&quot;, url, null, &#123;maxResolution: &quot;auto&quot;&#125;);</span><br><span class="line">//监听图层信息加载完成事件</span><br><span class="line">layer.events.on(&#123;&quot;layerInitialized&quot;: addLayer&#125;);</span><br><span class="line">function addLayer() &#123;</span><br><span class="line">    map.addLayer(layer);</span><br><span class="line">    map.addLayers([animatorVector]);</span><br><span class="line">    //显示地图范围</span><br><span class="line">    map.setCenter(new SuperMap.LonLat(120, 0), 0);</span><br><span class="line">    animatorVector.addFeatures(features);</span><br><span class="line">    animatorVector.animator.start();</span><br><span class="line">    animatorVector.animator.setSpeed(animatorVector.animator.getSpeed() * 0.7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;加载热力图&quot;&gt;&lt;a href=&quot;#加载热力图&quot; class=&quot;headerlink&quot; title=&quot;加载热力图&quot;&gt;&lt;/a&gt;加载热力图&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="supermap专题图" scheme="https://jiawanlong.github.io/tags/supermap%E4%B8%93%E9%A2%98%E5%9B%BE/"/>
    
      <category term="专题图" scheme="https://jiawanlong.github.io/tags/%E4%B8%93%E9%A2%98%E5%9B%BE/"/>
    
      <category term="GIS" scheme="https://jiawanlong.github.io/tags/GIS/"/>
    
  </entry>
  
  <entry>
    <title>了不起的Leaflet</title>
    <link href="https://jiawanlong.github.io/2018/07/31/%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Leaflet/"/>
    <id>https://jiawanlong.github.io/2018/07/31/了不起的Leaflet/</id>
    <published>2018-07-31T14:12:11.845Z</published>
    <updated>2018-07-31T15:21:36.332Z</updated>
    
    <content type="html"><![CDATA[<p>做为GIS专业的渣渣，毕业之后就很少接触到地图了。虽然辗转于中地和超图之间，但却很少系统的用到地图，之前有用过ol3，但总觉得过于庞大复杂。最近工作中有用到Leaflet，其简洁的语法令人发指，发现还是很适合我等渣渣的。<br>由于Leaflet的本身并不全面，但强大的生态以及插件足以震撼openlayers，此篇博客主要介绍Leaflet的插件用法，包括热力图，聚合图，量测控件。</p><blockquote><p> Leaflet是适用于移动设备的交互式地图的领先开源JavaScript库。它只需要大约38 KB的JS，它具有大多数开发人员所需的所有映射功能。Leaflet的设计考虑了简单性，性能和可用性。它的工作原理有效地跨所有主流桌面和移动平台，可以有很多的扩展插件，有一个美丽的，易于使用和良好记录的API 和一个简单的，可读的源代码。</p></blockquote><h3 id="1、热力图"><a href="#1、热力图" class="headerlink" title="1、热力图"></a>1、热力图</h3><p><img src="https://upload-images.jianshu.io/upload_images/8040955-9bc9446de70fba3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="热力图.png"><br>这里用到的是heatmap.js的这个插件，github的地址是 <a href="https://github.com/jiawanlong/heatmap.js" target="_blank" rel="noopener">heatmap</a>，demo代码地址是 <a href="https://github.com/jiawanlong/heatmap.js/blob/master/examples/leaflet-heatmap/index.html" target="_blank" rel="noopener">demo</a><br>1、首先需要引入JS文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/build/heatmap.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;/plugins/leaflet-heatmap/leaflet-heatmap.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>2、添加热力图到地图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var dataArr = [];</span><br><span class="line">for (let index = 0; index &lt; data.length; index++) &#123;</span><br><span class="line">    const element = data[index];</span><br><span class="line">    var obj = &#123; lat: element.smy, lng: element.smx, count: 1 &#125;;</span><br><span class="line">    dataArr.push(obj);</span><br><span class="line">&#125;</span><br><span class="line">var testData = &#123;</span><br><span class="line">    data: dataArr</span><br><span class="line">&#125;;</span><br><span class="line">var cfg = &#123;</span><br><span class="line">    radius: 0.002,</span><br><span class="line">    maxOpacity: 1,</span><br><span class="line">    scaleRadius: true,</span><br><span class="line">    useLocalExtrema: true,</span><br><span class="line">    latField: &quot;lat&quot;,</span><br><span class="line">    lngField: &quot;lng&quot;,</span><br><span class="line">    valueField: &quot;count&quot;</span><br><span class="line">&#125;;</span><br><span class="line">this.heatMapLayer = L.featureGroup().addTo(this.map);</span><br><span class="line">var heatmap = new HeatmapOverlay(cfg);</span><br><span class="line">heatmap.setData(testData);</span><br><span class="line">this.heatMapLayer.addLayer(heatmap);</span><br></pre></td></tr></table></figure></p><p>3、移除图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.heatMapLayer.remove();</span><br></pre></td></tr></table></figure></p><h3 id="2、聚合图"><a href="#2、聚合图" class="headerlink" title="2、聚合图"></a>2、聚合图</h3><p><img src="https://upload-images.jianshu.io/upload_images/8040955-696073988262357c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="聚合图.png"><br>这里用到的是markercluster.js的这个插件，github的地址是 <a href="https://github.com/jiawanlong/Leaflet.markercluster" target="_blank" rel="noopener">markercluster</a>，demo代码地址是，demo展示了加载1000个点的效果 <a href="https://leaflet.github.io/Leaflet.markercluster/example/marker-clustering-realworld.10000.html" target="_blank" rel="noopener">demo</a><br>1、将src目录放到自己的库下，引入JS文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;../dist/MarkerCluster.css&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;../dist/MarkerCluster.Default.css&quot; /&gt;</span><br><span class="line">&lt;script src=&quot;../dist/leaflet.markercluster-src.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>2、添加聚合图到地图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var juheLayer = L.markerClusterGroup(&#123;disableClusteringAtZoom: 15, chunkedLoading: true &#125;);</span><br><span class="line">for (var i = 0; i &lt; addressPoints.length; i++) &#123;</span><br><span class="line">    var a = addressPoints[i];</span><br><span class="line">    var title = a[2];  //标题</span><br><span class="line">    var marker = L.marker(L.latLng(a[0], a[1]), &#123; title: title &#125;);</span><br><span class="line">    marker.bindPopup(title); //点击时显示气泡</span><br><span class="line">    juheLayer.addLayer(marker);</span><br><span class="line">&#125;</span><br><span class="line">map.addLayer(juheLayer);</span><br></pre></td></tr></table></figure></p><p>3、移除聚合图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.removeLayer(juheLayer);</span><br></pre></td></tr></table></figure></p><h3 id="3、量测标记控件"><a href="#3、量测标记控件" class="headerlink" title="3、量测标记控件"></a>3、量测标记控件</h3><p><img src="https://upload-images.jianshu.io/upload_images/8040955-57f5efae71375c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控件.png"><br>这里用到的是Leaflet.draw的这个插件，github的地址是 <a href="https://github.com/jiawanlong/Leaflet.draw" target="_blank" rel="noopener">Leaflet.draw</a>，demo代码地址是，<a href="https://leaflet.github.io/Leaflet.draw/docs/examples/full.html" target="_blank" rel="noopener">demo</a>，api的github地址是 <a href="https://leaflet.github.io/Leaflet.draw/docs/leaflet-draw-latest.html" target="_blank" rel="noopener">api</a><br>1、将src目录放到自己的库下，引入JS文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/draw/leaflet.draw.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/Leaflet.draw.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/Leaflet.Draw.Event.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/Toolbar.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/Tooltip.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/ext/GeometryUtil.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/ext/LatLngUtil.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/ext/LineUtil.Intersect.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/ext/Polygon.Intersect.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/ext/Polyline.Intersect.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/ext/TouchEvents.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/DrawToolbar.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.Feature.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.SimpleShape.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.Polyline.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.Marker.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.Circle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.CircleMarker.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.Polygon.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/draw/handler/Draw.Rectangle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/EditToolbar.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/EditToolbar.Edit.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/EditToolbar.Delete.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/Control.Draw.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/Edit.Poly.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/Edit.SimpleShape.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/Edit.Rectangle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/Edit.Marker.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/Edit.CircleMarker.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./lib/draw/edit/handler/Edit.Circle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>2、完整的控件引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var editableLayers = new L.FeatureGroup();</span><br><span class="line">map.addLayer(editableLayers);</span><br><span class="line">var options = &#123;</span><br><span class="line">    position: &apos;topleft&apos;,</span><br><span class="line">    draw: &#123;</span><br><span class="line">        polyline: &#123;&#125;,</span><br><span class="line">        polygon: &#123;&#125;,</span><br><span class="line">        circle: &#123;&#125;,</span><br><span class="line">        rectangle: &#123;&#125;,</span><br><span class="line">        marker: &#123;&#125;,</span><br><span class="line">        remove: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    edit: &#123;</span><br><span class="line">        featureGroup: editableLayers,</span><br><span class="line">        remove: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var drawControl = new L.Control.Draw(options);</span><br><span class="line">map.addControl(drawControl);</span><br><span class="line">handleMapEvent(drawControl._container, map);</span><br><span class="line">map.on(L.Draw.Event.CREATED, function (e) &#123;</span><br><span class="line">    var type = e.layerType,</span><br><span class="line">        layer = e.layer;</span><br><span class="line">    if (type === &apos;marker&apos;) &#123;</span><br><span class="line">        layer.bindPopup(&apos;A popup!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    editableLayers.addLayer(layer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function handleMapEvent(div, map) &#123;</span><br><span class="line">    if (!div || !map) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    div.addEventListener(&apos;mouseover&apos;, function () &#123;</span><br><span class="line">        map.scrollWheelZoom.disable();</span><br><span class="line">        map.doubleClickZoom.disable();</span><br><span class="line">    &#125;);</span><br><span class="line">    div.addEventListener(&apos;mouseout&apos;, function () &#123;</span><br><span class="line">        map.scrollWheelZoom.enable();</span><br><span class="line">        map.doubleClickZoom.enable();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实，leaflet的功能不仅仅有这些，丰富的<a href="https://leafletjs.com/plugins.html" target="_blank" rel="noopener">插件</a> 更是多的让人抓狂，它简介的语法很适合新手学习，非常适合轻量级的应用开发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做为GIS专业的渣渣，毕业之后就很少接触到地图了。虽然辗转于中地和超图之间，但却很少系统的用到地图，之前有用过ol3，但总觉得过于庞大复杂。最近工作中有用到Leaflet，其简洁的语法令人发指，发现还是很适合我等渣渣的。&lt;br&gt;由于Leaflet的本身并不全面，但强大的生态
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="GIS" scheme="https://jiawanlong.github.io/tags/GIS/"/>
    
      <category term="Leaflet" scheme="https://jiawanlong.github.io/tags/Leaflet/"/>
    
      <category term="热力图" scheme="https://jiawanlong.github.io/tags/%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
    
      <category term="聚合图" scheme="https://jiawanlong.github.io/tags/%E8%81%9A%E5%90%88%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>你需要模块化</title>
    <link href="https://jiawanlong.github.io/2018/07/24/%E4%BD%A0%E9%9C%80%E8%A6%81%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://jiawanlong.github.io/2018/07/24/你需要模块化/</id>
    <published>2018-07-24T09:42:18.996Z</published>
    <updated>2018-07-31T15:16:59.157Z</updated>
    
    <content type="html"><![CDATA[<p>关于umd cmd amd import export。。。<br>先别慌，最近在给妹妹补课，忙得很，有空会更新。</p><!-- | AMD | AMD | CMD || :------:|  :------: | :------: || 代表 | require.js | sea.js | -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于umd cmd amd import export。。。&lt;br&gt;先别慌，最近在给妹妹补课，忙得很，有空会更新。&lt;/p&gt;
&lt;!-- | AMD | AMD | CMD |
| :------:|  :------: | :------: |
| 代表 | require.
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="模块化" scheme="https://jiawanlong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="require.js" scheme="https://jiawanlong.github.io/tags/require-js/"/>
    
      <category term="sea.js" scheme="https://jiawanlong.github.io/tags/sea-js/"/>
    
      <category term="es6" scheme="https://jiawanlong.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>组件通讯</title>
    <link href="https://jiawanlong.github.io/2018/07/05/%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    <id>https://jiawanlong.github.io/2018/07/05/组件通讯/</id>
    <published>2018-07-05T09:31:22.649Z</published>
    <updated>2018-07-05T09:32:03.281Z</updated>
    
    <content type="html"><![CDATA[<p>组件是vue最主要的语法特性之一，组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。<br>只有把各组件的通讯运用的游刃有余，才能说自己已经入门了，不是吗？</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="1、子组件调用父组件的方法"><a href="#1、子组件调用父组件的方法" class="headerlink" title="1、子组件调用父组件的方法"></a>1、子组件调用父组件的方法</h4><ul><li>直接用this.$parent.xxxx这样直接调用父组件的方法。</li><li>用$emit向父组件触发一个事件，父组件监听这个事件就行了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;child @refreshList=&quot;onRefresList&quot;&gt;&lt;/child&gt;  </span><br><span class="line">onRefresList(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子组件 </span><br><span class="line">this.$emit(&apos;refreshList&apos;,data);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、父组件调用子组件的方法"><a href="#2、父组件调用子组件的方法" class="headerlink" title="2、父组件调用子组件的方法"></a>2、父组件调用子组件的方法</h4><ul><li>用this.$children，但得到是一个数组，包含所有的子组件，可通过属性判断</li><li>通过ref调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;coma :das=&quot;da&quot; ref=&quot;comA&quot;&gt;&lt;/coma&gt;   //子</span><br><span class="line">this.$refs.comA.say(&quot;data&quot;);  //调用子的事件，并传值过去</span><br><span class="line">this.$refs.comA.val++;  //改变子的值</span><br><span class="line"></span><br><span class="line">//子组件</span><br><span class="line">say(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    alert(&quot;父调用我的&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、兄弟组件调用方法"><a href="#3、兄弟组件调用方法" class="headerlink" title="3、兄弟组件调用方法"></a>3、兄弟组件调用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//mian.js</span><br><span class="line">window.EventBus = new Vue();</span><br><span class="line"></span><br><span class="line">//兄弟1（调用者）</span><br><span class="line">EventBus.$emit(&quot;setVal&quot;, data);</span><br><span class="line"></span><br><span class="line">//兄弟2（被调用者）</span><br><span class="line">//mounted()钩子中监听</span><br><span class="line">bus.$on(&apos;setVal&apos;, (data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><h4 id="1、父组件传子组件"><a href="#1、父组件传子组件" class="headerlink" title="1、父组件传子组件"></a>1、父组件传子组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;child :inputName=&quot;name&quot;&gt;&lt;/child&gt;  //name是父组件的data里的值</span><br><span class="line">&lt;child inputName=&quot;name&quot;&gt;&lt;/child&gt;  //name是一个字符串</span><br><span class="line"></span><br><span class="line">//子组件</span><br><span class="line">props: [&quot;inputName&quot;,&quot;head&quot;]</span><br><span class="line">传过来的值不能在data里出现，不能修改，拿到后应用变量存着，其他来操作变量</span><br><span class="line"></span><br><span class="line">//子组件传过来验证、有默认值</span><br><span class="line">props: &#123;</span><br><span class="line">    &apos;head&apos;: Object,</span><br><span class="line">    &apos;pagecount&apos;: &#123;</span><br><span class="line">        default: 5,</span><br><span class="line">        type: Number  //String Number Boolean Function Object Array Symbol</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、子组件传父组件和兄弟组件传值用调用方法解决"><a href="#2、子组件传父组件和兄弟组件传值用调用方法解决" class="headerlink" title="2、子组件传父组件和兄弟组件传值用调用方法解决"></a>2、子组件传父组件和兄弟组件传值用调用方法解决</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组件是vue最主要的语法特性之一，组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。&lt;br&gt;只有把各组件的通讯运用的游刃有余，才能
      
    
    </summary>
    
      <category term="FUCK WORK" scheme="https://jiawanlong.github.io/categories/FUCK-WORK/"/>
    
    
      <category term="vue" scheme="https://jiawanlong.github.io/tags/vue/"/>
    
      <category term="组件" scheme="https://jiawanlong.github.io/tags/%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
</feed>
